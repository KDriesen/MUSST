var tipuesearch = {"pages":[{"tags":"home","title":" MUSST ","text":"MUSST MUSST is a set of modern fortran subroutines dedicated to the resolution of some lubrication problems. Table of Contents Brief description Installation Data-format Limitations Prerequesites Wrappers Make License Brief description MUSST implements the finite element method on Reynolds' equation. It can solve a large variety of problems with standard geometries like sliders, bearings and pockets.\nHowever, the user can provide the surface heights (as a .sur file for instance), whatever the surface.\nThe lubricant that can be modelled are perfect gases, incompressible fluids and compressible fluids (treated as gaz-fluid mixtures [1] ). The latter allows for cavitation phenomena to appear. The objective of the multiscale approach is to study flows between large rough surfaces needing very fine meshes while maintaining a reasonable computation time.\nFor this purpose, the domain is split into a number of subdomains (bottom-scale meshes) connected by a coarse mesh (top-scale).\nThe pressure distribution at the top-scale is used as boundary conditions for the bottom-scale problems.\nThis pressure is adjusted to ensure global mass flow balance between the contiguous subdomains. This multiscale method allows for a significant reduction of the number of operations as well as a satisfactory accuracy of the results if the top-scale mesh is properly fitted to the roughness lateral scale.\nFurthermore the present method is well-suited to parallel computation, leading to much more significant computation time reduction [2] . top Installation MUSST needs to call efficient sparse linear system solvers like MUMPS , UMFPACK , SuperLU or MA48 . As the use of the latter is restricted, the MSOLV makefile has to be tuned accordingly.\nIf the user can supply the following files : MSOLV/src/hsl_common90.f90 MSOLV/src/hsl_ddeps90.f90 MSOLV/src/hsl_ma48d.f90 and MSOLV/lib/libhsl_ma48.a then MA48_LIB = 1 , otherwise MA48_LIB = 0 . To build the whole package: $cd MUSST and $make all . To build MUSST core, $make , or $make debug , $make gprof , $make clean . To launch some test examples: $./main cfg/TEST_01.dat -> slider bearing,  deterministic, incompressible $./main cfg/TEST_02.dat -> journal bearing, deterministic, compressible $./main cfg/TEST_04.dat -> rough surface,   deterministic, compressible $./main cfg/TEST_05.dat -> pockect bearing, deterministic, perfect gas $./main cfg/TEST_11.dat -> slider bearing,  multiscale,    compressible $./main cfg/TEST_14.dat -> rough surface,   multiscale,    compressible top Data format top Limitations top Prerequesites top Wrappers top Make top License [1] Brunetière N. A General Model for Liquid and Gas Lubrication, Including Cavitation. ASME. J. Tribol. 2017 ; 140 (2):021702-021702-10. DOI [2] Brunetière, N.; Francisco, A. Multiscale Modeling Applied to the Hydrodynamic Lubrication of Rough Surfaces for Computation Time Reduction. Lubricants 2018 , 6 , 83. DOI Developer Info Noël Brunetière - Arthur Francisco","loc":"index.html"},{"tags":"","title":"mod_data.f90 – MUSST","text":"This file depends on sourcefile~~mod_data.f90~~EfferentGraph sourcefile~mod_data.f90 mod_data.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_data.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_fluid.f90 mod_fluid.f90 sourcefile~mod_data.f90->sourcefile~mod_fluid.f90 sourcefile~mod_fluid.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_data.f90~~AfferentGraph sourcefile~mod_data.f90 mod_data.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_data.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_data.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~mod_film.f90->sourcefile~mod_data.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 var pansourcefilemod_dataf90AfferentGraph = svgPanZoom('#sourcefilemod_dataf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules data_film_hd Source Code mod_data.f90 Source Code !! author: Noël Brunetière<br/>&emsp;Arthur Francisco !! version: 1.0.0 !! date: April,20 2017 !! summary: Data for a fluid film by FEM !< <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<       **Definition of the data for a film solution problem** !< </span> module data_film_hd use data_arch , only : I4 , R8 use fluid_law implicit none private type DATA_FILM real ( kind = R8 ) :: h_0 !! *h_0 : ambient pressure* real ( kind = R8 ) :: h_g !! *h_g : cavitation pressure* real ( kind = R8 ) :: V_x !! *V_x : surface velocity along x* real ( kind = R8 ) :: V_y !! *V_y : surface velocity along y* type ( FLUID ) :: fl !! *fluid rheological properties* integer ( kind = I4 ) :: pb_type !! *problem type, e.g. HD (hydrodynamic)* endtype DATA_FILM integer ( kind = I4 ), parameter :: HD = 0 !! *code for problem type, 0 : hydrodynamic problem* public :: DATA_FILM , HD endmodule data_film_hd","loc":"sourcefile/mod_data.f90.html"},{"tags":"","title":"mod_film.f90 – MUSST","text":"This file depends on sourcefile~~mod_film.f90~~EfferentGraph sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_film.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_num_par.f90 mod_num_par.f90 sourcefile~mod_film.f90->sourcefile~mod_num_par.f90 sourcefile~mod_mesh.f90 mod_mesh.f90 sourcefile~mod_film.f90->sourcefile~mod_mesh.f90 sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~mod_film.f90->sourcefile~mod_surfile.f90 sourcefile~mod_elements.f90 mod_elements.f90 sourcefile~mod_film.f90->sourcefile~mod_elements.f90 sourcefile~mod_fluid.f90 mod_fluid.f90 sourcefile~mod_film.f90->sourcefile~mod_fluid.f90 sourcefile~mod_data.f90 mod_data.f90 sourcefile~mod_film.f90->sourcefile~mod_data.f90 sourcefile~mod_solver.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_gen_par.f90 mod_gen_par.f90 sourcefile~mod_solver.f90->sourcefile~mod_gen_par.f90 sourcefile~umfpack.f90 umfpack.f90 sourcefile~mod_solver.f90->sourcefile~umfpack.f90 sourcefile~superlu.f90 superlu.f90 sourcefile~mod_solver.f90->sourcefile~superlu.f90 sourcefile~dmumps_struc.f90 dmumps_struc.f90 sourcefile~mod_solver.f90->sourcefile~dmumps_struc.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_num_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_mesh.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_surfile.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_surfile.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_elements.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_fluid.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_data.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_data.f90->sourcefile~mod_fluid.f90 sourcefile~mod_gen_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_film.f90~~AfferentGraph sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules film Source Code mod_film.f90 Source Code !! author: Noël Brunetière<br/>&emsp;Arthur Francisco !! version: 1.0.0 !! date: April,17 2017 !! summary: Definition of a fluid film by FEM !< <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !        **FE solution of the Reynolds equation** !  </span> !<# Description of the film module !  This is the main module for the finite element solution of the Reynolds equation. ! !<## Definition of FE_film ! [[FE_FILM]] is a data structure containing a [[FE_MESH]] and some data describing a lubrication problem !<## Solution procedure ! This module can be used to create a FE_FILM, assemble the FE_FIM and solve it. Some post-treatements like fluxes, forces are available. module film use data_arch , only : EPS_R8 use data_film_hd use fluid_law use num_param use mesh use solver use elements use omp_lib use surfile implicit none private type PRC_TAB !! <span style=\"color:green\"> !!   *PRC_TAB* stores some precomputed coefficients for the finite element matrices !! </span> integer ( kind = I4 ) :: ng !! *Gauss point number along a direction* real ( kind = R8 ), dimension (:), allocatable :: pg !! *point coordinates in a direction* real ( kind = R8 ), dimension (:), allocatable :: wg !! *point weight* real ( kind = R8 ), dimension (:,:,:), allocatable :: vni4 !! *for each node, shape function at Gauss points* real ( kind = R8 ), dimension (:,:,:), allocatable :: vni4x !! *for each node, shape function derivative at Gauss points* real ( kind = R8 ), dimension (:,:,:), allocatable :: vni4y !! *for each node, shape function derivative at Gauss points* real ( kind = R8 ), dimension (:,:,:), allocatable :: vni4d !! *for each node, upwind shape function at Gauss points* real ( kind = R8 ), dimension (:,:,:), allocatable :: vcal !! *14 values calculated at the Gauss points* endtype PRC_TAB type FE_FILM !! <span style=\"color:green\"> !!   *FE_FILM* stores the whole stuff related to a film: the nodal variables, the mesh, etc. !! </span> integer ( kind = I4 ) :: n_vn !! *number of nodal variables* integer ( kind = I4 ) :: n_vc !! *number of variables on cells* type ( FE_MESH ) :: m !! *mesh of the film* type ( DATA_FILM ) :: data_f !! *data of the problem* type ( PRC_TAB ) :: prc !! *precomputation* type ( NUM_PAR ) :: num_p !! *numerical param for iterative solution* real ( kind = R8 ), dimension (:,:), allocatable :: vn !! *nodal variables table* real ( kind = R8 ), dimension (:,:), allocatable :: vc !! *cell variables table* integer ( kind = I4 ), dimension (:,:), allocatable :: bc !! *boundary nodes code* character ( len = 20 ), dimension (:), allocatable :: vn_name !! *nodal variable names* character ( len = 20 ), dimension (:), allocatable :: vc_name !! *cell variable names* contains procedure :: fx !! *force computation along* x procedure :: fy !! *force computation along* y procedure :: fz !! *force computation along* z endtype FE_FILM ! codes for variables integer ( kind = I4 ), parameter :: H1_N = 1 !! *code for bottom surface height* h_1 integer ( kind = I4 ), parameter :: H2_N = 2 !! *code for top surface height* h_2 integer ( kind = I4 ), parameter :: H_N = 3 !! *code for film thickness* h integer ( kind = I4 ), parameter :: P_N = 4 !! *code for film absolute pressure* p integer ( kind = I4 ), parameter :: RHO_N = 5 !! *code for fluid density* \\rho integer ( kind = I4 ), parameter :: T_N = 6 !! *code for film absolute temperature* T integer ( kind = I4 ), parameter :: DRHODP_N = 7 !! *code for film compressibility* \\frac{\\partial \\rho}{\\partial p} integer ( kind = I4 ), parameter :: MU_N = 8 !! *code for fluid viscosity* \\mu integer ( kind = I4 ), parameter :: VX_N = 9 !! *code for surface velocity along* x V_x. *Should be modified (surfaces 1 and 2)* integer ( kind = I4 ), parameter :: VY_N = 10 !! *code for surface velocity along* y V_y. *Should be modified (surfaces 1 and 2)* integer ( kind = I4 ), parameter :: HG_C = 1 !! *code for groove depth on the stationnary surface* h_g, *cell variable* integer ( kind = I4 ), parameter :: PEK_C = 2 !! *code for Peclet number along* \\xi integer ( kind = I4 ), parameter :: PEE_C = 3 !! *code for Peclet number along* \\eta ! codes for boundary conditions integer ( kind = I4 ), parameter :: REY = 1 !! *code for imposed pressure at the boundary* ! codes for assembly integer ( kind = I4 ), parameter :: ASS = 1 !! *code for assembly of the system* integer ( kind = I4 ), parameter :: NO_ASS = 0 !! *code for no assemble, computation of the residual only* integer ( kind = I4 ), parameter :: NO_BC = - 1 !! *code for computation of the residual everywhere, even at the boundaries (fluxes computations)* ! private variable for a '.sur' file creation type ( SCALE_SURF ) :: scal_tmp !! *object [[SCALE_SURF]]* ! parameters controlling the iterative process logical ( kind = I4 ), parameter :: BC_SPLINE = . false . !! *instead of linearly interpolating the boundary pressures, it can be done in a smoother way. NOT TO BE USED YET.* public :: ASS , DRHODP_N , FE_FILM , H1_N , H2_N , HG_C , H_N , MU_N , NO_ASS , NO_BC , PEE_C , PEK_C , PRC_TAB , & P_N , REY , RHO_N , T_N , VX_N , VY_N , apply_bc_FE_film , apply_bc_FE_film_simple , assemble_in_mat_sol , assembly_FE_film_reynolds , compute_corner_fluxes , & elementary_full_domain_FE_film_reynolds , init_prc_tab , solve_FE_film , create_rect_FE_film , save_fe_field , BC_SPLINE contains !========================================================================================= !< @note Subroutine to create a [[FE_FILM]] !< !----------------------------------------------------------------------------------------- subroutine create_rect_FE_film ( data_f , num_p , fe_f ) implicit none type ( DATA_FILM ), intent ( inout ) :: data_f !! *data of the film* type ( NUM_PAR ), intent ( in ) :: num_p !! *numerical param for iterative solution* type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film data type* ! mesh creation call create_rect_x_ymesh ( fe_f % m ) ! copy of data fe_f % data_f = data_f ! allocation and initialisation of the variables and bc table select case ( fe_f % data_f % pb_type ) case ( HD ) ! nodal tables fe_f % n_vn = 10 allocate ( fe_f % vn ( fe_f % m % n , fe_f % n_vn ), fe_f % vn_name ( fe_f % n_vn )) fe_f % vn_name ( H1_N ) = 'h1(m)' fe_f % vn_name ( H2_N ) = 'h2(m)' fe_f % vn_name ( H_N ) = 'h(m)' fe_f % vn_name ( P_N ) = 'p(Pa)' fe_f % vn_name ( RHO_N ) = 'rho(kg.m-3)' fe_f % vn_name ( T_N ) = 'T(K)' fe_f % vn_name ( DRHODP_N ) = 'drhodp(kg.m-3.Pa-1)' fe_f % vn_name ( MU_N ) = 'mu(Pa.s)' fe_f % vn_name ( VX_N ) = 'Vx(m.s-1)' fe_f % vn_name ( VY_N ) = 'Vy(m.s-1)' fe_f % vn = 0._R8 fe_f % vn (:, H2_N ) = fe_f % data_f % h_0 fe_f % vn (:, H_N ) = fe_f % vn (:, H2_N ) - fe_f % vn (:, H1_N ) fe_f % vn (:, P_N ) = fe_f % data_f % fl % p_0 fe_f % vn (:, RHO_N ) = fe_f % data_f % fl % rho ( fe_f % data_f % fl % p_0 , fe_f % data_f % fl % T_0 ) fe_f % vn (:, T_N ) = fe_f % data_f % fl % T_0 fe_f % vn (:, MU_N ) = fe_f % data_f % fl % mu_0 fe_f % vn (:, VX_N ) = fe_f % data_f % v_x fe_f % vn (:, VY_N ) = fe_f % data_f % v_y fe_f % vn (:, DRHODP_N ) = fe_f % data_f % fl % drhodp ( fe_f % data_f % fl % p_0 , fe_f % data_f % fl % T_0 ) ! bondary condition table allocate ( fe_f % bc ( fe_f % m % n , 1 )) ! all the nodes are initialized as unknown fe_f % bc = 1 ! cell variable fe_f % n_vc = 3 allocate ( fe_f % vc ( fe_f % m % ne , fe_f % n_vc ), fe_f % vc_name ( fe_f % n_vc )) fe_f % vc_name ( HG_C ) = 'h_grv(m)' fe_f % vc_name ( PEK_C ) = 'Pek' fe_f % vc_name ( PEE_C ) = 'Pee' fe_f % vc = 0._R8 ! numerical parameters for iterative problems fe_f % num_p = num_p case default stop 'the problem type is undefined in create_rect_FE_film' endselect return endsubroutine create_rect_FE_film !========================================================================================= !< @note Subroutine to solve a [[FE_FILM]] !< !----------------------------------------------------------------------------------------- subroutine solve_FE_film ( fe_f , mat , bc , flag_ass ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film data type* type ( MAT_SOLV ), intent ( inout ) :: mat !! *matrices for solving* real ( kind = R8 ), intent ( in ), dimension ( MAX_NNC ) :: bc !! *boundary conditions at the corners* logical ( kind = I4 ), intent ( in ), optional :: flag_ass !! *optional flag for assembly* logical ( kind = I4 ) :: decomp integer ( kind = I4 ) :: ass_c , i , it , e logical ( kind = I4 ) :: conv real ( kind = R8 ) :: error integer ( kind = I4 ), dimension ( 2 ) :: compt ! solution parameters ass_c = ASS if ( present ( flag_ass )) then if (. not . flag_ass ) ass_c = NO_ASS endif decomp = ( ass_c == ASS ) ! apply boundary conditions if ( BC_SPLINE ) then call apply_bc_FE_film ( fe_f = fe_f , & bc = bc ) else call apply_bc_FE_film_simple ( fe_f = fe_f , & bc = bc ) endif if ( VERBOSE >= 20 ) write ( OPU , * ) 'bc applied' ! update fluid properties do i = 1 , fe_f % m % n fe_f % vn ( i , RHO_N ) = fe_f % data_f % fl % rho ( fe_f % vn ( i , P_N ) , fe_f % vn ( i , T_N )) fe_f % vn ( i , DRHODP_N ) = fe_f % data_f % fl % drhodp ( fe_f % vn ( i , P_N ) , fe_f % vn ( i , T_N )) enddo if ( VERBOSE >= 20 ) write ( OPU , * ) 'fluid properties updated' if ( mat % first ) then mat % nn = fe_f % m % n mat % ne = fe_f % m % ne call solve_syst ( mat = mat , & step = 'ini' ) if ( VERBOSE >= 10 ) write ( OPU , * ) 'Matrix initialized, thread ' , omp_get_thread_num () ! matrices allocation compt (:) = 0 do e = 1 , fe_f % m % ne compt ( 1 ) = compt ( 1 ) + fe_f % m % el_n ( e ) ! for each element, the number of lines is added do i = 1 , fe_f % m % el_t ( e ) compt ( 2 ) = compt ( 2 ) + fe_f % m % el_t ( e ) ! \" \", for each node, the number of contributions is added enddo enddo mat % nvar = compt ( 1 ) mat % nt = compt ( 2 ) if (. not . allocated ( mat % eltvar )) allocate ( mat % eltvar ( mat % nvar ) ) if (. not . allocated ( mat % a_elt )) allocate ( mat % a_elt ( mat % nt ) ) if (. not . allocated ( mat % eltptr )) allocate ( mat % eltptr ( mat % ne + 1 ) ) endif ! check of precomputed tables allocation if (. not . allocated ( fe_f % prc % vcal )) call init_prc_tab ( fe_f ) ! convergence is false at zero iteration conv = . false . it = 0 ! solution loop do if ( VERBOSE >= 20 ) write ( OPU , * ) '   Loop FE ' , it if ( conv ) exit ! assembly of the system call assembly_FE_film_reynolds ( fe_f , mat , ass_c ) if ( VERBOSE >= 30 ) write ( OPU , * ) '   System assembled, thread ' , omp_get_thread_num () if ( ass_c == ASS ) then ! some stuff can be saved here, provided the reloading of jptr, irow, ... (instead of convert_matrice_format) call convert_matrice_format ( mat ) if ( VERBOSE >= 30 ) write ( OPU , * ) '   Matrix converted, thread ' , omp_get_thread_num () endif if ( mat % first ) then call solve_syst ( mat = mat , & step = 'ana' ) mat % first = . false . if ( VERBOSE >= 10 ) write ( OPU , * ) '   Matrix analyzed, thread ' , omp_get_thread_num () endif ! solution of the system if ( ass_c == ASS ) then call solve_syst ( mat = mat , & step = 'fac' ) if ( VERBOSE >= 30 ) write ( OPU , * ) '   Matrix factorized, thread ' , omp_get_thread_num () endif call solve_syst ( mat = mat , & step = 'sol' ) if ( VERBOSE >= 30 ) write ( OPU , * ) '   System solved, thread ' , omp_get_thread_num () if ( ass_c == ASS ) then call solve_syst ( mat = mat , & step = 'fre' ) if ( VERBOSE >= 30 ) write ( OPU , * ) '   Matrix factors freed, thread ' , omp_get_thread_num () endif ! error computation error = ( sum ( mat % x ** 2 ) / sum ( fe_f % vn (:, P_N ) ** 2 )) ** ( 0.5_R8 ) it = it + 1 if ( VERBOSE >= 20 ) write ( OPU , * ) '   Error ' , error ! convergence check if ( error <= fe_f % num_p % eps ) conv = . true . ! update of variables if ( fe_f % data_f % fl % fluid_type == MIXT ) then do i = 1 , fe_f % m % n if ( mat % x ( i ) < 0. ) then fe_f % vn ( i , RHO_N ) = fe_f % vn ( i , RHO_N ) + fe_f % vn ( i , DRHODP_N ) * mat % x ( i ) * fe_f % num_p % relax if ( fe_f % vn ( i , RHO_N ) < 0. ) then fe_f % vn ( i , P_N ) = fe_f % data_f % fl % P_0 / 100 else fe_f % vn ( i , P_N ) = fe_f % data_f % fl % pres ( fe_f % vn ( i , RHO_N ), & ! fe_f % vn ( i , T_N ) ) endif else fe_f % vn ( i , P_N ) = fe_f % vn ( i , P_N ) + mat % x ( i ) * fe_f % num_p % relax endif enddo else fe_f % vn (:, P_N ) = fe_f % vn (:, P_N ) + mat % x * fe_f % num_p % relax endif ! check pressure if ( fe_f % data_f % fl % fluid_type == GP ) then if ( minval ( fe_f % vn (:, P_N )) < 0._R8 ) then if ( VERBOSE >= 30 ) write ( OPU , * ) 'P negative' endif where ( fe_f % vn (:, P_N ) < 0._R8 ) fe_f % vn (:, P_N ) = fe_f % data_f % fl % p_0 / 1.e3_R8 endif do i = 1 , fe_f % m % n fe_f % vn ( i , RHO_N ) = fe_f % data_f % fl % rho ( fe_f % vn ( i , P_N ) , fe_f % vn ( i , T_N )) fe_f % vn ( i , DRHODP_N ) = fe_f % data_f % fl % drhodp ( fe_f % vn ( i , P_N ) , fe_f % vn ( i , T_N )) enddo if ( it >= fe_f % num_p % it_max ) then conv = . true . if ( VERBOSE >= 20 ) write ( OPU , * ) 'maximum number of iteration reached before convergence' endif enddo return endsubroutine solve_FE_film !========================================================================================= !< @note Subroutine to apply boundary conditions on a [[FE_FILM]] !< !----------------------------------------------------------------------------------------- subroutine apply_bc_FE_film ( fe_f , bc ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film data type* real ( kind = R8 ), intent ( in ), dimension ( MAX_NNC ) :: bc !! *boundary conditions at the corners* integer ( kind = I4 ) :: e , i , ind , ind_var logical ( kind = I4 ) :: mixture real ( kind = R8 ) :: v , v1 , v2 , x1 , x2 , y1 , y2 , l , d mixture = ( fe_f % data_f % fl % fluid_type == MIXT ) ! case of hd problem: unknown is p if ( fe_f % data_f % pb_type == HD ) ind_var = P_N ! copy of the bc values on the node values do i = 1 , fe_f % m % nc fe_f % vn ( fe_f % m % cor ( i ), ind_var ) = fe_f % vn ( fe_f % m % cor ( i ), ind_var ) + bc ( i ) enddo ! loop on edges if ( mixture ) then v1 = bc ( 1 ) / fe_f % vn ( fe_f % m % cor ( 1 ), ind_var ) else v1 = bc ( 1 ) endif x1 = fe_f % m % x ( fe_f % m % cor ( 1 )) y1 = fe_f % m % y ( fe_f % m % cor ( 1 )) do e = fe_f % m % ned , 1 , - 1 v2 = v1 x2 = x1 y2 = y1 if ( mixture ) then v1 = bc ( e ) / fe_f % vn ( fe_f % m % cor ( e ), ind_var ) else v1 = bc ( e ) endif x1 = fe_f % m % x ( fe_f % m % cor ( e )) y1 = fe_f % m % y ( fe_f % m % cor ( e )) ! length of the edge l = (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ** 0.5_R8 do i = 2 , fe_f % m % ed ( e )% n - 1 ind = fe_f % m % ed ( e )% nm ( i ) ! distance to point 2 d = (( x2 - fe_f % m % x ( ind )) ** 2 + ( y2 - fe_f % m % y ( ind )) ** 2 ) ** 0.5_R8 d = d / l v = d * v1 + ( 1._R8 - d ) * v2 ! linear distribution along the edge if ( mixture ) then fe_f % vn ( ind , ind_var ) = exp ( log ( fe_f % vn ( ind , ind_var )) + v ) else fe_f % vn ( ind , ind_var ) = fe_f % vn ( ind , ind_var ) + v endif enddo do i = 1 , fe_f % m % ed ( e )% n ind = fe_f % m % ed ( e )% nm ( i ) ! boundary nodes are set as imposed fe_f % bc ( ind , REY ) = 0 enddo enddo return endsubroutine apply_bc_FE_film !========================================================================================= !< @note Subroutine to apply boundary conditions on a [[FE_FILM]] !< !----------------------------------------------------------------------------------------- subroutine apply_bc_FE_film_simple ( fe_f , bc ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film data type* real ( kind = R8 ), intent ( in ), dimension ( MAX_NNC ) :: bc !! *boundary conditions at the corners* integer ( kind = I4 ) :: e , i , ind , ind_var logical ( kind = I4 ) :: mixture real ( kind = R8 ) :: v , v1 , v2 , x1 , x2 , y1 , y2 , l , d mixture = ( fe_f % data_f % fl % fluid_type == MIXT ) ! case of hd problem: unknown is p if ( fe_f % data_f % pb_type == HD ) ind_var = P_N ! copy of the bc values on the node values do i = 1 , fe_f % m % nc fe_f % vn ( fe_f % m % cor ( i ), ind_var ) = bc ( i ) enddo ! loop on edges if ( mixture ) then v1 = log ( fe_f % vn ( fe_f % m % cor ( 1 ), ind_var )) else v1 = fe_f % vn ( fe_f % m % cor ( 1 ), ind_var ) endif x1 = fe_f % m % x ( fe_f % m % cor ( 1 )) y1 = fe_f % m % y ( fe_f % m % cor ( 1 )) do e = fe_f % m % ned , 1 , - 1 v2 = v1 x2 = x1 y2 = y1 if ( mixture ) then v1 = log ( fe_f % vn ( fe_f % m % cor ( e ), ind_var )) else v1 = fe_f % vn ( fe_f % m % cor ( e ), ind_var ) endif x1 = fe_f % m % x ( fe_f % m % cor ( e )) y1 = fe_f % m % y ( fe_f % m % cor ( e )) ! length of the edge l = (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ** 0.5_R8 do i = 2 , fe_f % m % ed ( e )% n - 1 ind = fe_f % m % ed ( e )% nm ( i ) ! distance to point 2 d = (( x2 - fe_f % m % x ( ind )) ** 2 + ( y2 - fe_f % m % y ( ind )) ** 2 ) ** 0.5_R8 d = d / l v = d * v1 + ( 1._R8 - d ) * v2 ! linear distribution along the edge if ( mixture ) then fe_f % vn ( ind , ind_var ) = exp ( v ) else fe_f % vn ( ind , ind_var ) = v endif enddo do i = 1 , fe_f % m % ed ( e )% n ind = fe_f % m % ed ( e )% nm ( i ) ! boundary nodes are set as imposed fe_f % bc ( ind , REY ) = 0 enddo enddo return endsubroutine apply_bc_FE_film_simple !========================================================================================= !< @note Subroutine to to solve a [[FE_FILM]] !< !----------------------------------------------------------------------------------------- subroutine assembly_FE_film_reynolds ( fe_f , mat , ass_c ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE_film data type* type ( MAT_SOLV ), intent ( inout ) :: mat !! *matrices for solving* integer ( kind = I4 ), intent ( in ) :: ass_c !! *assembly type* integer ( kind = I4 ), dimension ( 2 ) :: compt integer ( kind = I4 ), dimension ( MAX_NNE ) :: tind4 real ( kind = R8 ), dimension ( MAX_NNE ) :: b4 real ( kind = R8 ), dimension ( MAX_NNE , MAX_NNE ) :: k4 integer ( kind = I4 ) :: e , i , ii , el_t , el_n ! assembly compt ( 1 : 2 ) = 1 mat % b = 0._R8 do e = 1 , fe_f % m % ne call elementary_assembly_FE_film_reynolds ( fe_f = fe_f , & ! ke_ij = k4 , & ! elementary matrix         : OUT be_i = b4 , & ! elementary rhs member     : OUT ind_e = tind4 , & ! elementary index member   : OUT e = e , & ! element number ass_c = ass_c ) ! assembly type do i = 1 , 4 ii = tind4 ( i ) mat % b ( ii ) = mat % b ( ii ) + b4 ( i ) enddo el_t = fe_f % m % el_t ( e ) el_n = fe_f % m % el_n ( e ) ! assembly of the elemental matrix in the solver matrix if ( ass_c == ASS ) then call assemble_in_mat_sol ( mat = mat , & num = e , & nelt = el_t , & nline = el_n , & tind = tind4 , & m_elt = k4 , & compt = compt ) endif enddo if ( ass_c == ASS ) mat % eltptr ( 1 ) = 1 return endsubroutine assembly_FE_film_reynolds !========================================================================================= !< @note Subroutine to assemble elemental matrices in the solver matrices !< !----------------------------------------------------------------------------------------- subroutine assemble_in_mat_sol ( mat , num , nelt , nline , tind , m_elt , compt ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *mat_solv type* integer ( kind = I4 ), intent ( in ) :: num !! *element number* integer ( kind = I4 ), intent ( in ) :: nelt !! *size of elemental matrix* integer ( kind = I4 ), intent ( in ) :: nline !! *number of lines* integer ( kind = I4 ), intent ( in ), dimension ( nelt ) :: tind !! *index table of elemental matrix* real ( kind = R8 ), intent ( in ), dimension ( nelt , nelt ) :: m_elt !! *elemental matrix* integer ( kind = I4 ), intent ( inout ), dimension ( 2 ) :: compt !! *number to index the position in the solver matrix* integer ( kind = I4 ) :: i , j ! check compt if ( compt ( 2 ) > mat % nt ) stop 'compt > matrix size in assemble_in_mat_sol' do j = 1 , nline mat % eltvar ( compt ( 1 )) = tind ( j ) compt ( 1 ) = compt ( 1 ) + 1 enddo mat % eltptr ( num + 1 ) = compt ( 1 ) do j = 1 , nelt do i = 1 , nelt mat % a_elt ( compt ( 2 )) = m_elt ( i , j ) compt ( 2 ) = compt ( 2 ) + 1 enddo enddo return endsubroutine assemble_in_mat_sol !========================================================================================= !< @note Subroutine to solve a [[FE_FILM]] !< !----------------------------------------------------------------------------------------- subroutine elementary_assembly_FE_film_reynolds ( fe_f , ke_ij , be_i , ind_e , e , ass_c ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film* real ( kind = R8 ), intent ( out ), dimension ( MAX_NNE , MAX_NNE ) :: ke_ij !! *elementary matrix* real ( kind = R8 ), intent ( out ), dimension ( MAX_NNE ) :: be_i !! *elementary rhs member* integer ( kind = I4 ), intent ( out ), dimension ( MAX_NNE ) :: ind_e !! *elementary index member* integer ( kind = I4 ), intent ( in ) :: e !! *element number* integer ( kind = I4 ), intent ( in ) :: ass_c !! *assembly type* real ( kind = R8 ), dimension ( MAX_NNG , MAX_NNG ) :: vni4x , vni4y integer ( kind = I4 ), dimension ( MAX_NNE ) :: con integer ( kind = I4 ) :: i , j , ii , jj , ng , ne ng = fe_f % prc % ng ne = fe_f % m % el_t ( e ) ! check of precomputed tables allocation !~ if (.not.allocated(fe_f%prc%vcal)) call init_prc_tab(fe_f) ! assembly call compute_prc_tables_reynolds_supg ( fe_f , e ) con ( 1 : ne ) = fe_f % m % con ( e , 1 : ne ) ke_ij = 0._R8 ind_e = 0 be_i = 0._R8 do i = 1 , ne ii = con ( i ) ind_e ( i ) = ii ! case of nodes on the boundary if (( fe_f % bc ( ii , REY ) == 0 ) . and . ( ass_c /= NO_BC )) then ke_ij ( i , i ) = 1.0e10 ! case of nodes where the pressure is unknown else vni4x ( 1 : ng , 1 : ng ) = fe_f % prc % vni4x ( i , 1 : ng , 1 : ng ) vni4y ( 1 : ng , 1 : ng ) = fe_f % prc % vni4y ( i , 1 : ng , 1 : ng ) be_i ( i ) = be_i ( i ) - sum ( vni4x ( 1 : ng , 1 : ng ) * ( fe_f % prc % vcal ( 6 , 1 : ng , 1 : ng ) - fe_f % prc % vcal ( 8 , 1 : ng , 1 : ng )) ) & ! - sum ( vni4y ( 1 : ng , 1 : ng ) * ( fe_f % prc % vcal ( 7 , 1 : ng , 1 : ng ) - fe_f % prc % vcal ( 9 , 1 : ng , 1 : ng )) ) do j = 1 , fe_f % m % el_t ( e ) jj = con ( j ) ke_ij ( i , j ) = sum ( ( vni4x ( 1 : ng , 1 : ng ) * fe_f % prc % vni4x ( j , 1 : ng , 1 : ng ) & + vni4y ( 1 : ng , 1 : ng ) * fe_f % prc % vni4y ( j , 1 : ng , 1 : ng )) * fe_f % prc % vcal ( 2 , 1 : ng , 1 : ng ) ) & + sum ( ( vni4x ( 1 : ng , 1 : ng ) * fe_f % prc % vcal ( 10 , 1 : ng , 1 : ng ) & + vni4y ( 1 : ng , 1 : ng ) * fe_f % prc % vcal ( 11 , 1 : ng , 1 : ng )) * fe_f % prc % vni4 ( j , 1 : ng , 1 : ng )) * fe_f % vn ( jj , DRHODP_N ) & - sum ( ( vni4x ( 1 : ng , 1 : ng ) * fe_f % prc % vcal ( 3 , 1 : ng , 1 : ng ) & + vni4y ( 1 : ng , 1 : ng ) * fe_f % prc % vcal ( 4 , 1 : ng , 1 : ng )) & * fe_f % prc % vni4d ( j , 1 : ng , 1 : ng ) * fe_f % vn ( jj , DRHODP_N ) ) !better convergence enddo endif enddo return endsubroutine elementary_assembly_FE_film_reynolds !========================================================================================= !< @note Calculate the elementary matrices on a full domain !< !----------------------------------------------------------------------------------------- subroutine elementary_full_domain_FE_film_reynolds ( fe_f , mat , ke_ij , be_i , ind_e ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film* type ( MAT_SOLV ), intent ( inout ) :: mat !! *solver type matrices* real ( kind = R8 ), intent ( out ), dimension ( MAX_NNC , MAX_NNC ) :: ke_ij !! *elementary matrix* real ( kind = R8 ), intent ( inout ), dimension ( MAX_NNC ) :: be_i !! *elementary rhs member* integer ( kind = I4 ), intent ( out ), dimension ( MAX_NNC ) :: ind_e !! *elementary index member* integer ( kind = I4 ) :: e , ee , i , j , ii , nbc , nc logical ( kind = I4 ) :: flag integer ( kind = I4 ), dimension ( MAX_NBS ) :: ind_n real ( kind = R8 ), dimension ( MAX_NBS ) :: sav_vn real ( kind = R8 ), dimension ( MAX_NNC ) :: bc , dp nc = fe_f % m % nc ! check of precomputed tables allocation if (. not . allocated ( fe_f % prc % vcal )) call init_prc_tab ( fe_f ) ! boundary condition initialization if ( BC_SPLINE ) then bc ( 1 : nc ) = 0 else bc ( 1 : nc ) = be_i ( 1 : nc ) endif j = 1 do e = 1 , fe_f % m % ned do ee = 1 , fe_f % m % ed ( e )% n ind_n ( j ) = fe_f % m % ed ( e )% nm ( ee ) sav_vn ( j ) = fe_f % vn ( ind_n ( j ), P_N ) j = j + 1 enddo enddo nbc = j - 1 ! matrices ke_ij = 0._R8 ind_e = 0 be_i = 0._R8 ! calculation of the elementary matrix do i = 1 , nc ! number of corners ii = fe_f % m % cor ( i ) ind_e ( i ) = ii dp ( i ) = fe_f % vn ( ii , P_N ) / 1000 if ( BC_SPLINE ) then bc ( i ) = dp ( i ) else bc ( i ) = bc ( i ) + dp ( i ) endif if ( i == 1 ) flag = . true . call solve_FE_film ( fe_f = fe_f , & ! mat = mat , & ! bc = bc , & ! in flag_ass = flag ) ! flag = . false . call compute_corner_fluxes ( fe_f = fe_f , & ! mat = mat , & ! bf = be_i ) ! out ke_ij ( 1 : nc , i ) = - be_i ( 1 : nc ) / dp ( i ) if ( BC_SPLINE ) then bc ( i ) = 0 else bc ( i ) = bc ( i ) - dp ( i ) endif do j = 1 , nbc fe_f % vn ( ind_n ( j ), P_N ) = sav_vn ( j ) enddo enddo ! calculation of the RHS table call solve_FE_film ( fe_f = fe_f , & ! mat = mat , & ! bc = bc , & ! flag_ass = . false .) ! call compute_corner_fluxes ( fe_f = fe_f , & ! mat = mat , & ! bf = be_i ) ! out ! update of the matrix: the derivative is the difference ! between the residuals divided by the delta p do i = 1 , nc ke_ij ( 1 : nc , i ) = ke_ij ( 1 : nc , i ) + be_i ( 1 : nc ) / dp ( i ) enddo return endsubroutine elementary_full_domain_FE_film_reynolds !========================================================================================= !< @note Subroutine to calculate the precomputed tables on a FE_film !< !----------------------------------------------------------------------------------------- subroutine init_prc_tab ( fe_f ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f ! *FE film* integer ( kind = I4 ) :: i , j , k , ng real ( kind = R8 ), dimension (:), allocatable :: pg , wg ! number of Gauss points ng = 2 ! table allocation allocate ( pg ( ng ), wg ( ng )) fe_f % prc % ng = ng allocate ( fe_f % prc % pg ( ng ), & fe_f % prc % wg ( ng ), & fe_f % prc % vni4 ( 4 , ng , ng ), & fe_f % prc % vni4x ( 4 , ng , ng ), & fe_f % prc % vni4y ( 4 , ng , ng ), & fe_f % prc % vni4d ( 4 , ng , ng ), & fe_f % prc % vcal ( 20 , ng , ng ) ) ! Gauss points definition pg ( 1 ) = - 1._R8 / sqrt ( 3._R8 ) pg ( 2 ) = - pg ( 1 ) wg = 1._R8 fe_f % prc % pg = pg fe_f % prc % wg = wg ! precomputation of shape functions and derivatives at the Gauss points do i = 1 , ng do j = 1 , ng do k = 1 , 4 fe_f % prc % vni4 ( k , i , j ) = ni4 ( k , pg ( i ), pg ( j )) enddo enddo enddo deallocate ( pg , wg ) return endsubroutine init_prc_tab !========================================================================================= !> @note Subroutine to calculate the precomputed tables on a [[FE_FILM]] !  @endnote !----------------------------------------------------------------------------------------- subroutine compute_prc_tables_reynolds_supg ( fe_f , e ) implicit none type ( FE_film ), intent ( inout ) :: fe_f !! *FE film* integer ( kind = I4 ), intent ( in ) :: e !! *element number* integer ( kind = I4 ) :: i , j , k , ng , nne logical ( kind = I4 ) :: gaz real ( kind = R8 ), dimension ( MAX_NNE ) :: tvx , tvy , th , tp , trho , tmu , tdrdp , tx , ty , tnix , tniy real ( kind = R8 ), dimension ( MAX_NNG ) :: wg , pg real ( kind = R8 ) :: c5 , vc1 real ( kind = R8 ) :: Pe_ux , Pe_uy , Pe_u , Pe_vx , Pe_vy , Pe_v , coeff_x , coeff_y , kk real ( kind = R8 ) :: sx , sy , alpha_u , alpha_ux , alpha_uy , alpha_vx , alpha_vy , alpha_v real ( kind = R8 ) :: dNidx_p , dNidy_p , Nid_rho_h , Ni_p , Ni_h , Ni_h3 , Ni_vx , Ni_vy , Ni_mu , Ni_rho , Ni_inv_h , Ni_inv_mu real ( kind = R8 ) :: lu , wu , lv , wv real ( kind = R8 ) :: Ni_drhodp , gradh , gradhx , gradhy , gradp , gradpx , gradpy real ( kind = R8 ) :: drdp , h , mu , rho , u , ux , uy , v , vx , vy real ( kind = R8 ), dimension ( MAX_NNE ) :: vni4 , vni4x , vni4y , vni4d real ( kind = R8 ), dimension ( 14 ) :: vcal !============================================ !> {!MUSST/src/inc_doc/Reynolds_discretization.md!} !============================================ !============================================ !> {!MUSST/src/inc_doc/upwinding_coefficients.md!} !============================================ gaz = ( fe_f % data_f % fl % fluid_type == GP ) nne = fe_f % m % el_t ( e ) ! values on the nodes do i = 1 , nne j = fe_f % m % con ( e , i ) tx ( i ) = fe_f % m % x ( j ) ! coordinates ty ( i ) = fe_f % m % y ( j ) tvx ( i ) = fe_f % vn ( j , VX_N ) ! velocities tvy ( i ) = fe_f % vn ( j , VY_N ) th ( i ) = fe_f % vn ( j , H_N ) ! heigth tp ( i ) = fe_f % vn ( j , P_N ) ! pressure trho ( i ) = fe_f % vn ( j , RHO_N ) ! density tmu ( i ) = fe_f % vn ( j , MU_N ) ! viscosity tdrdp ( i ) = fe_f % vn ( j , DRHODP_N ) ! viscosity derivative regarding P enddo c5 = dj4 ( ksi = 0._R8 , eta = 0._R8 , x = tx ( 1 : nne ), y = ty ( 1 : nne )) call calc_ni4_xy_derivatives ( ni4x = tnix ( 1 : nne ), & ni4y = tniy ( 1 : nne ), & ksi = 0._R8 , & eta = 0._R8 , & x = tx ( 1 : nne ), & y = ty ( 1 : nne ), & dj = c5 ) ! addition of the groove depth th ( 1 : nne ) = th ( 1 : nne ) + fe_f % vc ( e , HG_C ) ux = sum ( tvx ( 1 : nne )) / nne uy = sum ( tvy ( 1 : nne )) / nne u = sqrt ( ux ** 2 + uy ** 2 ) h = sum ( th ( 1 : nne )) / nne drdp = sum ( tdrdp ( 1 : nne )) / nne mu = sum ( tmu ( 1 : nne )) / nne rho = sum ( trho ( 1 : nne )) / nne gradpx = sum ( tp ( 1 : nne ) * tnix ( 1 : nne ) ) gradpy = sum ( tp ( 1 : nne ) * tniy ( 1 : nne ) ) gradp = sqrt ( gradpx ** 2 + gradpy ** 2 ) gradhx = sum ( th ( 1 : nne ) * tnix ( 1 : nne ) ) gradhy = sum ( th ( 1 : nne ) * tniy ( 1 : nne ) ) gradh = sqrt ( gradhx ** 2 + gradhy ** 2 ) kk = 6 * ( drdp / rho ) * mu * ( 1. / h ** 2 ) ! Gauss points ng = fe_f % prc % ng pg ( 1 : ng ) = fe_f % prc % pg ( 1 : ng ) wg ( 1 : ng ) = fe_f % prc % wg ( 1 : ng ) if ( gaz ) then v = - ( h ** 2 ) / ( 6 * mu ) vx = v * gradpx vy = v * gradpy v = sqrt ( vx ** 2 + vy ** 2 ) call length_width_elem ( spdx = ux , & !  in, speed u along x spdy = uy , & !  in, speed u along y x = tx , & !  in, element x coordinates y = ty , & !  in, element y coordinates length = lu , & ! out, length along u width = wu ) ! out,  width call length_width_elem ( spdx = vx , & !  in, speed v along x spdy = vy , & !  in, speed v along y x = tx , & !  in, element x coordinates y = ty , & !  in, element y coordinates length = lv , & ! out, length along v width = wv ) ! out,  width ! Peclet number related to u Pe_ux = ux * ( lu / 2 ) * kk Pe_uy = uy * ( lu / 2 ) * kk Pe_u = sqrt ( Pe_ux ** 2 + Pe_uy ** 2 ) ! Peclet number related to v Pe_vx = vx * ( wu / 2 ) * kk Pe_vy = vy * ( wu / 2 ) * kk Pe_v = sqrt ( Pe_vx ** 2 + Pe_vy ** 2 ) alpha_ux = Pe_ux alpha_uy = Pe_uy alpha_u = Pe_u alpha_v = ( h / 1.e6 ) * ( u / 1.e2 ) * ( mu / 1.e-5 ) * ( wu / lu ) * ( Pe_vx * ( - uy ) + Pe_vy * ( + ux ) ) / u alpha_vx = alpha_v * ( - uy ) / u alpha_vy = alpha_v * ( + ux ) / u alpha_v = sqrt ( alpha_vx ** 2 + alpha_vy ** 2 ) coeff_x = alpha_ux + alpha_vx ; sx = sign ( 1._R8 , coeff_x ) ; coeff_x = abs ( coeff_x ) coeff_y = alpha_uy + alpha_vy ; sy = sign ( 1._R8 , coeff_y ) ; coeff_y = abs ( coeff_y ) fe_f % vc ( e , PEK_C ) = sx * coeff_x fe_f % vc ( e , PEE_C ) = sy * coeff_y else lu = maxval ( tx ( 1 : nne )) - minval ( tx ( 1 : nne )) wu = maxval ( ty ( 1 : nne )) - minval ( ty ( 1 : nne )) lv = lu * ux + wu * uy Pe_ux = kk * ( lv / 2 ) Pe_uy = 0._R8 if ( abs ( Pe_ux ) < 1.e-2_R8 ) then Pe_ux = Pe_ux / 3 else Pe_ux = 1._R8 / ( tanh ( Pe_ux )) - 1._R8 / Pe_ux endif alpha_vx = 1._r8 alpha_vy = 1._r8 if ( u > 0._r8 ) then alpha_vx = lv * ux / ( 2 * ( u ** 2 )) alpha_vy = lv * uy / ( 2 * ( u ** 2 )) endif fe_f % vc ( e , Pek_c ) = alpha_vx fe_f % vc ( e , Pee_c ) = alpha_vy endif !============================================= !> {!MUSST/src/inc_doc/precomputed_integrations.md!} !============================================= do i = 1 , ng do j = 1 , ng vni4 ( 1 : nne ) = fe_f % prc % vni4 ( 1 : nne , i , j ) ! computation of the shape function derivatives c5 = dj4 ( ksi = pg ( i ), eta = pg ( j ), x = tx ( 1 : nne ), y = ty ( 1 : nne )) call calc_ni4_xy_derivatives ( ni4x = vni4x ( 1 : nne ), & ni4y = vni4y ( 1 : nne ), & ksi = pg ( i ), & eta = pg ( j ), & x = tx ( 1 : nne ), & y = ty ( 1 : nne ), & dj = c5 ) if ( c5 < 0 ) stop 'compute_prc_tables_reynolds_supg: jacobian negative for elt' if ( gaz ) then do k = 1 , nne vni4d ( k ) = ni4_up_2d ( k , pg ( i ), pg ( j ), ( / coeff_x , coeff_y / ), ( / sx , sy / )) enddo else vni4d ( 1 : nne ) = vni4 ( 1 : nne ) - alpha_vx * Pe_ux * vni4x ( 1 : nne ) - alpha_vy * Pe_ux * vni4y ( 1 : nne ) endif fe_f % prc % vni4x ( 1 : nne , i , j ) = vni4x ( 1 : nne ) fe_f % prc % vni4y ( 1 : nne , i , j ) = vni4y ( 1 : nne ) fe_f % prc % vni4d ( 1 : nne , i , j ) = vni4d ( 1 : nne ) ! computation of the coefficients for the Reynolds equation vc1 = wg ( i ) * wg ( j ) * c5 dNidx_p = sum ( vni4x ( 1 : nne ) * tp ( 1 : nne )) dNidy_p = sum ( vni4y ( 1 : nne ) * tp ( 1 : nne )) Nid_rho_h = sum ( vni4d ( 1 : nne ) * trho ( 1 : nne ) * th ( 1 : nne )) Ni_p = sum ( vni4 ( 1 : nne ) * tp ( 1 : nne )) Ni_h = sum ( vni4 ( 1 : nne ) * th ( 1 : nne )) Ni_h3 = sum ( vni4 ( 1 : nne ) * th ( 1 : nne ) ** 3 ) Ni_vx = sum ( vni4 ( 1 : nne ) * tvx ( 1 : nne )) Ni_vy = sum ( vni4 ( 1 : nne ) * tvy ( 1 : nne )) Ni_mu = sum ( vni4 ( 1 : nne ) * tmu ( 1 : nne )) Ni_rho = sum ( vni4 ( 1 : nne ) * trho ( 1 : nne )) Ni_inv_h = sum ( vni4 ( 1 : nne ) * ( 1._R8 / th ( 1 : nne ))) Ni_inv_mu = sum ( vni4 ( 1 : nne ) * ( 1._R8 / tmu ( 1 : nne ))) Ni_drhodp = sum ( vni4 ( 1 : nne ) * tdrdp ( 1 : nne )) vcal ( 1 ) = vc1 vcal ( 2 ) = vc1 * Ni_h3 * Ni_rho * Ni_inv_mu vcal ( 3 ) = vc1 * 6 * Ni_vx * Ni_h vcal ( 4 ) = vc1 * 6 * Ni_vy * Ni_h vcal ( 5 ) = 0 vcal ( 6 ) = vc1 * Ni_h3 * Ni_inv_mu * Ni_rho * dNidx_p vcal ( 7 ) = vc1 * Ni_h3 * Ni_inv_mu * Ni_rho * dNidy_p vcal ( 8 ) = vc1 * 6 * Ni_vx * Nid_rho_h vcal ( 9 ) = vc1 * 6 * Ni_vy * Nid_rho_h vcal ( 10 ) = vc1 * Ni_h3 * Ni_inv_mu * dNidx_p vcal ( 11 ) = vc1 * Ni_h3 * Ni_inv_mu * dNidy_p vcal ( 12 ) = vc1 * Ni_p vcal ( 13 ) = vc1 * ( - dNidx_p * Ni_h / 2 - Ni_mu * Ni_vx * Ni_inv_h ) vcal ( 14 ) = vc1 * ( - dNidy_p * Ni_h / 2 - Ni_mu * Ni_vy * Ni_inv_h ) fe_f % prc % vcal ( 1 : 14 , i , j ) = vcal ( 1 : 14 ) enddo enddo !============================================= !> {!MUSST/css/button.html!} !============================================= return endsubroutine compute_prc_tables_reynolds_supg !========================================================================================= !> @note Subroutine to calculate the characteristic length of an element, giving !        x and y velocities !  @endnote !----------------------------------------------------------------------------------------- subroutine length_width_elem ( spdx , spdy , x , y , length , width ) implicit none real ( kind = R8 ), intent ( in ) :: spdx !! *fluid velocity along x axis* real ( kind = R8 ), intent ( in ) :: spdy !! *fluid velocity along y axis* real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: x !! *corner abscissae* real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: y !! *corner ordinates* real ( kind = R8 ), intent ( out ) :: length !! *fluid element length* real ( kind = R8 ), intent ( out ) :: width !! *fluid element width* real ( kind = R8 ) :: abx , adx , cbx , cdx , & aby , ady , cby , cdy , & acx , bdx , acy , bdy , & el_S , px , py , pm , spd , & ac_dot_p , bd_dot_p , ab_dot_p , & ad_dot_p , cb_dot_p , cd_dot_p , & x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4 length = 0. width = 0. spd = sqrt ( spdx ** 2 + spdy ** 2 ) if ( spd > EPS_R8 ) then px = - spdy ! direction perpendicular to vector v py = + spdx pm = spd x1 = x ( 1 ) ; y1 = y ( 1 ) x2 = x ( 2 ) ; y2 = y ( 2 ) x3 = x ( 3 ) ; y3 = y ( 3 ) x4 = x ( 4 ) ; y4 = y ( 4 ) acx = x3 - x1 ; acy = y3 - y1 bdx = x4 - x2 ; bdy = y4 - y2 abx = x2 - x1 ; aby = y2 - y1 adx = x4 - x1 ; ady = y4 - y1 cbx = x2 - x3 ; cby = y2 - y3 cdx = x4 - x3 ; cdy = y4 - y3 ac_dot_p = abs ( px * acx + py * acy ) bd_dot_p = abs ( px * bdx + py * bdy ) ab_dot_p = abs ( px * abx + py * aby ) ad_dot_p = abs ( px * adx + py * ady ) cb_dot_p = abs ( px * cbx + py * cby ) cd_dot_p = abs ( px * cdx + py * cdy ) ! quadrangle projection on the perpendicular to v width = max ( ac_dot_p , bd_dot_p , ab_dot_p , & ad_dot_p , cb_dot_p , cd_dot_p ) / pm ! quadrangle area el_S = 0.5 * ( abs ( cbx * cdy - cdx * cby ) + abs ( abx * ady - adx * aby ) ) ! element length length = el_S / width endif return endsubroutine length_width_elem !========================================================================================= !< @note Subroutine to calculate the fluxes at the corner of the domain !< !----------------------------------------------------------------------------------------- subroutine compute_corner_fluxes ( fe_f , mat , bf ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film* type ( MAT_SOLV ), intent ( inout ) :: mat !! *solver type matrices* real ( kind = R8 ), intent ( out ), dimension ( MAX_NNC ) :: bf !! *table of fluxes at the corner* integer ( kind = I4 ) :: ind2 , ind1 , ind , e , i real ( kind = R8 ) :: x1 , x2 , y1 , y2 , d , l ! calculation of the fluxes on the boundaries by assembly ass_c = no_bc call assembly_FE_film_reynolds ( fe_f = fe_f , & ! mat = mat , & ! ass_c = NO_BC ) ! ! projection of the fluxes on the corners ! loop on edges bf = 0.0_R8 ind1 = 1 x1 = fe_f % m % x ( fe_f % m % cor ( 1 )) y1 = fe_f % m % y ( fe_f % m % cor ( 1 )) do e = fe_f % m % ned , 1 , - 1 ind2 = ind1 x2 = x1 y2 = y1 ind1 = e x1 = fe_f % m % x ( fe_f % m % cor ( e )) y1 = fe_f % m % y ( fe_f % m % cor ( e )) ! length of the edge l = (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ** 0.5_R8 ! loop on all the nodes - 1 on the edge ! without -1, the corner contribution is counted two times do i = 1 , fe_f % m % ed ( e )% n - 1 ind = fe_f % m % ed ( e )% nm ( i ) ! distance to point 2 d = (( x2 - fe_f % m % x ( ind )) ** 2 + ( y2 - fe_f % m % y ( ind )) ** 2 ) ** 0.5_R8 d = d / l ! linear projection along the edge of the local flux bf ( ind1 ) = bf ( ind1 ) + d * mat % b ( ind ) bf ( ind2 ) = bf ( ind2 ) + ( 1._R8 - d ) * mat % b ( ind ) enddo enddo return endsubroutine compute_corner_fluxes !========================================================================================= !< @note function to calculate the generated load in a fluid film !<  \\int_\\Omega p d\\Omega  !< !----------------------------------------------------------------------------------------- real ( kind = R8 ) function fz ( fe_f ) implicit none class ( FE_film ), intent ( inout ) :: fe_f !! *fluid type* integer ( kind = I4 ) :: e fz = 0.0_R8 do e = 1 , fe_f % m % ne call compute_prc_tables_reynolds_supg ( fe_f , e ) fz = fz + sum ( fe_f % prc % vcal ( 12 , :, :)) enddo return endfunction fz !========================================================================================= !< @note function to calculate the friction force along x in a fluid film !<  \\int_\\Omega \\tau_{xz} d\\Omega  !< !----------------------------------------------------------------------------------------- real ( kind = R8 ) function fx ( fe_f ) implicit none class ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film* integer ( kind = I4 ) :: e fx = 0._R8 do e = 1 , fe_f % m % ne call compute_prc_tables_reynolds_supg ( fe_f , e ) fx = fx + sum ( fe_f % prc % vcal ( 13 , :, :)) enddo return endfunction fx !========================================================================================= !< @note function to calculate the friction force along y in a fluid film !<  \\int_\\Omega \\tau_{yz} d\\Omega  !< !----------------------------------------------------------------------------------------- real ( kind = R8 ) function fy ( fe_f ) implicit none class ( FE_film ), intent ( inout ) :: fe_f !! *FE film* integer ( kind = I4 ) :: e fy = 0._R8 do e = 1 , fe_f % m % ne call compute_prc_tables_reynolds_supg ( fe_f , e ) fy = fy + sum ( fe_f % prc % vcal ( 14 , :, :)) enddo return endfunction fy !========================================================================================= !> @note Subroutine to save a [[FE_FILM]] in a ```.sur``` file !  @endnote !----------------------------------------------------------------------------------------- subroutine save_fe_field ( fe_f , file_name , code , nodal ) implicit none type ( FE_FILM ), intent ( in ) :: fe_f character ( len =* ), intent ( in ) :: file_name integer ( kind = I4 ), intent ( in ) :: code logical ( kind = I4 ), intent ( in ) :: nodal !! if false : cell value, if true : nodal value integer ( kind = I4 ) :: nx , ny integer ( kind = I4 ), dimension ( 1 ) :: i1 , i2 real ( kind = R8 ), allocatable , dimension (:,:) :: tab_s real ( kind = R8 ) :: lx , ly character ( len = 8 ) :: unit_z nx = fe_f % m % nx ny = fe_f % m % ny lx = fe_f % m % lx ly = fe_f % m % ly call empty ( unit_z ) if (. not . nodal ) then nx = nx - 1 ny = ny - 1 endif allocate ( tab_s ( 1 : nx , 1 : ny ) ) ; tab_s = - 1. if ( nodal ) then tab_s = reshape ( fe_f % vn (:, code ), ( / nx , ny / ) ) i1 = index ( fe_f % vn_name ( code ), '(' ) + 1 i2 = index ( fe_f % vn_name ( code ), ')' ) - 1 unit_z = fe_f % vn_name ( code )( i1 ( 1 ): i2 ( 1 )) else tab_s = reshape ( fe_f % vc (:, code ), ( / nx , ny / ) ) i1 = index ( fe_f % vc_name ( code ), '(' ) + 1 i2 = index ( fe_f % vc_name ( code ), ')' ) - 1 unit_z = fe_f % vc_name ( code )( i1 ( 1 ): i2 ( 1 )) endif call init_scal ( scal = scal_tmp , & ! nx = nx , & ! ny = ny , & ! lx = lx , & ! default unit : m ly = ly , & ! unit_z = unit_z ) ! call write_surf ( nom_fic = file_name , & ! tab_s = tab_s , & ! scal = scal_tmp ) deallocate ( tab_s ) return endsubroutine save_fe_field endmodule film","loc":"sourcefile/mod_film.f90.html"},{"tags":"","title":"mod_fluid.f90 – MUSST","text":"This file depends on sourcefile~~mod_fluid.f90~~EfferentGraph sourcefile~mod_fluid.f90 mod_fluid.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_fluid.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_fluid.f90~~AfferentGraph sourcefile~mod_fluid.f90 mod_fluid.f90 sourcefile~mod_data.f90 mod_data.f90 sourcefile~mod_data.f90->sourcefile~mod_fluid.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_fluid.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_data.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_film.f90->sourcefile~mod_fluid.f90 sourcefile~mod_film.f90->sourcefile~mod_data.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_data.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 var pansourcefilemod_fluidf90AfferentGraph = svgPanZoom('#sourcefilemod_fluidf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules fluid_law Source Code mod_fluid.f90 Source Code !! author: Noël Brunetière<br/>&emsp;Arthur Francisco !! version: 1.0.0 !! date: May, 3 2017 !< <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<       **Rheological and thermodynamic behavior of fluid** !< </span> !<# Description of the fluid module !< The fluid module module_fluid_law proposes different rheological and thermodynamic laws for the fluids. ! !<##  Fluid type !< In the current version, three fluid types are proposed: !< !<- incompressible liquid !<- perfect gas !<- mixture of liquid and gaz !< !< The fluid parameters are: !< !<- \\rho_0,  liquid density; !<- r_g,     the perfect gas constant of the considered gas; !<- \\lambda, the gas mass fraction. !< ! !<## Density and compressibility !< The module is limited to the density \\rho [[FLUID:rho]] and compressibility !< \\frac{\\partial \\rho}{\\partial p} [[FLUID:drhodp]] computation based on the pressure p and absolute temperature t ! !<### Incompressible [[fluid_law:INC]] !<- \\rho=\\rho_0 !<- \\frac{\\partial \\rho}{\\partial p}=0 !<### Perfect gas [[fluid_law:GP]] !<- \\rho=\\frac{p}{r_g T} !<- \\frac{\\partial \\rho}{\\partial p}=\\frac{1}{r_g T} !<### Mixture [[fluid_law:MIXT]] !<- \\rho=\\frac{1}{\\frac{1-\\lambda}{\\rho_0}+\\frac{\\lambda r_g T}{p}} !<- \\frac{\\partial \\rho}{\\partial p}=\\frac{\\lambda \\rho_O&#94;2 r_g T}{\\left(p(1-\\lambda) +\\lambda r_g T \\rho_0\\right)&#94;2} module fluid_law use data_arch , only : I4 , R8 implicit none private type FLUID integer ( kind = I4 ) :: fluid_type !! *constant for the fluid type: INC, GP, MIXT* real ( kind = R8 ) :: p_0 !! *reference pressure* real ( kind = R8 ) :: rho_0 !! *reference liquid density* real ( kind = R8 ) :: mu_0 !! *reference dynamic viscosity* real ( kind = R8 ) :: T_0 !! *reference temperature* real ( kind = R8 ) :: rg !! *perfect gas constant* real ( kind = R8 ) :: lambda !! *gas mass fraction* real ( kind = R8 ), dimension ( 20 ) :: cst !! *table of parameters for the thermodynamic and rheological laws* contains procedure :: rho !! *density* procedure :: drhodp !! *compressibility* procedure :: pres !! *pressure (perfect gas)* endtype FLUID ! Codes for basic fluid type integer ( kind = I4 ), parameter :: INC = 0 !! *incompressible fluid* integer ( kind = I4 ), parameter :: GP = 1 !! *perfect gas* integer ( kind = I4 ), parameter :: MIXT = 2 !! *mixture of liquid and gas* public :: FLUID , INC , GP , MIXT contains real ( kind = R8 ) function rho ( fl , p , t ) !========================================================================================= !< @note Function to calculate the density of the fluid based on *t* and *p* ! !+ if fl is set to [[fluid_law:INC]]  (incompressible) \\rho=\\rho_0          where \\rho_0 is a member of fl [[FLUID]] !+ if fl is set to [[fluid_law:GP]]   (perfect gas)    \\rho=\\frac{p}{r_g T} where r_g    is a member of fl [[FLUID]] !+ if fl is set to [[fluid_law:MIXT]] (mixture)        \\rho=\\frac{1}{\\frac{1-\\lambda}{\\rho_0}+\\frac{\\lambda r_g T}{p}} where \\lambda \\text{ and } r_g are members of fl [[FLUID]] ! !  @endnote !------------------------------------------------------------------------------------------ implicit none class ( FLUID ), intent ( in ) :: fl !! *fluid type* real ( kind = R8 ), intent ( in ) :: p !! *pressure* real ( kind = R8 ), intent ( in ) :: t !! *absolute temperature* select case ( fl % fluid_type ) case ( INC ) ; rho = fl % rho_0 case ( GP ) ; rho = p / ( fl % rg * t ) case ( MIXT ) ; rho = 1._R8 / (( 1._R8 - fl % lambda ) / fl % rho_0 + ( fl % lambda * fl % rg * t ) / p ) case default ; stop 'Bad case number rho' endselect return endfunction rho real ( kind = R8 ) function drhodp ( fl , p , t ) !========================================================================================= !< @note Function to calculate compressibility (drdp)T based on T and p ! !+ if fl is set to [[fluid_law:INC]]  (incompressible) \\rho=0 !+ if fl is set to [[fluid_law:GP]]   (perfect gas)    \\rho=\\frac{1}{r_g T} where r_g !                                                            is a member of fl [[FLUID]] !+ if fl is set to [[fluid_law:MIXT]] (mixture)        \\rho=\\frac{\\lambda \\rho_0&#94;2 r_g T}{(p(1-\\lambda) + !                  \\lambda r_g T \\rho_0)&#94;2} where \\lambda \\' , \\' \\rho_0 \\text{ and } r_g are members of fl [[FLUID]] !  @endnote !----------------------------------------------------------------------------------------- implicit none class ( FLUID ), intent ( in ) :: fl !! *fluid type* real ( kind = R8 ), intent ( in ) :: p !! *pressure* real ( kind = R8 ), intent ( in ) :: t !! *absolute temperature* select case ( fl % fluid_type ) case ( INC ) ; drhodp = 0._R8 case ( GP ) ; drhodp = 1._R8 / ( fl % rg * t ) case ( MIXT ) ; drhodp = fl % lambda * ( fl % rho_0 ** 2 ) * fl % rg * t / ((( 1._R8 - fl % lambda ) * p + fl % lambda * fl % rho_0 * fl % rg * t ) ** 2 ) case default ; stop 'Bad case number drhodp' endselect return endfunction drhodp real ( kind = R8 ) function pres ( fl , rho , t ) !========================================================================================= !< @note Function to calculate pressure (pres) based on T and density ! !+ if fl is set to [[fluid_law:GP]]   (perfect gas)    pres=\\rho r_g T where r_g !                                                            is a member of fl [[FLUID]] !+ if fl is set to [[fluid_law:MIXT]] (mixture)        pres=\\frac{\\lambda r_g T}{\\frac{1}{\\rho} - !                                           \\frac{1-\\lambda}{\\rho_0}} are members of fl [[FLUID]] !  @endnote !----------------------------------------------------------------------------------------- implicit none class ( FLUID ), intent ( in ) :: fl !! *fluid type* real ( kind = R8 ), intent ( in ) :: rho !! *density* real ( kind = R8 ), intent ( in ) :: t !! *absolute temperature* select case ( fl % fluid_type ) case ( GP ) ; pres = rho * fl % rg * T case ( MIXT ) ; pres = fl % lambda * fl % rg * T / ( 1.0_R8 / rho - ( 1.0_R8 - fl % lambda ) / fl % rho_0 ) case default ; stop 'Bad case number pres' endselect endfunction pres endmodule fluid_law","loc":"sourcefile/mod_fluid.f90.html"},{"tags":"","title":"mod_inout_files.f90 – MUSST","text":"This file depends on sourcefile~~mod_inout_files.f90~~EfferentGraph sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_vtk.f90 mod_vtk.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_vtk.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_surfile.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_surfile.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_num_par.f90 mod_num_par.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_num_par.f90 sourcefile~mod_mesh.f90 mod_mesh.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_mesh.f90 sourcefile~mod_bspline.f90 mod_bspline.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_bspline.f90 sourcefile~mod_fluid.f90 mod_fluid.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_fluid.f90 sourcefile~mod_data.f90 mod_data.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_data.f90 sourcefile~mod_ir_vtk.f90 mod_ir_vtk.f90 sourcefile~mod_vtk.f90->sourcefile~mod_ir_vtk.f90 sourcefile~mod_surfile.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_surfile.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_film.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_film.f90->sourcefile~mod_surfile.f90 sourcefile~mod_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_film.f90->sourcefile~mod_num_par.f90 sourcefile~mod_film.f90->sourcefile~mod_mesh.f90 sourcefile~mod_elements.f90 mod_elements.f90 sourcefile~mod_film.f90->sourcefile~mod_elements.f90 sourcefile~mod_film.f90->sourcefile~mod_fluid.f90 sourcefile~mod_film.f90->sourcefile~mod_data.f90 sourcefile~mod_solver.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_gen_par.f90 mod_gen_par.f90 sourcefile~mod_solver.f90->sourcefile~mod_gen_par.f90 sourcefile~umfpack.f90 umfpack.f90 sourcefile~mod_solver.f90->sourcefile~umfpack.f90 sourcefile~superlu.f90 superlu.f90 sourcefile~mod_solver.f90->sourcefile~superlu.f90 sourcefile~dmumps_struc.f90 dmumps_struc.f90 sourcefile~mod_solver.f90->sourcefile~dmumps_struc.f90 sourcefile~mod_num_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_mesh.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_elements.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_fluid.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_data.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_data.f90->sourcefile~mod_fluid.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_gen_par.f90->sourcefile~mod_data_arch.f90 var pansourcefilemod_inout_filesf90EfferentGraph = svgPanZoom('#sourcefilemod_inout_filesf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_inout_files.f90~~AfferentGraph sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules inout_files Source Code mod_inout_files.f90 Source Code !! author: Noël Brunetière<br/>&emsp;Arthur Francisco !! version: 1.0.0 !! date: April,17 2017 !! summary: save subroutines !< <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !         **Subroutines to save the data** !  </span> module inout_files use VTK use data_arch , only : I4 , R8 , get_unit use film use ms_film use surfile implicit none private integer ( kind = I4 ) :: s_vtk ! flag for vtk save integer ( kind = I4 ), parameter :: NO_VTK = 0 , TS_VTK = 1 , BS_VTK = 2 ! parameters for s_vtk public :: s_vtk , NO_VTK , TS_VTK , BS_VTK , save_fe_f_vtk , & save_ms_fe_f_vtk , & save_profile_x_comp_slider , & save_profile_x_comp_air_pocket , & save_profile_y_comp_air_pocket , & save_profile_x_fe , & save_profile_x_ms contains !========================================================================================= !< @note Subroutine to save deterministic data following VTK model !  @endnote !----------------------------------------------------------------------------------------- subroutine save_fe_f_vtk ( fe_f , nom_fic ) implicit none type ( FE_FILM ), intent ( in ) :: fe_f !! [[FE_FILM]] *element to store* character ( len =* ), intent ( in ) :: nom_fic !! *filename* integer ( kind = I4 ) :: E_IO ! parametre identification vtk integer ( kind = I4 ) :: i , k real ( kind = R8 ), dimension (:), allocatable :: z ! tableau supplementaire pour la sortie integer ( kind = I4 ), dimension (:), allocatable :: connec , tipo allocate ( z ( fe_f % m % n ), connec ( fe_f % m % ne * ( 1 + 4 )), tipo ( fe_f % m % ne )) z = 0._R8 tipo = 9 ! elements a quatre noeuds: 9 dans le formalisme vtk k = 0 do i = 1 , fe_f % m % ne connec ( k + 1 ) = 4 connec ( k + 2 ) = fe_f % m % con ( i , 1 ) - 1 connec ( k + 3 ) = fe_f % m % con ( i , 2 ) - 1 connec ( k + 4 ) = fe_f % m % con ( i , 3 ) - 1 connec ( k + 5 ) = fe_f % m % con ( i , 4 ) - 1 k = k + 5 enddo ! ouverture du fichier E_IO = VTK_INI ( output_format = 'binary' , & filename = nom_fic , & title = 'Resultats fe_f fluide' , & mesh_topology = 'UNSTRUCTURED_GRID' ) ! ecriture des coordonnees E_IO = VTK_GEO ( NN = fe_f % m % n , & X = fe_f % m % x , & Y = fe_f % m % y , & Z = Z ) ! definition des cellules E_IO = VTK_CON ( NC = fe_f % m % ne , & connect = connec , & cell_type = tipo ) ! choix du type de variable (elementaire) E_IO = VTK_DAT ( NC_NN = fe_f % m % ne , & var_location = 'cell' ) ! passage des variables cellules do i = 1 , fe_f % n_vc E_IO = VTK_VAR ( NC_NN = fe_f % m % ne , & varname = fe_f % vc_name ( i ), & var = fe_f % vc (:, i )) enddo ! choix du type de variable (nodale) E_IO = VTK_DAT ( NC_NN = fe_f % m % n , & var_location = 'node' ) ! passage des variables nodales do i = 1 , fe_f % n_vn E_IO = VTK_VAR ( NC_NN = fe_f % m % n , & varname = fe_f % vn_name ( i ), & var = fe_f % vn (:, i )) enddo ! fermeture du fichier vtk E_IO = VTK_END () ! liberation des tableaux deallocate ( z , connec , tipo ) return endsubroutine save_fe_f_vtk !========================================================================================= !< @note Subroutine to save the top scale data following VTK model !  @endnote !----------------------------------------------------------------------------------------- subroutine save_ms_fe_f_vtk ( ms_fe_f , nom_fic ) implicit none type ( MS_FE_FILM ), intent ( in ) :: ms_fe_f !! [[MS_FE_FILM]] *element to store* character ( len =* ), intent ( in ) :: nom_fic !! *filename* integer ( kind = I4 ) :: e , ne , i , l character ( len = 256 ) :: nom_fic_bs , nom_fic_ts character ( len = 128 ) :: suff nom_fic_bs = repeat ( \" \" , len ( nom_fic_bs )) nom_fic_ts = repeat ( \" \" , len ( nom_fic_bs )) suff = repeat ( \" \" , len ( suff ) ) i = index ( trim ( nom_fic ), \"/\" , back = . true .) l = len_trim ( nom_fic ) if ( s_vtk > NO_VTK ) then nom_fic_ts = nom_fic ( 1 : i ) // \"ts_\" // nom_fic ( i + 1 : l ) call save_fe_f_vtk ( ms_fe_f % ts_fe_f , trim ( nom_fic_ts )) write ( * , * ) trim ( nom_fic_ts ) endif if ( s_vtk == BS_VTK ) then ne = ms_fe_f % ts_fe_f % m % ne do e = 1 , ne write ( suff , '(i5.5, 2a)' ) e , \"_\" , nom_fic ( i + 1 : l ) nom_fic_bs = nom_fic ( 1 : i ) // trim ( suff ) call save_fe_f_vtk ( ms_fe_f % bs_fe_f ( e ), trim ( nom_fic_bs )) enddo endif return endsubroutine save_ms_fe_f_vtk !========================================================================================= !< @note Subroutine to save the pressures along a line following the flow, at distance !        zy from a border. !  @endnote !----------------------------------------------------------------------------------------- subroutine save_profile_x_fe ( fe_f , file_name , lx , zy ) implicit none type ( FE_FILM ), intent ( in ) :: fe_f !! [[FE_FILM]] *element* character ( len =* ), intent ( in ) :: file_name !! *filename* real ( kind = R8 ), intent ( in ) :: lx !! *surface length* real ( kind = R8 ), intent ( in ) :: zy !! *distance from a border* real ( kind = R8 ) :: dr integer ( kind = I4 ) :: i , k dr = lx / fe_f % m % n dr = dr / 10 call get_unit ( k ) open ( k , file = file_name , status = 'unknown' ) do i = 1 , fe_f % m % n if ((( fe_f % m % y ( i ) - zy ) ** 2 ) < ( dr ** 2 )) then write ( k , * ) fe_f % m % x ( i ), fe_f % vn ( i , H_N ), fe_f % vn ( i , P_N ) endif enddo close ( k ) return endsubroutine save_profile_x_fe !========================================================================================= !< @note Subroutine to save the pressures along a line following the flow, at distance !        zy from a border. !  @endnote !----------------------------------------------------------------------------------------- subroutine save_profile_x_ms ( ms_fe_f , file_name , lx , zy ) implicit none type ( MS_FE_FILM ), intent ( in ) :: ms_fe_f !! [[MS_FE_FILM]] *element* character ( len =* ), intent ( in ) :: file_name !! *filename* real ( kind = R8 ), intent ( in ) :: lx !! *surface length* real ( kind = R8 ), intent ( in ) :: zy !! *distance from a border* real ( kind = R8 ) :: dr integer ( kind = I4 ) :: i , e , k dr = lx / ms_fe_f % bs_fe_f ( 1 )% m % n dr = dr / 10 call get_unit ( k ) open ( k , file = file_name , status = 'unknown' ) do e = 1 , ms_fe_f % ts_fe_f % m % ne do i = 1 , ms_fe_f % bs_fe_f ( e )% m % n if ((( ms_fe_f % bs_fe_f ( e )% m % y ( i ) - zy ) ** 2 ) < ( dr ** 2 )) then write ( k , * ) ms_fe_f % bs_fe_f ( e )% m % x ( i ), ms_fe_f % bs_fe_f ( e )% vn ( i , H_N ), & ms_fe_f % bs_fe_f ( e )% vn ( i , P_N ) endif enddo enddo close ( k ) return endsubroutine save_profile_x_ms !========================================================================================= !< @note Subroutine to save the pressures along a line following the flow, at distance !        zy from a border. The theoretical values are also stored. !  @endnote !----------------------------------------------------------------------------------------- subroutine save_profile_x_comp_slider ( fe_f , file_name , lx , zy ) implicit none type ( FE_FILM ), intent ( in ) :: fe_f !! [[FE_FILM]] *element* character ( len =* ), intent ( in ) :: file_name !! *filename* real ( kind = R8 ), intent ( in ) :: lx !! *slider length* real ( kind = R8 ), intent ( in ) :: zy !! *distance from a border* real ( kind = R8 ) :: pref , K , dr , hr , hb , p0 integer ( kind = I4 ) :: i , kk dr = lx / fe_f % m % n dr = dr / 10 K = maxval ( fe_f % vn (:, H_N )) / minval ( fe_f % vn (:, H_N )) hr = minval ( fe_f % vn (:, H_N )) pref = 6 * fe_f % data_f % fl % mu_0 * fe_f % data_f % V_x * lx / ( hr ** 2 ) p0 = minval ( fe_f % vn (:, P_N )) call get_unit ( kk ) open ( kk , file = file_name , status = 'unknown' ) do i = 1 , fe_f % m % n if ((( fe_f % m % y ( i ) - zy ) ** 2 ) < ( dr ** 2 )) then hb = fe_f % vn ( i , H_N ) / hr write ( kk , * ) fe_f % m % x ( i ) / lx , hb , ( fe_f % vn ( i , P_N ) - p0 ) / pref , & 1.0 / ( K - 1 ) * ( 1.0 / hb - K / ( K + 1 ) * ( hb ** ( - 2 ) - K ** ( - 2 )) - 1.0 / K ) endif enddo close ( kk ) return endsubroutine save_profile_x_comp_slider !========================================================================================= !< @note Subroutine to save the pressures along a line following the flow, at distance !        zy from a border !  @endnote !----------------------------------------------------------------------------------------- subroutine save_profile_x_comp_air_pocket ( fe_f , file_name , lx , zy , bc ) implicit none type ( FE_FILM ), intent ( in ) :: fe_f !! [[FE_FILM]] *element* character ( len =* ), intent ( in ) :: file_name !! *filename* real ( kind = R8 ), intent ( in ) :: lx !! *pocket length* real ( kind = R8 ), intent ( in ) :: zy !! *distance from a border* real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: bc !! *pressure boundaries* real ( kind = R8 ) :: dr , hr , hb , p0 integer ( kind = I4 ) :: i , k dr = lx / fe_f % m % n dr = dr / 10 hr = minval ( fe_f % vn (:, H_N )) p0 = bc ( 1 ) call get_unit ( k ) open ( k , file = file_name , status = 'unknown' ) do i = 1 , fe_f % m % n if ((( fe_f % m % y ( i ) - zy ) ** 2 ) < ( dr ** 2 )) then hb = ( fe_f % vn ( i , H_N ) + fe_f % vc ( i , HG_C )) / hr write ( k , * ) fe_f % m % x ( i ) / lx , hb , fe_f % vn ( i , P_N ) / p0 , hb endif enddo close ( k ) return endsubroutine save_profile_x_comp_air_pocket !========================================================================================= !< @note Subroutine to save the pressures along a line perpendicular to the flow, at distance !        zx !  @endnote !----------------------------------------------------------------------------------------- subroutine save_profile_y_comp_air_pocket ( fe_f , file_name , ly , zx , bc ) implicit none type ( FE_FILM ), intent ( in ) :: fe_f !! [[FE_FILM]] *element* character ( len =* ), intent ( in ) :: file_name !! *filename* real ( kind = R8 ), intent ( in ) :: ly !! *pocket width* real ( kind = R8 ), intent ( in ) :: zx !! *distance from the pocket entry* real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: bc !! *pressure boundaries* real ( kind = R8 ) :: dr , hr , hb , p0 integer ( kind = I4 ) :: i , ii , jj , k logical ( kind = I4 ), allocatable , dimension (:) :: done dr = ly / fe_f % m % n dr = dr / 10 hr = minval ( fe_f % vn (:, H_N )) p0 = bc ( 1 ) allocate ( done ( 1 : fe_f % m % n )) ; done = . false . call get_unit ( k ) open ( k , file = file_name , status = 'unknown' ) do ii = 1 , fe_f % m % ne do jj = 1 , fe_f % m % el_t ( ii ) i = fe_f % m % con ( ii , jj ) if ( done ( i )) cycle done ( i ) = . true . if ((( fe_f % m % x ( i ) - zx ) ** 2 ) < ( dr ** 2 )) then hb = ( fe_f % vn ( i , H_N ) + fe_f % vc ( ii , HG_C )) / hr write ( k , * ) fe_f % m % y ( i ) / ly , hb , fe_f % vn ( i , P_N ) / p0 , hb endif enddo enddo close ( k ) deallocate ( done ) return endsubroutine save_profile_y_comp_air_pocket endmodule inout_files","loc":"sourcefile/mod_inout_files.f90.html"},{"tags":"","title":"mod_ir_vtk.f90 – MUSST","text":"provides variables that contains the smallest real evaluable by the running calculator, Zero, Zero16, Zero8 and Zero4.\n Finally the module provides a function to convert a string to number, 'cton', that accepts both reals and integers, and 2 other\n functions that convert a number to string: 'str' that convert real and integer to string and 'strz' that convert only integer to\n string prefixing the string with zeros. Files dependent on this one sourcefile~~mod_ir_vtk.f90~~AfferentGraph sourcefile~mod_ir_vtk.f90 mod_ir_vtk.f90 sourcefile~mod_vtk.f90 mod_vtk.f90 sourcefile~mod_vtk.f90->sourcefile~mod_ir_vtk.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_vtk.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules IR_VTK Source Code mod_ir_vtk.f90 Source Code !------------------------------------------------------------------------------------------ !! file: IR_precision.f03 !! author: Stefano Zaghi !! version: 1.0 !! brief: Module de passage des differents types numeriques !! details: The module IR_Precision makes available some portable kind-parameters and some usefull informations to deal with them. It also !! provides variables that contains the smallest real evaluable by the running calculator, Zero, Zero16, Zero8 and Zero4. !! Finally the module provides a function to convert a string to number, 'cton', that accepts both reals and integers, and 2 other !! functions that convert a number to string: 'str' that convert real and integer to string and 'strz' that convert only integer to !! string prefixing the string with zeros. !------------------------------------------------------------------------------------------ module IR_VTK !----------------------------------------------------------------------------------------------------------------------------------- implicit none private #ifdef r16p public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , ZeroR16 #endif public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P public :: str , strz , cton public :: IR_Print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- !!The following are the portable kind parameters available. !! !!Real precision definitions: !! #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) ! 33  digits, range $[10&#94;{-4931}, 10&#94;{+4931} - 1]$ #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) ! 15  digits, range $[10&#94;{-307} , 10&#94;{+307}  - 1]$ integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) ! 6   digits, range $[10&#94;{-37}  , 10&#94;{+37}   - 1]$ integer , parameter :: R_P = R8P ! default real precision !! !!Integer precision definitions: !! integer , parameter :: I8P = selected_int_kind ( 18 ) ! range $[-2&#94;{63},+2&#94;{63} - 1]$, 19 number of digits plus sign integer , parameter :: I4P = selected_int_kind ( 9 ) ! range $[-2&#94;{31},+2&#94;{31} - 1]$, 10 number of digits plus sign integer , parameter :: I2P = selected_int_kind ( 4 ) ! range $[-2&#94;{15},+2&#94;{15} - 1]$, 5  number of digits plus sign integer , parameter :: I1P = selected_int_kind ( 2 ) ! range $[-2&#94;{7} ,+2&#94;{7}  - 1]$, 3  number of digits plus sign integer , parameter :: I_P = I4P ! default integer precision !! !!Besides the kind parameters there are also the format parameters useful for writing in a well-ascii-format numeric variables. !! !!Real output formats: !! #ifdef r16p character ( 10 ), parameter :: FR16P = '(E42.33E4)' ! R16P  output format #endif character ( 10 ), parameter :: FR8P = '(E23.15E3)' ! R8P   output format character ( 9 ), parameter :: FR4P = '(E13.6E2)' ! R4P   output format character ( 10 ), parameter :: FR_P = FR8P ! R\\_P  output format !! !!Real number of digits of output formats: #ifdef r16p integer , parameter :: DR16P = 42 ! R16P output format digits #endif integer , parameter :: DR8P = 23 ! R8P  output format digits integer , parameter :: DR4P = 13 ! R4P  output format digits integer , parameter :: DR_P = DR8P ! R\\_P  output format digits !! !!Real min and max values: #ifdef r16p real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ), MaxR16P = huge ( 1._R16P ) ! R16P min and max values #endif real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ), MaxR8P = huge ( 1._R8P ) ! R8P  min and max values real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ), MaxR4P = huge ( 1._R4P ) ! R4P  min and max values real ( R_P ), parameter :: MinR_P = MinR8P , MaxR_P = MaxR8P ! R\\_P  min and max values !! !!Integer output formats: !! character ( 5 ), parameter :: FI8P = '(I20)' ! I8P output format character ( 8 ), parameter :: FI8PZP = '(I20.19)' ! I8P output format with zero prefixing character ( 5 ), parameter :: FI4P = '(I11)' ! I4P output format character ( 8 ), parameter :: FI4PZP = '(I11.10)' ! I4P output format with zero prefixing character ( 4 ), parameter :: FI2P = '(I6)' ! I2P output format character ( 6 ), parameter :: FI2PZP = '(I6.5)' ! I2P output format with zero prefixing character ( 4 ), parameter :: FI1P = '(I4)' ! I1P output format character ( 6 ), parameter :: FI1PZP = '(I4.3)' ! I1P output format with zero prefixing character ( 5 ), parameter :: FI_P = FI4P ! I\\_P output format character ( 8 ), parameter :: FI_PZP = FI4PZP ! I\\_P output format with zero prefixing !! !!Integer number of digits of output formats: integer , parameter :: DI8P = 20 ! I8P output format digits integer , parameter :: DI4P = 11 ! I4P output format digits integer , parameter :: DI2P = 6 ! I2P output format digits integer , parameter :: DI1P = 4 ! I1P output format digits integer , parameter :: DI_P = DI4P ! I\\_P output format digits !! !!Integer min and max values: integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) - 1_I8P , MaxI8P = huge ( 1_I8P ) ! I8P min and max values integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) - 1_I4P , MaxI4P = huge ( 1_I4P ) ! I4P min and max values integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) - 1_I2P , MaxI2P = huge ( 1_I2P ) ! I2P min and max values integer ( I2P ), parameter :: MinI1P = - huge ( 1_I1P ) - 1_I1P , MaxI1P = huge ( 1_I1P ) ! I1P min and max values integer ( I_P ), parameter :: MinI_P = MinI4P , MaxI_P = MaxI4P ! I\\_P min and max values !! !!IR\\_Precision module provides some global variables in order to store the smallest real evaluable by the running calculator. !! #ifdef r16p real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - nearest ( 1._R16P , - 1._R16P ) #endif #ifdef pgf95 real ( R8P ), parameter :: ZeroR8 = 0._R8P real ( R4P ), parameter :: ZeroR4 = 0._R4P #else real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - nearest ( 1._R8P , - 1._R8P ) real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - nearest ( 1._R4P , - 1._R4P ) #endif real ( R_P ), parameter :: Zero = ZeroR8 !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- !! str overloading interface str module procedure & #ifdef r16p str_R16P , & #endif str_R8P , & str_R4P , & str_I8P , & str_I4P , & str_I2P , & str_I1P endinterface !! strz overloading interface strz module procedure strz_I8P , & strz_I4P , & strz_I2P , & strz_I1P endinterface !! ctoi overloading interface cton module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains #ifdef r16p elemental function str_R16P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function str\\_R16P converts real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign ! Flag for leaving out the sign. real ( R16P ), intent ( IN ) :: n ! Real to be converted. character ( DR16P ) :: str ! Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P #endif elemental function str_R8P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function str\\_R8P converts real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign ! Flag for leaving out the sign. real ( R8P ), intent ( IN ) :: n ! Real to be converted. character ( DR8P ) :: str ! Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function str\\_R4P converts real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign ! Flag for leaving out the sign. real ( R4P ), intent ( IN ) :: n ! Real to be converted. character ( DR4P ) :: str ! Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function str\\_I8P converts integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign ! Flag for leaving out the sign. integer ( I8P ), intent ( IN ) :: n ! Integer to be converted. character ( DI8P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function str\\_I4P converts integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign ! Flag for leaving out the sign. integer ( I4P ), intent ( IN ) :: n ! Integer to be converted. character ( DI4P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function str\\_I2P converts integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign ! Flag for leaving out the sign. integer ( I2P ), intent ( IN ) :: n ! Integer to be converted. character ( DI2P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function str\\_I1P converts integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign ! Flag for leaving out the sign. integer ( I1P ), intent ( IN ) :: n ! Integer to be converted. character ( DI1P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function strz_I8P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function strz\\_I8P converts integer to string, prefixing with the right number of zeros. This function achieves casting of !!integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad ! Number of zeros padding. integer ( I8P ), intent ( IN ) :: n ! Integer to be converted. character ( DI8P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function strz\\_I4P converts integer to string, prefixing with the right number of zeros. This function achieves casting of !!integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad ! Number of zeros padding. integer ( I4P ), intent ( IN ) :: n ! Integer to be converted. character ( DI4P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function strz\\_I2P converts integer to string, prefixing with the right number of zeros. This function achieves casting of !!integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad ! Number of zeros padding. integer ( I2P ), intent ( IN ) :: n ! Integer to be converted. character ( DI2P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function strz\\_I1P converts integer to string, prefixing with the right number of zeros. This function achieves casting of !!integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad ! Number of zeros padding. integer ( I1P ), intent ( IN ) :: n ! Integer to be converted. character ( DI1P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P #ifdef r16p function ctor_R16P ( str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function ctor\\_R16P converts string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: str ! String containing input number. real ( R16P ), intent ( IN ) :: knd ! Number kind. real ( R16P ) :: n ! Number returned. integer ( I4P ) :: E_IO ! Input/Output debug flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = E_IO ) n ! Casting of str to n. if ( E_IO /= 0 ) then write ( 6 , '(A)' ) 'Conversion of string \"' // str // '\" to real failed' write ( 6 , '(A,' // FR16P // ')' ) 'Kind parameter ' , knd write ( 6 , '(A)' ) 'Function used \"ctor_R16P\"' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P #endif function ctor_R8P ( str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function ctor\\_R8P converts string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: str ! String containing input number. real ( R8P ), intent ( IN ) :: knd ! Number kind. real ( R8P ) :: n ! Number returned. integer ( I4P ) :: E_IO ! Input/Output debug flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = E_IO ) n ! Casting of str to n. if ( E_IO /= 0 ) then write ( 6 , '(A)' ) 'Conversion of string \"' // str // '\" to real failed' write ( 6 , '(A,' // FR8P // ')' ) 'Kind parameter ' , knd write ( 6 , '(A)' ) 'Function used \"ctor_R8P\"' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function ctor\\_R4P converts string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: str ! String containing input number. real ( R4P ), intent ( IN ) :: knd ! Number kind. real ( R4P ) :: n ! Number returned. integer ( I4P ) :: E_IO ! Input/Output debug flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = E_IO ) n ! Casting of str to n. if ( E_IO /= 0 ) then write ( 6 , '(A)' ) 'Conversion of string \"' // str // '\" to real failed' write ( 6 , '(A,' // FR4P // ')' ) 'Kind parameter ' , knd write ( 6 , '(A)' ) 'Function used \"ctor_R4P\"' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function ctoi\\_I8P converts string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: str ! String containing input number. integer ( I8P ), intent ( IN ) :: knd ! Number kind. integer ( I8P ) :: n ! Number returned. integer ( I4P ) :: E_IO ! Input/Output debug flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = E_IO ) n ! Casting of str to n. if ( E_IO /= 0 ) then write ( 6 , '(A)' ) 'Conversion of string \"' // str // '\" to integer failed' write ( 6 , '(A,' // FI8P // ')' ) 'Kind parameter ' , knd write ( 6 , '(A)' ) 'Function used \"ctoi_I8P\"' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function ctoi\\_I4P converts string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: str ! String containing input number. integer ( I4P ), intent ( IN ) :: knd ! Number kind. integer ( I4P ) :: n ! Number returned. integer ( I4P ) :: E_IO ! Input/Output debug flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = E_IO ) n ! Casting of str to n. if ( E_IO /= 0 ) then write ( 6 , '(A)' ) 'Conversion of string \"' // str // '\" to integer failed' write ( 6 , '(A,' // FI4P // ')' ) 'Kind parameter ' , knd write ( 6 , '(A)' ) 'Function used \"ctoi_I4P\"' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function ctoi\\_I2P converts string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: str ! String containing input number. integer ( I2P ), intent ( IN ) :: knd ! Number kind. integer ( I2P ) :: n ! Number returned. integer ( I4P ) :: E_IO ! Input/Output debug flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = E_IO ) n ! Casting of str to n. if ( E_IO /= 0 ) then write ( 6 , '(A)' ) 'Conversion of string \"' // str // '\" to integer failed' write ( 6 , '(A,' // FI2P // ')' ) 'Kind parameter ' , knd write ( 6 , '(A)' ) 'Function used \"ctoi_I2P\"' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function ctoi\\_I1P converts string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: str ! String containing input number. integer ( I1P ), intent ( IN ) :: knd ! Number kind. integer ( I1P ) :: n ! Number returned. integer ( I4P ) :: E_IO ! Input/Output debug flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = E_IO ) n ! Casting of str to n. if ( E_IO /= 0 ) then write ( 6 , '(A)' ) 'Conversion of string \"' // str // '\" to integer failed' write ( 6 , '(A,' // FI1P // ')' ) 'Kind parameter ' , knd write ( 6 , '(A)' ) 'Function used \"ctoi_I1P\"' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P subroutine IR_Print () !--------------------------------------------------------------------------------------------------------------------------------- !!The subroutine IR\\_Print print to the standard output the kind definition of reals and integers and the utility variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( * , '(A)' ) ' Reals kind precision definition' #ifdef r16p write ( * , '(A,I2,A,I2)' ) ' R16P Kind \"' , R16P , '\" | FR16P format \"' // FR16P // '\" | DR16P chars ' , DR16P #endif write ( * , '(A,I2,A,I2)' ) ' R8P  Kind \"' , R8P , '\" | FR8P  format \"' // FR8P // '\" | DR8P  chars ' , DR8P write ( * , '(A,I2,A,I2)' ) ' R4P  Kind \"' , R4P , '\" | FR4P  format \"' // FR4P // '\"  | DR4P  chars ' , DR4P write ( * , '(A)' ) ' Integers kind precision definition' write ( * , '(A,I2,A,I2)' ) ' I8P Kind \"' , I8P , '\" | FI8P format \"' // FI8P // '\" | DI8P chars ' , DI8P write ( * , '(A,I2,A,I2)' ) ' I4P Kind \"' , I4P , '\" | FI4P format \"' // FI4P // '\" | DI4P chars ' , DI4P write ( * , '(A,I2,A,I2)' ) ' I2P Kind \"' , I2P , '\" | FI2P format \"' // FI2P // '\"  | DI2P chars ' , DI2P write ( * , '(A,I2,A,I2)' ) ' I1P Kind \"' , I1P , '\" | FI1P format \"' // FI1P // '\"  | DI1P chars ' , DI1P write ( * , '(A)' ) ' Reals minimum and maximum values' #ifdef r16p write ( * , '(A,' // FR16P // ',A,' // FR16P // ',A)' ) ' MinR16P \"' , MinR16P , '\" | MaxR16P \"' , MaxR16P , '\"' #endif write ( * , '(A,' // FR8P // ',A,19X,A,' // FR8P // ',A)' ) ' MinR8P  \"' , MinR8P , '\"' , ' | MaxR8P  \"' , MaxR8P , '\"' write ( * , '(A,' // FR4P // ',A,29X,A,' // FR4P // ',A)' ) ' MinR4P  \"' , MinR4P , '\"' , ' | MaxR4P  \"' , MaxR4P , '\"' write ( * , '(A)' ) ' Integers minimum and maximum values' write ( * , '(A,' // FI8P // ',A,' // FI8P // ',A)' ) ' MinI8P  \"' , MinI8P , '\" | MaxI8P  \"' , MaxI8P , '\"' write ( * , '(A,' // FI4P // ',A,9X,A,' // FI4P // ',A)' ) ' MinI4P  \"' , MinI4P , '\"' , ' | MaxI4P  \"' , MaxI4P , '\"' write ( * , '(A,' // FI2P // ',A,14X,A,' // FI2P // ',A)' ) ' MinI2P  \"' , MinI2P , '\"' , ' | MaxI2P  \"' , MaxI2P , '\"' write ( * , '(A,' // FI1P // ',A,16X,A,' // FI1P // ',A)' ) ' MinI1P  \"' , MinI1P , '\"' , ' | MaxI1P  \"' , MaxI1P , '\"' write ( * , '(A)' ) ' Machine precions' #ifdef r16p write ( * , '(A,' // FR16P // ')' ) ' ZeroR16 \"' , ZeroR16 #endif write ( * , '(A,' // FR8P // ')' ) ' ZeroR8  \"' , ZeroR8 write ( * , '(A,' // FR4P // ')' ) ' ZeroR4  \"' , ZeroR4 !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine IR_Print endmodule IR_VTK","loc":"sourcefile/mod_ir_vtk.f90.html"},{"tags":"","title":"mod_mesh.f90 – MUSST","text":"This file depends on sourcefile~~mod_mesh.f90~~EfferentGraph sourcefile~mod_mesh.f90 mod_mesh.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_mesh.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_mesh.f90~~AfferentGraph sourcefile~mod_mesh.f90 mod_mesh.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_mesh.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_film.f90->sourcefile~mod_mesh.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 var pansourcefilemod_meshf90AfferentGraph = svgPanZoom('#sourcefilemod_meshf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mesh Source Code mod_mesh.f90 Source Code !! author: Noël Brunetière<br/>&emsp;Arthur Francisco !! version: 1.0.0 !! date: March,22 2017 !! summary: Definition of a finite element mesh !< <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<       **Definition of a finite element mesh** !< </span> !<### FE_edge type !< The edge type define a line which is the boundary of the domain. It contains a number of node, of elements and a connectivity table. !< A table is used to give a link with the 2D domain nodes number !<### Fe_mesh type !< The mesh is a 2D mesh (only 4 nodes quadrangles in the current version) !<### Mesh generation !< It is possible to create a structured rectanguler mesh with \\ref module_fe_mesh::create_rect_x_ymesh module mesh use data_arch , only : I4 , R8 implicit none private ! FE_edge type definition type FE_EDGE integer ( kind = I4 ) :: n !! *number of nodes* integer ( kind = I4 ) :: ne !! *number of elements* integer ( kind = I4 ), dimension (:), allocatable :: nm !! *mesh node (numbers in the 2d mesh)* integer ( kind = I4 ), dimension (:,:), allocatable :: con !! *connectivity table* endtype FE_EDGE ! FE_mesh type definition type FE_MESH real ( kind = R8 ) :: lx , ly !! *size of rectangle* real ( kind = R8 ) :: zx , zy !! *coordinates of first point* integer ( kind = I4 ) :: nx , ny !! *number of nodes in x, y directions* integer ( kind = I4 ) :: n !! *number of nodes* integer ( kind = I4 ) :: ne !! *number of elements* integer ( kind = I4 ) :: ned !! *number of edges* integer ( kind = I4 ) :: nc !! *number of corners* real ( kind = R8 ), dimension (:), allocatable :: x , y , z !! *nodes coordinates* integer ( kind = I4 ), dimension (:,:), allocatable :: con !! *connectivity table* integer ( kind = I4 ), dimension (:), allocatable :: el_t !! *element type* integer ( kind = I4 ), dimension (:), allocatable :: el_n !! *element number of lines* type ( FE_EDGE ), dimension (:), allocatable :: ed !! *edges of the mesh* integer ( kind = I4 ), dimension (:), allocatable :: cor !! *number of the corner node* endtype FE_MESH integer ( kind = I4 ), parameter :: MAX_NNE = 4 !! *maximum number of nodes per element* integer ( kind = I4 ), parameter :: MAX_NNC = 4 !! *maximum number of corners per element* integer ( kind = I4 ), parameter :: MAX_NNG = 2 !! *maximum number of Gauss points in a direction* integer ( kind = I4 ), parameter :: MAX_NBS = 512 !! *maximum number of nodes per BS element in a direction* public :: FE_EDGE , FE_MESH , create_rect_x_ymesh , MAX_NNE , MAX_NNC , MAX_NNG , MAX_NBS contains !========================================================================================= !< @note Subroutine to create a rectangular mesh in the x, y directions !< !----------------------------------------------------------------------------------------- subroutine create_rect_x_ymesh ( m ) implicit none type ( FE_MESH ), intent ( inout ) :: m !! *FE mesh* integer ( kind = I4 ) :: i , j , ind , inde real ( kind = R8 ) :: lx , ly , zx , zy integer ( kind = I4 ) :: nx , ny lx = m % lx ly = m % ly zx = m % zx zy = m % zy nx = m % nx ny = m % ny ! mesh size definition ! number of nodes m % n = nx * ny ! number of elements m % ne = ( nx - 1 ) * ( ny - 1 ) ! nodes and elements table allocation allocate ( m % x ( m % n ), m % y ( m % n ), m % z ( m % n ), m % con ( m % ne , 4 ), m % el_t ( m % ne ), m % el_n ( m % ne ) ) ! all the elements are qua_4 m % el_t = 4 ! 4 nodes m % el_n = 4 ! number of different lines ! tables initialisation m % con = 0 m % x = 0._R8 m % y = 0._R8 m % z = 0._R8 ! nodes coordinates do j = 1 , ny do i = 1 , nx ind = ( j - 1 ) * nx + i m % x ( ind ) = zx + lx * ( i - 1 ) / ( nx - 1 ) m % y ( ind ) = zy + ly * ( j - 1 ) / ( ny - 1 ) enddo enddo ! connectivity table do j = 1 , ny - 1 do i = 1 , nx - 1 inde = ( j - 1 ) * ( nx - 1 ) + i ind = ( j - 1 ) * nx + i m % con ( inde , 1 ) = ind m % con ( inde , 2 ) = ind + 1 m % con ( inde , 3 ) = ind + 1 + nx m % con ( inde , 4 ) = ind + nx enddo enddo !---- ! edges definition ! number of edges m % ned = 4 ! allocattion of the edges table allocate ( m % ed ( m % ned ) ) ! number of nodes and elements of each edge m % ed ( 1 )% n = nx m % ed ( 1 )% ne = nx - 1 m % ed ( 2 )% n = ny m % ed ( 2 )% ne = ny - 1 m % ed ( 3 )% n = nx m % ed ( 3 )% ne = nx - 1 m % ed ( 4 )% n = ny m % ed ( 4 )% ne = ny - 1 ! allocation of the edges nodes table do j = 1 , m % ned allocate ( m % ed ( j )% nm ( m % ed ( j )% n ) ) m % ed ( j )% nm = 0 enddo ! nodes number of the edges from the 2D mesh do i = 1 , nx m % ed ( 1 )% nm ( i ) = i m % ed ( 3 )% nm ( i ) = ( ny - 1 ) * nx + ( nx - i + 1 ) enddo do j = 1 , ny m % ed ( 2 )% nm ( j ) = nx * j m % ed ( 4 )% nm ( j ) = nx * ( ny - j ) + 1 enddo ! edges connectivity table allocation and creation do j = 1 , m % ned allocate ( m % ed ( j )% con ( m % ed ( j )% ne , 2 )) m % ed ( j )% con = 0 do i = 1 , m % ed ( j )% ne m % ed ( j )% con ( i , 1 ) = m % ed ( j )% nm ( i ) m % ed ( j )% con ( i , 2 ) = m % ed ( j )% nm ( i ) + 1 enddo enddo !---- ! corners of the mesh ! number of corners ( = 4) m % nc = m % ned ! allocation of corner nodes table allocate ( m % cor ( m % nc )) ! value of the corner nodes table do j = 1 , m % nc m % cor ( j ) = m % ed ( j )% nm ( 1 ) enddo return endsubroutine create_rect_x_ymesh endmodule mesh","loc":"sourcefile/mod_mesh.f90.html"},{"tags":"","title":"mod_ms_film.f90 – MUSST","text":"This file depends on sourcefile~~mod_ms_film.f90~~EfferentGraph sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_num_par.f90 mod_num_par.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_num_par.f90 sourcefile~mod_mesh.f90 mod_mesh.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_mesh.f90 sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_surfile.f90 sourcefile~mod_bspline.f90 mod_bspline.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_bspline.f90 sourcefile~mod_fluid.f90 mod_fluid.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_fluid.f90 sourcefile~mod_data.f90 mod_data.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_data.f90 sourcefile~mod_solver.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_gen_par.f90 mod_gen_par.f90 sourcefile~mod_solver.f90->sourcefile~mod_gen_par.f90 sourcefile~superlu.f90 superlu.f90 sourcefile~mod_solver.f90->sourcefile~superlu.f90 sourcefile~dmumps_struc.f90 dmumps_struc.f90 sourcefile~mod_solver.f90->sourcefile~dmumps_struc.f90 sourcefile~umfpack.f90 umfpack.f90 sourcefile~mod_solver.f90->sourcefile~umfpack.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_film.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_film.f90->sourcefile~mod_num_par.f90 sourcefile~mod_film.f90->sourcefile~mod_mesh.f90 sourcefile~mod_film.f90->sourcefile~mod_surfile.f90 sourcefile~mod_film.f90->sourcefile~mod_fluid.f90 sourcefile~mod_film.f90->sourcefile~mod_data.f90 sourcefile~mod_elements.f90 mod_elements.f90 sourcefile~mod_film.f90->sourcefile~mod_elements.f90 sourcefile~mod_num_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_mesh.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_surfile.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_surfile.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_fluid.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_data.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_data.f90->sourcefile~mod_fluid.f90 sourcefile~mod_gen_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_elements.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 var pansourcefilemod_ms_filmf90EfferentGraph = svgPanZoom('#sourcefilemod_ms_filmf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_ms_film.f90~~AfferentGraph sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ms_film Source Code mod_ms_film.f90 Source Code !! author: Noël Brunetiere, Arthur Francisco !! version: 1.0.0 !! date: February, 15 2017 !! summary: Creation and resolution of multi-scale FE film !< <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<       **MultiScale FE solution of the Reynolds equation** !< </span> !<# Description of the film module !< This module can be used for a two-scale solution of the lubrication problems (more particularly for rough surface problems) ! !<## Definition of MS_FE_film !< [[MS_FE_FILM]] is a data structure containing a [[FE_FILM]] which is the Top Scale or macro-scale of the problem and a table of [[FE_FILM]] which is the Bottom Scale or micro-scale !<## Solution procedure !< This module can be used to create a [[MS_FE_FILM]], assemble the [[MS_FE_FILM]], and solve it. Some post-treatements like fluxes, forces are available. module ms_film use data_arch , only : I4 , R8 , NB_THREADS_MAX use film use mesh , only : MAX_NNC , MAX_NBS use solver use omp_lib use bspline use surfile use data_film_hd use num_param use fluid_law implicit none private ! multi scale fe fluid film type type MS_FE_FILM !! <span style=\"color:green\"> !!   *MS_FE_FILM* is the top-scale [[FE_FILM]] plus all of the bottom-scale [[FE_FILM]] !! </span> type ( FE_FILM ) :: ts_fe_f !! *top-scale fe_film* type ( FE_FILM ), dimension (:), allocatable :: bs_fe_f !! *bottom-scale fe_film* contains procedure :: ms_fx !! *force computation along x* procedure :: ms_fy !! *force computation along y* procedure :: ms_fz !! *force computation along z* endtype ms_fe_film type ( SCALE_SURF ) :: scal_tmp !! *object [[SCALE_SURF]]* logical ( kind = I4 ), parameter :: SMOOTH_MS = . true . !! *at the end of the iterative process, the pressure field can be smoothed* public :: MS_FE_FILM , multi_scale_create_rect_fe_film , multi_scale_solve_fe_film , save_ms_field , ms_fe_f_2_mat contains !========================================================================================= !< @note Subroutine to create a [[MS_FE_FILM]] !  @endnote !----------------------------------------------------------------------------------------- subroutine multi_scale_create_rect_fe_film ( data_f , bs_nx , bs_ny , num_pts , num_pbs , ms_fe_f ) implicit none type ( DATA_FILM ), intent ( inout ) :: data_f !! *data of the film* integer ( kind = I4 ), intent ( in ) :: bs_nx !! *number of nodes in x direction for the bottom scale* integer ( kind = I4 ), intent ( in ) :: bs_ny !! *number of nodes in y direction for the bottom scale* type ( NUM_PAR ), intent ( in ) :: num_pts !! *numerical parameters for iterative solution, top scale* type ( NUM_PAR ), intent ( in ) :: num_pbs !! *numerical parameters for iterative solution, bottom scale* type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f !! *MS FE film* integer ( kind = I4 ) :: e , ne , i1 , i3 ! creation of the top scale fe film call create_rect_FE_film ( data_f = data_f , & num_p = num_pts , & fe_f = ms_fe_f % ts_fe_f ) ! allocation of the bottom scale table ne = ms_fe_f % ts_fe_f % m % ne allocate ( ms_fe_f % bs_fe_f ( ne )) ! creation of the bottom scale fe_film do e = 1 , ne i1 = ms_fe_f % ts_fe_f % m % con ( e , 1 ) i3 = ms_fe_f % ts_fe_f % m % con ( e , 3 ) ms_fe_f % bs_fe_f ( e )% m % nx = bs_nx ms_fe_f % bs_fe_f ( e )% m % ny = bs_ny ms_fe_f % bs_fe_f ( e )% m % zx = ms_fe_f % ts_fe_f % m % x ( i1 ) ms_fe_f % bs_fe_f ( e )% m % zy = ms_fe_f % ts_fe_f % m % y ( i1 ) ms_fe_f % bs_fe_f ( e )% m % lx = ms_fe_f % ts_fe_f % m % x ( i3 ) - ms_fe_f % bs_fe_f ( e )% m % zx ms_fe_f % bs_fe_f ( e )% m % ly = ms_fe_f % ts_fe_f % m % y ( i3 ) - ms_fe_f % bs_fe_f ( e )% m % zy call create_rect_FE_film ( data_f = data_f , & num_p = num_pbs , & fe_f = ms_fe_f % bs_fe_f ( e )) enddo return endsubroutine multi_scale_create_rect_fe_film !========================================================================================= !< @note Subroutine to solve a [[MS_FE_FILM]] !  @endnote !----------------------------------------------------------------------------------------- subroutine multi_scale_solve_fe_film ( ms_fe_f , ms_mat , bc ) implicit none type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f !! *multi-scale FE film* type ( MS_MAT_SOLV ), intent ( inout ) :: ms_mat !! *multi-scale solver matrices* real ( kind = R8 ), intent ( in ), dimension ( MAX_NNC ) :: bc !! *boundary conditions at the corners* logical ( kind = I4 ) :: decomp integer ( kind = I4 ) :: i , e , it , fluid logical ( kind = I4 ) :: conv , ts_init real ( kind = R8 ) :: error , relax integer ( kind = I4 ) :: ass_c integer ( kind = I4 ), dimension ( 2 ) :: compt relax = ms_fe_f % ts_fe_f % num_p % relax fluid = ms_fe_f % ts_fe_f % data_f % fl % fluid_type VERBOSE = nint ( VERBOSE / 1 0. ) ! open mp instructions (parallele computation) if ( VERBOSE >= 1 ) write ( OPU , * ) 'nb_threads_max' , NB_THREADS_MAX if ( NB_THREADS_MAX <= 0 ) NB_THREADS_MAX = 1 !$ call omp_set_num_threads(NB_THREADS_MAX) if ( VERBOSE >= 1 ) write ( OPU , * ) 'nb_threads_used' , NB_THREADS_MAX ! check of matrices allocation allocate ( ms_mat % bs_mat ( ms_fe_f % ts_fe_f % m % ne )) ms_mat % bs_mat (:)% slv_t = SOLVER_BS ms_mat % bs_mat (:)% first = . true . ! solution parameters ass_c = ASS decomp = ( ass_c == ASS ) ! update fluid properties do i = 1 , ms_fe_f % ts_fe_f % m % n ms_fe_f % ts_fe_f % vn ( i , RHO_N ) = ms_fe_f % ts_fe_f % data_f % fl % rho ( ms_fe_f % ts_fe_f % vn ( i , P_N ), & ms_fe_f % ts_fe_f % vn ( i , T_N ) ) ms_fe_f % ts_fe_f % vn ( i , DRHODP_N ) = ms_fe_f % ts_fe_f % data_f % fl % drhodp ( ms_fe_f % ts_fe_f % vn ( i , P_N ), & ms_fe_f % ts_fe_f % vn ( i , T_N ) ) enddo if ( VERBOSE >= 2 ) write ( OPU , * ) 'fluid properties updated' ms_mat % ts_mat % slv_t = SOLVER_TS ms_mat % ts_mat % first = . true . ms_mat % ts_mat % nn = ms_fe_f % ts_fe_f % m % n ms_mat % ts_mat % ne = ms_fe_f % ts_fe_f % m % ne ! matrices allocation compt (:) = 0 do e = 1 , ms_fe_f % ts_fe_f % m % ne compt ( 1 ) = compt ( 1 ) + ms_fe_f % ts_fe_f % m % el_n ( e ) ! for each element, the number of lines is added do i = 1 , ms_fe_f % ts_fe_f % m % el_t ( e ) compt ( 2 ) = compt ( 2 ) + ms_fe_f % ts_fe_f % m % el_t ( e ) ! \" \", for each node, the number of contributions is added enddo enddo ms_mat % ts_mat % nvar = compt ( 1 ) ms_mat % ts_mat % nt = compt ( 2 ) allocate ( ms_mat % ts_mat % eltvar ( ms_mat % ts_mat % nvar ) ) allocate ( ms_mat % ts_mat % a_elt ( ms_mat % ts_mat % nt ) ) allocate ( ms_mat % ts_mat % eltptr ( ms_mat % ts_mat % ne + 1 ) ) ! check of precomputed tables allocation if (. not . allocated ( ms_fe_f % ts_fe_f % prc % vcal )) call init_prc_tab ( ms_fe_f % ts_fe_f ) ! convergence is false at zero iteration conv = . false . it = 0 ts_init = . false . if ( ts_init ) then call solve_FE_film ( fe_f = ms_fe_f % ts_fe_f , & mat = ms_mat % ts_mat , & bc = bc , & flag_ass = . true .) else ! apply boundary conditions call apply_bc_FE_film_simple ( fe_f = ms_fe_f % ts_fe_f , & bc = bc ) if ( VERBOSE >= 2 ) write ( OPU , * ) 'bc applied' call solve_syst ( mat = ms_mat % ts_mat , & step = 'ini' ) if ( VERBOSE >= 2 ) write ( OPU , * ) 'TS solver initialized' endif if ( sum ( ms_fe_f % bs_fe_f ( 1 )% m % ed (:)% n ) > MAX_NBS ) stop 'MAX_NBS under estimated' ! solution loop do if ( VERBOSE >= 3 ) write ( OPU , * ) \"loop MS *******************\" , it if ( conv ) then do e = 1 , ms_fe_f % ts_fe_f % m % ne call solve_syst ( mat = ms_mat % bs_mat ( e ), & ! step = 'end' ) if ( VERBOSE >= 3 ) write ( OPU , * ) '   Matrix BS released, thread ' , omp_get_thread_num () enddo exit endif if ( SMOOTH_MS ) call smooth_ms_fe_f ( ms_fe_f , code = P_N , nodal = . true .) if ( BC_SPLINE ) call interp_ts_bs_splin ( ms_fe_f ) ! assembly of the system call multi_scale_assembly_fe_film_reynolds ( ms_fe_f = ms_fe_f , & ms_mat = ms_mat , & ass_c = ass_c ) if ( VERBOSE >= 3 ) write ( OPU , * ) 'ms reynolds assembled' if ( VERBOSE >= 3 ) write ( OPU , * ) 'ass_c' , ass_c , 'first' , ms_mat % ts_mat % first !~          if (ass_c == ASS) then ! some stuff can be saved here, provided the reloading of jptr, irow, ... (instead of convert_matrice_format) call convert_matrice_format ( mat = ms_mat % ts_mat ) if ( VERBOSE >= 3 ) write ( OPU , * ) 'Matrix TS formated, thread ' , omp_get_thread_num () !~          endif if ( ms_mat % ts_mat % first ) then call solve_syst ( mat = ms_mat % ts_mat , & step = 'ana' ) ms_mat % ts_mat % first = . false . if ( VERBOSE >= 3 ) write ( OPU , * ) 'Matrix TS analyzed, thread ' , omp_get_thread_num () endif ! solution of the system !~          if (ass_c == ASS) then call solve_syst ( mat = ms_mat % ts_mat , & step = 'fac' ) if ( VERBOSE >= 3 ) write ( OPU , * ) 'Matrix TS factorized, thread ' , omp_get_thread_num () !~          endif call solve_syst ( mat = ms_mat % ts_mat , & step = 'sol' ) if ( VERBOSE >= 3 ) write ( OPU , * ) 'System TS solved, thread ' , omp_get_thread_num () !if (ass_c == ASS) then call solve_syst ( mat = ms_mat % ts_mat , & step = 'fre' ) if ( VERBOSE >= 3 ) write ( OPU , * ) 'Matrix factors freed, thread ' , omp_get_thread_num () !endif ! error computation error = ( sum ( ms_mat % ts_mat % x ** 2 ) / sum ( ms_fe_f % ts_fe_f % vn (:, P_N ) ** 2 )) ** ( 0.5 ) it = it + 1 if ( VERBOSE >= 1 ) write ( OPU , * ) 'Iteration ' , it , 'error TS' , error ! convergence check if ( error <= ms_fe_f % ts_fe_f % num_p % eps ) conv = . true . ! update of variables if ( fluid == MIXT ) then do i = 1 , ms_fe_f % ts_fe_f % m % n if ( ms_mat % ts_mat % x ( i ) < 0. ) then ms_fe_f % ts_fe_f % vn ( i , RHO_N ) = ms_fe_f % ts_fe_f % vn ( i , RHO_N ) + ms_fe_f % ts_fe_f % vn ( i , DRHODP_N ) * ms_mat % ts_mat % x ( i ) * relax if ( ms_fe_f % ts_fe_f % vn ( i , RHO_N ) < 0. ) then ms_fe_f % ts_fe_f % vn ( i , P_N ) = ms_fe_f % ts_fe_f % data_f % fl % p_0 / 100 else ms_fe_f % ts_fe_f % vn ( i , P_N ) = ms_fe_f % ts_fe_f % data_f % fl % pres ( ms_fe_f % ts_fe_f % vn ( i , RHO_N ), & ! ms_fe_f % ts_fe_f % vn ( i , T_N ) ) endif else ms_fe_f % ts_fe_f % vn ( i , P_N ) = ms_fe_f % ts_fe_f % vn ( i , P_N ) + ms_mat % ts_mat % x ( i ) * relax endif enddo else ms_fe_f % ts_fe_f % vn (:, P_N ) = ms_fe_f % ts_fe_f % vn (:, P_N ) + ms_mat % ts_mat % x * relax endif ! check pressure if ( fluid == GP ) then if ( minval ( ms_fe_f % ts_fe_f % vn (:, P_N )) < 0._R8 ) write ( OPU , * ) 'MS p negative' where ( ms_fe_f % ts_fe_f % vn (:, P_N ) < 0._R8 ) ms_fe_f % ts_fe_f % vn (:, P_N ) = ms_fe_f % ts_fe_f % data_f % fl % p_0 / 1.e2_R8 endif ! update fluid properties do i = 1 , ms_fe_f % ts_fe_f % m % n ms_fe_f % ts_fe_f % vn ( i , RHO_N ) = ms_fe_f % ts_fe_f % data_f % fl % rho ( ms_fe_f % ts_fe_f % vn ( i , P_N ), & ms_fe_f % ts_fe_f % vn ( i , T_N ) ) ms_fe_f % ts_fe_f % vn ( i , DRHODP_N ) = ms_fe_f % ts_fe_f % data_f % fl % drhodp ( ms_fe_f % ts_fe_f % vn ( i , P_N ), & ms_fe_f % ts_fe_f % vn ( i , T_N ) ) enddo if ( it >= ms_fe_f % ts_fe_f % num_p % it_max ) then conv = . true . write ( OPU , * ) 'maximum number of iteration reached before convergence' endif enddo call solve_syst ( mat = ms_mat % ts_mat , & ! step = 'end' ) if ( VERBOSE >= 2 ) write ( OPU , * ) 'Matrix TS released, thread ' , omp_get_thread_num () return endsubroutine multi_scale_solve_fe_film !========================================================================================= !< @note Subroutine to interpolate the top-scale nodes for the bottom-scale boundaries !  @endnote !----------------------------------------------------------------------------------------- subroutine interp_ts_bs_splin ( ms_fe_f ) implicit none type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f integer ( kind = I4 ) :: i , j , inbvx , inbvy , iloy , iflag , ts_nx , ts_ny , e , ed , bs_nx , bs_ny , n_edg , n_nod , nn , node_number real ( kind = R8 ) :: x_n , y_n , val real ( kind = R8 ), dimension (:,:), allocatable :: log_press real ( kind = R8 ), dimension (:,:), allocatable :: coeff real ( kind = R8 ), dimension (:), allocatable :: tx ! x knots real ( kind = R8 ), dimension (:), allocatable :: ty ! y knots real ( kind = R8 ), dimension (:), allocatable :: x real ( kind = R8 ), dimension (:), allocatable :: y integer ( kind = I4 ), parameter :: deg = 2 logical ( kind = I4 ) :: mixture mixture = ( ms_fe_f % ts_fe_f % data_f % fl % fluid_type == MIXT ) ts_nx = ms_fe_f % ts_fe_f % m % nx ts_ny = ms_fe_f % ts_fe_f % m % ny allocate ( coeff ( 1 : ts_nx , 1 : ts_ny ) ) allocate ( tx ( 1 :( ts_nx + deg )), & ty ( 1 :( ts_ny + deg )) ) allocate ( x ( 1 : ts_nx ), & y ( 1 : ts_ny ) ) allocate ( log_press ( 1 : ts_nx , 1 : ts_ny ) ) log_press = reshape ( ms_fe_f % ts_fe_f % vn (:, P_N ), ( / ts_nx , ts_ny / ) ) if ( mixture ) log_press = log ( log_press ) x ( 1 : ts_nx ) = ms_fe_f % ts_fe_f % m % x ( 1 : ts_nx ) i = 0 do j = 1 , ts_nx * ( ts_ny - 1 ) + 1 , ts_nx i = i + 1 y ( i ) = ms_fe_f % ts_fe_f % m % y ( j ) enddo iflag = 0 call db2ink ( x = x ( 1 : ts_nx ), & ! Array of x abcissae. Must be strictly increasing. nx = ts_nx , & ! Number of x abcissae y = y ( 1 : ts_ny ), & ! Array of y abcissae. Must be strictly increasing. ny = ts_ny , & ! Number of y abcissae fcn = log_press ( 1 : ts_nx , 1 : ts_ny ), & ! Array of function values to interpolate. fcn(i,j) should !    contain the function value at the point (x(i),y(j)) kx = deg , & ! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) ky = deg , & ! The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) tx = tx ( 1 :( ts_nx + deg )), & ! The knots in the x direction for the spline interpolant. !    If iflag=0 these are chosen by [[db2ink]]. !    If iflag=1 these are specified by the user. !    Must be non-decreasing. ty = ty ( 1 :( ts_ny + deg )), & ! The knots in the y direction for the spline interpolant. !    If iflag=0 these are chosen by [[db2ink]]. !    If iflag=1 these are specified by the user. !    Must be non-decreasing. bcoef = coeff ( 1 : ts_nx , 1 : ts_ny ), & ! Array of coefficients of the b-spline interpolant. iflag = iflag ) ! **on input:**  0 = knot sequence chosen by [[db2ink]]. !                1 = knot sequence chosen by user. ! **on output:** 1 = successful execution. !                2 = iflag out of range. !                3 = nx out of range. !                4 = kx out of range. !                5 = x not strictly increasing. !                6 = tx not non-decreasing. !                7 = ny out of range. !                8 = ky out of range. !                9 = y not strictly increasing. !               10 = ty not non-decreasing. if ( iflag /= 1 ) error stop 'error calling db2ink' inbvx = 1 inbvy = 1 iloy = 1 do e = 1 , ms_fe_f % ts_fe_f % m % ne bs_nx = ms_fe_f % bs_fe_f ( e )% m % nx bs_ny = ms_fe_f % bs_fe_f ( e )% m % ny n_edg = ms_fe_f % bs_fe_f ( e )% m % ned do ed = 1 , n_edg n_nod = ms_fe_f % bs_fe_f ( e )% m % ed ( ed )% n do nn = 1 , n_nod node_number = ms_fe_f % bs_fe_f ( e )% m % ed ( ed )% nm ( nn ) x_n = ms_fe_f % bs_fe_f ( e )% m % x ( node_number ) y_n = ms_fe_f % bs_fe_f ( e )% m % y ( node_number ) call db2val ( xval = x_n , & ! xval     !! x coordinate of evaluation point. yval = y_n , & ! yval     !! y coordinate of evaluation point. idx = 0 , & ! idx      !! x derivative of piecewise polynomial to evaluate. idy = 0 , & ! idy      !! y derivative of piecewise polynomial to evaluate. tx = tx ( 1 :( ts_nx + deg )), & ! tx       !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db2ink]]) ty = ty ( 1 :( ts_ny + deg )), & ! ty       !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db2ink]]) nx = ts_nx , & ! nx       !! the number of interpolation points in x. (same as in last call to [[db2ink]]) ny = ts_ny , & ! ny       !! the number of interpolation points in y. (same as in last call to [[db2ink]]) kx = deg , & ! kx       !! order of polynomial pieces in x. (same as in last call to [[db2ink]]) ky = deg , & ! ky       !! order of polynomial pieces in y. (same as in last call to [[db2ink]]) bcoef = coeff ( 1 : ts_nx , 1 : ts_ny ), & ! bcoef    !! the b-spline coefficients computed by [[db2ink]]. f = val , & ! f        !! interpolated value & iflag = iflag , & ! iflag    !! status flag: 0 : no errors, /=0 : error inbvx = inbvx , & ! inbvx    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. inbvy = inbvy , & ! inbvy    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. iloy = iloy ) ! iloy     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. if ( iflag /= 0 ) error stop 'error' if ( mixture ) val = exp ( val ) ms_fe_f % bs_fe_f ( e )% vn ( node_number , P_N ) = val ms_fe_f % bs_fe_f ( e )% bc ( node_number , REY ) = 0 enddo enddo enddo deallocate ( log_press , coeff , tx , ty , x , y ) return endsubroutine interp_ts_bs_splin !========================================================================================= !< @note Subroutine to save the information controlled by *code* of the whole mesh. ! !        The genertaed file is a ```.sur``` file. !  @endnote !----------------------------------------------------------------------------------------- subroutine save_ms_field ( ms_fe_f , file_name , code , nodal ) implicit none type ( MS_FE_FILM ), intent ( in ) :: ms_fe_f character ( len =* ), intent ( in ) :: file_name !! *filename like \"./out/pressure.sur\"* integer ( kind = I4 ), intent ( in ) :: code !! *saved information like P_N* logical ( kind = I4 ), intent ( in ) :: nodal !! *if false : cell value, if true : nodal value* integer ( kind = I4 ) :: nnx , nny character ( len = 8 ) :: unit_z , string integer ( kind = I4 ), dimension ( 1 ) :: i1 , i2 real ( kind = R8 ), allocatable , dimension (:,:) :: mat call ms_fe_f_2_mat ( ms_fe_f , code , nodal , mat ) nnx = ubound ( mat , 1 ) nny = ubound ( mat , 2 ) call empty ( unit_z ) if ( nodal ) then string = trim ( ms_fe_f % ts_fe_f % vn_name ( code )) else string = trim ( ms_fe_f % ts_fe_f % vc_name ( code )) endif i1 = index ( string , '(' ) + 1 i2 = index ( string , ')' ) - 1 unit_z = string ( i1 ( 1 ): i2 ( 1 )) call init_scal ( scal = scal_tmp , & ! nx = nnx , & ! ny = nny , & ! lx = ms_fe_f % ts_fe_f % m % lx , & ! default unit : m ly = ms_fe_f % ts_fe_f % m % ly , & ! unit_z = unit_z ) ! call write_surf ( nom_fic = file_name , & ! tab_s = mat , & ! scal = scal_tmp ) deallocate ( mat ) return endsubroutine save_ms_field !========================================================================================= !< @note Subroutine to transform a MS_FE_FILM information into a matrix !  @endnote !----------------------------------------------------------------------------------------- subroutine ms_fe_f_2_mat ( ms_fe_f , code , nodal , mat ) implicit none type ( MS_FE_FILM ), intent ( in ) :: ms_fe_f integer ( kind = I4 ), intent ( in ) :: code !! *saved information like P_N* logical ( kind = I4 ), intent ( in ) :: nodal !! *if false : cell value, if true : nodal value* real ( kind = R8 ), intent ( inout ), allocatable :: mat (:,:) !! *output matrix containing the information* integer ( kind = I4 ) :: ts_nx , ts_ny , ex , ey , e , ne_x , ne_y , nnx , nny , c integer ( kind = I4 ), allocatable , dimension (:) :: bs_nx , bs_ny ts_nx = ms_fe_f % ts_fe_f % m % nx - 1 ts_ny = ms_fe_f % ts_fe_f % m % ny - 1 allocate ( bs_nx ( ts_nx * ts_ny ), bs_ny ( ts_nx * ts_ny )) bs_nx (:) = ms_fe_f % bs_fe_f (:)% m % nx - 1 bs_ny (:) = ms_fe_f % bs_fe_f (:)% m % ny - 1 nnx = sum ( bs_nx ( 1 : ts_nx ) ) nny = sum ( bs_ny ( 1 : ts_ny ) ) if ( nodal ) then nnx = nnx + 1 nny = nny + 1 endif allocate ( mat ( 1 : nnx , 1 : nny ) ) ; mat = - 1. c = 0 if ( nodal ) c = 1 do ey = 1 , ts_ny do ex = 1 , ts_nx e = ts_nx * ( ey - 1 ) + ex ne_x = bs_nx ( e ) * ( ex - 1 ) + 1 ne_y = bs_ny ( e ) * ( ey - 1 ) + 1 mat ( ne_x :( ne_x + bs_nx ( e ) - 1 + c ), & ne_y :( ne_y + bs_ny ( e ) - 1 + c ) ) = reshape ( ms_fe_f % bs_fe_f ( e )% vn (:, code ), ( / bs_nx ( e ) + c , bs_ny ( e ) + c / ) ) enddo enddo deallocate ( bs_nx , bs_ny ) return endsubroutine ms_fe_f_2_mat !========================================================================================= !< @note Subroutine to transform a matrix into a MS_FE_FILM !  @endnote !----------------------------------------------------------------------------------------- subroutine mat_2_ms_fe_f ( ms_fe_f , code , nodal , mat ) implicit none type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f integer ( kind = I4 ), intent ( in ) :: code !! *saved information like P_N* logical ( kind = I4 ), intent ( in ) :: nodal !! *if false : cell value, if true : nodal value* real ( kind = R8 ), intent ( in ), dimension (:,:) :: mat !! *input matrix containing the information* integer ( kind = I4 ) :: ts_nx , ts_ny , ex , ey , e , ne_x , ne_y , nnx , nny , c integer ( kind = I4 ), allocatable , dimension (:) :: bs_nx , bs_ny ts_nx = ms_fe_f % ts_fe_f % m % nx - 1 ts_ny = ms_fe_f % ts_fe_f % m % ny - 1 allocate ( bs_nx ( ts_nx * ts_ny ), bs_ny ( ts_nx * ts_ny )) bs_nx (:) = ms_fe_f % bs_fe_f (:)% m % nx - 1 bs_ny (:) = ms_fe_f % bs_fe_f (:)% m % ny - 1 nnx = sum ( bs_nx ( 1 : ts_nx ) ) nny = sum ( bs_ny ( 1 : ts_ny ) ) if ( nodal ) then nnx = nnx + 1 nny = nny + 1 endif c = 0 if ( nodal ) c = 1 do ey = 1 , ts_ny do ex = 1 , ts_nx e = ts_nx * ( ey - 1 ) + ex ne_x = bs_nx ( e ) * ( ex - 1 ) + 1 ne_y = bs_ny ( e ) * ( ey - 1 ) + 1 ms_fe_f % bs_fe_f ( e )% vn (:, code ) = reshape ( mat ( ne_x :( ne_x + bs_nx ( e ) - 1 + c ), & ! ne_y :( ne_y + bs_ny ( e ) - 1 + c ) ), ( / ( bs_nx ( e ) + c ) * ( bs_ny ( e ) + c ) / ) ) enddo enddo deallocate ( bs_nx , bs_ny ) return endsubroutine mat_2_ms_fe_f !========================================================================================= !< @note Subroutine to smooth a MS_FE_FILM field, the pressure for instance. ! !        By default, the smoothing kernel is a 5x5 Gaussian filter !  @endnote !----------------------------------------------------------------------------------------- subroutine smooth_ms_fe_f ( ms_fe_f , code , nodal ) implicit none type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f integer ( kind = I4 ), intent ( in ) :: code !! *saved information like P_N* logical ( kind = I4 ), intent ( in ) :: nodal !! *if false : cell value, if true : nodal value* integer ( kind = I4 ) :: nx , ny real ( kind = R8 ), allocatable , dimension (:,:) :: mat call ms_fe_f_2_mat ( ms_fe_f , code , nodal , mat ) nx = ubound ( mat , 1 ) ; ny = ubound ( mat , 2 ) call smooth_mat ( mat , nx , ny , s = 5 ) call mat_2_ms_fe_f ( ms_fe_f , code , nodal , mat ) deallocate ( mat ) return endsubroutine smooth_ms_fe_f !========================================================================================= !< @note Subroutine to smooth a matrix form field, the pressure for instance. !  @endnote !----------------------------------------------------------------------------------------- subroutine smooth_mat ( mat , nx , ny , s ) implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *matrix x size* integer ( kind = I4 ), intent ( in ) :: ny !! *matrix y size* integer ( kind = I4 ), intent ( in ) :: s !! *kernel size* real ( kind = R8 ), intent ( inout ), dimension ( nx , ny ) :: mat !! *matrix* integer ( kind = I4 ), dimension ( 3 , 3 ) :: kernel3 integer ( kind = I4 ), dimension ( 5 , 5 ) :: kernel5 real ( kind = R8 ), dimension ( 5 , 5 ) :: mi_mat real ( kind = R8 ), dimension (:,:), allocatable :: mat_tmp integer ( kind = I4 ) :: i , j allocate ( mat_tmp ( nx , ny ) ) if ( s == 3 ) then kernel3 ( 1 : 3 , 1 : 3 ) = reshape (( / 1 , 2 , 1 , & ! 2 , 4 , 2 , & ! 1 , 2 , 1 / ), ( / 3 , 3 / )) do j = 1 + 1 , nx - 1 do i = 1 + 1 , ny - 1 mi_mat ( 1 : 3 , 1 : 3 ) = mat ( i - 1 : i + 1 , j - 1 : j + 1 ) mat_tmp ( i , j ) = sum ( mi_mat ( 1 : 3 , 1 : 3 ) * kernel3 ( 1 : 3 , 1 : 3 ) ) / 1 6. enddo enddo do j = 1 + 1 , nx - 1 do i = 1 + 1 , ny - 1 mat ( i , j ) = mat_tmp ( i , j ) enddo enddo endif if ( s == 5 ) then kernel5 ( 1 : 5 , 1 : 5 ) = reshape (( / 1 , 4 , 6 , 4 , 1 , & ! 4 , 16 , 24 , 16 , 4 , & ! 6 , 24 , 36 , 24 , 6 , & ! 4 , 16 , 24 , 16 , 4 , & ! 1 , 4 , 6 , 4 , 1 / ), ( / 5 , 5 / )) do j = 1 + 2 , nx - 2 do i = 1 + 2 , ny - 2 mi_mat ( 1 : 5 , 1 : 5 ) = mat ( i - 2 : i + 2 , j - 2 : j + 2 ) mat_tmp ( i , j ) = sum ( mi_mat ( 1 : 5 , 1 : 5 ) * kernel5 ( 1 : 5 , 1 : 5 ) ) / 25 6. enddo enddo do j = 1 + 2 , nx - 2 do i = 1 + 2 , ny - 2 mat ( i , j ) = mat_tmp ( i , j ) enddo enddo endif deallocate ( mat_tmp ) return endsubroutine smooth_mat !========================================================================================= !< @note Subroutine to assemble the top-scale system, all of the bottom-scale systems being solved. !  @endnote !----------------------------------------------------------------------------------------- subroutine multi_scale_assembly_fe_film_reynolds ( ms_fe_f , ms_mat , ass_c ) implicit none type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f !! type ( MS_MAT_SOLV ), intent ( inout ) :: ms_mat !! *solver type matrices table* integer ( kind = I4 ), intent ( in ) :: ass_c !! *assembly type* real ( kind = R8 ), dimension (:,:,:), allocatable :: ke_ij real ( kind = R8 ), dimension (:,:) , allocatable :: be_i integer ( kind = I4 ), dimension (:,:) , allocatable :: ind_e integer ( kind = I4 ), dimension ( 2 ) :: compt integer ( kind = I4 ) :: e , i , ii , ne real ( kind = R8 ) :: val_t logical ( kind = I4 ) :: first_assembly ne = ms_fe_f % ts_fe_f % m % ne allocate ( ke_ij ( ne , MAX_NNC , MAX_NNC ) ) allocate ( be_i ( ne , MAX_NNC ) ) allocate ( ind_e ( ne , MAX_NNC ) ) ! assembly compt (:) = 1 ms_mat % ts_mat % b = 0._R8 if (. not . allocated ( ms_mat % ass_loc_in_mat )) then allocate ( ms_mat % ass_loc_in_mat ( ne )) ms_mat % ass_loc_in_mat = - 1 endif ! check for first assembly: save the assembly location in ass_loc_in_mat if ( ms_mat % ass_loc_in_mat ( 1 ) == - 1 ) then first_assembly = . true . ms_mat % ass_loc_in_mat ( 1 ) = 1 else first_assembly = . false . endif do e = 1 , ne ! copy of the boundary conditions do i = 1 , 4 ii = ms_fe_f % ts_fe_f % m % con ( e , i ) be_i ( e , i ) = ms_fe_f % ts_fe_f % vn ( ii , P_N ) enddo enddo ! elementary matrices calculation !------------------------------------------- !open mp instructions (parallele computation) !$omp parallel !$omp do schedule(runtime) do e = 1 , ms_fe_f % ts_fe_f % m % ne if ( VERBOSE >= 3 ) write ( OPU , * ) \"MS elements \" , e , ' thread ' , omp_get_thread_num () call elementary_full_domain_FE_film_reynolds ( fe_f = ms_fe_f % bs_fe_f ( e ), & mat = ms_mat % bs_mat ( e ), & ke_ij = ke_ij ( e , :, :), & be_i = be_i ( e , :), & ind_e = ind_e ( e , :)) enddo !$OMP end do !$OMP end parallel !end open mp instructions !------------------------------------------- do e = 1 , ne ! consideration of the bc condition do i = 1 , 4 ii = ms_fe_f % ts_fe_f % m % con ( e , i ) ind_e ( e , i ) = ii if ( ms_fe_f % ts_fe_f % bc ( ii , REY ) == 0 ) then val_t = ke_ij ( e , i , i ) ke_ij ( e , i , :) = 0._R8 ke_ij ( e , i , i ) = val_t be_i ( e , i ) = 0._R8 endif enddo ! copy of the rhs member do i = 1 , 4 ii = ms_fe_f % ts_fe_f % m % con ( e , i ) ms_mat % ts_mat % b ( ii ) = ms_mat % ts_mat % b ( ii ) + be_i ( e , i ) enddo enddo ! assembly of the elemental matrix in the solver matrix if ( ass_c == ASS ) then do e = 1 , ne call assemble_in_mat_sol ( mat = ms_mat % ts_mat , & num = e , & nelt = 4 , & nline = 4 , & tind = ind_e ( e , :), & m_elt = ke_ij ( e , :, :), & compt = compt ) enddo ms_mat % ts_mat % eltptr ( 1 ) = 1 endif deallocate ( ke_ij , be_i , ind_e ) return endsubroutine multi_scale_assembly_fe_film_reynolds !========================================================================================= !< @note Function to calculate the generated load in a fluid MS film !         \\int_\\Omega p d\\Omega  !  @endnote !----------------------------------------------------------------------------------------- real ( kind = R8 ) function ms_fz ( ms_fe_f ) implicit none class ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f !! *MS FE film* integer ( kind = I4 ) :: e ms_fz = 0._R8 do e = 1 , ms_fe_f % ts_fe_f % m % ne ms_fz = ms_fz + ms_fe_f % bs_fe_f ( e )% fz () enddo return endfunction ms_fz !========================================================================================= !< @note Function to calculate the friction force along x in a fluid MS film !         \\int_\\Omega \\tau_{xz} d\\Omega  !  @endnote !----------------------------------------------------------------------------------------- real ( kind = R8 ) function ms_fx ( ms_fe_f ) implicit none class ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f integer ( kind = I4 ) :: e ms_fx = 0._R8 do e = 1 , ms_fe_f % ts_fe_f % m % ne ms_fx = ms_fx + ms_fe_f % bs_fe_f ( e )% fx () enddo return endfunction ms_fx !========================================================================================= !< @note Function to calculate the friction force along y in a fluid MS film !         \\int_\\Omega \\tau_{yz} d\\Omega  !  @endnote !----------------------------------------------------------------------------------------- real ( kind = R8 ) function ms_fy ( ms_fe_f ) implicit none class ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f integer ( kind = I4 ) :: e ms_fy = 0._R8 do e = 1 , ms_fe_f % ts_fe_f % m % ne ms_fy = ms_fy + ms_fe_f % bs_fe_f ( e )% fy () enddo return endfunction ms_fy endmodule ms_film","loc":"sourcefile/mod_ms_film.f90.html"},{"tags":"","title":"mod_num_par.f90 – MUSST","text":"This file depends on sourcefile~~mod_num_par.f90~~EfferentGraph sourcefile~mod_num_par.f90 mod_num_par.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_num_par.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_num_par.f90~~AfferentGraph sourcefile~mod_num_par.f90 mod_num_par.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_num_par.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_num_par.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_num_par.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 sourcefile~mod_film.f90->sourcefile~mod_num_par.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 var pansourcefilemod_num_parf90AfferentGraph = svgPanZoom('#sourcefilemod_num_parf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules num_param Source Code mod_num_par.f90 Source Code !< author: Noël Brunetière<br/>&emsp;Arthur Francisco !  version: 1.0.0 !  date: july, 12 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **MUSST general parameters** !  </span> !@note !        The type *NUM_PAR* is not used in **MSOLV**, it is a type related to the iterative process of **MUSST** !@endnote module num_param use iso_fortran_env , only : input_unit , output_unit use data_arch , only : I4 , R8 implicit none public ! codes for message integer ( kind = I4 ), parameter :: NO_MESS = 0 !! *code for no message on screen during problem solving* integer ( kind = I4 ), parameter :: PRINT_MESS = 1 !! *code for printing message during problem solving* integer ( kind = I4 ) :: VERBOSE !! *Output detail control* integer ( kind = I4 ) :: OPU = output_unit !! *Output unit* character ( len = 128 ) :: OUTPUT_FILE !! *When needed, output file* ! num_par definition type NUM_PAR real ( kind = R8 ) :: relax !! *relaxation parameter* real ( kind = R8 ) :: eps !! *error for convergence* integer ( kind = I4 ) :: it_max !! *maximal number of iterations* integer ( kind = I4 ) :: mess !! *message* endtype NUM_PAR private :: input_unit , output_unit endmodule num_param","loc":"sourcefile/mod_num_par.f90.html"},{"tags":"","title":"mod_test_musst.f90 – MUSST","text":"This file depends on sourcefile~~mod_test_musst.f90~~EfferentGraph sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_solver.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_num_par.f90 mod_num_par.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_num_par.f90 sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_surfile.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~mod_data.f90 mod_data.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_data.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_num_par.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_surfile.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_data.f90 sourcefile~mod_mesh.f90 mod_mesh.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_mesh.f90 sourcefile~mod_bspline.f90 mod_bspline.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_bspline.f90 sourcefile~mod_fluid.f90 mod_fluid.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_fluid.f90 sourcefile~mod_solver.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_gen_par.f90 mod_gen_par.f90 sourcefile~mod_solver.f90->sourcefile~mod_gen_par.f90 sourcefile~superlu.f90 superlu.f90 sourcefile~mod_solver.f90->sourcefile~superlu.f90 sourcefile~dmumps_struc.f90 dmumps_struc.f90 sourcefile~mod_solver.f90->sourcefile~dmumps_struc.f90 sourcefile~umfpack.f90 umfpack.f90 sourcefile~mod_solver.f90->sourcefile~umfpack.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_film.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_film.f90->sourcefile~mod_num_par.f90 sourcefile~mod_film.f90->sourcefile~mod_surfile.f90 sourcefile~mod_film.f90->sourcefile~mod_data.f90 sourcefile~mod_film.f90->sourcefile~mod_mesh.f90 sourcefile~mod_film.f90->sourcefile~mod_fluid.f90 sourcefile~mod_elements.f90 mod_elements.f90 sourcefile~mod_film.f90->sourcefile~mod_elements.f90 sourcefile~mod_num_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_surfile.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_surfile.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_surfile.f90 sourcefile~mod_vtk.f90 mod_vtk.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_vtk.f90 sourcefile~mod_data.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_data.f90->sourcefile~mod_fluid.f90 sourcefile~mod_gen_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_mesh.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_ir_vtk.f90 mod_ir_vtk.f90 sourcefile~mod_vtk.f90->sourcefile~mod_ir_vtk.f90 sourcefile~mod_fluid.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_elements.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 var pansourcefilemod_test_musstf90EfferentGraph = svgPanZoom('#sourcefilemod_test_musstf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_test_musst.f90~~AfferentGraph sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules test_musst Source Code mod_test_musst.f90 Source Code !! author: Noël Brunetière<br/>&emsp;Arthur Francisco !! version: 1.0.0 !! date: April,17 2017 !! summary: run different tests !< <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<       **Subroutines to read a batch file and run tests** !< </span> module test_musst use data_arch , only : R4 , PI_R8 , get_unit use data_film_hd use ms_film use film use inout_files use surfile use num_param use solver implicit none private type ( FE_FILM ) :: fe_f !! [[FE_FILM]] *deterministic finite element* type ( MS_FE_FILM ) :: ms_fe_f !! [[MS_FE_FILM]] *multiscale finite element* type ( DATA_FILM ) :: data_f !! [[DATA_FILM]] *parameter* type ( NUM_PAR ) :: num_pbs !! [[NUM_PAR]] *parameter for the bottom-scale* type ( NUM_PAR ) :: num_pts !! [[NUM_PAR]] *parameter for the top-scale* type ( MAT_SOLV ) :: mat !! [[MAT_SOLV]] *solver type matrices* type ( MS_MAT_SOLV ) :: ms_mat !! [[MS_MAT_SOLV]] *solver type matrices* integer ( kind = I4 ) :: nx !! *total number of nodes in x direction* integer ( kind = I4 ) :: ny !! *total number of nodes in y direction* integer ( kind = I4 ) :: n_mac !! *number of macro elements in a direction* integer ( kind = I4 ) :: n_mic !! *number of nodes in x or y direction for the bottom scale* real ( kind = R8 ) :: lx !! *domain size along x* real ( kind = R8 ) :: ly !! *domain size along y* real ( kind = R8 ) :: sq !! *roughness height* real ( kind = R8 ), dimension (:, :), allocatable :: tab_s !! *roughness table* real ( kind = R8 ), dimension (:, :), allocatable :: tab_sol !! *rough surface pressure solution* real ( kind = R8 ), dimension ( 4 ) :: bc , bf !! *boundary conditions* real ( kind = R4 ) :: t1 , t2 !! *cpu time* integer ( kind = I4 ) :: cend , cr , cinit !! *real time* integer ( kind = I4 ) :: unit_num_res !! *file number* integer ( kind = I4 ) :: compare_solution_file !! *whether to compare the pressure MS solution to a reference* character ( len = 256 ) :: ms_vtk !! *output vtk file name* character ( len = 256 ) :: prof_ts , prof_bs !! *ts/bs mat profile name* character ( len = 256 ) :: res_file !! *result file name* character ( len = 256 ) :: surface_file !! *surface file name* character ( len = 256 ) :: pressure_solution_file !! *pressure solution file for a rough surface* character ( len = 15 ) :: res_dir !! *\"/out\" subdirectory for results* type ( SCALE_SURF ) :: scal_tmp !! *object [[SCALE_SURF]]* integer ( kind = I4 ) :: test_num !! *test number* logical ( kind = I4 ) :: save_PeK !! *save x Peclet field* logical ( kind = I4 ) :: save_PeE !! *save y Peclet field* public :: run_test , read_data , test_num contains !========================================================================================= !< @note Subroutine to run the specified test !  @endnote !----------------------------------------------------------------------------------------- subroutine run_test implicit none mat % slv_t = SOLVER_TS call get_unit ( unit_num_res ) ; open ( unit = unit_num_res , file = trim ( res_file ), status = 'unknown' ) select case ( test_num ) case ( 1 ); call test_slider_fe case ( 11 ); call test_slider_ms case ( 2 ); call test_bearing_x_fe case ( 3 ); call test_bearing_y_fe case ( 4 ); call test_rough_fe case ( 14 ); call test_rough_ms case ( 5 ); call test_pocket_fe case default ; stop 'Bad test number' endselect close ( unit_num_res ) return endsubroutine run_test !========================================================================================= !< @note Subroutine to read the 'EXEC_MUSST' section !  @endnote !----------------------------------------------------------------------------------------- subroutine read_data ( iunit , dir ) implicit none integer ( kind = I4 ), intent ( in ) :: iunit character ( len = 15 ), intent ( in ) :: dir !! *output directory* integer ( kind = I4 ) :: err_read character ( len = 064 ) :: word res_dir = dir compare_solution_file = 0 data_f % h_0 = - 1._R8 data_f % h_g = - 1._R8 data_f % V_x = 0._R8 data_f % V_y = 0._R8 data_f % pb_type = 0 data_f % fl % fluid_type = - 1 data_f % fl % p_0 = - 1.e10_R8 data_f % fl % rho_0 = - 1.e10_R8 data_f % fl % mu_0 = - 1.e10_R8 data_f % fl % rg = 28 7._R8 data_f % fl % lambda = 1.e-5_R8 data_f % fl % T_0 = 27 3._R8 surface_file = \"no_file\" compare_solution_file = 0 pressure_solution_file = \"no_file\" lx = - 1._R8 ly = - 1._R8 nx = - 1 ny = - 1 n_mac = - 1 bc ( 1 : 4 ) = [ 1.e5_R8 , 1.e5_R8 , 1.e5_R8 , 1.e5_R8 ] num_pts = NUM_PAR ( 0._R8 , 1.e10_R8 , 0 , 0 ) num_pbs = NUM_PAR ( 0._R8 , 1.e10_R8 , 0 , 0 ) sq = 0._R8 s_vtk = 0 ms_vtk = \"no_file\" prof_ts = \"no_file\" prof_bs = \"no_file\" res_file = \"no_file\" do word = repeat ( ' ' , len ( word )) read ( iunit , * , iostat = err_read ) word if ( index ( word , '[END_MUSST]' ) /= 0 ) exit if ( index ( word , '[PROBLEM_TYPE]' ) /= 0 ) then read ( iunit , * ) test_num cycle endif if ( index ( word , '[GAP]' ) /= 0 ) then read ( iunit , * ) data_f % h_0 , data_f % h_g cycle endif if ( index ( word , '[SPEED]' ) /= 0 ) then read ( iunit , * ) data_f % V_x , data_f % V_y cycle endif if ( index ( word , '[ELASTICITY]' ) /= 0 ) then read ( iunit , * ) data_f % pb_type cycle endif if ( index ( word , '[FLUID_TYPE]' ) /= 0 ) then read ( iunit , * ) data_f % fl % fluid_type cycle endif if ( index ( word , '[AMBIENT_PRESSURE]' ) /= 0 ) then read ( iunit , * ) data_f % fl % p_0 cycle endif if ( index ( word , '[DENSITY]' ) /= 0 ) then read ( iunit , * ) data_f % fl % rho_0 cycle endif if ( index ( word , '[VISCOSITY]' ) /= 0 ) then read ( iunit , * ) data_f % fl % mu_0 cycle endif if ( index ( word , '[GAZ_CONSTANT]' ) /= 0 ) then read ( iunit , * ) data_f % fl % rg cycle endif if ( index ( word , '[MIXTURE_TRANSITION]' ) /= 0 ) then read ( iunit , * ) data_f % fl % lambda cycle endif if ( index ( word , '[AMBIENT_TEMPERATURE]' ) /= 0 ) then read ( iunit , * ) data_f % fl % T_0 cycle endif if ( index ( word , '[ROUGH_SURFACE]' ) /= 0 ) then read ( iunit , * ) surface_file cycle endif if ( index ( word , '[ROUGH_SURFACE_SOLUTION]' ) /= 0 ) then read ( iunit , * ) compare_solution_file read ( iunit , * ) pressure_solution_file cycle endif if ( index ( word , '[LENGTH]' ) /= 0 ) then read ( iunit , * ) lx , ly cycle endif if ( index ( word , '[NUMBER_NODES]' ) /= 0 ) then read ( iunit , * ) nx , ny cycle endif if ( index ( word , '[NUMBER_MACRO_ELEMENTS]' ) /= 0 ) then read ( iunit , * ) n_mac cycle endif if ( index ( word , '[BOUNDARY_PRESSURES]' ) /= 0 ) then read ( iunit , * ) bc ( 1 : 4 ) cycle endif if ( index ( word , '[NUMERICAL_TS_PARAMETERS]' ) /= 0 ) then read ( iunit , * ) num_pts cycle endif if ( index ( word , '[NUMERICAL_BS_PARAMETERS]' ) /= 0 ) then read ( iunit , * ) num_pbs cycle endif if ( index ( word , '[HEIGHT_STD_DEV]' ) /= 0 ) then read ( iunit , * ) sq cycle endif if ( index ( word , '[VTK_OUTPUT]' ) /= 0 ) then read ( iunit , * ) s_vtk , ms_vtk read ( iunit , * ) prof_ts read ( iunit , * ) prof_bs read ( iunit , * ) res_file cycle endif enddo ms_vtk = \"out/\" // res_dir // \"/\" // trim ( ms_vtk ) prof_ts = \"out/\" // res_dir // \"/\" // trim ( prof_ts ) prof_bs = \"out/\" // res_dir // \"/\" // trim ( prof_bs ) res_file = \"out/\" // res_dir // \"/\" // trim ( res_file ) return endsubroutine read_data !========================================================================================= !< @note Subroutine to define the slider geometry !  @endnote !----------------------------------------------------------------------------------------- subroutine modify_h_slider ( fe_f , lx ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f real ( kind = R8 ), intent ( in ) :: lx integer ( kind = I4 ) :: i do i = 1 , fe_f % m % n fe_f % vn ( i , H2_N ) = fe_f % data_f % h_0 + fe_f % data_f % h_0 * ( lx - fe_f % m % x ( i )) / lx enddo fe_f % vn (:, H_N ) = fe_f % vn (:, H2_N ) - fe_f % vn (:, H1_N ) return endsubroutine modify_h_slider !========================================================================================= !< @note Subroutine to define the pocket geometry !  @endnote !----------------------------------------------------------------------------------------- subroutine modify_h_pocket ( fe_f , lx ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f real ( kind = R8 ), intent ( in ) :: lx integer ( kind = I4 ) :: e , i logical ( kind = I4 ) :: groove fe_f % vn (:, H2_N ) = fe_f % data_f % h_0 fe_f % vn (:, H1_N ) = 0._R8 do e = 1 , fe_f % m % ne groove = . true . do i = 1 , 4 if ( fe_f % m % x ( fe_f % m % con ( e , i )) > ( lx / 2._R8 )) groove = . false . enddo if ( groove ) then fe_f % vc ( e , HG_C ) = fe_f % data_f % h_g endif enddo fe_f % vn (:, H_N ) = fe_f % vn (:, H2_N ) - fe_f % vn (:, H1_N ) return endsubroutine modify_h_pocket !========================================================================================= !< @note Subroutine to define the slider, in a multiscale problem !  @endnote !----------------------------------------------------------------------------------------- subroutine modify_h_slider_MS ( ms_fe_f , lx ) implicit none type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f real ( kind = R8 ), intent ( in ) :: lx integer ( kind = I4 ) :: e call modify_h_slider ( ms_fe_f % ts_fe_f , lx ) do e = 1 , ms_fe_f % ts_fe_f % m % ne call modify_h_slider ( ms_fe_f % bs_fe_f ( e ), lx ) enddo return endsubroutine modify_h_slider_MS !========================================================================================= !< @note Subroutine to define the bearing geometry !  @endnote !----------------------------------------------------------------------------------------- subroutine modify_h_bearing ( fe_f , lx ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f real ( kind = R8 ), intent ( in ) :: lx integer ( kind = I4 ) :: i do i = 1 , fe_f % m % n fe_f % vn ( i , H2_N ) = fe_f % data_f % h_0 + 0.5_R8 * fe_f % data_f % h_0 * cos ( 2 * PI_R8 * fe_f % m % x ( i ) / lx ) enddo fe_f % vn (:, H_N ) = fe_f % vn (:, H2_N ) - fe_f % vn (:, H1_N ) return endsubroutine modify_h_bearing !========================================================================================= !< @note Subroutine to define the bearing geometry !  @endnote !----------------------------------------------------------------------------------------- subroutine modify_h_bearing_y ( fe_f , ly ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f real ( kind = R8 ), intent ( in ) :: ly integer ( kind = I4 ) :: i do i = 1 , fe_f % m % n fe_f % vn ( i , H2_N ) = fe_f % data_f % h_0 + 0.5_R8 * fe_f % data_f % h_0 * cos ( 2 * PI_R8 * fe_f % m % y ( i ) / ly ) enddo fe_f % vn (:, H_N ) = fe_f % vn (:, H2_N ) - fe_f % vn (:, H1_N ) return endsubroutine modify_h_bearing_y !========================================================================================= !< @note Subroutine to apply a roughness table to a surface !  @endnote !----------------------------------------------------------------------------------------- subroutine apply_roughness ( fe_f , tab_s ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f real ( kind = R8 ), intent ( in ), dimension (:,:) :: tab_s real ( kind = R8 ) :: xp , yp integer ( kind = I4 ) :: k , i , j do k = 1 , fe_f % m % n xp = fe_f % m % x ( k ) yp = fe_f % m % y ( k ) i = int (( fe_f % m % nx - 1 ) * xp / fe_f % m % lx ) + 1 j = int (( fe_f % m % ny - 1 ) * yp / fe_f % m % ly ) + 1 fe_f % vn ( k , H2_N ) = fe_f % data_f % h_0 - tab_s ( i , j ) enddo fe_f % vn (:, H_N ) = fe_f % vn (:, H2_N ) - fe_f % vn (:, H1_N ) return endsubroutine apply_roughness !========================================================================================= !< @note Subroutine to apply a roughness table to a surface for a multiscale problem !  @endnote !----------------------------------------------------------------------------------------- subroutine apply_roughness_MS ( ms_fe_f , tab_s ) implicit none type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f real ( kind = R8 ), intent ( in ), dimension (:,:) :: tab_s real ( kind = R8 ) :: xp , yp integer ( kind = I4 ) :: k , i , j , e do k = 1 , ms_fe_f % ts_fe_f % m % n xp = ms_fe_f % ts_fe_f % m % x ( k ) yp = ms_fe_f % ts_fe_f % m % y ( k ) i = int (( ms_fe_f % ts_fe_f % m % nx - 1 ) * xp / ms_fe_f % ts_fe_f % m % lx ) + 1 j = int (( ms_fe_f % ts_fe_f % m % ny - 1 ) * yp / ms_fe_f % ts_fe_f % m % ly ) + 1 ms_fe_f % ts_fe_f % vn ( k , H2_N ) = ms_fe_f % ts_fe_f % data_f % h_0 - tab_s ( i , j ) enddo ms_fe_f % ts_fe_f % vn (:, H_N ) = ms_fe_f % ts_fe_f % vn (:, H2_N ) - ms_fe_f % ts_fe_f % vn (:, H1_N ) do e = 1 , ms_fe_f % ts_fe_f % m % ne call apply_roughness ( ms_fe_f % bs_fe_f ( e ), tab_s ) enddo return endsubroutine apply_roughness_ms !========================================================================================= !< @note Subroutine to run the slider test !  @endnote !----------------------------------------------------------------------------------------- subroutine test_slider_fe implicit none call init_fe_prob call modify_h_slider ( fe_f , lx ) call solve_fe_prob return endsubroutine test_slider_fe !========================================================================================= !< @note Subroutine to run the bearing test !  @endnote !----------------------------------------------------------------------------------------- subroutine test_bearing_x_fe implicit none call init_fe_prob call modify_h_bearing ( fe_f , lx ) call solve_fe_prob return endsubroutine test_bearing_x_fe !========================================================================================= !< @note Subroutine to run the bearing test !  @endnote !----------------------------------------------------------------------------------------- subroutine test_bearing_y_fe implicit none call init_fe_prob call modify_h_bearing_y ( fe_f , ly ) call solve_fe_prob return endsubroutine test_bearing_y_fe !========================================================================================= !< @note Subroutine to run the deterministic rough surface test !  @endnote !----------------------------------------------------------------------------------------- subroutine test_rough_fe implicit none call init_rough_prob call init_fe_prob call apply_roughness ( fe_f , tab_s ) call solve_fe_prob return endsubroutine test_rough_fe !========================================================================================= !< @note Subroutine to run the pocket test !  @endnote !----------------------------------------------------------------------------------------- subroutine test_pocket_fe implicit none call init_fe_prob call modify_h_pocket ( fe_f , lx ) call solve_fe_prob return endsubroutine test_pocket_fe !========================================================================================= !< @note Subroutine to run the multiscale slider test !  @endnote !----------------------------------------------------------------------------------------- subroutine test_slider_ms implicit none call init_ms_prob call modify_h_slider_MS ( ms_fe_f , lx ) call solve_ms_prob return endsubroutine test_slider_ms !========================================================================================= !< @note Subroutine to run the rough surface multiscale problem !  @endnote !----------------------------------------------------------------------------------------- subroutine test_rough_ms implicit none call init_rough_prob call init_ms_prob call apply_roughness_MS ( ms_fe_f , tab_s ) call solve_ms_prob return endsubroutine test_rough_ms !========================================================================================= !< @note Subroutine to initialize a deterministic 'smooth' problem !  @endnote !----------------------------------------------------------------------------------------- subroutine init_fe_prob implicit none if ( mod ( nx , 2 ) /= 1 ) then write ( OPU , * ) 'It is better to use an odd number of nodes in the x dir to have profile for comparison with analytical sol.' endif fe_f % m % nx = nx fe_f % m % ny = ny fe_f % m % lx = lx fe_f % m % ly = ly fe_f % m % zx = 0. fe_f % m % zy = 0. call create_rect_FE_film ( data_f = data_f , & num_p = num_pts , & fe_f = fe_f ) write ( OPU , * ) 'film created' return endsubroutine init_fe_prob !========================================================================================= !< @note Subroutine to initialize a deterministic 'rough' problem !  @endnote !----------------------------------------------------------------------------------------- subroutine init_rough_prob implicit none allocate ( tab_s ( nx , ny )) tab_s = 0._R8 call read_surf ( nom_fic = trim ( surface_file ), mu = 1._R8 , sq = sq , tab_s = tab_s , scal = scal_tmp ) return endsubroutine init_rough_prob !========================================================================================= !< @note Subroutine to initialize a multiscale 'smooth' problem !  @endnote !----------------------------------------------------------------------------------------- subroutine init_ms_prob implicit none n_mic = ( nx - 1 ) / n_mac + 1 ms_fe_f % ts_fe_f % m % nx = n_mac + 1 ms_fe_f % ts_fe_f % m % ny = n_mac + 1 ms_fe_f % ts_fe_f % m % lx = lx ms_fe_f % ts_fe_f % m % ly = ly ms_fe_f % ts_fe_f % m % zx = 0. ms_fe_f % ts_fe_f % m % zy = 0. call multi_scale_create_rect_fe_film ( data_f = data_f , & bs_nx = n_mic , & bs_ny = n_mic , & num_pts = num_pts , & num_pbs = num_pbs , & ms_fe_f = ms_fe_f ) write ( OPU , * ) 'film created' return endsubroutine init_ms_prob !========================================================================================= !< @note Subroutine to solve a deterministic 'smooth' problem !  @endnote !----------------------------------------------------------------------------------------- subroutine solve_fe_prob implicit none call system_clock ( count = cinit ) call cpu_time ( t1 ) call solve_FE_film ( fe_f , mat , bc ) call compute_corner_fluxes ( fe_f , mat , bf ) call cpu_time ( t2 ) call system_clock ( count = cend , count_rate = cr ) write ( OPU , * ) 'FE cpu time (s):' , char ( 9 ), t2 - t1 write ( unit_num_res , * ) 'FE_cpu_time_(s):' , char ( 9 ), t2 - t1 write ( OPU , * ) 'FE real comp time (s):' , char ( 9 ), real ( cend - cinit ) / real ( cr ) write ( unit_num_res , * ) 'FE_real_comp_time_(s):' , char ( 9 ), real ( cend - cinit ) / real ( cr ) save_PeK = . false . save_PeE = . false . if ( s_vtk /= NO_VTK ) call save_fe_f_vtk ( fe_f , trim ( ms_vtk )) select case ( test_num ) case ( 1 ) call save_profile_x_comp_slider ( fe_f , trim ( prof_ts ), lx , ly / 2 ) call execute_command_line ( \"python3 bin/pyt/filetoplot.py \" // trim ( prof_ts ) // \" '$x/L$' '$ph&#94;2/6 \\mu V L$' \" ) case ( 5 ) call save_profile_y_comp_air_pocket ( fe_f , trim ( prof_ts ), ly , lx / 2 , bc ) call execute_command_line ( \"python3 bin/pyt/filetoplot.py \" // trim ( prof_ts ) // \" '$x/L$' '$ph&#94;2/6 \\mu V L$' \" ) call save_profile_x_comp_air_pocket ( fe_f , trim ( prof_ts ) // '2' , lx , ly / 2 , bc ) call execute_command_line ( \"python3 bin/pyt/filetoplot.py \" // trim ( prof_ts ) // '2' // \" '$x/L$' '$ph&#94;2/6 \\mu V L$' \" ) case default call save_profile_x_fe ( fe_f , trim ( prof_ts ), lx , ly / 2 ) endselect call save_fe_field ( fe_f = fe_f , & ! file_name = \"out/\" // res_dir // \"/\" // \"pressure.sur\" , & ! code = P_N , & ! nodal = . true .) if ( save_PeK ) & ! call save_fe_field ( fe_f = fe_f , & ! file_name = \"out/\" // res_dir // \"/\" // \"PeK.sur\" , & ! code = PEK_C , & ! nodal = . false .) if ( save_PeE ) & ! call save_fe_field ( fe_f = fe_f , & ! file_name = \"out/\" // res_dir // \"/\" // \"PeE.sur\" , & ! code = PEE_C , & ! nodal = . false .) write ( OPU , * ) 'load FE (N):' , char ( 9 ), fe_f % fz () write ( unit_num_res , * ) 'load_FE_(N):' , char ( 9 ), fe_f % fz () write ( OPU , * ) 'fric/x FE (N)' , char ( 9 ), fe_f % fx () write ( unit_num_res , * ) 'fric/x_FE_(N)' , char ( 9 ), fe_f % fx () write ( OPU , * ) 'fric/y FE (N)' , char ( 9 ), fe_f % fy () write ( unit_num_res , * ) 'fric/y_FE_(N)' , char ( 9 ), fe_f % fy () return endsubroutine solve_fe_prob !========================================================================================= !< @note Subroutine to solve a 'smooth' multiscale problem !  @endnote !----------------------------------------------------------------------------------------- subroutine solve_ms_prob implicit none real ( kind = R8 ), dimension (:, :), allocatable :: tab call system_clock ( count = cinit ) call cpu_time ( t1 ) call multi_scale_solve_fe_film ( ms_fe_f , ms_mat , bc ) call cpu_time ( t2 ) call system_clock ( count = cend , count_rate = cr ) write ( OPU , * ) 'MS cpu time (s):' , char ( 9 ), t2 - t1 write ( unit_num_res , * ) 'MS_cpu_time_(s):' , char ( 9 ), t2 - t1 write ( OPU , * ) 'MS real comp time (s):' , char ( 9 ), real ( cend - cinit ) / real ( cr ) write ( unit_num_res , * ) 'MS_real_comp_time_(s):' , char ( 9 ), real ( cend - cinit ) / real ( cr ) write ( OPU , * ) 'load MS_FE (N):' , char ( 9 ), ms_fe_f % ms_fz () write ( unit_num_res , * ) 'load_MS_FE_(N):' , char ( 9 ), ms_fe_f % ms_fz () write ( OPU , * ) 'fric/x MS FE (N):' , char ( 9 ), ms_fe_f % ms_fx () write ( unit_num_res , * ) 'fric/x_MS_FE_(N):' , char ( 9 ), ms_fe_f % ms_fx () write ( OPU , * ) 'fric/y MS FE (N):' , char ( 9 ), ms_fe_f % ms_fy () write ( unit_num_res , * ) 'fric/y_MS_FE_(N):' , char ( 9 ), ms_fe_f % ms_fy () call save_ms_fe_f_vtk ( ms_fe_f , trim ( ms_vtk )) call save_profile_x_fe ( ms_fe_f % ts_fe_f , trim ( prof_ts ), lx , ly / 2 ) call save_profile_x_ms ( ms_fe_f , trim ( prof_bs ), lx , ly / 2 ) call save_ms_field ( ms_fe_f = ms_fe_f , & ! file_name = \"out/\" // res_dir // \"/\" // \"ms_pressure.sur\" , & ! code = P_N , & ! nodal = . true . ) if ( compare_solution_file /= 0 ) then if ( allocated ( tab_sol ) ) deallocate ( tab_sol ) call read_surf ( nom_fic = trim ( pressure_solution_file ), & ! mu = - 1._R8 , & ! sq = - 1._R8 , & ! tab_s = tab_sol , & ! scal = scal_tmp ) if ( allocated ( tab_s ) ) deallocate ( tab_s ) call ms_fe_f_2_mat ( ms_fe_f = ms_fe_f , & ! code = P_N , & ! nodal = . true ., & ! mat = tab_s ) allocate ( tab ( 1 : nx , 1 : ny ) ) tab ( 1 : nx , 1 : ny ) = abs ( tab_s ( 1 : nx , 1 : ny ) - tab_sol ( 1 : nx , 1 : ny )) scal_tmp % zlength_unit = 'Pa' scal_tmp % dz_unit = 'Pa' call write_surf ( nom_fic = \"out/\" // res_dir // \"/\" // \"compare_pressure.sur\" , & ! tab_s = tab ( 1 : nx , 1 : ny ), & ! scal = scal_tmp ) where ( tab_s < data_f % fl % p_0 . and . tab_sol > data_f % fl % p_0 ) tab = - 1._R8 elsewhere ( tab_s > data_f % fl % p_0 . and . tab_sol < data_f % fl % p_0 ) tab = + 1._R8 elsewhere ( tab_s < data_f % fl % p_0 . and . tab_sol < data_f % fl % p_0 ) tab = 0._R8 elsewhere tab = - 2._R8 endwhere scal_tmp % zlength_unit = '  ' scal_tmp % dz_unit = '  ' call write_surf ( nom_fic = \"out/\" // res_dir // \"/\" // \"compare_cavitation.sur\" , & ! tab_s = tab ( 1 : nx , 1 : ny ), & ! scal = scal_tmp ) endif if ( allocated ( tab ) ) deallocate ( tab ) if ( allocated ( tab_s ) ) deallocate ( tab_s ) if ( allocated ( tab_sol ) ) deallocate ( tab_sol ) return endsubroutine solve_ms_prob endmodule test_musst","loc":"sourcefile/mod_test_musst.f90.html"},{"tags":"","title":"mod_vtk.f90 – MUSST","text":"This file depends on sourcefile~~mod_vtk.f90~~EfferentGraph sourcefile~mod_vtk.f90 mod_vtk.f90 sourcefile~mod_ir_vtk.f90 mod_ir_vtk.f90 sourcefile~mod_vtk.f90->sourcefile~mod_ir_vtk.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_vtk.f90~~AfferentGraph sourcefile~mod_vtk.f90 mod_vtk.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_vtk.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules VTK Source Code mod_vtk.f90 Source Code !------------------------------------------------------------------------------------------ !! file: Lib_VTK_IO.f03 !! author: Stefano Zaghi !! version: 1.0 !! brief: LIBVTKIO is a library of functions for Input and Output pure fortran data (both ascii and binary) in VTK format. !------------------------------------------------------------------------------------------ module VTK !----------------------------------------------------------------------------------------------------------------------------------- !!LIBVTKIO is a library of functions for Input and Output pure fortran data (both ascii and binary) in VTK format. !! !!The VTK standard can be separated into two main catagories: the \\MaiuscolettoBS{VTK Legacy Standard} and the !!\\MaiuscolettoBS{VTK XML Standard}. The latter is more powerful and will has a stronger support from VTk comunity than legacy !!standard; XML file format would to be preferred despite the legacy one. ! !At the present only a few functions of the final library have been implemented. The InPut functions are totaly absent, but the !OutPut functions are almost complete (the \\virgo{polydata} functions are the only missing). ! !The functions actually present are: ! !\\begin{boxred}{Functions for Legacy VTK file format} !\\begin{enumerate1Red} ! \\item \\MaiuscolettoS{VTK\\_INI} ! \\item \\MaiuscolettoS{VTK\\_GEO} ! \\item \\MaiuscolettoS{VTK\\_CON} ! \\item \\MaiuscolettoS{VTK\\_DAT} ! \\item \\MaiuscolettoS{VTK\\_VAR} ! \\item \\MaiuscolettoS{VTK\\_END} !\\end{enumerate1Red} !\\end{boxred} ! !\\begin{boxred}{Functions for XML VTK file format} !\\begin{enumerate1Red} ! \\item \\MaiuscolettoS{VTK\\_INI\\_XML} ! \\item \\MaiuscolettoS{VTK\\_GEO\\_XML} ! \\item \\MaiuscolettoS{VTK\\_CON\\_XML} ! \\item \\MaiuscolettoS{VTK\\_DAT\\_XML} ! \\item \\MaiuscolettoS{VTK\\_VAR\\_XML} ! \\item \\MaiuscolettoS{VTK\\_END\\_XML} !\\end{enumerate1Red} !\\end{boxred} !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- USE IR_VTK ! Real and integer portable multi-precision kind definition. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! functions for VTK LEGACY public :: VTK_INI public :: VTK_GEO public :: VTK_CON public :: VTK_DAT public :: VTK_VAR public :: VTK_END ! functions for VTK XML public :: VTK_INI_XML public :: VTK_GEO_XML public :: VTK_CON_XML public :: VTK_DAT_XML public :: VTK_VAR_XML public :: VTK_END_XML ! functions for VTM XML public :: VTM_INI_XML public :: VTM_BLK_XML public :: VTM_WRF_XML public :: VTM_END_XML ! portable kind-precision !public:: R16P, FR16P public :: R8P , FR8P public :: R4P , FR4P public :: R_P , FR_P public :: I8P , FI8P public :: I4P , FI4P public :: I2P , FI2P public :: I1P , FI1P public :: I_P , FI_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! overloading of VTK_GEO interface VTK_GEO module procedure VTK_GEO_UNST_R8 , & ! real(R8P) UNSTRUCTURED\\_GRID VTK_GEO_UNST_R4 , & ! real(R4P) UNSTRUCTURED\\_GRID VTK_GEO_STRP_R8 , & ! real(R8P) STRUCTURED\\_POINTS VTK_GEO_STRP_R4 , & ! real(R4P) STRUCTURED\\_POINTS VTK_GEO_STRG_R8 , & ! real(R8P) STRUCTURED\\_GRID VTK_GEO_STRG_R4 , & ! real(R4P) STRUCTURED\\_GRID VTK_GEO_RECT_R8 , & ! real(R8P) RECTILINEAR\\_GRID VTK_GEO_RECT_R4 ! real(R4P) RECTILINEAR\\_GRID endinterface ! overloading of VTK_VAR interface VTK_VAR module procedure VTK_VAR_SCAL_R8 , & ! real(R8P)    scalar VTK_VAR_SCAL_R4 , & ! real(R4P)    scalar VTK_VAR_SCAL_I4 , & ! integer(I4P) scalar VTK_VAR_VECT_R8 , & ! real(R8P)    vectorial VTK_VAR_VECT_R4 , & ! real(R4P)    vectorial VTK_VAR_VECT_I4 , & ! integer(I4P) vectorial VTK_VAR_TEXT_R8 , & ! real(R8P)    vectorial (texture) VTK_VAR_TEXT_R4 ! real(R4P)    vectorial (texture) endinterface ! overloading of VTK_GEO_XML interface VTK_GEO_XML module procedure VTK_GEO_XML_STRG_R4 , & ! real(R4P) StructuredGrid VTK_GEO_XML_STRG_R8 , & ! real(R8P) StructuredGrid VTK_GEO_XML_RECT_R8 , & ! real(R8P) RectilinearGrid VTK_GEO_XML_RECT_R4 , & ! real(R4P) RectilinearGrid VTK_GEO_XML_UNST_R8 , & ! real(R8P) UnstructuredGrid VTK_GEO_XML_UNST_R4 , & ! real(R4P) UnstructuredGrid VTK_GEO_XML_CLOSEP ! closing tag \"Piece\" function endinterface ! overloading of VTK_VAR_XML interface VTK_VAR_XML module procedure VTK_VAR_XML_SCAL_R8 , & ! real(R8P)    scalar VTK_VAR_XML_SCAL_R4 , & ! real(R4P)    scalar VTK_VAR_XML_SCAL_I8 , & ! integer(I8P) scalar VTK_VAR_XML_SCAL_I4 , & ! integer(I4P) scalar VTK_VAR_XML_SCAL_I2 , & ! integer(I2P) scalar VTK_VAR_XML_SCAL_I1 , & ! integer(I1P) scalar VTK_VAR_XML_VECT_R8 , & ! real(R8P)    vectorial VTK_VAR_XML_VECT_R4 , & ! real(R4P)    vectorial VTK_VAR_XML_VECT_I8 , & ! integer(I4P) vectorial VTK_VAR_XML_VECT_I4 , & ! integer(I4P) vectorial VTK_VAR_XML_VECT_I2 , & ! integer(I4P) vectorial VTK_VAR_XML_VECT_I1 , & ! integer(I4P) vectorial VTK_VAR_XML_LIST_R8 , & ! real(R8P)    list VTK_VAR_XML_LIST_R4 , & ! real(R4P)    list VTK_VAR_XML_LIST_I8 , & ! integer(I4P) list VTK_VAR_XML_LIST_I4 , & ! integer(I4P) list VTK_VAR_XML_LIST_I2 , & ! integer(I2P) list VTK_VAR_XML_LIST_I1 ! integer(I1P) list endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- !\\LIBVTKIO uses a small set of internal variables that are private (not accessible from the outside). The following are ! private variables: ! integer ( I4P ), parameter :: maxlen = 500 ! max number of characters of static string character ( 1 ), parameter :: end_rec = char ( 10 ) ! end-character for binary-record finalize integer ( I4P ), parameter :: f_out_ascii = 0 ! ascii-output-format parameter identifier integer ( I4P ), parameter :: f_out_binary = 1 ! binary-output-format parameter identifier integer ( I4P ) :: f_out = f_out_ascii ! current output-format (initialized to ascii format) character ( len = maxlen ) :: topology ! mesh topology integer ( I4P ) :: Unit_VTK ! internal logical unit integer ( I4P ) :: Unit_VTK_Append ! internal logical unit for raw binary XML append file integer ( I4P ) :: N_Byte ! number of byte to be written/read real ( R8P ) :: Tipo_R8 = 1._R8P ! prototype of R8P real real ( R4P ) :: Tipo_R4 = 1._R4P ! prototype of R4P real integer ( I8P ) :: Tipo_I8 = 1_I8P ! prototype of I8P integer integer ( I4P ) :: Tipo_I4 = 1_I4P ! prototype of I4P integer integer ( I2P ) :: Tipo_I2 = 1_I2P ! prototype of I2P integer integer ( I1P ) :: Tipo_I1 = 1_I1P ! prototype of I1P integer integer ( I8P ) :: ioffset ! offset pointer integer ( I4P ) :: indent ! indent pointer ! VTM specific variables integer ( I4P ) :: Unit_VTM ! internal logical unit integer ( I4P ) :: blk ! block index integer ( I4P ) :: vtm_indent ! indent pointer !----------------------------------------------------------------------------------------------------------------------------------- !In the following chapters there is the API reference of all functions of \\LIBVTKIO. contains !\\chapter{Auxiliary functions} !\\minitoc !\\vspace*{8mm} ! !\\LIBVTKIO uses two auxiliary functions that are not connected with the VTK standard. These functions are private and so they !cannot be called outside the library. function GetUnit () result ( Free_Unit ) !--------------------------------------------------------------------------------------------------------------------------------- !!The GetUnit function is used for getting a free logic unit. The users of \\LIBVTKIO does not know which is !!the logical unit: \\LIBVTKIO handels this information without boring the users. The logical unit used is safe-free: if the !!program calling \\LIBVTKIO has others logical units used \\LIBVTKIO will never use these units, but will choice one that is free. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ) :: Free_Unit ! free logic unit integer ( I4P ) :: n1 ! counter integer ( I4P ) :: ios ! inquiring flag logical ( 4 ) :: lopen ! inquiring flag !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- !!The following is the code snippet of GetUnit function: the units 0, 5, 6, 9 and all non-free units are discarded. !! !(\\doc)codesnippet Free_Unit = - 1_I4P ! initializing free logic unit n1 = 1_I4P ! initializing counter do if (( n1 /= 5_I4P ). AND .( n1 /= 6_I4P ). AND .( n1 /= 9_I4P )) then inquire ( unit = n1 , opened = lopen , iostat = ios ) ! verify logic units if ( ios == 0_I4P ) then if (. NOT . lopen ) then Free_Unit = n1 ! assignment of free logic return endif endif endif n1 = n1 + 1_I4P ! updating counter enddo return !(doc/)codesnippet !!GetUnit function is private and cannot be called outside \\LIBVTKIO. If you are interested to use it change its scope to public. !--------------------------------------------------------------------------------------------------------------------------------- endfunction GetUnit function Upper_Case ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !!The Upper\\_Case function converts the lower case characters of a string to upper case one. \\LIBVTKIO uses this function in !!order to achieve case-insensitive: all character variables used within \\LIBVTKIO functions are pre-processed by !!Uppper\\_Case function before these variables are used. So the users can call \\LIBVTKIO functions whitout pay attention of the !!case of the kwywords passed to the functions: calling the function VTK\\_INI with the string \\code{E_IO = VTK_INI('Ascii',...)} !!or with the string  \\code{E_IO = VTK_INI('AscII',...)} is equivalent. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len =* ), intent ( IN ) :: string ! string to be converted character ( len = len ( string )) :: Upper_Case ! converted string integer :: n1 ! characters counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- !!The following is the code snippet of Upper\\_Case function. !! !(\\doc)codesnippet Upper_Case = string do n1 = 1 , len ( string ) select case ( ichar ( string ( n1 : n1 ))) case ( 97 : 122 ) Upper_Case ( n1 : n1 ) = char ( ichar ( string ( n1 : n1 )) - 32 ) ! Upper case conversion endselect enddo return !(doc/)codesnippet !!Upper\\_Case function is private and cannot be called outside \\LIBVTKIO. If you are interested to use it change its scope !!to public. !--------------------------------------------------------------------------------------------------------------------------------- endfunction Upper_Case !\\chapter{VTK LEGACY functions} !\\minitoc !\\vspace*{8mm} ! function VTK_INI ( output_format , filename , title , mesh_topology ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!The VTK\\_INI function is used for initializing file. This function must be the first to be called. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: output_format ! output format: ASCII or BINARY character ( * ), intent ( IN ) :: filename ! name of file character ( * ), intent ( IN ) :: title ! title character ( * ), intent ( IN ) :: mesh_topology ! mesh topology integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !!The VTK\\_INI variables have the following meaning: !! !!\\begin{description} !! \\item[{\\color{RoyalBlue}output\\_format}] indicates the \\virgo{format} of output file. It can assume the following values: !! \\begin{enumerateABlu} !!  \\item \\emph{ascii} (it is case insensitive) $\\rightarrow$ creating an ascii output file. !!  \\item \\emph{binary} (it is case insensitive) $\\rightarrow$ creating a binary (big\\_endian encoding) output file. !! \\end{enumerateABlu} !! \\item[{\\color{RoyalBlue}filename}] contains the name (with its path) of the output file. !! \\item[{\\color{RoyalBlue}title}] contains the title of the VTK dataset. !! \\item[{\\color{RoyalBlue}topology}] indicates the topology of the mesh and can assume the following values: !! \\begin{enumerateABlu} !!  \\item \\emph{STRUCTURED\\_POINTS}. !!  \\item \\emph{STRUCTURED\\_GRID}. !!  \\item \\emph{UNSTRUCTURED\\_GRID}. !!  \\item \\emph{RECTILINEAR\\_GRID}. !! \\end{enumerateABlu} !! \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling. !!\\end{description} !! !!The following is an example of VTK\\_INI calling: !! !!\\begin{boxred}{VTK\\_INI Calling} !!\\begin{verbatim} !!... !!E_IO = VTK_INI('Binary','example.vtk','VTK legacy file','UNSTRUCTURED_GRID') !!... !!\\end{verbatim} !!\\end{boxred} !!\\noindent Note that the \\virgo{.vtk} extension is necessary in the file name. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- topology = trim ( mesh_topology ) Unit_VTK = GetUnit () select case ( trim ( Upper_Case ( output_format ))) case ( 'ASCII' ) f_out = f_out_ascii open ( unit = Unit_VTK , & file = trim ( filename ), & form = 'FORMATTED' , & access = 'SEQUENTIAL' , & action = 'WRITE' , & iostat = E_IO ) ! writing header of file write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) '# vtk DataFile Version 3.0' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) trim ( title ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) trim ( Upper_Case ( output_format )) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'DATASET ' // trim ( topology ) case ( 'BINARY' ) f_out = f_out_binary open ( unit = Unit_VTK , & file = trim ( filename ), & form = 'UNFORMATTED' , & access = 'STREAM' , & action = 'WRITE' , & convert = 'BIG_ENDIAN' , & iostat = E_IO ) ! writing header of file write ( unit = Unit_VTK , iostat = E_IO ) '# vtk DataFile Version 3.0' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) trim ( title ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) trim ( Upper_Case ( output_format )) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) 'DATASET ' // trim ( topology ) // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_INI !(doc)INCLUDE{/home/szaghi/VTK_IO/LIB_VTK_IO/source/DOC_VTK_GEO.doc} !(\\doc)skippedblock function VTK_GEO_STRP_R8 ( Nx , Ny , Nz , X0 , Y0 , Z0 , Dx , Dy , Dz ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = STRUCTURED\\_POINTS (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx ! number of nodes in x direction integer ( I4P ), intent ( IN ) :: Ny ! number of nodes in y direction integer ( I4P ), intent ( IN ) :: Nz ! number of nodes in z direction real ( R8P ), intent ( IN ) :: X0 ! x coordinate of origin real ( R8P ), intent ( IN ) :: Y0 ! y coordinate of origin real ( R8P ), intent ( IN ) :: Z0 ! z coordinate of origin real ( R8P ), intent ( IN ) :: Dx ! space step in x direction real ( R8P ), intent ( IN ) :: Dy ! space step in y direction real ( R8P ), intent ( IN ) :: Dz ! space step in z direction integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , fmt = '(A,3' // FR8P // ')' , iostat = E_IO ) 'ORIGIN ' , X0 , Y0 , Z0 write ( unit = Unit_VTK , fmt = '(A,3' // FR8P // ')' , iostat = E_IO ) 'SPACING ' , Dx , Dy , Dz case ( f_out_binary ) write ( s_buffer , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,3' // FR8P // ')' , iostat = E_IO ) 'ORIGIN ' , X0 , Y0 , Z0 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,3' // FR8P // ')' , iostat = E_IO ) 'SPACING ' , Dx , Dy , Dz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRP_R8 function VTK_GEO_STRP_R4 ( Nx , Ny , Nz , X0 , Y0 , Z0 , Dx , Dy , Dz ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = STRUCTURED\\_POINTS (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx ! number of nodes in x direction integer ( I4P ), intent ( IN ) :: Ny ! number of nodes in y direction integer ( I4P ), intent ( IN ) :: Nz ! number of nodes in z direction real ( R4P ), intent ( IN ) :: X0 ! x coordinate of origin real ( R4P ), intent ( IN ) :: Y0 ! y coordinate of origin real ( R4P ), intent ( IN ) :: Z0 ! z coordinate of origin real ( R4P ), intent ( IN ) :: Dx ! space step in x direction real ( R4P ), intent ( IN ) :: Dy ! space step in y direction real ( R4P ), intent ( IN ) :: Dz ! space step in z direction integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , fmt = '(A,3' // FR4P // ')' , iostat = E_IO ) 'ORIGIN ' , X0 , Y0 , Z0 write ( unit = Unit_VTK , fmt = '(A,3' // FR4P // ')' , iostat = E_IO ) 'SPACING ' , Dx , Dy , Dz case ( f_out_binary ) write ( s_buffer , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,3' // FR4P // ')' , iostat = E_IO ) 'ORIGIN ' , X0 , Y0 , Z0 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,3' // FR4P // ')' , iostat = E_IO ) 'SPACING ' , Dx , Dy , Dz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRP_R4 function VTK_GEO_STRG_R8 ( Nx , Ny , Nz , NN , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = STRUCTURED\\_GRID (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx ! number of nodes in x direction integer ( I4P ), intent ( IN ) :: Ny ! number of nodes in y direction integer ( I4P ), intent ( IN ) :: Nz ! number of nodes in z direction integer ( I4P ), intent ( IN ) :: NN ! number of all nodes real ( R8P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates real ( R8P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates real ( R8P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' double' write ( unit = Unit_VTK , fmt = '(3' // FR8P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' double' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRG_R8 function VTK_GEO_STRG_R4 ( Nx , Ny , Nz , NN , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = STRUCTURED\\_GRID (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx ! number of nodes in x direction integer ( I4P ), intent ( IN ) :: Ny ! number of nodes in y direction integer ( I4P ), intent ( IN ) :: Nz ! number of nodes in z direction integer ( I4P ), intent ( IN ) :: NN ! number of all nodes real ( R4P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates real ( R4P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates real ( R4P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' float' write ( unit = Unit_VTK , fmt = '(3' // FR4P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' float' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRG_R4 function VTK_GEO_RECT_R8 ( Nx , Ny , Nz , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = RECTILINEAR\\_GRID (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx ! number of nodes in x direction integer ( I4P ), intent ( IN ) :: Ny ! number of nodes in y direction integer ( I4P ), intent ( IN ) :: Nz ! number of nodes in z direction real ( R8P ), intent ( IN ) :: X ( 1 : Nx ) ! x coordinates real ( R8P ), intent ( IN ) :: Y ( 1 : Ny ) ! y coordinates real ( R8P ), intent ( IN ) :: Z ( 1 : Nz ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'X_COORDINATES ' , Nx , ' double' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO )( X ( n1 ), n1 = 1 , Nx ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Y_COORDINATES ' , Ny , ' double' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO )( Y ( n1 ), n1 = 1 , Ny ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Z_COORDINATES ' , Nz , ' double' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO )( Z ( n1 ), n1 = 1 , Nz ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'X_COORDINATES ' , Nx , ' double' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( X ( n1 ), n1 = 1 , Nx ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Y_COORDINATES ' , Ny , ' double' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( Y ( n1 ), n1 = 1 , Ny ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Z_COORDINATES ' , Nz , ' double' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( Z ( n1 ), n1 = 1 , Nz ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_RECT_R8 function VTK_GEO_RECT_R4 ( Nx , Ny , Nz , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = RECTILINEAR\\_GRID (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx ! number of nodes in x direction integer ( I4P ), intent ( IN ) :: Ny ! number of nodes in y direction integer ( I4P ), intent ( IN ) :: Nz ! number of nodes in z direction real ( R4P ), intent ( IN ) :: X ( 1 : Nx ) ! x coordinates real ( R4P ), intent ( IN ) :: Y ( 1 : Ny ) ! y coordinates real ( R4P ), intent ( IN ) :: Z ( 1 : Nz ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'X_COORDINATES ' , Nx , ' float' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO )( X ( n1 ), n1 = 1 , Nx ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Y_COORDINATES ' , Ny , ' float' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO )( Y ( n1 ), n1 = 1 , Ny ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Z_COORDINATES ' , Nz , ' float' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO )( Z ( n1 ), n1 = 1 , Nz ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'X_COORDINATES ' , Nx , ' float' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( X ( n1 ), n1 = 1 , Nx ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Y_COORDINATES ' , Ny , ' float' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( Y ( n1 ), n1 = 1 , Ny ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Z_COORDINATES ' , Nz , ' float' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( Z ( n1 ), n1 = 1 , Nz ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_RECT_R4 function VTK_GEO_UNST_R8 ( NN , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = UNSTRUCTURED\\_GRID (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NN ! number of nodes real ( R8P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates of all nodes real ( R8P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates of all nodes real ( R8P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates of all nodes integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' double' write ( unit = Unit_VTK , fmt = '(3' // FR8P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' double' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_UNST_R8 function VTK_GEO_UNST_R4 ( NN , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = UNSTRUCTURED\\_GRID (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NN ! number of nodes real ( R4P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates of all nodes real ( R4P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates of all nodes real ( R4P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates of all nodes integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' float' write ( unit = Unit_VTK , fmt = '(3' // FR4P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' float' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_UNST_R4 !(doc/)skippedblock function VTK_CON ( NC , connect , cell_type ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!This function \\MaiuscolettoBS{must} be used when unstructured grid is used. It saves the connectivity of the unstructured !!mesh. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC ! number of cells integer ( I4P ), intent ( IN ) :: connect (:) ! mesh connectivity integer ( I4P ), intent ( IN ) :: cell_type ( 1 : NC ) ! VTK cell type integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: ncon ! dimension of connectivity vector !!The VTK\\_CON variables have the following meaning: !! !!\\begin{description} !! \\item[{\\color{RoyalBlue}NC}] indicates the number of all cells. !! \\item[{\\color{RoyalBlue}connect}] contains the connectivity of the mesh. It is a vector. !! \\item[{\\color{RoyalBlue}cell\\_type}] contains the type of every cells. It is a vector of $[1:NC]$. !! \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling. !!\\end{description} !! !!The vector \\MaiuscolettoBS{connect} must follow the VTK legacy standard. It is passed as \\MaiuscolettoBS{assumed-shape} array !!because its dimensions is related to the mesh dimensions in a complex way. Its dimensions can be calculated by the following !!equation: !! !!\\begin{equation} !!dc = NC + \\sum\\limits_{i = 1}&#94;{NC} {nvertex_i } !!\\label{eq:connectivity dimensions} !!\\end{equation} !! !!\\noindent where $dc$ is connectivity vector dimension and $nvertex_i$ is the number of vertices of $i&#94;{th}$ cell. The VTK !!legacy standard for the mesh connectivity is quite obscure at least at first sight. It is more simple analizing an example. !!Suppose we have a mesh composed by 2 cells, one hexahedron (8 vertices) and one pyramid with square basis (5 vertices); suppose !!that the basis of pyramid is constitute by a face of the hexahedron and so the two cells share 4 vertices. The equation !!\\ref{eq:connectivity dimensions} gives $dc=2+8+5=15$; the connectivity vector for this mesh can be: !! !!\\begin{boxred}{Connectivity vector example for VTK legacy standard} !!\\begin{verbatim} !!! first cell !!connect(1)  = 8  => number of vertices of 1° cell !!connect(2)  = 0  => identification flag of 1° vertex of 1° cell !!connect(3)  = 1  => identification flag of 2° vertex of 1° cell !!connect(4)  = 2  => identification flag of 3° vertex of 1° cell !!connect(5)  = 3  => identification flag of 4° vertex of 1° cell !!connect(6)  = 4  => identification flag of 5° vertex of 1° cell !!connect(7)  = 5  => identification flag of 6° vertex of 1° cell !!connect(8)  = 6  => identification flag of 7° vertex of 1° cell !!connect(9)  = 7  => identification flag of 8° vertex of 1° cell !!! second cell !!connect(10) = 5  => number of vertices of 2° cell !!connect(11) = 0  => identification flag of 1° vertex of 2° cell !!connect(12) = 1  => identification flag of 2° vertex of 2° cell !!connect(13) = 2  => identification flag of 3° vertex of 2° cell !!connect(14) = 3  => identification flag of 4° vertex of 2° cell !!connect(15) = 8  => identification flag of 5° vertex of 2° cell !!\\end{verbatim} !!\\end{boxred} !! !!\\noindent Note that the first 4 identification flags of pyramid vertices as the same of the first 4 identification flags of !!the hexahedron because the two cells share this face. It is also important to note that the identification flags start !!form $0$ value: this is impose to the VTK standard. The function VTK\\_CON does not calculate the connectivity vector: it !!writes the connectivity vector conforming the VTK standard, but does not calculate it. In the future release of \\LIBVTKIO will !!be included a function to calculate the connectivity vector. !! !!The vector variable \\MaiuscolettoBS{tipo} must conform the VTK standard \\footnote{See the file VTK-Standard at the Kitware !!homepage.}. It contains the \\emph{type} of each cells. For the above example this vector is: !! !!\\begin{boxred}{Cell-Type vector example for VTK legacy standard} !!\\begin{verbatim} !!tipo(1) = 12  => VTK hexahedron type of 1° cell !!tipo(2) = 14  => VTK pyramid type of 2° cell !!\\end{verbatim} !!\\end{boxred} !! !!The following is an example of VTK\\_CON calling: !! !!\\begin{boxred}{VTK\\_CON Calling} !!\\begin{verbatim} !!... !!integer(4), parameter:: NC=2 !!integer(4), parameter:: Nvertex1=8 !!integer(4), parameter:: Nvertex2=5 !!integer(4), parameter:: dc=NC+Nvertex1+Nvertex2 !!integer(4)::            connect(1:dc) !!integer(4)::            cell_type(1:NC) !!... !!E_IO = VTK_CON(NC,connect,cell_type) !!... !!\\end{verbatim} !!\\end{boxred} !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ncon = size ( connect , 1 ) select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,2' // FI4P // ')' , iostat = E_IO ) 'CELLS ' , NC , ncon write ( unit = Unit_VTK , fmt = FI4P , iostat = E_IO ) connect write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'CELL_TYPES ' , NC write ( unit = Unit_VTK , fmt = FI4P , iostat = E_IO ) cell_type case ( f_out_binary ) write ( s_buffer , fmt = '(A,2' // FI4P // ')' , iostat = E_IO ) 'CELLS ' , NC , ncon write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) connect write ( unit = Unit_VTK , iostat = E_IO ) end_rec write ( s_buffer , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'CELL_TYPES ' , NC write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) cell_type write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_CON function VTK_DAT ( NC_NN , var_location ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!This function \\MaiuscolettoBS{must} be called before saving the data related to geometric mesh. This function initializes the !!saving of data variables indicating the \\emph{type} of variables that will be saved. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes of field character ( * ), intent ( IN ) :: var_location ! location of saving variables: cell for cell-centered, node for node-centered integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string !!The VTK\\_DAT variables have the following meaning: !! !!\\begin{description} !! \\item[{\\color{RoyalBlue}NC\\_NN}] indicates the number of all cells or all nodes according to the value of !!                                  {\\color{RoyalBlue}tipo}. !! \\item[{\\color{RoyalBlue}var\\_location}] contains the location-type of variables that will be saved after VTK\\_DAT. It is !!                                         a scalar and cab assume the following values: !! \\begin{enumerateABlu} !!  \\item \\emph{cell} (it is case insensitive) $\\rightarrow$ variables will be cell-centered. !!  \\item \\emph{node} (it is case insensitive) $\\rightarrow$ variables will be node-centered. !! \\end{enumerateABlu} !! \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling. !!\\end{description} !! !!Of course a single file can contain both cell and node centered variables; in this case the VTK\\_DAT function must be !!called two times, before saving cell-centered variables and before saving node-centered variables. !! !!The following is an example of VTK\\_DAT calling: !! !!\\begin{boxred}{VTK\\_DAT Calling} !!\\begin{verbatim} !!... !!E_IO = VTK_DAT(50,'node') !!... !!\\end{verbatim} !!\\end{boxred} !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) select case ( trim ( Upper_Case ( var_location ))) case ( 'CELL' ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'CELL_DATA ' , NC_NN case ( 'NODE' ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'POINT_DATA ' , NC_NN endselect case ( f_out_binary ) select case ( trim ( Upper_Case ( var_location ))) case ( 'CELL' ) write ( s_buffer , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'CELL_DATA ' , NC_NN write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec case ( 'NODE' ) write ( s_buffer , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'POINT_DATA ' , NC_NN write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_DAT !(doc)INCLUDE{/home/szaghi/VTK_IO/LIB_VTK_IO/source/DOC_VTK_VAR.doc} !(\\doc)skippedblock function VTK_VAR_SCAL_R8 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving field of scalar variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells character ( * ), intent ( IN ) :: varname ! variable name real ( R8P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' double 1' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'LOOKUP_TABLE default' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO ) var case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' double 1' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) 'LOOKUP_TABLE default' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) var write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_SCAL_R8 function VTK_VAR_SCAL_R4 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving field of scalar variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells character ( * ), intent ( IN ) :: varname ! variable name real ( R4P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' float 1' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'LOOKUP_TABLE default' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO ) var case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' float 1' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) 'LOOKUP_TABLE default' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) var write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_SCAL_R4 function VTK_VAR_SCAL_I4 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving field of scalar variable (I4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells character ( * ), intent ( IN ) :: varname ! variable name integer ( I4P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' int 1' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'LOOKUP_TABLE default' write ( unit = Unit_VTK , fmt = FI4P , iostat = E_IO ) var case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' int 1' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) 'LOOKUP_TABLE default' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) var write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_SCAL_I4 function VTK_VAR_VECT_R8 ( vec_type , NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving field of vectorial variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: vec_type ! vector type: vect = generic vector , norm = normal vector integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells character ( * ), intent ( IN ) :: varname ! variable name real ( R8P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component of vector real ( R8P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component of vector real ( R8P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component of vector integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I8P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) select case ( Upper_Case ( trim ( vec_type ))) case ( 'VECT' ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' double' case ( 'NORM' ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'NORMALS ' // trim ( varname ) // ' double' endselect write ( unit = Unit_VTK , fmt = '(3' // FR8P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( f_out_binary ) select case ( Upper_Case ( trim ( vec_type ))) case ( 'VECT' ) write ( unit = Unit_VTK , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' double' // end_rec case ( 'NORM' ) write ( unit = Unit_VTK , iostat = E_IO ) 'NORMALS ' // trim ( varname ) // ' double' // end_rec endselect write ( unit = Unit_VTK , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_VECT_R8 function VTK_VAR_VECT_R4 ( vec_type , NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving field of vectorial variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: vec_type ! vector type: vect = generic vector , norm = normal vector integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells character ( * ), intent ( IN ) :: varname ! variable name real ( R4P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component of vector real ( R4P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component of vector real ( R4P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component of vector integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I8P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) select case ( Upper_Case ( trim ( vec_type ))) case ( 'vect' ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' float' case ( 'norm' ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'NORMALS ' // trim ( varname ) // ' float' endselect write ( unit = Unit_VTK , fmt = '(3' // FR4P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( f_out_binary ) select case ( Upper_Case ( trim ( vec_type ))) case ( 'vect' ) write ( unit = Unit_VTK , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' float' // end_rec case ( 'norm' ) write ( unit = Unit_VTK , iostat = E_IO ) 'NORMALS ' // trim ( varname ) // ' float' // end_rec endselect write ( unit = Unit_VTK , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_VECT_R4 function VTK_VAR_VECT_I4 ( NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving field of vectorial variable (I4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells character ( * ), intent ( IN ) :: varname ! variable name integer ( I4P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component of vector integer ( I4P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component of vector integer ( I4P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component of vector integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I8P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' int' write ( unit = Unit_VTK , fmt = '(3' // FI4P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' int' // end_rec write ( unit = Unit_VTK , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_VECT_I4 function VTK_VAR_TEXT_R8 ( NC_NN , dimm , varname , textCoo ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving texture variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells integer ( I4P ), intent ( IN ) :: dimm ! texture dimensions character ( * ), intent ( IN ) :: varname ! variable name real ( R8P ), intent ( IN ) :: textCoo ( 1 : NC_NN , 1 : dimm ) ! texture integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I8P ) :: n1 , n2 ! counters !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,1X,' // FI4P // ',1X,A)' , iostat = E_IO ) 'TEXTURE_COORDINATES ' // trim ( varname ), dimm , ' double' write ( s_buffer , fmt = '(I1)' , iostat = E_IO ) dimm s_buffer = '(' // trim ( s_buffer ) // FR4P // ')' write ( unit = Unit_VTK , fmt = trim ( s_buffer ), iostat = E_IO )(( textCoo ( n1 , n2 ), n2 = 1 , dimm ), n1 = 1 , NC_NN ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,1X,' // FI4P // ',1X,A)' , iostat = E_IO ) 'TEXTURE_COORDINATES ' // trim ( varname ), dimm , ' double' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )(( textCoo ( n1 , n2 ), n2 = 1 , dimm ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_TEXT_R8 function VTK_VAR_TEXT_R4 ( NC_NN , dimm , varname , textCoo ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving texture variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells integer ( I4P ), intent ( IN ) :: dimm ! texture dimensions character ( * ), intent ( IN ) :: varname ! variable name real ( R4P ), intent ( IN ) :: textCoo ( 1 : NC_NN , 1 : dimm ) ! texture integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I8P ) :: n1 , n2 ! counters !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,1X,' // FI4P // ',1X,A)' , iostat = E_IO ) 'TEXTURE_COORDINATES ' // trim ( varname ), dimm , ' float' write ( s_buffer , fmt = '(I1)' , iostat = E_IO ) dimm s_buffer = '(' // trim ( s_buffer ) // FR4P // ')' write ( unit = Unit_VTK , fmt = trim ( s_buffer ), iostat = E_IO )(( textCoo ( n1 , n2 ), n2 = 1 , dimm ), n1 = 1 , NC_NN ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,1X,' // FI4P // ',1X,A)' , iostat = E_IO ) 'TEXTURE_COORDINATES ' // trim ( varname ), dimm , ' float' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )(( textCoo ( n1 , n2 ), n2 = 1 , dimm ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_TEXT_R4 !(doc/)skippedblock function VTK_END () result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!This function is used to finalize the file opened and it has not inputs. The \\LIBVTKIO manages the file unit without the !!user's action. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !!The VTK\\_END variables have the following meaning: !! !!\\begin{description} !! \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling. !!\\end{description} !! !!The following is an example of VTK\\_END calling: !! !!\\begin{boxred}{VTK\\_END Calling} !!\\begin{verbatim} !!... !!E_IO = VTK_END() !!... !!\\end{verbatim} !!\\end{boxred} !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- close ( unit = Unit_VTK , iostat = E_IO ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_END !\\chapter{VTK XML functions} !\\minitoc !\\vspace*{8mm} ! !\\lettrine[lines=2,loversize=-.1,lraise=0.2]{{\\bf T}}{he} XML standard is more powerful than legacy one. It is more flexible !and free but on the other hand is more (but not so more using a library like \\LIBVTKIO...) complex than legacy standard. The !output of XML functions is a well-formated XML file at least for the ascii format (in the binary format \\LIBVTKIO use !raw-data format that does not produce a well formated XML file). ! !The XML functions follow the same calling-convention of the legacy functions; all the \\LIBVTKIO XML functions are !\\MaiuscolettoBS{4-byte integer function}: the output of these functions is an integer that is $0$ if the function calling !has been done right while it is $> 0$  if some errors occur. The functions calling is the same as legacy functions: ! !\\begin{boxred}{Functions Calling} !\\begin{verbatim} !... !integer(4):: E_IO !... !E_IO = VTK_INI_XML(.... !... !\\end{verbatim} !\\end{boxred} ! !\\noindent Note that the XML functions have the same name of legacy functions with the suffix \\virgo{\\_XML}. ! function VTK_INI_XML ( output_format , filename , mesh_topology , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!The VTK\\_INI\\_XML function is used for initializing file. This function must be the first to be called. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: output_format ! output format: ASCII or BINARY character ( * ), intent ( IN ) :: filename ! file name character ( * ), intent ( IN ) :: mesh_topology ! mesh topology integer ( I4P ), intent ( IN ), optional :: nx1 , nx2 ! initial and final nodes of x axis integer ( I4P ), intent ( IN ), optional :: ny1 , ny2 ! initial and final nodes of y axis integer ( I4P ), intent ( IN ), optional :: nz1 , nz2 ! initial and final nodes of z axis integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string !!The VTK\\_INI\\_XML variables have the following meaning: !! !!\\begin{description} !!\\item[{\\color{RoyalBlue}output\\_format}] indicates the \\virgo{format} of output file. It can assume the following values: !! \\begin{enumerateABlu} !!  \\item \\emph{ascii} (it is case insensitive) $\\rightarrow$ creating an ascii output file. !!  \\item \\emph{binary} (it is case insensitive) $\\rightarrow$ creating a binary (big\\_endian encoding) output file. !! \\end{enumerateABlu} !! \\item[{\\color{RoyalBlue}filename}] contains the name (with its path) of the output file. !! \\item[{\\color{RoyalBlue}topology}] indicates the topology of the mesh and can assume the following values: !! \\begin{enumerateABlu} !!  \\item \\emph{StructuredGrid}. !!  \\item \\emph{RectilinearGrid}. !!  \\item \\emph{UnstructuredGrid}. !! \\end{enumerateABlu} !! \\item[{\\color{RoyalBlue}nx1,nx2}] contains the extent of X axis; $nx1$ is the initial node and $nx2$ is the final. !! \\item[{\\color{RoyalBlue}ny1,ny2}] contains the extent of Y axis; $ny1$ is the initial node and $ny2$ is the final. !! \\item[{\\color{RoyalBlue}nz1,nz2}] contains the extent of Z axis; $nz1$ is the initial node and $nz2$ is the final. !! \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling. !!\\end{description} !! !!This function is quite more complex than the rispective legacy function; it needs more inputs: the XML standard needs more !!informations to initialize the file. !! !!The following is an example of VTK\\_INI\\_XML calling: !! !!\\begin{boxred}{VTK\\_INI\\_XML Calling} !!\\begin{verbatim} !!... !!... !!E_IO = VTK_INI_XML('BINARY','XML_RECT_BINARY.vtr', & !!                   'RectilinearGrid',              & !!                   nx1=nx1,nx2=nx2,                & !!                   ny1=ny1,ny2=ny2,                & !!                   nz1=nz1,nz2=nz2) !!... !!\\end{verbatim} !!\\end{boxred} !! !!\\noindent Note that the file extension is necessary in the file name. The XML standard has different extensions for each !!different topologies (i.e. \\MaiuscolettoBS{.vtr} for rectilinear topology). See the VTK-standard file for more information. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- topology = trim ( mesh_topology ) Unit_VTK = GetUnit () select case ( trim ( Upper_Case ( output_format ))) case ( 'ASCII' ) f_out = f_out_ascii open ( unit = Unit_VTK , & file = trim ( filename ), & form = 'FORMATTED' , & access = 'SEQUENTIAL' , & action = 'WRITE' , & iostat = E_IO ) ! writing header of file write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) '<?xml version=\"1.0\"?>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) '<VTKFile type=\"' // trim ( topology ) // '\" version=\"0.1\" byte_order=\"BigEndian\">' indent = 2 select case ( trim ( topology )) case ( 'RectilinearGrid' , 'StructuredGrid' ) write ( unit = Unit_VTK , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<' // & trim ( topology ) // & ' WholeExtent=\"' , & nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , & '\">' case ( 'UnstructuredGrid' ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<' // trim ( topology ) // '>' endselect indent = indent + 2 case ( 'BINARY' ) f_out = f_out_binary open ( unit = Unit_VTK , & file = trim ( filename ), & form = 'UNFORMATTED' , & access = 'STREAM' , & action = 'WRITE' , & convert = 'BIG_ENDIAN' , & iostat = E_IO ) ! writing header of file write ( unit = Unit_VTK , iostat = E_IO ) '<?xml version=\"1.0\"?>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) '<VTKFile type=\"' // trim ( topology ) // '\" version=\"0.1\" byte_order=\"BigEndian\">' // end_rec indent = 2 select case ( trim ( topology )) case ( 'RectilinearGrid' , 'StructuredGrid' ) write ( s_buffer , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<' // & trim ( topology ) // & ' WholeExtent=\"' , & nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , & '\">' case ( 'UnstructuredGrid' ) write ( s_buffer , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<' // trim ( topology ) // '>' endselect write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec indent = indent + 2 Unit_VTK_Append = GetUnit () ! opening the SCRATCH file used for appending raw binary data open ( unit = Unit_VTK_Append , & form = 'UNFORMATTED' , & access = 'STREAM' , & action = 'READWRITE' , & convert = 'BIG_ENDIAN' , & status = 'SCRATCH' , & iostat = E_IO ) ioffset = 0 ! initializing offset puntator endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_INI_XML !(doc)INCLUDE{/home/szaghi/VTK_IO/LIB_VTK_IO/source/DOC_VTK_GEO_XML.doc} !(\\doc)skippedblock function VTK_GEO_XML_STRG_R8 ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = StructuredGrid (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: nx1 , nx2 ! initial and final nodes of x axis integer ( I4P ), intent ( IN ) :: ny1 , ny2 ! initial and final nodes of y axis integer ( I4P ), intent ( IN ) :: nz1 , nz2 ! initial and final nodes of z axis integer ( I4P ), intent ( IN ) :: NN ! number of all nodes real ( R8P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates real ( R8P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates real ( R8P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Point\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FR8P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' case ( f_out_binary ) write ( s_buffer , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' // end_rec indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Point\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NN * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , 3 * NN write ( unit = Unit_VTK_Append , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_STRG_R8 function VTK_GEO_XML_STRG_R4 ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = StructuredGrid (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: nx1 , nx2 ! initial and final nodes of x axis integer ( I4P ), intent ( IN ) :: ny1 , ny2 ! initial and final nodes of y axis integer ( I4P ), intent ( IN ) :: nz1 , nz2 ! initial and final nodes of z axis integer ( I4P ), intent ( IN ) :: NN ! number of all nodes real ( R4P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates real ( R4P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates real ( R4P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Point\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FR4P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' case ( f_out_binary ) write ( s_buffer , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' // end_rec indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Point\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NN * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , 3 * NN write ( unit = Unit_VTK_Append , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_STRG_R4 function VTK_GEO_XML_RECT_R8 ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = RectilinearGrid (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: nx1 , nx2 ! initial and final nodes of x axis integer ( I4P ), intent ( IN ) :: ny1 , ny2 ! initial and final nodes of y axis integer ( I4P ), intent ( IN ) :: nz1 , nz2 ! initial and final nodes of z axis real ( R8P ), intent ( IN ) :: X ( nx1 : nx2 ) ! x coordinates real ( R8P ), intent ( IN ) :: Y ( ny1 : ny2 ) ! y coordinates real ( R8P ), intent ( IN ) :: Z ( nz1 : nz2 ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Coordinates>' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Float64\" Name=\"X\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO )( X ( n1 ), n1 = nx1 , nx2 ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Float64\" Name=\"Y\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO )( Y ( n1 ), n1 = ny1 , ny2 ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Float64\" Name=\"Z\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO )( Z ( n1 ), n1 = nz1 , nz2 ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Coordinates>' case ( f_out_binary ) write ( s_buffer , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<Coordinates>' // end_rec indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"X\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = ( nx2 - nx1 + 1 ) * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , nx2 - nx1 + 1 write ( unit = Unit_VTK_Append , iostat = E_IO )( X ( n1 ), n1 = nx1 , nx2 ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"Y\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = ( ny2 - ny1 + 1 ) * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , ny2 - ny1 + 1 write ( unit = Unit_VTK_Append , iostat = E_IO )( Y ( n1 ), n1 = ny1 , ny2 ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"Z\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = ( nz2 - nz1 + 1 ) * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , nz2 - nz1 + 1 write ( unit = Unit_VTK_Append , iostat = E_IO )( Z ( n1 ), n1 = nz1 , nz2 ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Coordinates>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_RECT_R8 function VTK_GEO_XML_RECT_R4 ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = RectilinearGrid (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: nx1 , nx2 ! initial and final nodes of x axis integer ( I4P ), intent ( IN ) :: ny1 , ny2 ! initial and final nodes of y axis integer ( I4P ), intent ( IN ) :: nz1 , nz2 ! initial and final nodes of z axis real ( R4P ), intent ( IN ) :: X ( nx1 : nx2 ) ! x coordinates real ( R4P ), intent ( IN ) :: Y ( ny1 : ny2 ) ! y coordinates real ( R4P ), intent ( IN ) :: Z ( nz1 : nz2 ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Coordinates>' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Float32\" Name=\"X\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO )( X ( n1 ), n1 = nx1 , nx2 ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Float32\" Name=\"Y\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO )( Y ( n1 ), n1 = ny1 , ny2 ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Float32\" Name=\"Z\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO )( Z ( n1 ), n1 = nz1 , nz2 ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Coordinates>' case ( f_out_binary ) write ( s_buffer , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<Coordinates>' // end_rec indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"X\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = ( nx2 - nx1 + 1 ) * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , nx2 - nx1 + 1 write ( unit = Unit_VTK_Append , iostat = E_IO )( X ( n1 ), n1 = nx1 , nx2 ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"Y\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = ( ny2 - ny1 + 1 ) * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , ny2 - ny1 + 1 write ( unit = Unit_VTK_Append , iostat = E_IO )( Y ( n1 ), n1 = ny1 , ny2 ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"Z\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = ( nz2 - nz1 + 1 ) * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , nz2 - nz1 + 1 write ( unit = Unit_VTK_Append , iostat = E_IO )( Z ( n1 ), n1 = nz1 , nz2 ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Coordinates>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_RECT_R4 function VTK_GEO_XML_UNST_R8 ( NN , NC , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = UnstructuredGrid (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NN ! number of nodes integer ( I4P ), intent ( IN ) :: NC ! number of cells real ( R8P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates real ( R8P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates real ( R8P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A,' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<Piece NumberOfPoints=\"' , & NN , & '\" NumberOfCells=\"' , & NC , & '\">' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Point\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FR8P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' case ( f_out_binary ) write ( s_buffer , fmt = '(A,' // FI4P // ',A,' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<Piece NumberOfPoints=\"' , & NN , & '\" NumberOfCells=\"' , & NC , & '\">' indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' // end_rec indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Point\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NN * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , 3 * NN write ( unit = Unit_VTK_Append , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_UNST_R8 function VTK_GEO_XML_UNST_R4 ( NN , NC , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = UnstructuredGrid (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NN ! number of nodes integer ( I4P ), intent ( IN ) :: NC ! number of cells real ( R4P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates real ( R4P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates real ( R4P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A,' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<Piece NumberOfPoints=\"' , & NN , & '\" NumberOfCells=\"' , & NC , & '\">' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Point\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FR4P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' case ( f_out_binary ) write ( s_buffer , fmt = '(A,' // FI4P // ',A,' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<Piece NumberOfPoints=\"' , & NN , & '\" NumberOfCells=\"' , & NC , & '\">' indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' // end_rec indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Point\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NN * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , 3 * NN write ( unit = Unit_VTK_Append , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_UNST_R4 function VTK_GEO_XML_CLOSEP () result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for closing mesh block data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- indent = indent - 2 select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Piece>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Piece>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_CLOSEP !(doc/)skippedblock function VTK_CON_XML ( NC , connect , offset , cell_type ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!This function \\MaiuscolettoBS{must} be used when unstructured grid is used. It saves the connectivity of the unstructured mesh. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC ! number of cells integer ( I4P ), intent ( IN ) :: connect (:) ! mesh connectivity integer ( I4P ), intent ( IN ) :: offset ( 1 : NC ) ! cell offset integer ( I1P ), intent ( IN ) :: cell_type ( 1 : NC ) ! VTK cell type integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !!The VTK\\_CON\\_XML variables have the following meaning: !! !!\\begin{description} !! \\item[{\\color{RoyalBlue}NCelle}] indicates the number of all cells. !! \\item[{\\color{RoyalBlue}connect}] contains the connectivity of the mesh. It is a vector. !! \\item[{\\color{RoyalBlue}offset}] contains the offset\\footnote{The summ of nodes of all previous cells included the !!                                  current cell.} of every cells. It is a vector of $[1:NCelle]$. !! \\item[{\\color{RoyalBlue}tipo}] contains the type of every cells. It is a vector of $[1:NCelle]$. !! \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling. !!\\end{description} !! !!The vector \\MaiuscolettoBS{connect} must follow the VTK XML standard. It is passed as \\MaiuscolettoBS{assumed-shape} !!array because its dimensions is related to the mesh dimensions in a complex way. Its dimensions can be calculated by !!the following equation: !! !!\\begin{equation} !!dc = \\sum\\limits_{i = 1}&#94;{NCelle} {nvertex_i } !!\\label{eq:xml connectivity dimensions} !!\\end{equation} !! !!\\noindent where $dc$ is connectivity vector dimension and $nvertex_i$ is the number of vertices of $i&#94;{th}$ cell. !!Note that this equation is different from the legacy one (eq. \\ref{eq:connectivity dimensions}). The XML connectivity !!convention is quite different from the legacy standard. As an example considering the same mesh of section \\ref{sec:VTKCON}: !!suppose we have a mesh composed by 2 cells, one hexahedron (8 vertices) and one pyramid with square basis (5 vertices); !!suppose that the basis of pyramid is constitute by a face of the hexahedron and so the two cells share 4 vertices. The !!equation \\ref{eq:xml connectivity dimensions} gives $dc=8+5=13$; the connectivity vector for this mesh can be: !! !!\\begin{boxred}{Connectivity vector example for VTK XML standard} !!\\begin{verbatim} !!! first cell !!connect(1)  = 0  => identification flag of 1° vertex of 1° cell !!connect(2)  = 1  => identification flag of 2° vertex of 1° cell !!connect(3)  = 2  => identification flag of 3° vertex of 1° cell !!connect(4)  = 3  => identification flag of 4° vertex of 1° cell !!connect(5)  = 4  => identification flag of 5° vertex of 1° cell !!connect(6)  = 5  => identification flag of 6° vertex of 1° cell !!connect(7)  = 6  => identification flag of 7° vertex of 1° cell !!connect(8)  = 7  => identification flag of 8° vertex of 1° cell !!! second cell !!connect(9)  = 0  => identification flag of 1° vertex of 2° cell !!connect(10) = 1  => identification flag of 2° vertex of 2° cell !!connect(11) = 2  => identification flag of 3° vertex of 2° cell !!connect(12) = 3  => identification flag of 4° vertex of 2° cell !!connect(13) = 8  => identification flag of 5° vertex of 2° cell !!\\end{verbatim} !!\\end{boxred} !! !!Therefore this connectivity vector convention is more simple than the legacy convention, now we must create also the !!\\MaiuscolettoBS{offset} vector that contains the data now missing in the \\MaiuscolettoBS{connect} vector. The offset !!vector for this mesh can be: !! !!\\begin{boxred}{Offset vector example for VTK XML standard} !!\\begin{verbatim} !!! first cell !!offset(1) = 8  => summ of nodes of 1° cell !!! second cell !!offset(2) = 13 => summ of nodes of 1° and 2° cells !!\\end{verbatim} !!\\end{boxred} !! !!\\noindent The value of every cell-offset can be calculated by the following equation: !! !!\\begin{equation} !!offset_c = \\sum\\limits_{i = 1}&#94;{c} {nvertex_i } !!\\label{eq:xml offset vlue} !!\\end{equation} !! !!\\noindent where $offset_c$ is the value of $c&#94;{th}$ cell and $nvertex_i$ is the number of vertices of $i&#94;{th}$ cell. !! !!The function VTK\\_CON\\_XML does not calculate the connectivity and offset vectors: it writes the connectivity and offset !!vectors conforming the VTK XML standard, but does not calculate them. In the future release of \\LIBVTKIO will be included !!a function to calculate the connectivity and offset vector. !! !!The vector variable \\MaiuscolettoBS{tipo} must conform the VTK XML standard \\footnote{See the file VTK-Standard at the !!Kitware homepage.} that is the same of the legacy standard presented previous (sec. \\ref{sec:VTKCON}). It contains the !!\\emph{type} of each cells. For the above example this vector is: !! !!\\begin{boxred}{Cell-Type vector example for VTK legacy standard} !!\\begin{verbatim} !!tipo(1) = 12  => VTK hexahedron type of 1° cell !!tipo(2) = 14  => VTK pyramid type of 2° cell !!\\end{verbatim} !!\\end{boxred} !! !!The following is an example of VTK\\_CON\\_XML calling: !! !!\\begin{boxred}{VTK\\_CON\\_XML Calling} !!\\begin{verbatim} !!... !!integer(4), parameter:: NCelle=2 !!integer(4), parameter:: Nvertex1=8 !!integer(4), parameter:: Nvertex2=5 !!integer(4), parameter:: dc=Nvertex1+Nvertex2 !!integer(4)::            connect(1:dc) !!integer(4)::            offset(1:NCelle) !!integer(4)::            tipo(1:NCelle) !!... !!E_IO = VTK_CON_XML(NCelle,connect,offset,tipo) !!... !!\\end{verbatim} !!\\end{boxred} !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Cells>' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FI4P , iostat = E_IO )( connect ( n1 ), n1 = 1 , size ( connect )) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FI4P , iostat = E_IO )( offset ( n1 ), n1 = 1 , NC ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Int8\" Name=\"types\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FI1P , iostat = E_IO )( cell_type ( n1 ), n1 = 1 , NC ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Cells>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<Cells>' // end_rec indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"connectivity\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = size ( connect ) * sizeof ( Tipo_I4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I4' , size ( connect ) write ( unit = Unit_VTK_Append , iostat = E_IO )( connect ( n1 ), n1 = 1 , size ( connect )) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"offsets\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC * sizeof ( Tipo_I4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I4' , NC write ( unit = Unit_VTK_Append , iostat = E_IO )( offset ( n1 ), n1 = 1 , NC ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int8\" Name=\"types\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC * sizeof ( Tipo_I1 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I1' , NC write ( unit = Unit_VTK_Append , iostat = E_IO )( cell_type ( n1 ), n1 = 1 , NC ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Cells>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_CON_XML function VTK_DAT_XML ( var_location , var_block_action ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!This function \\MaiuscolettoBS{must} be called before saving the data related to geometric mesh. This function initializes !!the saving of data variables indicating the \\emph{type} of variables that will be saved. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: var_location ! location of saving variables: CELL for cell-centered, NODE for node-centered character ( * ), intent ( IN ) :: var_block_action ! variables block action: OPEN or CLOSE block integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !!The VTK\\_DAT\\_XML variables have the following meaning: !! !!\\begin{description} !!\\item[{\\color{RoyalBlue}var\\_location}] contains the location-type of variables that will be saved after VTK\\_DAT. !!It is a scalar and cab assume the following values: !! \\begin{enumerateABlu} !!  \\item \\emph{cell} (it is case insensitive) $\\rightarrow$ variables will be cell-centered. !!  \\item \\emph{node} (it is case insensitive) $\\rightarrow$ variables will be node-centered. !! \\end{enumerateABlu} !! \\item[{\\color{RoyalBlue}var\\_block\\_action}] indicates if the block-data-variables is being opened or closed; it can !!                                              assume the following values: !! \\begin{enumerateABlu} !!  \\item \\emph{open}  (it is case insensitive) $\\rightarrow$ block-data is being opened. !!  \\item \\emph{close} (it is case insensitive) $\\rightarrow$ block-data is being closed. !! \\end{enumerateABlu} !! \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling. !!\\end{description} !! !!Of course a single file can contain both cell and node centered variables. The \\MaiuscolettoBS{VTK\\_DAT\\_XML} must be !!called two times, before saving a block-data-variables in order to open the block, and after the block-data-variables !!has been saved in order to close the block. XML file can contains as many blocks as you want. !! !!The following is an example of VTK\\_DAT\\_XML calling: !! !!\\begin{boxred}{VTK\\_DAT\\_XML Calling} !!\\begin{verbatim} !!... !!E_IO = VTK_DAT_XML('node','OPEN') !!... !!SAVE YOUR DATA WITH VTK_VAR_XML !!... !!E_IO = VTK_DAT_XML('node','CLOSE') !!... !!\\end{verbatim} !!\\end{boxred} !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) select case ( trim ( Upper_Case ( var_location ))) case ( 'CELL' ) select case ( trim ( Upper_Case ( var_block_action ))) case ( 'OPEN' ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<CellData>' indent = indent + 2 case ( 'CLOSE' ) indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</CellData>' endselect case ( 'NODE' ) select case ( trim ( Upper_Case ( var_block_action ))) case ( 'OPEN' ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<PointData>' indent = indent + 2 case ( 'CLOSE' ) indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</PointData>' endselect endselect case ( f_out_binary ) select case ( trim ( Upper_Case ( var_location ))) case ( 'CELL' ) select case ( trim ( Upper_Case ( var_block_action ))) case ( 'OPEN' ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<CellData>' // end_rec indent = indent + 2 case ( 'CLOSE' ) indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</CellData>' // end_rec endselect case ( 'NODE' ) select case ( trim ( Upper_Case ( var_block_action ))) case ( 'OPEN' ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<PointData>' // end_rec indent = indent + 2 case ( 'CLOSE' ) indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</PointData>' // end_rec endselect endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_DAT_XML !(doc)INCLUDE{/home/szaghi/VTK_IO/LIB_VTK_IO/source/DOC_VTK_VAR_XML.doc} !(\\doc)skippedblock function VTK_VAR_XML_SCAL_R8 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving scalar variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name real ( R8P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO )( var ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC_NN * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( var ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_R8 function VTK_VAR_XML_SCAL_R4 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving scalar variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name real ( R4P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO ) var write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC_NN * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( var ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_R4 function VTK_VAR_XML_SCAL_I8 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving scalar variable (I8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I8P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FI8P , iostat = E_IO ) var write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC_NN * sizeof ( Tipo_I8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I8' , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( var ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_I8 function VTK_VAR_XML_SCAL_I4 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving scalar variable (I4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I4P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FI4P , iostat = E_IO ) var write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC_NN * sizeof ( Tipo_I4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I4' , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( var ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_I4 function VTK_VAR_XML_SCAL_I2 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving scalar variable (I2P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I2P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int16\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FI2P , iostat = E_IO ) var write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int16\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC_NN * sizeof ( Tipo_I2 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I2' , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( var ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_I2 function VTK_VAR_XML_SCAL_I1 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving scalar variable (I1P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I1P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int8\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FI1P , iostat = E_IO ) var write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int8\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC_NN * sizeof ( Tipo_I1 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I1' , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( var ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_I1 function VTK_VAR_XML_VECT_R8 ( NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving vectorial variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name real ( R8P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component real ( R8P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component real ( R8P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FR8P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NC_NN * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , 3 * NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_R8 function VTK_VAR_XML_VECT_R4 ( NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving vectorial variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name real ( R4P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component real ( R4P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component real ( R4P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FR4P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NC_NN * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , 3 * NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_R4 function VTK_VAR_XML_VECT_I8 ( NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving vectorial variable (I8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I8P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component integer ( I8P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component integer ( I8P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FI8P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NC_NN * sizeof ( Tipo_I8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I8' , 3 * NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_I8 function VTK_VAR_XML_VECT_I4 ( NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving vectorial variable (I4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I4P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component integer ( I4P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component integer ( I4P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FI4P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NC_NN * sizeof ( Tipo_I4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I4' , 3 * NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_I4 function VTK_VAR_XML_VECT_I2 ( NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving vectorial variable (I2P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I2P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component integer ( I2P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component integer ( I2P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int16\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FI2P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int16\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NC_NN * sizeof ( Tipo_I2 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I2' , 3 * NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_I2 function VTK_VAR_XML_VECT_I1 ( NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving vectorial variable (I1P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I1P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component integer ( I1P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component integer ( I1P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int8\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FI1P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int8\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NC_NN * sizeof ( Tipo_I1 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I1' , 3 * NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_I1 function VTK_VAR_XML_LIST_R8 ( NC_NN , N_COL , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving list variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes integer ( I4P ), intent ( IN ) :: N_COL ! number of columns character ( * ), intent ( IN ) :: varname ! variable name real ( R8P ), intent ( IN ) :: var ( 1 : NC_NN , 1 : N_COL ) ! components integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 , n2 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"ascii\">' do n1 = 1 , NC_NN write ( unit = Unit_VTK , fmt = '(' // FR8P // ')' , iostat = E_IO ) ( var ( n1 , n2 ), n2 = 1 , N_COL ) enddo write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), '\">' // & end_rec N_Byte = N_COL * NC_NN * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , N_COL * NC_NN do n1 = 1 , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO ) var ( n1 ,:) enddo write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_R8 function VTK_VAR_XML_LIST_R4 ( NC_NN , N_COL , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving list variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes integer ( I4P ), intent ( IN ) :: N_COL ! number of columns character ( * ), intent ( IN ) :: varname ! variable name real ( R4P ), intent ( IN ) :: var ( 1 : NC_NN , 1 : N_COL ) ! components integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 , n2 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"ascii\">' do n1 = 1 , NC_NN write ( unit = Unit_VTK , fmt = '(' // FR4P // ')' , iostat = E_IO ) ( var ( n1 , n2 ), n2 = 1 , N_COL ) enddo write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), '\">' // & end_rec N_Byte = N_COL * NC_NN * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , N_COL * NC_NN do n1 = 1 , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO ) var ( n1 ,:) enddo write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_R4 function VTK_VAR_XML_LIST_I8 ( NC_NN , N_COL , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving list variable (I8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes integer ( I4P ), intent ( IN ) :: N_COL ! number of columns character ( * ), intent ( IN ) :: varname ! variable name integer ( I8P ), intent ( IN ) :: var ( 1 : NC_NN , 1 : N_COL ) ! components integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 , n2 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"ascii\">' do n1 = 1 , NC_NN write ( unit = Unit_VTK , fmt = '(' // FI8P // ')' , iostat = E_IO ) ( var ( n1 , n2 ), n2 = 1 , N_COL ) enddo write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // end_rec N_Byte = N_COL * NC_NN * sizeof ( Tipo_I8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I8' , N_COL * NC_NN do n1 = 1 , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO ) var ( n1 ,:) enddo write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_I8 function VTK_VAR_XML_LIST_I4 ( NC_NN , N_COL , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving list variable (I4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes integer ( I4P ), intent ( IN ) :: N_COL ! number of columns character ( * ), intent ( IN ) :: varname ! variable name integer ( I4P ), intent ( IN ) :: var ( 1 : NC_NN , 1 : N_COL ) ! components integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 , n2 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"ascii\">' do n1 = 1 , NC_NN write ( unit = Unit_VTK , fmt = '(' // FI4P // ')' , iostat = E_IO ) ( var ( n1 , n2 ), n2 = 1 , N_COL ) enddo write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // end_rec N_Byte = N_COL * NC_NN * sizeof ( Tipo_I4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I4' , N_COL * NC_NN do n1 = 1 , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO ) var ( n1 ,:) enddo write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_I4 function VTK_VAR_XML_LIST_I2 ( NC_NN , N_COL , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving list variable (I2P). !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes integer ( I4P ), intent ( IN ) :: N_COL ! number of columns character ( * ), intent ( IN ) :: varname ! variable name integer ( I2P ), intent ( IN ) :: var ( 1 : NC_NN , 1 : N_COL ) ! components integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 , n2 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int16\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"ascii\">' do n1 = 1 , NC_NN write ( unit = Unit_VTK , fmt = '(' // FI2P // ')' , iostat = E_IO ) ( var ( n1 , n2 ), n2 = 1 , N_COL ) enddo write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int16\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // end_rec N_Byte = N_COL * NC_NN * sizeof ( Tipo_I2 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I2' , N_COL * NC_NN do n1 = 1 , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO ) var ( n1 ,:) enddo write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction function VTK_VAR_XML_LIST_I1 ( NC_NN , N_COL , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving list variable (I1P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes integer ( I4P ), intent ( IN ) :: N_COL ! number of columns character ( * ), intent ( IN ) :: varname ! variable name integer ( I1P ), intent ( IN ) :: var ( 1 : NC_NN , 1 : N_COL ) ! components integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 , n2 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int8\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"ascii\">' do n1 = 1 , NC_NN write ( unit = Unit_VTK , fmt = '(' // FI1P // ')' , iostat = E_IO ) ( var ( n1 , n2 ), n2 = 1 , N_COL ) enddo write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int8\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // end_rec N_Byte = N_COL * NC_NN * sizeof ( Tipo_I1 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I1' , N_COL * NC_NN do n1 = 1 , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO ) var ( n1 ,:) enddo write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_I1 !(doc/)skippedblock function VTK_END_XML () result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!This function is used to finalize the file opened. The \\LIBVTKIO manages the file unit without the user's action. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( 2 ) :: var_type ! var\\_type = R8,R4,I8,I4,I2,I1 real ( R8P ), allocatable :: v_R8 (:) ! R8 vector for IO in AppendData real ( R4P ), allocatable :: v_R4 (:) ! R4 vector for IO in AppendData integer ( I8P ), allocatable :: v_I8 (:) ! I8 vector for IO in AppendData integer ( I4P ), allocatable :: v_I4 (:) ! I4 vector for IO in AppendData integer ( I2P ), allocatable :: v_I2 (:) ! I2 vector for IO in AppendData integer ( I1P ), allocatable :: v_I1 (:) ! I1 vector for IO in AppendData integer ( I4P ) :: N_v ! vector dimension integer ( I4P ) :: n1 ! counter !!The following is an example of VTK\\_END\\_XML calling: !! !!\\begin{boxred}{VTK\\_END\\_XML Calling} !!\\begin{verbatim} !!... !!E_IO = VTK_END_XML() !!... !!\\end{verbatim} !!\\end{boxred} !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</' // trim ( topology ) // '>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) '</VTKFile>' case ( f_out_binary ) indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</' // trim ( topology ) // '>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<AppendedData encoding=\"raw\">' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) '_' endfile ( unit = Unit_VTK_Append , iostat = E_IO ) rewind ( unit = Unit_VTK_Append , iostat = E_IO ) do read ( unit = Unit_VTK_Append , iostat = E_IO , end = 100 ) N_Byte , var_type , N_v select case ( var_type ) case ( 'R8' ) allocate ( v_R8 ( 1 : N_v )) read ( unit = Unit_VTK_Append , iostat = E_IO )( v_R8 ( n1 ), n1 = 1 , N_v ) write ( unit = Unit_VTK , iostat = E_IO ) N_Byte ,( v_R8 ( n1 ), n1 = 1 , N_v ) deallocate ( v_R8 ) case ( 'R4' ) allocate ( v_R4 ( 1 : N_v )) read ( unit = Unit_VTK_Append , iostat = E_IO )( v_R4 ( n1 ), n1 = 1 , N_v ) write ( unit = Unit_VTK , iostat = E_IO ) N_Byte ,( v_R4 ( n1 ), n1 = 1 , N_v ) deallocate ( v_R4 ) case ( 'I8' ) allocate ( v_I8 ( 1 : N_v )) read ( unit = Unit_VTK_Append , iostat = E_IO )( v_I8 ( n1 ), n1 = 1 , N_v ) write ( unit = Unit_VTK , iostat = E_IO ) N_Byte ,( v_I8 ( n1 ), n1 = 1 , N_v ) deallocate ( v_I8 ) case ( 'I4' ) allocate ( v_I4 ( 1 : N_v )) read ( unit = Unit_VTK_Append , iostat = E_IO )( v_I4 ( n1 ), n1 = 1 , N_v ) write ( unit = Unit_VTK , iostat = E_IO ) N_Byte ,( v_I4 ( n1 ), n1 = 1 , N_v ) deallocate ( v_I4 ) case ( 'I2' ) allocate ( v_I2 ( 1 : N_v )) read ( unit = Unit_VTK_Append , iostat = E_IO )( v_I2 ( n1 ), n1 = 1 , N_v ) write ( unit = Unit_VTK , iostat = E_IO ) N_Byte ,( v_I2 ( n1 ), n1 = 1 , N_v ) deallocate ( v_I2 ) case ( 'I1' ) allocate ( v_I1 ( 1 : N_v )) read ( unit = Unit_VTK_Append , iostat = E_IO )( v_I1 ( n1 ), n1 = 1 , N_v ) write ( unit = Unit_VTK , iostat = E_IO ) N_Byte ,( v_I1 ( n1 ), n1 = 1 , N_v ) deallocate ( v_I1 ) case default E_IO = 1 write ( 6 , \"(' N_Byte =', I10, ' N_v =', I10)\" ) N_Byte , N_v write ( 6 , \"(' var1 =', I10, ' var2 =', I10)\" ) ichar ( var_type ( 1 : 1 )), ichar ( var_type ( 2 : 2 )) write ( 6 , '(A)' ) 'bad var_type' return endselect enddo 100 continue write ( unit = Unit_VTK , iostat = E_IO ) end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</AppendedData>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) '</VTKFile>' // end_rec ! closing AppendData file close ( unit = Unit_VTK_Append , iostat = E_IO ) endselect close ( unit = Unit_VTK , iostat = E_IO ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_END_XML ! VTM wrapper function VTM_INI_XML ( filename ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!The VTK_VTM_XML function is used for initializing a VTM (VTK Multiblocks) XML file that is a wrapper to a set of VTK XML files. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: filename ! file name integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Unit_VTM = GetUnit () open ( unit = Unit_VTM , & file = trim ( filename ), & form = 'FORMATTED' , & access = 'SEQUENTIAL' , & action = 'WRITE' , & iostat = E_IO ) write ( unit = Unit_VTM , fmt = '(A)' , iostat = E_IO ) '<?xml version=\"1.0\"?>' write ( unit = Unit_VTM , fmt = '(A)' , iostat = E_IO ) '<VTKFile type=\"vtkMultiBlockDataSet\" version=\"1.0\"' // & ' byte_order=\"BigEndian\" compressor=\"vtkZLibDataCompressor\">' vtm_indent = 2 write ( unit = Unit_VTM , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm_indent ) // '<vtkMultiBlockDataSet>' vtm_indent = vtm_indent + 2 blk = - 1 return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTM_INI_XML function VTM_BLK_XML ( block_action ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!The VTM_BLK_XML function is used for opening or closing a block level of a VTM file. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: block_action ! block action: OPEN or CLOSE block integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( Upper_Case ( block_action ))) case ( 'OPEN' ) blk = blk + 1 write ( unit = Unit_VTM , fmt = '(A,I4.4,A)' , iostat = E_IO ) repeat ( ' ' , vtm_indent ) // '<Block index=\"' , blk , '\">' vtm_indent = vtm_indent + 2 case ( 'CLOSE' ) vtm_indent = vtm_indent - 2 write ( unit = Unit_VTM , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm_indent ) // '</Block>' endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTM_BLK_XML function VTM_WRF_XML ( wrf_dir , vtk_xml_file_list ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!The VTM_WRF_XML function is used for saving the list of VTK XML wrapped files by the actual block of the mutliblock VTM file. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ), optional :: wrf_dir ! directory into which wrapped VTK XML are (optional) character ( * ), intent ( IN ) :: vtk_xml_file_list (:) ! list of VTK XML wrapped files integer ( I4P ) :: E_IO ! Input/Output inquiring flag: 0 if IO is done, > 0 if IO is not done integer ( I4P ) :: f ! file counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( wrf_dir )) then do f = 1 , size ( vtk_xml_file_list ) write ( unit = Unit_VTM , fmt = '(A,I3.3,A)' , iostat = E_IO ) repeat ( ' ' , vtm_indent ) // & '<DataSet index=\"' , f - 1 , '\" file=\"' // & adjustl ( trim ( wrf_dir )) // adjustl ( trim ( vtk_xml_file_list ( f ))) // & '\"></DataSet>' enddo else do f = 1 , size ( vtk_xml_file_list ) write ( unit = Unit_VTM , fmt = '(A,I3.3,A)' , iostat = E_IO ) repeat ( ' ' , vtm_indent ) // & '<DataSet index=\"' , f - 1 , '\" file=\"' // & adjustl ( trim ( vtk_xml_file_list ( f ))) // & '\"></DataSet>' enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTM_WRF_XML function VTM_END_XML () result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!This function is used to finalize the VTM file opened. The \\LIBVTKIO manages the file unit without the user's action. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- vtm_indent = vtm_indent - 2 write ( unit = Unit_VTM , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm_indent ) // '</vtkMultiBlockDataSet>' write ( unit = Unit_VTM , fmt = '(A)' , iostat = E_IO ) '</VTKFile>' close ( unit = Unit_VTM ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTM_END_XML endmodule VTK !(doc)INCLUDE{/home/szaghi/VTK_IO/LIB_VTK_IO/source/DOC_Footer.doc}","loc":"sourcefile/mod_vtk.f90.html"},{"tags":"","title":"main.f90 – MUSST","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~main.f90->sourcefile~mod_solver.f90 sourcefile~mod_num_par.f90 mod_num_par.f90 sourcefile~main.f90->sourcefile~mod_num_par.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~main.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_solver.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_num_par.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_surfile.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~mod_data.f90 mod_data.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_data.f90 sourcefile~mod_solver.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_gen_par.f90 mod_gen_par.f90 sourcefile~mod_solver.f90->sourcefile~mod_gen_par.f90 sourcefile~superlu.f90 superlu.f90 sourcefile~mod_solver.f90->sourcefile~superlu.f90 sourcefile~dmumps_struc.f90 dmumps_struc.f90 sourcefile~mod_solver.f90->sourcefile~dmumps_struc.f90 sourcefile~umfpack.f90 umfpack.f90 sourcefile~mod_solver.f90->sourcefile~umfpack.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_num_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_num_par.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_surfile.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_data.f90 sourcefile~mod_bspline.f90 mod_bspline.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_bspline.f90 sourcefile~mod_mesh.f90 mod_mesh.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_mesh.f90 sourcefile~mod_fluid.f90 mod_fluid.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_fluid.f90 sourcefile~mod_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_film.f90->sourcefile~mod_num_par.f90 sourcefile~mod_film.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_film.f90->sourcefile~mod_surfile.f90 sourcefile~mod_film.f90->sourcefile~mod_data.f90 sourcefile~mod_elements.f90 mod_elements.f90 sourcefile~mod_film.f90->sourcefile~mod_elements.f90 sourcefile~mod_film.f90->sourcefile~mod_mesh.f90 sourcefile~mod_film.f90->sourcefile~mod_fluid.f90 sourcefile~mod_gen_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_surfile.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_surfile.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_surfile.f90 sourcefile~mod_vtk.f90 mod_vtk.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_vtk.f90 sourcefile~mod_data.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_data.f90->sourcefile~mod_fluid.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_ir_vtk.f90 mod_ir_vtk.f90 sourcefile~mod_vtk.f90->sourcefile~mod_ir_vtk.f90 sourcefile~mod_elements.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_mesh.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_fluid.f90->sourcefile~mod_data_arch.f90 var pansourcefilemainf90EfferentGraph = svgPanZoom('#sourcefilemainf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs main Source Code main.f90 Source Code !! author: Noël Brunetière<br/>&emsp;Arthur Francisco !! version: 1.0.0 !! date: April,17 2017 !! summary: main program to run MUSST on a configuration file !< <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<       **Subroutine to run a test with MUSST** !< </span> program main use omp_lib use test_musst use data_arch , only : I4 , NB_THREADS_MAX , OUT_U => OPU , get_unit use num_param , only : VERBOSE , OUTPUT_FILE , OPU use solver , only : SOLVER_BS , SOLVER_TS , SOLV_MESS implicit none character ( len = 128 ) :: prg_arg character ( len = 128 ) :: job_file character ( len = 8 ) :: date character ( len = 10 ) :: time character ( len = 15 ) :: repos integer ( kind = I4 ) :: archive ! a result directory is created under \"/out\" with the date as name ! ---------------------------------------------------------------- call date_and_time ( date , time ) repos = date // '_' // time ( 1 : 6 ) call execute_command_line ( \"mkdir out/\" // repos , wait = . true .) ! the job file is the program argument ! ------------------------------------ prg_arg = repeat ( ' ' , len ( prg_arg )) job_file = repeat ( ' ' , len ( job_file )) call get_command_argument ( 1 , prg_arg ) ! argument one: job file if ( len_trim ( prg_arg ) == 0 ) then ! if there is no job file, stop stop 'no job file, stop' else job_file = trim ( adjustl ( prg_arg )) endif ! the job file is copied in the result directory ! ---------------------------------------------- call execute_command_line ( \"cp \" // trim ( job_file ) // \" out/\" // repos , wait = . true .) ! the job file is processed ! ------------------------- call read_config call run_test if ( OPU /= OUT_U ) close ( OPU ) stop contains subroutine read_config () implicit none integer ( kind = I4 ) :: jf , err_read character ( len = 032 ) :: word character ( len = 128 ) :: job_copy job_copy = \"out/\" // repos // job_file ( 4 : len_trim ( job_file )) VERBOSE = 20 SOLV_MESS = 0 OPU = 0 OUTPUT_FILE = \"no_file\" SOLVER_BS = 3 SOLVER_TS = 2 NB_THREADS_MAX = - 1 archive = 0 test_num = 0 call get_unit ( jf ) ; open ( jf , file = trim ( job_file ), status = 'old' ) do word = repeat ( ' ' , len ( word )) read ( jf , * , iostat = err_read ) word if ( index ( word , 'END_FILE' ) /= 0 ) exit if ( index ( word , 'VERBOSE' ) /= 0 ) then read ( jf , * ) VERBOSE endif if ( index ( word , 'SOLV_MESS' ) /= 0 ) then read ( jf , * ) SOLV_MESS endif if ( index ( word , 'OUTPUT_UNIT' ) /= 0 ) then read ( jf , * ) OPU if ( OPU == 0 ) then OPU = OUT_U else read ( jf , * ) OUTPUT_FILE call get_unit ( OPU ) open ( unit = OPU , & file = \"out/\" // repos // \"/\" // trim ( adjustl ( OUTPUT_FILE )), & status = 'unknown' ) endif endif if ( index ( word , 'SOLVER_BS' ) /= 0 ) then read ( jf , * ) SOLVER_BS if ( SOLVER_BS == 1 ) stop \"some remaining problems with SuLU, choose '3' instead\" if ( SOLVER_BS == 2 ) stop \"MUMPS is multithreaded, it is designed for TS, choose '3' instead\" endif if ( index ( word , 'SOLVER_TS' ) /= 0 ) then read ( jf , * ) SOLVER_TS endif if ( index ( word , 'PROBLEM_TYPE' ) /= 0 ) then read ( jf , * ) test_num endif if ( index ( word , 'PARAM_MUSST' ) /= 0 ) then call read_data ( jf , repos ) endif if ( index ( word , 'NB_THREADS_MAX' ) /= 0 ) then read ( jf , * ) NB_THREADS_MAX if ( NB_THREADS_MAX < 0 ) then !$ NB_THREADS_MAX = omp_get_num_procs() endif endif if ( index ( word , 'ARCHIVE' ) /= 0 ) then read ( jf , * ) archive if ( ARCHIVE == 1 ) then call execute_command_line ( \"sh bin/save/save.sh\" , wait = . true .) call execute_command_line ( \"mv *.7z out/\" // repos // \"/\" ) endif endif enddo close ( jf ) return endsubroutine read_config endprogram main","loc":"sourcefile/main.f90.html"},{"tags":"","title":"mod_elements.f90 – MUSST","text":"This file depends on sourcefile~~mod_elements.f90~~EfferentGraph sourcefile~mod_elements.f90 mod_elements.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_elements.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_elements.f90~~AfferentGraph sourcefile~mod_elements.f90 mod_elements.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_film.f90->sourcefile~mod_elements.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 var pansourcefilemod_elementsf90AfferentGraph = svgPanZoom('#sourcefilemod_elementsf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules elements Source Code mod_elements.f90 Source Code !! author: Noël Brunetière<br/>&emsp;Arthur Francisco !! version: 1.0.0 !! date: March, 26 2019 !< <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<       **Subroutines about the finite elements that are used** !< </span> module elements use data_arch , only : I4 , R8 , HIG_R8 implicit none private public :: ni4 , ni4_up_2d , dj4 , calc_ni4_xy_derivatives contains !========================================================================================= !< @note Standard QU4 element !  @endnote !----------------------------------------------------------------------------------------- real ( kind = R8 ) function ni4 ( numn , ksi , eta ) implicit none real ( kind = R8 ), intent ( in ) :: ksi real ( kind = R8 ), intent ( in ) :: eta integer ( kind = I4 ), intent ( in ) :: numn !! *local node number: 1->SW, 2-> SE, 3->NE, 4->NW* ni4 = HIG_R8 select case ( numn ) case ( 1 ); ni4 = ( 1._R8 - ksi ) * ( 1._R8 - eta ) / 4._R8 case ( 2 ); ni4 = ( 1._R8 + ksi ) * ( 1._R8 - eta ) / 4._R8 case ( 3 ); ni4 = ( 1._R8 + ksi ) * ( 1._R8 + eta ) / 4._R8 case ( 4 ); ni4 = ( 1._R8 - ksi ) * ( 1._R8 + eta ) / 4._R8 case default ; stop 'ni4 bad case' endselect return endfunction ni4 !========================================================================================= !< @note Up-Downwind 1D element for perfect gaz cases ! !   Instead of the standard linear 1D element, a parameter *pe* is introduced to control the !   slope. The higher *pe* the steepest curve => it can even lead to a quasi-discontinuous function. !   If *pe* is zero, then the shape functions are the standard ones. ! !   *se* is linked to the flow direction: se=1 for upwind, se=-1 for downwind. ! !   <p style=\"text-align:center;\"><img src=\"../media/up_downwind.png\" alt=\"Upwinding coeffs\" width=\"450px\"/></p> ! ! @endnote !----------------------------------------------------------------------------------------- real ( kind = R8 ) function ni4_up_1d ( numn , ksi , pe , se ) implicit none integer ( kind = I4 ), intent ( in ) :: numn !! *local node number* real ( kind = R8 ), intent ( in ) :: ksi real ( kind = R8 ), intent ( in ) :: pe !! *parameter controlling the shape function slope* real ( kind = R8 ), intent ( in ) :: se !! *+1 -> upwind, -1 -> downwind* real ( kind = R8 ) :: p , t p = ( pe + 1._R8 ) / 2 t = p * ( ksi - se ) select case ( numn ) case ( 1 ); ni4_up_1d = - t + ( 1._R8 - se ) / 2 case ( 2 ); ni4_up_1d = + t + ( 1._R8 + se ) / 2 case default ; stop 'ni4_up_1d bad case' endselect ni4_up_1d = max ( ni4_up_1d , 0._R8 ) ni4_up_1d = min ( ni4_up_1d , 1._R8 ) return endfunction ni4_up_1d !========================================================================================= !< @note Up-Downwind 2D element for perfect gaz cases ! !  @endnote !----------------------------------------------------------------------------------------- real ( kind = R8 ) function ni4_up_2d ( numn , ksi , eta , pe , se ) implicit none integer ( kind = I4 ), intent ( in ) :: numn !! *local node number* real ( kind = R8 ), intent ( in ) :: ksi real ( kind = R8 ), intent ( in ) :: eta real ( kind = R8 ), intent ( in ), dimension ( 2 ) :: pe !! *parameter controling the shape function slope for each direction* real ( kind = R8 ), intent ( in ), dimension ( 2 ) :: se !! *+1 -> upwind, -1 -> downwind, for each direction* select case ( numn ) case ( 1 ); ni4_up_2d = ni4_up_1d ( 1 , ksi , pe ( 1 ), se ( 1 )) * ni4_up_1d ( 1 , eta , pe ( 2 ), se ( 2 )) case ( 2 ); ni4_up_2d = ni4_up_1d ( 2 , ksi , pe ( 1 ), se ( 1 )) * ni4_up_1d ( 1 , eta , pe ( 2 ), se ( 2 )) case ( 3 ); ni4_up_2d = ni4_up_1d ( 2 , ksi , pe ( 1 ), se ( 1 )) * ni4_up_1d ( 2 , eta , pe ( 2 ), se ( 2 )) case ( 4 ); ni4_up_2d = ni4_up_1d ( 1 , ksi , pe ( 1 ), se ( 1 )) * ni4_up_1d ( 2 , eta , pe ( 2 ), se ( 2 )) case default ; stop 'ni4_up_2d bad case' endselect return endfunction ni4_up_2d !========================================================================================= !< @note Up-Downwind 1D element for perfect gaz cases, smooth functions !  @endnote !  @warning !    NOT USED !  @endwarning !----------------------------------------------------------------------------------------- real ( kind = R8 ) function ni_tanh_1d ( numn , ksi , pe , se ) implicit none integer ( kind = I4 ), intent ( in ) :: numn real ( kind = R8 ), intent ( in ) :: ksi real ( kind = R8 ), intent ( in ) :: pe real ( kind = R8 ), intent ( in ) :: se real ( kind = R8 ) :: tksi , x if ( se > 0. ) then x = 1._r8 - ksi else x = 1._r8 + ksi endif tksi = tanh ( pe * x ) / tanh ( 2 * pe ) select case ( numn ) case ( 1 ); ni_tanh_1d = (( 1._R8 - se ) / 2 + se * tksi ) case ( 2 ); ni_tanh_1d = (( 1._R8 + se ) / 2 - se * tksi ) case default ; stop 'ni_tanh_1d bad case' endselect return endfunction ni_tanh_1d !========================================================================================= !< @note Up-Downwind 1D element for perfect gaz cases, smooth functions !  @endnote !  @warning !    NOT USED !  @endwarning !----------------------------------------------------------------------------------------- real ( kind = R8 ) function ni_tanh_1d_der ( numn , ksi , pe , se ) implicit none integer ( kind = I4 ), intent ( in ) :: numn real ( kind = R8 ), intent ( in ) :: ksi real ( kind = R8 ), intent ( in ) :: pe real ( kind = R8 ), intent ( in ) :: se real ( kind = R8 ) :: tksi_der , tksi1 , tksi2 , x if ( se > 0. ) then x = 1._r8 - ksi else x = 1._r8 + ksi endif tksi1 = tanh ( pe * x ) tksi2 = tanh ( 2 * pe ) tksi_der = ( pe / tksi2 ) * ( 1._R8 - tksi1 ** 2 ) select case ( numn ) case ( 1 ); ni_tanh_1d_der = (( 1._R8 - se ) / 2 + se * tksi_der ) case ( 2 ); ni_tanh_1d_der = (( 1._R8 + se ) / 2 - se * tksi_der ) case default ; stop 'ni_tanh_1d_der bad case' endselect return endfunction ni_tanh_1d_der !========================================================================================= !< @note Up-Downwind 2D element for perfect gaz cases, smooth functions !  @endnote !  @warning !    NOT USED !  @endwarning !----------------------------------------------------------------------------------------- real ( kind = R8 ) function ni_tanh_2d ( numn , ksi , eta , pe , se ) implicit none integer ( kind = I4 ), intent ( in ) :: numn real ( kind = R8 ), intent ( in ) :: ksi real ( kind = R8 ), intent ( in ) :: eta real ( kind = R8 ), intent ( in ), dimension ( 2 ) :: pe real ( kind = R8 ), intent ( in ), dimension ( 2 ) :: se select case ( numn ) case ( 1 ); ni_tanh_2d = ni_tanh_1d ( 1 , ksi , pe ( 1 ), se ( 1 )) * ni_tanh_1d ( 1 , eta , pe ( 2 ), se ( 2 )) case ( 2 ); ni_tanh_2d = ni_tanh_1d ( 2 , ksi , pe ( 1 ), se ( 1 )) * ni_tanh_1d ( 1 , eta , pe ( 2 ), se ( 2 )) case ( 3 ); ni_tanh_2d = ni_tanh_1d ( 2 , ksi , pe ( 1 ), se ( 1 )) * ni_tanh_1d ( 2 , eta , pe ( 2 ), se ( 2 )) case ( 4 ); ni_tanh_2d = ni_tanh_1d ( 1 , ksi , pe ( 1 ), se ( 1 )) * ni_tanh_1d ( 2 , eta , pe ( 2 ), se ( 2 )) case default ; stop 'ni_tanh_2d bad case' endselect return endfunction ni_tanh_2d !========================================================================================= !< @note Up-Downwind 2D element for perfect gaz cases, smooth functions !  @endnote !  @warning !    NOT USED !  @endwarning !----------------------------------------------------------------------------------------- real ( kind = R8 ) function ni_tanh_2d_ksi ( numn , ksi , eta , pe , se ) implicit none integer ( kind = I4 ), intent ( in ) :: numn real ( kind = R8 ), intent ( in ) :: ksi real ( kind = R8 ), intent ( in ) :: eta real ( kind = R8 ), intent ( in ), dimension ( 2 ) :: pe real ( kind = R8 ), intent ( in ), dimension ( 2 ) :: se select case ( numn ) case ( 1 ); ni_tanh_2d_ksi = ni_tanh_1d_der ( 1 , ksi , pe ( 1 ), se ( 1 )) * ni_tanh_1d ( 1 , eta , pe ( 2 ), se ( 2 )) case ( 2 ); ni_tanh_2d_ksi = ni_tanh_1d_der ( 2 , ksi , pe ( 1 ), se ( 1 )) * ni_tanh_1d ( 1 , eta , pe ( 2 ), se ( 2 )) case ( 3 ); ni_tanh_2d_ksi = ni_tanh_1d_der ( 2 , ksi , pe ( 1 ), se ( 1 )) * ni_tanh_1d ( 2 , eta , pe ( 2 ), se ( 2 )) case ( 4 ); ni_tanh_2d_ksi = ni_tanh_1d_der ( 1 , ksi , pe ( 1 ), se ( 1 )) * ni_tanh_1d ( 2 , eta , pe ( 2 ), se ( 2 )) case default ; stop 'ni_tanh_2d bad case' endselect return endfunction ni_tanh_2d_ksi !========================================================================================= !< @note Up-Downwind 2D element for perfect gaz cases, smooth functions !  @endnote !  @warning !    NOT USED !  @endwarning !----------------------------------------------------------------------------------------- real ( kind = R8 ) function ni_tanh_2d_eta ( numn , ksi , eta , pe , se ) implicit none integer ( kind = I4 ), intent ( in ) :: numn real ( kind = R8 ), intent ( in ) :: ksi real ( kind = R8 ), intent ( in ) :: eta real ( kind = R8 ), intent ( in ), dimension ( 2 ) :: pe real ( kind = R8 ), intent ( in ), dimension ( 2 ) :: se select case ( numn ) case ( 1 ); ni_tanh_2d_eta = ni_tanh_1d ( 1 , ksi , pe ( 1 ), se ( 1 )) * ni_tanh_1d_der ( 1 , eta , pe ( 2 ), se ( 2 )) case ( 2 ); ni_tanh_2d_eta = ni_tanh_1d ( 2 , ksi , pe ( 1 ), se ( 1 )) * ni_tanh_1d_der ( 1 , eta , pe ( 2 ), se ( 2 )) case ( 3 ); ni_tanh_2d_eta = ni_tanh_1d ( 2 , ksi , pe ( 1 ), se ( 1 )) * ni_tanh_1d_der ( 2 , eta , pe ( 2 ), se ( 2 )) case ( 4 ); ni_tanh_2d_eta = ni_tanh_1d ( 1 , ksi , pe ( 1 ), se ( 1 )) * ni_tanh_1d_der ( 2 , eta , pe ( 2 ), se ( 2 )) case default ; stop 'ni_tanh_2d_eta bad case' endselect return endfunction ni_tanh_2d_eta !========================================================================================= !< @note Standard 2D element function derivatives (with respect to \\xi) !  @endnote !----------------------------------------------------------------------------------------- real ( kind = R8 ) function ni4ksi ( numn , eta ) implicit none integer ( kind = I4 ), intent ( in ) :: numn real ( kind = R8 ), intent ( in ) :: eta select case ( numn ) case ( 1 ); ni4ksi = - ( 1._R8 - eta ) / 4._R8 case ( 2 ); ni4ksi = + ( 1._R8 - eta ) / 4._R8 case ( 3 ); ni4ksi = + ( 1._R8 + eta ) / 4._R8 case ( 4 ); ni4ksi = - ( 1._R8 + eta ) / 4._R8 case default ; stop 'ni4ksi bad case' endselect return endfunction ni4ksi !========================================================================================= !< @note Standard 2D element function derivatives (with respect to \\eta) !  @endnote !----------------------------------------------------------------------------------------- real ( kind = R8 ) function ni4eta ( numn , ksi ) implicit none integer ( kind = I4 ), intent ( in ) :: numn real ( kind = R8 ), intent ( in ) :: ksi ni4eta = HIG_R8 select case ( numn ) case ( 1 ); ni4eta = - ( 1._R8 - ksi ) / 4._R8 case ( 2 ); ni4eta = - ( 1._R8 + ksi ) / 4._R8 case ( 3 ); ni4eta = + ( 1._R8 + ksi ) / 4._R8 case ( 4 ); ni4eta = + ( 1._R8 - ksi ) / 4._R8 case default ; stop 'ni4eta bad case' endselect return endfunction ni4eta !========================================================================================= !< @note Jacobian intermediate calculus ! !   *Example* !   if numn=1 j_4=\\sum_{i=1}&#94;{4} \\frac{\\partial N_i}{\\partial \\xi} x_i !  @endnote !----------------------------------------------------------------------------------------- real ( kind = R8 ) function j4 ( numn , ksi , eta , x , y ) implicit none integer ( kind = I4 ), intent ( in ) :: numn real ( kind = R8 ), intent ( in ) :: ksi real ( kind = R8 ), intent ( in ) :: eta real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: x real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: y real ( kind = R8 ) :: valint integer ( kind = I4 ) :: i valint = 0._R8 select case ( numn ) case ( 1 ) do i = 1 , 4 valint = valint + ni4ksi ( i , eta ) * x ( i ) enddo case ( 2 ) do i = 1 , 4 valint = valint + ni4ksi ( i , eta ) * y ( i ) enddo case ( 3 ) do i = 1 , 4 valint = valint + ni4eta ( i , ksi ) * x ( i ) enddo case ( 4 ) do i = 1 , 4 valint = valint + ni4eta ( i , ksi ) * y ( i ) enddo case default stop 'j4 bad case' endselect j4 = valint return endfunction j4 !========================================================================================= !< @note Jacobian calculated without calling any function, for computing speed reasons. ! !  @endnote !< @note **Maxima**, **Wxmaxima** script ! !   ```ni4_1(xi, eta):= (1. -xi)*(1. -eta)/4.$```                                                                                <br/> !   ```ni4_2(xi, eta):= (1. +xi)*(1. -eta)/4.$```                                                                                <br/> !   ```ni4_3(xi, eta):= (1. +xi)*(1. +eta)/4.$```                                                                                <br/> !   ```ni4_4(xi, eta):= (1. -xi)*(1. +eta)/4.$```                                                                                <br/> !   ```ni4xi_1(xi, eta):=diff(ni4_1(xi, eta),xi,1)$```                                                                           <br/> !   ```ni4xi_2(xi, eta):=diff(ni4_2(xi, eta),xi,1)$```                                                                           <br/> !   ```ni4xi_3(xi, eta):=diff(ni4_3(xi, eta),xi,1)$```                                                                           <br/> !   ```ni4xi_4(xi, eta):=diff(ni4_4(xi, eta),xi,1)$```                                                                           <br/> !   ```ni4eta_1(xi, eta):=diff(ni4_1(xi, eta),eta,1)$```                                                                         <br/> !   ```ni4eta_2(xi, eta):=diff(ni4_2(xi, eta),eta,1)$```                                                                         <br/> !   ```ni4eta_3(xi, eta):=diff(ni4_3(xi, eta),eta,1)$```                                                                         <br/> !   ```ni4eta_4(xi, eta):=diff(ni4_4(xi, eta),eta,1)$```                                                                         <br/> !   ```j4_1(xi, eta):=factorsum(ni4xi_1(xi, eta)*x1+ni4xi_2(xi, eta)*x2+ni4xi_3(xi, eta)*x3+ni4xi_4(xi, eta)*x4)$```             <br/> !   ```j4_1(xi, eta);```                                                                                                         <br/> !   ```j4_2(xi, eta):=factorsum(ni4xi_1(xi, eta)*y1+ni4xi_2(xi, eta)*y2+ni4xi_3(xi, eta)*y3+ni4xi_4(xi, eta)*y4)$```             <br/> !   ```j4_2(xi, eta);```                                                                                                         <br/> !   ```j4_3(xi, eta):=factorsum(ni4eta_1(xi, eta)*x1+ni4eta_2(xi, eta)*x2+ni4eta_3(xi, eta)*x3+ni4eta_4(xi, eta)*x4)$```         <br/> !   ```j4_3(xi, eta);```                                                                                                         <br/> !   ```j4_4(xi, eta):=factorsum(ni4eta_1(xi, eta)*y1+ni4eta_2(xi, eta)*y2+ni4eta_3(xi, eta)*y3+ni4eta_4(xi, eta)*y4)$```         <br/> !   ```j4_4(xi, eta);```                                                                                                         <br/> !   ```dj4(xi, eta):=factorout(j4_1(xi, eta)*j4_4(xi, eta)-j4_2(xi, eta)*j4_3(xi, eta),xi,eta)$```                               <br/> !   ```dj4(xi, eta);```                                                                                                          <br/> !   ```ni4x_1(xi,eta):=factorout(j4_4(xi, eta)*ni4xi_1(xi, eta),eta,xi) - factorout(j4_3(xi, eta)*ni4eta_1(xi, eta),xi,eta)$```  <br/> !   ```ni4x_1(xi,eta);```                                                                                                        <br/> !   ```ni4x_2(xi,eta):=factorout(j4_4(xi, eta)*ni4xi_2(xi, eta),eta,xi) - factorout(j4_3(xi, eta)*ni4eta_2(xi, eta),eta,xi)$```  <br/> !   ```ni4x_2(xi,eta);```                                                                                                        <br/> !   ```ni4x_3(xi,eta):=factorout(j4_4(xi, eta)*ni4xi_3(xi, eta),eta,xi) - factorout(j4_3(xi, eta)*ni4eta_3(xi, eta),xi,eta)$```  <br/> !   ```ni4x_3(xi,eta);```                                                                                                        <br/> !   ```ni4x_4(xi,eta):=factorout(j4_4(xi, eta)*ni4xi_4(xi, eta),eta,xi) - factorout(j4_3(xi, eta)*ni4eta_4(xi, eta),eta,xi)$```  <br/> !   ```ni4x_4(xi,eta);```                                                                                                        <br/> !   ```ni4y_1(xi,eta):=factorout(-j4_2(xi, eta)*ni4xi_1(xi, eta),eta,xi) + factorout(j4_1(xi, eta)*ni4eta_1(xi, eta),xi,eta)$``` <br/> !   ```ni4y_1(xi,eta);```                                                                                                        <br/> !   ```ni4y_2(xi,eta):=factorout(-j4_2(xi, eta)*ni4xi_2(xi, eta),eta,xi) + factorout(j4_1(xi, eta)*ni4eta_2(xi, eta),eta,xi)$``` <br/> !   ```ni4y_2(xi,eta);```                                                                                                        <br/> !   ```ni4y_3(xi,eta):=factorout(-j4_2(xi, eta)*ni4xi_3(xi, eta),eta,xi) + factorout(j4_1(xi, eta)*ni4eta_3(xi, eta),xi,eta)$``` <br/> !   ```ni4y_3(xi,eta);```                                                                                                        <br/> !   ```ni4y_4(xi,eta):=factorout(-j4_2(xi, eta)*ni4xi_4(xi, eta),eta,xi) + factorout(j4_1(xi, eta)*ni4eta_4(xi, eta),eta,xi)$``` <br/> !   ```ni4y_4(xi,eta);```                                                                                                        <br/> ! !  @endnote !----------------------------------------------------------------------------------------- real ( kind = R8 ) function dj4 ( ksi , eta , x , y ) implicit none real ( kind = R8 ), intent ( in ) :: ksi real ( kind = R8 ), intent ( in ) :: eta real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: x real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: y !~       standard calculation !~       dj4 = j4(1, ksi, eta, x, y) * j4(4, ksi, eta, x, y) - & ! !~             j4(2, ksi, eta, x, y) * j4(3, ksi, eta, x, y) real ( kind = R8 ) :: km1 , kp1 , em1 , ep1 , kme , kpe , x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4 km1 = ksi - 1._R8 kp1 = ksi + 1._R8 em1 = eta - 1._R8 ep1 = eta + 1._R8 kme = ksi - eta kpe = ksi + eta x1 = x ( 1 ) ; x2 = x ( 2 ) ; x3 = x ( 3 ) ; x4 = x ( 4 ) y1 = y ( 1 ) ; y2 = y ( 2 ) ; y3 = y ( 3 ) ; y4 = y ( 4 ) dj4 = 0.125_R8 * ( + km1 * ( x1 * y4 - x4 * y1 ) & ! + kp1 * ( x2 * y3 - x3 * y2 ) & ! - em1 * ( x1 * y2 - x2 * y1 ) & ! + ep1 * ( x3 * y4 - x4 * y3 ) & ! - kpe * ( x2 * y4 - x4 * y2 ) & ! - kme * ( x1 * y3 - x3 * y1 ) ) return endfunction dj4 !========================================================================================= !< @note QU4 derivatives with respect to x and y without any function call, for speed reasons !< !----------------------------------------------------------------------------------------- subroutine calc_ni4_xy_derivatives ( ni4x , ni4y , ksi , eta , x , y , dj ) implicit none real ( kind = R8 ), intent ( out ), dimension ( 4 ) :: ni4x real ( kind = R8 ), intent ( out ), dimension ( 4 ) :: ni4y real ( kind = R8 ), intent ( in ) :: ksi real ( kind = R8 ), intent ( in ) :: eta real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: x real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: y real ( kind = R8 ), intent ( in ) :: dj !~       standard calculation !~       ni4x = ( j4(4, ksi, eta, x, y)*ni4ksi(numn, eta) -& !~                j4(3, ksi, eta, x, y)*ni4eta(numn, ksi) )/dj4(ksi, eta, x, y) !~       ni4y = ( -j4(2, ksi, eta, x, y)*ni4ksi(numn, eta) +& !~                 j4(1, ksi, eta, x, y)*ni4eta(numn, ksi) )/dj4(ksi, eta, x, y) real ( kind = R8 ) :: km1 , kp1 , em1 , ep1 , kme , kpe , & ! x1 , x2 , x3 , x4 , & ! y1 , y2 , y3 , y4 , & ! kx , ky , ex , ey km1 = ksi - 1._R8 kp1 = ksi + 1._R8 em1 = eta - 1._R8 ep1 = eta + 1._R8 kme = ksi - eta kpe = ksi + eta x1 = x ( 1 ) ; x2 = x ( 2 ) ; x3 = x ( 3 ) ; x4 = x ( 4 ) y1 = y ( 1 ) ; y2 = y ( 2 ) ; y3 = y ( 3 ) ; y4 = y ( 4 ) kx = - km1 * x1 + kp1 * x2 - kp1 * x3 + km1 * x4 ky = - km1 * y1 + kp1 * y2 - kp1 * y3 + km1 * y4 ex = - em1 * x1 + ep1 * x2 - ep1 * x3 + em1 * x4 ey = - em1 * y1 + ep1 * y2 - ep1 * y3 + em1 * y4 ni4x ( 1 ) = 0.0625_R8 * ( + km1 * kx - em1 * ky ) / dj ni4x ( 2 ) = 0.0625_R8 * ( - kp1 * kx + em1 * ky ) / dj ni4x ( 3 ) = 0.0625_R8 * ( + kp1 * kx - ep1 * ky ) / dj ni4x ( 4 ) = 0.0625_R8 * ( - km1 * kx + ep1 * ky ) / dj kx = - km1 * x1 + km1 * x2 - kp1 * x3 + kp1 * x4 ky = - km1 * y1 + km1 * y2 - kp1 * y3 + kp1 * y4 ex = - em1 * x1 + em1 * x2 - ep1 * x3 + ep1 * x4 ey = - em1 * y1 + em1 * y2 - ep1 * y3 + ep1 * y4 ni4y ( 1 ) = 0.0625_R8 * ( - km1 * ex + em1 * ey ) / dj ni4y ( 2 ) = 0.0625_R8 * ( + kp1 * ex - em1 * ey ) / dj ni4y ( 3 ) = 0.0625_R8 * ( - kp1 * ex + ep1 * ey ) / dj ni4y ( 4 ) = 0.0625_R8 * ( + km1 * ex - ep1 * ey ) / dj return endsubroutine calc_ni4_xy_derivatives endmodule elements","loc":"sourcefile/mod_elements.f90.html"},{"tags":"","title":"mod_surfile.f90 – MUSST","text":"This file depends on sourcefile~~mod_surfile.f90~~EfferentGraph sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_surfile.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_surfile.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_surfile.f90~~AfferentGraph sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_surfile.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_surfile.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_surfile.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 sourcefile~mod_film.f90->sourcefile~mod_surfile.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 var pansourcefilemod_surfilef90AfferentGraph = svgPanZoom('#sourcefilemod_surfilef90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules surfile Source Code mod_surfile.f90 Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: july, 23 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **Routines to handle Digital Surf binary format (.sur)** !  </span> module surfile use , intrinsic :: ISO_C_BINDING , only : C_CHAR , C_NULL_CHAR , C_FLOAT , C_INT , C_SHORT use data_arch use sort_arrays , only : sort_real , sort_real_1real , sort_real_2real implicit none private !< <span style=\"color:green\">Surface object: header and heights</span> ! @note !    Adapted from 'surffile.c', 'gwyddion' software, Copyright (C) 2005 David Necas, Petr Klapetek. ! @endnote ! @warning !    Must be 512 bytes long ! @endwarning type SCALE_SURF ! bytes below: 8+10+2*12+9*16+2*30+34+128 = 408 character ( len = 12 ) :: signature character ( len = 16 ) :: xlength_unit character ( len = 16 ) :: ylength_unit character ( len = 16 ) :: zlength_unit character ( len = 16 ) :: xaxis character ( len = 16 ) :: yaxis character ( len = 16 ) :: zaxis character ( len = 16 ) :: dx_unit character ( len = 16 ) :: dy_unit character ( len = 16 ) :: dz_unit character ( len = 30 ) :: object_name character ( len = 30 ) :: operator_name character ( len = 128 ) :: client_zone character ( len = 8 ) :: reserved character ( len = 34 ) :: reservedzone character ( len = 12 ) :: obsolete character ( len = 10 ) :: obsolete2 ! bytes below: 10*4 = 40 real ( kind = R4 ) :: dx real ( kind = R4 ) :: dy real ( kind = R4 ) :: dz real ( kind = R4 ) :: xunit_ratio real ( kind = R4 ) :: yunit_ratio real ( kind = R4 ) :: zunit_ratio real ( kind = R4 ) :: XOffset real ( kind = R4 ) :: YOffset real ( kind = R4 ) :: ZOffset real ( kind = R4 ) :: measurement_duration ! bytes below: 5*4 = 20 integer ( kind = I4 ) :: zmin integer ( kind = I4 ) :: zmax integer ( kind = I4 ) :: xres integer ( kind = I4 ) :: yres integer ( kind = I4 ) :: nofpoints ! bytes below: 22*2 = 44 integer ( kind = 2 ) :: format integer ( kind = 2 ) :: version integer ( kind = 2 ) :: material_code integer ( kind = 2 ) :: type integer ( kind = 2 ) :: range integer ( kind = 2 ) :: special_points integer ( kind = 2 ) :: absolute integer ( kind = 2 ) :: pointsize integer ( kind = 2 ) :: imprint integer ( kind = 2 ) :: inversion integer ( kind = 2 ) :: leveling integer ( kind = 2 ) :: seconds integer ( kind = 2 ) :: minutes integer ( kind = 2 ) :: hours integer ( kind = 2 ) :: day integer ( kind = 2 ) :: month integer ( kind = 2 ) :: year integer ( kind = 2 ) :: dayof integer ( kind = 2 ) :: comment_size integer ( kind = 2 ) :: private_size integer ( kind = 2 ) :: nobjects integer ( kind = 2 ) :: acquisition real ( kind = R8 ) :: lx !! *surface length* real ( kind = R8 ) :: ly !! *surface width* real ( kind = R8 ) :: lz !! *surface height (max -min)* real ( kind = R8 ) :: mu !! *surface mean height* real ( kind = R8 ) :: si !! *surface mean height* endtype SCALE_SURF type OBJ_SURF ! bytes below: 8+10+2*12+9*16+2*30+34+128 = 408 character ( kind = C_CHAR ), dimension ( 12 ) :: signature character ( kind = C_CHAR ), dimension ( 16 ) :: xlength_unit character ( kind = C_CHAR ), dimension ( 16 ) :: ylength_unit character ( kind = C_CHAR ), dimension ( 16 ) :: zlength_unit character ( kind = C_CHAR ), dimension ( 16 ) :: xaxis character ( kind = C_CHAR ), dimension ( 16 ) :: yaxis character ( kind = C_CHAR ), dimension ( 16 ) :: zaxis character ( kind = C_CHAR ), dimension ( 16 ) :: dx_unit character ( kind = C_CHAR ), dimension ( 16 ) :: dy_unit character ( kind = C_CHAR ), dimension ( 16 ) :: dz_unit character ( kind = C_CHAR ), dimension ( 30 ) :: object_name character ( kind = C_CHAR ), dimension ( 30 ) :: operator_name character ( kind = C_CHAR ), dimension ( 128 ) :: client_zone character ( kind = C_CHAR ), dimension ( 8 ) :: reserved character ( kind = C_CHAR ), dimension ( 34 ) :: reservedzone character ( kind = C_CHAR ), dimension ( 12 ) :: obsolete character ( kind = C_CHAR ), dimension ( 10 ) :: obsolete2 ! bytes below: 10*4 = 40 real ( kind = C_FLOAT ) :: dx real ( kind = C_FLOAT ) :: dy real ( kind = C_FLOAT ) :: dz real ( kind = C_FLOAT ) :: xunit_ratio real ( kind = C_FLOAT ) :: yunit_ratio real ( kind = C_FLOAT ) :: zunit_ratio real ( kind = C_FLOAT ) :: XOffset real ( kind = C_FLOAT ) :: YOffset real ( kind = C_FLOAT ) :: ZOffset real ( kind = C_FLOAT ) :: measurement_duration ! bytes below: 5*4 = 20 integer ( kind = C_INT ) :: zmin integer ( kind = C_INT ) :: zmax integer ( kind = C_INT ) :: xres integer ( kind = C_INT ) :: yres integer ( kind = C_INT ) :: nofpoints ! bytes below: 22*2 = 44 integer ( kind = C_SHORT ) :: format integer ( kind = C_SHORT ) :: version integer ( kind = C_SHORT ) :: material_code integer ( kind = C_SHORT ) :: type integer ( kind = C_SHORT ) :: range integer ( kind = C_SHORT ) :: special_points integer ( kind = C_SHORT ) :: absolute integer ( kind = C_SHORT ) :: pointsize integer ( kind = C_SHORT ) :: imprint integer ( kind = C_SHORT ) :: inversion integer ( kind = C_SHORT ) :: leveling integer ( kind = C_SHORT ) :: seconds integer ( kind = C_SHORT ) :: minutes integer ( kind = C_SHORT ) :: hours integer ( kind = C_SHORT ) :: day integer ( kind = C_SHORT ) :: month integer ( kind = C_SHORT ) :: year integer ( kind = C_SHORT ) :: dayof integer ( kind = C_SHORT ) :: comment_size integer ( kind = C_SHORT ) :: private_size integer ( kind = C_SHORT ) :: nobjects integer ( kind = C_SHORT ) :: acquisition integer ( kind = C_INT ), allocatable :: val (:) !! *heights* endtype OBJ_SURF integer ( kind = 4 ), parameter :: SURF_DAT = 1 !! *'.dat' format, txt* integer ( kind = 4 ), parameter :: SURF_SUR = 2 !! *'.sur' format, binary* public :: read_surf , write_surf , init_scal , unit2IUc , unit2IUf , & trans_surf_txt , scal2surf , surf2scal , empty , SCALE_SURF , OBJ_SURF contains subroutine scal2surf ( scal , surf ) implicit none type ( SCALE_SURF ), intent ( in ) :: scal !! *object [[SCALE_SURF]]* type ( OBJ_SURF ), intent ( out ) :: surf !! *object [[OBJ_SURF]]* call f_c_string ( fs = trim ( scal % signature ), & cs = surf % signature ) call f_c_string ( fs = trim ( scal % xlength_unit ), & cs = surf % xlength_unit ) call f_c_string ( fs = trim ( scal % ylength_unit ), & cs = surf % ylength_unit ) call f_c_string ( fs = trim ( scal % zlength_unit ), & cs = surf % zlength_unit ) call f_c_string ( fs = trim ( scal % xaxis ), & cs = surf % xaxis ) call f_c_string ( fs = trim ( scal % yaxis ), & cs = surf % yaxis ) call f_c_string ( fs = trim ( scal % zaxis ), & cs = surf % zaxis ) call f_c_string ( fs = trim ( scal % dx_unit ), & cs = surf % dx_unit ) call f_c_string ( fs = trim ( scal % dy_unit ), & cs = surf % dy_unit ) call f_c_string ( fs = trim ( scal % dz_unit ), & cs = surf % dz_unit ) call f_c_string ( fs = trim ( scal % object_name ), & cs = surf % object_name ) call f_c_string ( fs = trim ( scal % operator_name ), & cs = surf % operator_name ) call f_c_string ( fs = trim ( scal % client_zone ), & cs = surf % client_zone ) call f_c_string ( fs = trim ( scal % reserved ), & cs = surf % reserved ) call f_c_string ( fs = trim ( scal % reservedzone ), & cs = surf % reservedzone ) call f_c_string ( fs = trim ( scal % obsolete ), & cs = surf % obsolete ) call f_c_string ( fs = trim ( scal % obsolete2 ), & cs = surf % obsolete2 ) surf % dx = scal % dx surf % dy = scal % dy surf % dz = scal % dz surf % xunit_ratio = scal % xunit_ratio surf % yunit_ratio = scal % yunit_ratio surf % zunit_ratio = scal % zunit_ratio surf % XOffset = scal % XOffset surf % YOffset = scal % YOffset surf % ZOffset = scal % ZOffset surf % measurement_duration = scal % measurement_duration surf % zmin = scal % zmin surf % zmax = scal % zmax surf % xres = scal % xres surf % yres = scal % yres surf % nofpoints = scal % nofpoints surf % format = scal % format surf % version = scal % version surf % material_code = scal % material_code surf % type = scal % type surf % range = scal % range surf % special_points = scal % special_points surf % absolute = scal % absolute surf % pointsize = scal % pointsize surf % imprint = scal % imprint surf % inversion = scal % inversion surf % leveling = scal % leveling surf % seconds = scal % seconds surf % minutes = scal % minutes surf % hours = scal % hours surf % day = scal % day surf % month = scal % month surf % year = scal % year surf % dayof = scal % dayof surf % comment_size = scal % comment_size surf % private_size = scal % private_size surf % nobjects = scal % nobjects surf % acquisition = scal % acquisition return endsubroutine scal2surf subroutine surf2scal ( surf , scal ) implicit none type ( OBJ_SURF ), intent ( in ) :: surf !! *object [[OBJ_SURF]]* type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* integer ( kind = I4 ) :: i call c_f_string ( cs = surf % signature , & fs = scal % signature , & borne_s = i ) call c_f_string ( cs = surf % xlength_unit , & fs = scal % xlength_unit , & borne_s = i ) call c_f_string ( cs = surf % ylength_unit , & fs = scal % ylength_unit , & borne_s = i ) call c_f_string ( cs = surf % zlength_unit , & fs = scal % zlength_unit , & borne_s = i ) call c_f_string ( cs = surf % xaxis , & fs = scal % xaxis , & borne_s = i ) call c_f_string ( cs = surf % yaxis , & fs = scal % yaxis , & borne_s = i ) call c_f_string ( cs = surf % zaxis , & fs = scal % zaxis , & borne_s = i ) call c_f_string ( cs = surf % dx_unit , & fs = scal % dx_unit , & borne_s = i ) call c_f_string ( cs = surf % dy_unit , & fs = scal % dy_unit , & borne_s = i ) call c_f_string ( cs = surf % dz_unit , & fs = scal % dz_unit , & borne_s = i ) call c_f_string ( cs = surf % object_name , & fs = scal % object_name , & borne_s = i ) call c_f_string ( cs = surf % operator_name , & fs = scal % operator_name , & borne_s = i ) call c_f_string ( cs = surf % client_zone , & fs = scal % client_zone , & borne_s = i ) call c_f_string ( cs = surf % reserved , & fs = scal % reserved , & borne_s = i ) call c_f_string ( cs = surf % reservedzone , & fs = scal % reservedzone , & borne_s = i ) call c_f_string ( cs = surf % obsolete , & fs = scal % obsolete , & borne_s = i ) call c_f_string ( cs = surf % obsolete2 , & fs = scal % obsolete2 , & borne_s = i ) scal % dx = surf % dx scal % dy = surf % dy scal % dz = surf % dz scal % xunit_ratio = surf % xunit_ratio scal % yunit_ratio = surf % yunit_ratio scal % zunit_ratio = surf % zunit_ratio scal % XOffset = surf % XOffset scal % YOffset = surf % YOffset scal % ZOffset = surf % ZOffset scal % measurement_duration = surf % measurement_duration scal % zmin = surf % zmin scal % zmax = surf % zmax scal % xres = surf % xres scal % yres = surf % yres scal % nofpoints = surf % nofpoints scal % format = surf % format scal % version = surf % version scal % material_code = surf % material_code scal % type = surf % type scal % range = surf % range scal % special_points = surf % special_points scal % absolute = surf % absolute scal % pointsize = surf % pointsize scal % imprint = surf % imprint scal % inversion = surf % inversion scal % leveling = surf % leveling scal % seconds = surf % seconds scal % minutes = surf % minutes scal % hours = surf % hours scal % day = surf % day scal % month = surf % month scal % year = surf % year scal % dayof = surf % dayof scal % comment_size = surf % comment_size scal % private_size = surf % private_size scal % nobjects = surf % nobjects scal % acquisition = surf % acquisition return endsubroutine surf2scal !========================================================================================= !>@note !   Just empties a string ! @endnote !----------------------------------------------------------------------------------------- subroutine empty ( charinout ) implicit none character ( len =* ), intent ( inout ) :: charinout charinout = repeat ( ' ' , len ( charinout )) return endsubroutine empty !========================================================================================= !< @note !   Converts a C string to a Fortran string ! !   A From a memory viewpoint, a C string is like a character vector ending with a ```C_NULL_CHAR```, so as long as !   it is not found, the characters are copied one by one in a fortran string ! @endnote !----------------------------------------------------------------------------------------- subroutine c_f_string ( cs , fs , borne_s ) implicit none character ( kind = C_CHAR ), dimension (:), intent ( in ) :: cs !! *C string* character ( len =* ), intent ( out ) :: fs !! *Fortran string* integer ( kind = I4 ), intent ( out ) :: borne_s !! *resulting Fortran string length* integer ( kind = I4 ) :: i , ucs ucs = size ( cs ) ! vector length borne_s = ucs ! resulting string default length i = 1 do if ( i > ucs ) exit if ( cs ( i ) == C_NULL_CHAR ) then ! fin de chaîne c rencontrée ; s'il n'y a pas de null_char borne_s = i - 1 ! c'est qu'on utilise tout le vecteur exit endif i = i + 1 enddo call empty ( fs ) do i = 1 , borne_s ! the C string is translated into fortran fs ( i : i ) = cs ( i ) enddo return endsubroutine c_f_string !========================================================================================= !< @note !   Converts a Fortran string to a C string ! !   A From a memory viewpoint, a C string is like a character vector ending with a ```C_NULL_CHAR```, !   so the characters are copied one by one in a ```C_CHAR``` vector that ends with a ```C_NULL_CHAR``` ! @endnote !----------------------------------------------------------------------------------------- subroutine f_c_string ( fs , cs ) implicit none character ( len =* ), intent ( in ) :: fs !! *fortran string* character ( kind = C_CHAR ), dimension (:), intent ( out ) :: cs !! *resulting C string* integer ( kind = I4 ) :: i , ufs ufs = len_trim ( fs ) ! longueur de la chaîne fortran sans les null, les blancs, ... if ( ufs == 0 ) then ! si la chaîne est vide cs ( 1 ) = C_NULL_CHAR else do i = 1 , ufs cs ( i ) = fs ( i : i ) enddo if ( ufs < size ( cs )) cs ( ufs + 1 ) = C_NULL_CHAR ! si la fin du vecteur n'est pas atteinte endif return endsubroutine f_c_string !========================================================================================= !> @note !   [[OBJ_SURF]] initialization, every unit is m ! @endnote !----------------------------------------------------------------------------------------- subroutine init_scal ( scal , nx , ny , lx , ly , unit_z ) implicit none type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* integer ( kind = I4 ), optional , intent ( in ) :: nx integer ( kind = I4 ), optional , intent ( in ) :: ny real ( kind = R8 ), optional , intent ( in ) :: lx real ( kind = R8 ), optional , intent ( in ) :: ly character ( * ), optional , intent ( in ) :: unit_z integer ( kind = I4 ), dimension ( 1 : 8 ) :: time_val character ( len = 256 ) :: string call date_and_time ( values = time_val ) scal % format = 0 scal % nobjects = 1 scal % version = 1 scal % type = 2 scal % material_code = 1 scal % acquisition = 0 scal % range = 0 scal % special_points = 0 scal % absolute = 1 scal % pointsize = 32 scal % zmin = 0 scal % zmax = 0 scal % xres = 0 scal % yres = 0 scal % nofpoints = 0 scal % xunit_ratio = 1. scal % yunit_ratio = 1. scal % zunit_ratio = 1. scal % imprint = 0 scal % inversion = 0 scal % leveling = 0 scal % seconds = time_val ( 7 ) scal % minutes = time_val ( 6 ) scal % hours = time_val ( 5 ) scal % day = time_val ( 3 ) scal % month = time_val ( 2 ) scal % year = time_val ( 1 ) scal % dayof = 0 scal % measurement_duration = 0.0 scal % comment_size = 0 scal % private_size = 0 scal % XOffset = 0. scal % YOffset = 0. scal % ZOffset = 0. call empty ( scal % reserved ) call empty ( scal % obsolete2 ) call empty ( scal % obsolete ) call empty ( scal % reservedzone ) call empty ( scal % client_zone ) call empty ( scal % object_name ) call empty ( scal % signature ) call empty ( scal % operator_name ) scal % object_name = 'HOME MADE' scal % signature = 'DIGITAL SURF' scal % operator_name = 'MOD_SURFILE' call empty ( scal % xaxis ) call empty ( scal % yaxis ) call empty ( scal % zaxis ) scal % xaxis = \"X\" scal % yaxis = \"Y\" scal % zaxis = \"Z\" call empty ( scal % xlength_unit ) call empty ( scal % ylength_unit ) call empty ( scal % zlength_unit ) call empty ( scal % dx_unit ) call empty ( scal % dy_unit ) call empty ( scal % dz_unit ) scal % xlength_unit = \"m\" ; scal % dx_unit = trim ( scal % xlength_unit ) ; scal % dx = 1.0 scal % ylength_unit = \"m\" ; scal % dy_unit = trim ( scal % ylength_unit ) ; scal % dy = 1.0 scal % zlength_unit = \"m\" ; scal % dz_unit = trim ( scal % zlength_unit ) ; scal % dz = 1.0 scal % mu = 0 scal % si = 0 if ( present ( nx )) scal % xres = nx if ( present ( ny )) scal % yres = ny if ( present ( nx ). and . present ( lx )) scal % dx = lx / nx if ( present ( ny ). and . present ( ly )) scal % dy = ly / ny if ( present ( unit_z )) then ; scal % zlength_unit = trim ( unit_z ) scal % dz_unit = trim ( unit_z ) ; endif return endsubroutine init_scal !========================================================================================= !< @note !   Writes an [[OBJ_SURF]] object in a text file ! !   The object components are first written in a fortran string, then it is written into !   the file with a comment ! @endnote !----------------------------------------------------------------------------------------- subroutine trans_surf_txt ( surf , fichier , xyz ) implicit none type ( OBJ_SURF ), intent ( in ) :: surf !! *object [[OBJ_SURF]]* character ( len =* ), intent ( in ) :: fichier !! *text file to write* logical ( kind = I4 ), intent ( in ) :: xyz !! *whether to also write the heights (maybe huge)* integer ( kind = I4 ) :: i , k , s character ( len = 512 ) :: string , cc call get_unit ( k ) open ( k , file = trim ( fichier )) call c_f_string ( cs = surf % signature , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"signature              \" ; call empty ( cc ) write ( cc , * ) surf % format ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"format                 \" ; call empty ( cc ) write ( cc , * ) surf % nobjects ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"nobjects               \" ; call empty ( cc ) write ( cc , * ) surf % version ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"version                \" ; call empty ( cc ) write ( cc , * ) surf % type ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"type                   \" ; call empty ( cc ) call c_f_string ( cs = surf % object_name , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"object_name            \" ; call empty ( cc ) call c_f_string ( cs = surf % operator_name , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"operator_name          \" ; call empty ( cc ) write ( cc , * ) surf % material_code ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"material_code          \" ; call empty ( cc ) write ( cc , * ) surf % acquisition ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"acquisition            \" ; call empty ( cc ) write ( cc , * ) surf % range ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"range                  \" ; call empty ( cc ) write ( cc , * ) surf % special_points ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"special_points         \" ; call empty ( cc ) write ( cc , * ) surf % absolute ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"absolute               \" ; call empty ( cc ) call c_f_string ( cs = surf % reserved , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"reserved               \" ; call empty ( cc ) write ( cc , * ) surf % pointsize ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"pointsize              \" ; call empty ( cc ) write ( cc , * ) surf % zmin ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zmin                   \" ; call empty ( cc ) write ( cc , * ) surf % zmax ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zmax                   \" ; call empty ( cc ) write ( cc , * ) surf % xres ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xres                   \" ; call empty ( cc ) write ( cc , * ) surf % yres ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"yres                   \" ; call empty ( cc ) write ( cc , * ) surf % nofpoints ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"nofpoints              \" ; call empty ( cc ) write ( cc , * ) surf % dx ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dx                     \" ; call empty ( cc ) write ( cc , * ) surf % dy ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dy                     \" ; call empty ( cc ) write ( cc , * ) surf % dz ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dz                     \" ; call empty ( cc ) call c_f_string ( cs = surf % xaxis , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xaxis                  \" ; call empty ( cc ) call c_f_string ( cs = surf % yaxis , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"yaxis                  \" ; call empty ( cc ) call c_f_string ( cs = surf % zaxis , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zaxis                  \" ; call empty ( cc ) call c_f_string ( cs = surf % dx_unit , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dx_unit                \" ; call empty ( cc ) call c_f_string ( cs = surf % dy_unit , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dy_unit                \" ; call empty ( cc ) call c_f_string ( cs = surf % dz_unit , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dz_unit                \" ; call empty ( cc ) call c_f_string ( cs = surf % xlength_unit , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xlength_unit           \" ; call empty ( cc ) call c_f_string ( cs = surf % ylength_unit , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"ylength_unit           \" ; call empty ( cc ) call c_f_string ( cs = surf % zlength_unit , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zlength_unit           \" ; call empty ( cc ) write ( cc , * ) surf % xunit_ratio ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xunit_ratio            \" ; call empty ( cc ) write ( cc , * ) surf % yunit_ratio ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"yunit_ratio            \" ; call empty ( cc ) write ( cc , * ) surf % zunit_ratio ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zunit_ratio            \" ; call empty ( cc ) write ( cc , * ) surf % imprint ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"imprint                \" ; call empty ( cc ) write ( cc , * ) surf % inversion ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"inversion              \" ; call empty ( cc ) write ( cc , * ) surf % leveling ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"leveling               \" ; call empty ( cc ) call c_f_string ( cs = surf % obsolete , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"obsolete               \" ; call empty ( cc ) write ( cc , * ) surf % seconds ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"seconds                \" ; call empty ( cc ) write ( cc , * ) surf % minutes ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"minutes                \" ; call empty ( cc ) write ( cc , * ) surf % hours ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"hours                  \" ; call empty ( cc ) write ( cc , * ) surf % day ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"day                    \" ; call empty ( cc ) write ( cc , * ) surf % month ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"month                  \" ; call empty ( cc ) write ( cc , * ) surf % year ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"year                   \" ; call empty ( cc ) write ( cc , * ) surf % dayof ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dayof                  \" ; call empty ( cc ) write ( cc , * ) surf % measurement_duration ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"measurement_duration   \" ; call empty ( cc ) call c_f_string ( cs = surf % obsolete2 , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"obsolete2              \" ; call empty ( cc ) write ( cc , * ) surf % comment_size ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"comment_size           \" ; call empty ( cc ) write ( cc , * ) surf % private_size ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"private_size           \" ; call empty ( cc ) call c_f_string ( cs = surf % client_zone , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"client_zone            \" ; call empty ( cc ) write ( cc , * ) surf % XOffset ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"XOffset                \" ; call empty ( cc ) write ( cc , * ) surf % YOffset ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"YOffset                \" ; call empty ( cc ) write ( cc , * ) surf % ZOffset ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"ZOffset                \" ; call empty ( cc ) call c_f_string ( cs = surf % reservedzone , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"reservedzone           \" ; call empty ( cc ) if ( xyz ) then do i = 0 , surf % nofpoints - 1 write ( k , * ) mod ( i , surf % xres ) * surf % dx , ( i / surf % xres ) * surf % dy , surf % val ( i + 1 ) * surf % dz enddo endif close ( k ) return endsubroutine trans_surf_txt !========================================================================================= !< @note !   Subroutine that opens a ```.sur``` file and transfers it contents into an object [[OBJ_SURF]] ! @endnote ! @warning !    By default here, the heights are not written with ```dump=.true.``` ! @endwarning !----------------------------------------------------------------------------------------- subroutine open_surffile ( fichier , surf , scal , dump ) implicit none character ( len =* ), intent ( in ) :: fichier !! *file to be read* type ( OBJ_SURF ), intent ( out ) :: surf !! *object that will contain the file infos and heights* type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* logical ( kind = I4 ), optional , intent ( in ) :: dump !! *whether to transform the data in a text file* integer ( kind = I4 ) :: i , k real ( kind = R8 ) :: scal_x , scal_y , scal_z character ( kind = C_CHAR ) :: charact call get_unit ( k ) open ( k , file = trim ( fichier ), & ! form = 'unformatted' , & ! access = \"stream\" , & ! beware the \"frecord-marker\" in other modes action = \"read\" , & ! position = \"rewind\" , & ! convert = 'little_endian' ,& ! status = 'old' ) read ( k ) surf % signature , surf % format , surf % nobjects , surf % version , surf % type , surf % object_name , & surf % operator_name , surf % material_code , surf % acquisition , surf % range , surf % special_points , & surf % absolute , surf % reserved , surf % pointsize , surf % zmin , surf % zmax , surf % xres , surf % yres , & surf % nofpoints , surf % dx , surf % dy , surf % dz , surf % xaxis , surf % yaxis , surf % zaxis , surf % dx_unit , & surf % dy_unit , surf % dz_unit , surf % xlength_unit , surf % ylength_unit , surf % zlength_unit , & surf % xunit_ratio , surf % yunit_ratio , surf % zunit_ratio , surf % imprint , surf % inversion , surf % leveling , & surf % obsolete , surf % seconds , surf % minutes , surf % hours , surf % day , surf % month , surf % year , surf % dayof , & surf % measurement_duration , surf % obsolete2 , surf % comment_size , surf % private_size , surf % client_zone , & surf % XOffset , surf % YOffset , surf % ZOffset , surf % reservedzone do i = 1 , surf % comment_size read ( k ) charact enddo allocate ( surf % val ( 1 : surf % nofpoints ) ) do i = 1 , surf % nofpoints read ( k ) surf % val ( i ) enddo close ( k ) call surf2scal ( surf , scal ) if ( present ( dump ). and . dump ) call trans_surf_txt ( surf , trim ( fichier ) // '.txt' , xyz = . false .) return endsubroutine open_surffile !========================================================================================= !< @note !   Converts uppercase to lowercase, adapted from [here](http://fortranwiki.org/fortran/show/String_Functions) ! @endnote !----------------------------------------------------------------------------------------- function lower ( s1 ) result ( s2 ) character ( * ), intent ( in ) :: s1 !! *string to transform to lower case* character ( len ( s1 )) :: s2 !! *result: same string but each character is lower case* character ( len = 1 ) :: ch integer ( kind = I4 ), parameter :: duc = ichar ( 'A' ) - ichar ( 'a' ) integer ( kind = I4 ) :: i do i = 1 , len ( s1 ) ch = s1 ( i : i ) if ( ch >= 'A' . and . ch <= 'Z' ) ch = char ( ichar ( ch ) - duc ) s2 ( i : i ) = ch enddo return endfunction lower function unit2IUc ( string ) result ( met ) implicit none real ( kind = R8 ) :: met character ( kind = C_CHAR ), dimension (:), intent ( in ) :: string character ( len = 2 ) :: chaine chaine = string ( 1 ) // string ( 2 ) met = unit2IUf ( chaine ) return endfunction unit2IUc function unit2IUf ( string ) result ( met ) implicit none real ( kind = R8 ) :: met character ( * ), intent ( in ) :: string select case ( string ) case ( 'm ' ) met = 1.e+00_R8 case ( 'cm' ) met = 1.e-02_R8 case ( 'mm' ) met = 1.e-03_R8 case ( 'µm' ) met = 1.e-06_R8 case ( 'nm' ) met = 1.e-09_R8 case ( 'pm' ) met = 1.e-12_R8 case ( 'Pa' ) met = 1.e+00_R8 case ( 'MP' ) met = 1.e+06_R8 case ( 'GP' ) met = 1.e+09_R8 case default met = 1.e+00_R8 endselect return endfunction unit2IUf !========================================================================================= !< @note !   Subroutine that writes the heights of an [[OBJ_SURF]] object into a 2D array ! @endnote !----------------------------------------------------------------------------------------- subroutine trans_surf_tab ( surf , tab ) implicit none type ( OBJ_SURF ), intent ( inout ) :: surf !! *object ```OBJ_SURF``` that contains the heights* real ( kind = R8 ), dimension (:, :), allocatable , intent ( out ) :: tab !! *height array* integer ( kind = I4 ) :: long , larg , i , j , k real ( kind = R8 ) :: unit_z long = surf % xres larg = surf % yres allocate ( tab ( 1 : long , 1 : larg ) ) unit_z = unit2IUc ( surf % dz_unit ) do j = 1 , larg do i = 1 , long k = ( j - 1 ) * long + i tab ( i , j ) = ( surf % val ( k ) * surf % dz + surf % Zoffset ) * unit_z enddo enddo deallocate ( surf % val ) return endsubroutine trans_surf_tab !========================================================================================= !< @note !   Subroutine that opens a surface file ```.sur``` or ```.dat``` ! !   The heights are centred, scaled then put into a vector. ! @endnote ! @warning !    If the scale factor ```sq``` is negative, the heights are not scaled when reading ```.sur``` ! @endwarning ! @warning !    By default, the ```.sur``` header is dumped ! @endwarning !----------------------------------------------------------------------------------------- subroutine read_surf ( nom_fic , mu , sq , tab_s , scal ) implicit none character ( len =* ), intent ( in ) :: nom_fic !! *file name* real ( kind = R8 ), intent ( in ) :: mu !! *if > 0, values are centered* real ( kind = R8 ), intent ( in ) :: sq !! *desired height standard deviation* type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* real ( kind = R8 ), dimension (:,:), allocatable , intent ( out ) :: tab_s !! *height array* integer ( kind = I4 ) :: style , i , ii , j , jj , k , nb , eof , tmp , nx , ny real ( kind = R8 ) :: sqs , mean , dz , lx , ly , lz type ( OBJ_SURF ) :: surf character ( len = 3 ) :: ext real ( kind = R8 ), dimension (:), allocatable :: x , y , z i = len_trim ( nom_fic ) ext = lower ( nom_fic ( i - 2 : i ) ) if ( ext == 'dat' ) style = SURF_DAT if ( ext == 'sur' ) style = SURF_SUR select case ( style ) case ( SURF_SUR ) call open_surffile ( fichier = trim ( nom_fic ), surf = surf , scal = scal , dump = . false .) call trans_surf_tab ( surf = surf , tab = tab_s ) case ( SURF_DAT ) call get_unit ( k ) open ( unit = k , file = trim ( nom_fic ), status = 'old' ) nb = 0 do read ( k , * , iostat = eof ) if ( eof /= 0 ) exit nb = nb + 1 enddo rewind ( k ) allocate ( x ( 1 : nb ) ) allocate ( y ( 1 : nb ) ) allocate ( z ( 1 : nb ) ) do i = 1 , nb read ( k , * ) x ( i ), y ( i ), z ( i ) enddo close ( k ) ! the triplet x, y, z is sorted according x !----------------------------------------------------------- call sort_real_2real ( g = 1 , d = nb , rtabref = x ( 1 : nb ), rtab1 = y ( 1 : nb ), rtab2 = z ( 1 : nb )) i = 1 do if ( abs ( x ( i ) - x ( 1 )) > 100 * EPS_R8 ) exit i = i + 1 enddo scal % dx = abs ( x ( i ) - x ( 1 )) j = 1 do if ( abs ( x ( j + 1 ) - x ( j )) > 1.0e-10 ) exit j = j + 1 enddo ny = j ! number of same abscissae for a given column if ( mod ( nb , ny ) /= 0 ) STOP 'READ_SURF, non rectangular mesh' nx = nb / ny scal % xres = nx scal % yres = ny do i = 1 , nx ii = ( i - 1 ) * ny + 1 jj = ii + ny - 1 call sort_real_1real ( g = 1 , d = ny , rtabref = y ( ii : jj ), rtab1 = z ( ii : jj )) enddo j = 1 do if ( abs ( y ( j ) - y ( 1 )) > 100 * EPS_R8 ) exit j = j + 1 enddo scal % dy = abs ( y ( j ) - y ( 1 )) allocate ( tab_s ( 1 : nx , 1 : ny ) ) k = 0 do i = 1 , nx do j = 1 , ny k = k + 1 tab_s ( i , j ) = z ( k ) enddo enddo lx = maxval ( x ) - minval ( x ) ly = maxval ( y ) - minval ( y ) lz = maxval ( tab_s ) - minval ( tab_s ) scal % dz = lz / ( nx * ny ) scal % xlength_unit = 'm ' ; scal % dx_unit = 'm ' scal % ylength_unit = 'm ' ; scal % dy_unit = 'm ' scal % zlength_unit = 'm ' ; scal % dz_unit = 'm ' !call sort_real(g=1, d=nx*ny, rtabref=z(1:nx*ny)) !scal%dz = 1.e+10 !do i = 2, nx*ny !   dz = z(i) -z(i-1) !   if (abs(dz) < 100*EPS_R8) cycle !   scal%dz = min(scal%dz, dz) !enddo !scal%dz = dz deallocate ( x , y , z ) endselect nx = scal % xres ny = scal % yres ! centering ? if ( mu > 0. ) then mean = sum ( tab_s ( 1 : nx , 1 : ny )) / ( nx * ny ) scal % mu = mean tab_s ( 1 : nx , 1 : ny ) = tab_s ( 1 : nx , 1 : ny ) - mean endif ! scaling ? if ( sq > 0. ) then sqs = ( sum ( tab_s ( 1 : nx , 1 : ny ) ** 2 ) / ( nx * ny )) ** ( 0.5_R8 ) scal % si = sqs tab_s ( 1 : nx , 1 : ny ) = tab_s ( 1 : nx , 1 : ny ) * sq / sqs endif return endsubroutine read_surf !========================================================================================= !< @note !   Subroutine that creates an object [[OBJ_SURF]] ! @endnote !----------------------------------------------------------------------------------------- subroutine build_surf ( surf , tab ) implicit none type ( OBJ_SURF ), intent ( inout ) :: surf !! *resulting object ```OBJ_SURF```* real ( kind = R8 ), dimension ( 1 : surf % xres , 1 : surf % yres ), intent ( in ) :: tab integer ( kind = I4 ) :: i , j , k , nx , ny real ( kind = R8 ) :: max_n , min_t , max_t , mil_t , amp_t , unit_x , unit_y , unit_z nx = surf % xres ny = surf % yres surf % nofpoints = nx * ny unit_x = unit2IUc ( surf % dx_unit ) unit_y = unit2IUc ( surf % dy_unit ) unit_z = unit2IUc ( surf % dz_unit ) if ( allocated ( surf % val )) deallocate ( surf % val ) allocate ( surf % val ( 1 : surf % nofpoints )) min_t = minval ( tab ( 1 : nx , 1 : ny ) ) / unit_z max_t = maxval ( tab ( 1 : nx , 1 : ny ) ) / unit_z mil_t = 0.5_R8 * ( min_t + max_t ) ! middle of the range amp_t = max_t - min_t ! range amplitude surf % ZOffset = mil_t max_n = 0.5 * huge ( 1 ) ! the heights are integers, allowed to span ! half the positive integer range. surf % dz = amp_t / max_n ! subsequent dz k = 0 do j = 1 , ny do i = 1 , nx k = k + 1 surf % val ( k ) = nint ( ( tab ( i , j ) / unit_z - surf % ZOffset ) / surf % dz ) ! enddo enddo surf % zmin = minval ( surf % val ) surf % zmax = maxval ( surf % val ) return endsubroutine build_surf !========================================================================================= !< @note !   Subroutine that writes an object [[OBJ_SURF]] in a file ! @endnote !----------------------------------------------------------------------------------------- subroutine write_surffile ( fichier , surf ) implicit none character ( len =* ), intent ( in ) :: fichier !! *file to be written* type ( OBJ_SURF ), intent ( inout ) :: surf !! *object ```OBJ_SURF``` to write* integer ( kind = I4 ) :: i , k call get_unit ( k ) open ( k , file = trim ( fichier ), & ! form = 'unformatted' , & ! access = \"stream\" , & ! beware the \"frecord-marker\" in other modes action = \"write\" , & ! position = \"rewind\" , & ! status = \"replace\" , & ! convert = 'little_endian' ) write ( k ) surf % signature , surf % format , surf % nobjects , surf % version , surf % type , surf % object_name , & surf % operator_name , surf % material_code , surf % acquisition , surf % range , surf % special_points , & surf % absolute , surf % reserved , surf % pointsize , surf % zmin , surf % zmax , surf % xres , surf % yres , & surf % nofpoints , surf % dx , surf % dy , surf % dz , surf % xaxis , surf % yaxis , surf % zaxis , surf % dx_unit , & surf % dy_unit , surf % dz_unit , surf % xlength_unit , surf % ylength_unit , surf % zlength_unit , & surf % xunit_ratio , surf % yunit_ratio , surf % zunit_ratio , surf % imprint , surf % inversion , surf % leveling , & surf % obsolete , surf % seconds , surf % minutes , surf % hours , surf % day , surf % month , surf % year , surf % dayof , & surf % measurement_duration , surf % obsolete2 , surf % comment_size , surf % private_size , surf % client_zone , & surf % XOffset , surf % YOffset , surf % ZOffset , surf % reservedzone , & ( surf % val ( i ), i = 1 , surf % nofpoints ) close ( k ) return endsubroutine write_surffile !========================================================================================= !< @note !   Subroutine that writes a height array into a surface file ```.sur``` or ```.dat``` ! @endnote !----------------------------------------------------------------------------------------- subroutine write_surf ( nom_fic , tab_s , scal ) implicit none character ( len =* ), intent ( in ) :: nom_fic !! *file name* type ( SCALE_SURF ), intent ( inout ) :: scal !! *object [[SCALE_SURF]]* real ( kind = R8 ), dimension ( 1 : scal % xres , 1 : scal % yres ), intent ( in ) :: tab_s character ( len = 3 ) :: ext integer ( kind = I4 ) :: style , i , j , k type ( OBJ_SURF ) :: surf_s real ( kind = R8 ) :: dx , dy i = len_trim ( nom_fic ) ext = lower ( nom_fic ( i - 2 : i ) ) if ( ext == 'dat' ) style = SURF_DAT if ( ext == 'sur' ) style = SURF_SUR select case ( style ) case ( SURF_SUR ) call scal2surf ( scal , surf_s ) call build_surf ( surf = surf_s , tab = tab_s ( 1 : scal % xres , 1 : scal % yres )) surf_s % comment_size = 0 ! to increase compatibility with mountains call write_surffile ( fichier = trim ( nom_fic ), surf = surf_s ) call surf2scal ( surf_s , scal ) case ( SURF_DAT ) dx = scal % dx dy = scal % dy call get_unit ( k ) open ( k , file = trim ( nom_fic )) do i = 1 , scal % xres do j = 1 , scal % yres write ( k , * ) ( i - 1 ) * dx , ( j - 1 ) * dy , tab_s ( i , j ) enddo enddo close ( k ) endselect return endsubroutine write_surf endmodule surfile !============ EN TETE TYPIQUE !~  \"DIGITAL SURF\" !~  0 !~  1 !~  1 !~  2 !~  \"* 16-774-lm1-pnm bouches *\" !~  \"\" !~  0 !~  0 !~  0 !~  0 !~  1 !~  \"\" !~  32 !~  -19122091 !~  4341882 !~  512 !~  512 !~  262144 !~  3.55476077E-04 !~  3.54291551E-04 !~  3.25564076E-10 !~  \"X\" !~  \"Y\" !~  \"Z\" !~  \"mm\" !~  \"mm\" !~  \"mm\" !~  \"mm\" !~  \"mm\" !~  \"mm\" !~  1.00000000 !~  1.00000000 !~  1.00000000 !~  0 !~  0 !~  0 !~  \"\" !~  0 !~  0 !~  0 !~  0 !~  0 !~  0 !~  0 !~  0.00000000 !~  \"\" !~  0 !~  0 !~  \"\" !~   0.00000000 !~   0.00000000 !~  -0.00000000 !~  \"\" !~","loc":"sourcefile/mod_surfile.f90.html"},{"tags":"","title":"mod_bspline.f90 – MUSST","text":"Description Multidimensional (1D-6D) B-Spline interpolation of data on a regular grid.\n  Basic subroutine interface. Notes This module is based on the bspline and spline routines from [1].\n  The original Fortran 77 routines were converted to free-form source.\n  Some of them are relatively unchanged from the originals, but some have\n  been extensively refactored. In addition, new routines for\n  1d, 4d, 5d, and 6d interpolation were also created (these are simply\n  extensions of the same algorithm into higher dimensions). See also\n  * An object-oriented interface can be found in [bspline_oo_module]. References DBSPLIN and DTENSBS from the NIST Core Math Library .\n     Original code is public domain. Carl de Boor, \"A Practical Guide to Splines\",\n     Springer-Verlag, New York, 1978. Carl de Boor, Efficient Computer Manipulation of Tensor\n     Products ,\n     ACM Transactions on Mathematical Software,\n     Vol. 5 (1979), p. 173-182. D.E. Amos, \"Computation with Splines and B-Splines\",\n     SAND78-1968, Sandia Laboratories, March, 1979. Carl de Boor, Package for calculating with B-splines ,\n     SIAM Journal on Numerical Analysis 14, 3 (June 1977), p. 441-472. Files dependent on this one sourcefile~~mod_bspline.f90~~AfferentGraph sourcefile~mod_bspline.f90 mod_bspline.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_bspline.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules bspline Source Code mod_bspline.f90 Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !# Description ! !  Multidimensional (1D-6D) B-Spline interpolation of data on a regular grid. !  Basic subroutine interface. ! !# Notes ! !  This module is based on the bspline and spline routines from [1]. !  The original Fortran 77 routines were converted to free-form source. !  Some of them are relatively unchanged from the originals, but some have !  been extensively refactored. In addition, new routines for !  1d, 4d, 5d, and 6d interpolation were also created (these are simply !  extensions of the same algorithm into higher dimensions). ! !# See also !  * An object-oriented interface can be found in [bspline_oo_module]. ! !# References ! !  1. DBSPLIN and DTENSBS from the !     [NIST Core Math Library](http://www.nist.gov/itl/math/mcsd-software.cfm). !     Original code is public domain. !  2. Carl de Boor, \"A Practical Guide to Splines\", !     Springer-Verlag, New York, 1978. !  3. Carl de Boor, [Efficient Computer Manipulation of Tensor !     Products](http://dl.acm.org/citation.cfm?id=355831), !     ACM Transactions on Mathematical Software, !     Vol. 5 (1979), p. 173-182. !  4. D.E. Amos, \"Computation with Splines and B-Splines\", !     SAND78-1968, Sandia Laboratories, March, 1979. !  5. Carl de Boor, !     [Package for calculating with B-splines](http://epubs.siam.org/doi/abs/10.1137/0714026), !     SIAM Journal on Numerical Analysis 14, 3 (June 1977), p. 441-472. module bspline use , intrinsic :: iso_fortran_env , only : real64 use , intrinsic :: iso_fortran_env , only : error_unit implicit none private integer , parameter :: wp = real64 !! Real precision !main routines: public :: db1ink , db1val public :: db2ink , db2val contains !***************************************************************************************** !***************************************************************************************** !> Determines the parameters of a function that interpolates !  the one-dimensional gridded data !   [x(i),\\mathrm{fcn}(i)] ~\\mathrm{for}~ i=1,..,n_x  !  The interpolating function and its derivatives may !  subsequently be evaluated by the function [[db1val]]. ! !# History ! !  * Jacob Williams, 10/30/2015 : Created 1D routine. subroutine db1ink ( x , nx , fcn , kx , tx , bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! Number of x abcissae integer , intent ( in ) :: kx !! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) real ( wp ), dimension ( nx ), intent ( in ) :: x !! Array of x abcissae. Must be strictly increasing. real ( wp ), dimension ( nx ), intent ( in ) :: fcn !! Array of function values to interpolate. fcn(i) should !!    contain the function value at the point x(i) real ( wp ), dimension ( nx + kx ), intent ( inout ) :: tx !! The knots in the x direction for the spline interpolant. !!    If iflag=0 these are chosen by [[db1ink]]. !!    If iflag=1 these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension ( nx ), intent ( out ) :: bcoef !! Array of coefficients of the b-spline interpolant. integer , intent ( inout ) :: iflag !! **on input:**  0 = knot sequence chosen by [[db1ink]]. !!                1 = knot sequence chosen by user. !! **on output:** 1 = successful execution. !!                2 = iflag out of range. !!                3 = nx out of range. !!                4 = kx out of range. !!                5 = x not strictly increasing. !!                6 = tx not non-decreasing. real ( wp ), dimension ( 2 * kx * ( nx + 1 )) :: work logical :: status_ok !check validity of inputs call check_inputs ( 'db1ink' ,& iflag ,& nx = nx ,& kx = kx ,& x = x ,& tx = tx ,& status_ok = status_ok ) if ( status_ok ) then !choose knots if ( iflag == 0 ) then call dbknot ( x , nx , kx , tx ) endif !construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , 1 , tx , kx , bcoef , work , iflag ) if ( iflag == 0 ) iflag = 1 endif endsubroutine db1ink !***************************************************************************************** !***************************************************************************************** !> Evaluates the tensor product piecewise polynomial !  interpolant constructed by the routine [[db1ink]] or one of its !  derivatives at the point xval. ! !  To evaluate the interpolant itself, set idx=0, !  to evaluate the first partial with respect to x, set idx=1, and so on. ! !  db1val returns 0.0 if (xval,yval) is out of range. that is, if !```fortran !   xval < tx(1) .or. xval > tx(nx+kx) !``` !  if the knots tx were chosen by [[db1ink]], then this is equivalent to: !```fortran !   xval < x(1) .or. xval > x(nx)+epsx !``` !  where !```fortran !   epsx = 0.1*(x(nx)-x(nx-1)) !``` ! !  The input quantities tx, nx, kx, and bcoef should be !  unchanged since the last call of [[db1ink]]. ! !# History ! !  * Jacob Williams, 10/30/2015 : Created 1D routine. subroutine db1val ( xval , idx , tx , nx , kx , bcoef , f , iflag , inbvx ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db1ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db1ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db1ink]]) real ( wp ), dimension ( nx ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db1ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. real ( wp ), dimension ( 3 * kx ) :: work f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then write ( error_unit , '(A)' ) 'db1val - x value out of bounds' iflag = 1 return endif f = dbvalu ( tx , bcoef , nx , kx , idx , xval , inbvx , work , iflag ) endsubroutine db1val !***************************************************************************************** !***************************************************************************************** !> Determines the parameters of a function that interpolates !  the two-dimensional gridded data !   [x(i),y(j),\\mathrm{fcn}(i,j)] ~\\mathrm{for}~ i=1,..,n_x ~\\mathrm{and}~ j=1,..,n_y  !  The interpolating function and its derivatives may !  subsequently be evaluated by the function [[db2val]]. ! !  The interpolating function is a piecewise polynomial function !  represented as a tensor product of one-dimensional b-splines. the !  form of this function is ! !   s(x,y) = \\sum_{i=1}&#94;{n_x} \\sum_{j=1}&#94;{n_y} a_{ij} u_i(x) v_j(y)  ! !  where the functions u_i and v_j are one-dimensional b-spline !  basis functions. the coefficients  a_{ij}  are chosen so that ! !   s(x(i),y(j)) = \\mathrm{fcn}(i,j) ~\\mathrm{for}~ i=1,..,n_x ~\\mathrm{and}~ j=1,..,n_y  ! !  Note that for each fixed value of y,  s(x,y)  is a piecewise !  polynomial function of x alone, and for each fixed value of x,  s(x,y)  !  is a piecewise polynomial function of y alone. in one dimension !  a piecewise polynomial may be created by partitioning a given !  interval into subintervals and defining a distinct polynomial piece !  on each one. the points where adjacent subintervals meet are called !  knots. each of the functions u_i and v_j above is a piecewise !  polynomial. ! !  Users of db2ink choose the order (degree+1) of the polynomial !  pieces used to define the piecewise polynomial in each of the x and !  y directions (kx and ky). users also may define their own knot !  sequence in x and y separately (tx and ty). if iflag=0, however, !  db2ink will choose sequences of knots that result in a piecewise !  polynomial interpolant with kx-2 continuous partial derivatives in !  x and ky-2 continuous partial derivatives in y. (kx knots are taken !  near each endpoint in the x direction, not-a-knot end conditions !  are used, and the remaining knots are placed at data points if kx !  is even or at midpoints between data points if kx is odd. the y !  direction is treated similarly.) ! !  After a call to db2ink, all information necessary to define the !  interpolating function are contained in the parameters nx, ny, kx, !  ky, tx, ty, and bcoef. These quantities should not be altered until !  after the last call of the evaluation routine [[db2val]]. ! !# History ! !  * Boisvert, Ronald, NBS : 25 may 1982 : Author of original routine. !  * JEC : 000330 modified array declarations. !  * Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. subroutine db2ink ( x , nx , y , ny , fcn , kx , ky , tx , ty , bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! Number of x abcissae integer , intent ( in ) :: ny !! Number of y abcissae integer , intent ( in ) :: kx !! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer , intent ( in ) :: ky !! The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) real ( wp ), dimension ( nx ), intent ( in ) :: x !! Array of x abcissae. Must be strictly increasing. real ( wp ), dimension ( ny ), intent ( in ) :: y !! Array of y abcissae. Must be strictly increasing. real ( wp ), dimension ( nx , ny ), intent ( in ) :: fcn !! Array of function values to interpolate. fcn(i,j) should !!    contain the function value at the point (x(i),y(j)) real ( wp ), dimension ( nx + kx ), intent ( inout ) :: tx !! The knots in the x direction for the spline interpolant. !!    If iflag=0 these are chosen by [[db2ink]]. !!    If iflag=1 these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension ( ny + ky ), intent ( inout ) :: ty !! The knots in the y direction for the spline interpolant. !!    If iflag=0 these are chosen by [[db2ink]]. !!    If iflag=1 these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension ( nx , ny ), intent ( out ) :: bcoef !! Array of coefficients of the b-spline interpolant. integer , intent ( inout ) :: iflag !! **on input:**  0 = knot sequence chosen by [[db2ink]]. !!                1 = knot sequence chosen by user. !! **on output:** 1 = successful execution. !!                2 = iflag out of range. !!                3 = nx out of range. !!                4 = kx out of range. !!                5 = x not strictly increasing. !!                6 = tx not non-decreasing. !!                7 = ny out of range. !!                8 = ky out of range. !!                9 = y not strictly increasing. !!               10 = ty not non-decreasing. real ( wp ), dimension ( nx * ny ) :: temp real ( wp ), dimension ( max ( 2 * kx * ( nx + 1 ), 2 * ky * ( ny + 1 ))) :: work logical :: status_ok !check validity of inputs call check_inputs ( 'db2ink' ,& iflag ,& nx = nx , ny = ny ,& kx = kx , ky = ky ,& x = x , y = y ,& tx = tx , ty = ty ,& status_ok = status_ok ) if ( status_ok ) then !choose knots if ( iflag == 0 ) then call dbknot ( x , nx , kx , tx ) call dbknot ( y , ny , ky , ty ) endif !construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , ny , tx , kx , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( y , ny , temp , ny , nx , ty , ky , bcoef , work , iflag ) if ( iflag == 0 ) iflag = 1 endif endsubroutine db2ink !***************************************************************************************** !***************************************************************************************** !> Evaluates the tensor product piecewise polynomial !  interpolant constructed by the routine [[db2ink]] or one of its !  derivatives at the point (xval,yval). ! !  To evaluate the interpolant !  itself, set idx=idy=0, to evaluate the first partial with respect !  to x, set idx=1,idy=0, and so on. ! !  db2val returns 0.0 if (xval,yval) is out of range. that is, if !```fortran !   xval < tx(1) .or. xval > tx(nx+kx) .or. !   yval < ty(1) .or. yval > ty(ny+ky) !``` !  if the knots tx and ty were chosen by [[db2ink]], then this is equivalent to: !```fortran !   xval < x(1) .or. xval > x(nx)+epsx .or. !   yval < y(1) .or. yval > y(ny)+epsy !``` !  where !```fortran !   epsx = 0.1*(x(nx)-x(nx-1)) !   epsy = 0.1*(y(ny)-y(ny-1)) !``` ! !  The input quantities tx, ty, nx, ny, kx, ky, and bcoef should be !  unchanged since the last call of [[db2ink]]. ! !# History ! !  * Boisvert, Ronald, NBS : 25 may 1982 : Author of original routine. !  * JEC : 000330 modified array declarations. !  * Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. subroutine db2val ( xval , yval , idx , idy , tx , ty , nx , ny , kx , ky , bcoef , f , iflag , inbvx , inbvy , iloy ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idy !! y derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db2ink]]) integer , intent ( in ) :: ny !! the number of interpolation points in y. (same as in last call to [[db2ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db2ink]]) integer , intent ( in ) :: ky !! order of polynomial pieces in y. (same as in last call to [[db2ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), intent ( in ) :: yval !! y coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db2ink]]) real ( wp ), dimension ( ny + ky ), intent ( in ) :: ty !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db2ink]]) real ( wp ), dimension ( nx , ny ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db2ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer :: k , lefty , mflag , kcol real ( wp ), dimension ( ky ) :: temp real ( wp ), dimension ( 3 * max ( kx , ky )) :: work f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then write ( error_unit , '(A)' ) 'db2val - x value out of bounds' iflag = 1 return endif if ( yval < ty ( 1 ) . or . yval > ty ( ny + ky )) then write ( error_unit , '(A)' ) 'db2val - y value out of bounds' iflag = 2 return endif iflag = - 1 call dintrv ( ty , ny + ky , yval , iloy , lefty , mflag ); if ( mflag /= 0 ) return kcol = lefty - ky do k = 1 , ky kcol = kcol + 1 temp ( k ) = dbvalu ( tx , bcoef (:, kcol ), nx , kx , idx , xval , inbvx , work , iflag ) if ( iflag /= 0 ) return !error enddo kcol = lefty - ky + 1 f = dbvalu ( ty ( kcol :), temp , ky , ky , idy , yval , inbvy , work , iflag ) endsubroutine db2val !***************************************************************************************** !***************************************************************************************** !> Check the validity of the inputs to the \"ink\" routines. !  Prints warning message if there is an error, !  and also sets iflag and status_ok. ! !  Supports up to 6D: x,y,z,q,r,s ! !# Notes ! !  The code is new, but the logic is based on the original !  logic in the CMLIB routines db2ink and db3ink. ! !# History ! !  * Jacob Williams, 2/24/2015 : Created this routine. subroutine check_inputs ( routine ,& iflag ,& nx , ny , nz , nq , nr , ns ,& kx , ky , kz , kq , kr , ks ,& x , y , z , q , r , s ,& tx , ty , tz , tq , tr , ts ,& status_ok ) implicit none character ( len =* ), intent ( in ) :: routine integer , intent ( inout ) :: iflag integer , intent ( in ), optional :: nx , ny , nz , nq , nr , ns integer , intent ( in ), optional :: kx , ky , kz , kq , kr , ks real ( wp ), dimension (:), intent ( in ), optional :: x , y , z , q , r , s real ( wp ), dimension (:), intent ( in ), optional :: tx , ty , tz , tq , tr , ts logical , intent ( out ) :: status_ok logical :: error status_ok = . false . if (( iflag < 0 ) . or . ( iflag > 1 )) then write ( error_unit , '(A,1X,I5)' ) & trim ( routine ) // ' - iflag is out of range: ' , iflag iflag = 2 else call check ( 'x' , nx , kx , x , tx ,[ 3 , 4 , 5 , 6 ], error ); if ( error ) return call check ( 'y' , ny , ky , y , ty ,[ 7 , 8 , 9 , 10 ], error ); if ( error ) return call check ( 'z' , nz , kz , z , tz ,[ 11 , 12 , 13 , 14 ], error ); if ( error ) return call check ( 'q' , nq , kq , q , tq ,[ 15 , 16 , 17 , 18 ], error ); if ( error ) return call check ( 'r' , nr , kr , r , tr ,[ 19 , 20 , 21 , 22 ], error ); if ( error ) return call check ( 's' , ns , ks , s , ts ,[ 23 , 24 , 25 , 26 ], error ); if ( error ) return status_ok = . true . endif contains subroutine check ( s , n , k , x , t , ierrs , error ) !check t,x,n,k for validity implicit none character ( len = 1 ), intent ( in ), optional :: s !! coordinate string: 'x','y','z','q','r','s' integer , intent ( in ), optional :: n !! size of x integer , intent ( in ), optional :: k !! order real ( wp ), dimension (:), intent ( in ), optional :: x !! abcissae vector real ( wp ), dimension (:), intent ( in ), optional :: t !! knot vector size(n+k) integer , dimension (:), intent ( in ) :: ierrs !! int error codes for n,k,x,t checks logical , intent ( out ) :: error !! true if there was an error if ( present ( n )) then call check_n ( 'n' // s , n , ierrs ( 1 ), error ); if ( error ) return if ( present ( k )) then call check_k ( 'k' // s , k , n , ierrs ( 2 ), error ); if ( error ) return endif if ( present ( x )) then call check_x ( s , n , x , ierrs ( 3 ), error ); if ( error ) return endif if ( iflag /= 0 ) then if ( present ( k ) . and . present ( t )) then call check_t ( 't' // s , n , k , t , ierrs ( 4 ), error ); if ( error ) return endif endif endif endsubroutine check subroutine check_n ( s , n , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n integer , intent ( in ) :: ierr logical , intent ( out ) :: error if ( n < 3 ) then write ( error_unit , '(A,1X,I5)' ) & trim ( routine ) // ' - ' // trim ( s ) // ' is out of range: ' , n iflag = ierr error = . true . else error = . false . endif endsubroutine check_n subroutine check_k ( s , k , n , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: k integer , intent ( in ) :: n integer , intent ( in ) :: ierr logical , intent ( out ) :: error if (( k < 2 ) . or . ( k >= n )) then write ( error_unit , '(A,1X,I5)' ) & trim ( routine ) // ' - ' // trim ( s ) // ' is out of range: ' , k iflag = ierr error = . true . else error = . false . endif endsubroutine check_k subroutine check_x ( s , n , x , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n real ( wp ), dimension (:), intent ( in ) :: x integer , intent ( in ) :: ierr logical , intent ( out ) :: error integer :: i error = . true . do i = 2 , n if ( x ( i ) <= x ( i - 1 )) then iflag = ierr write ( error_unit , '(A)' ) trim ( routine ) // ' - ' // trim ( s ) // & ' array must be strictly increasing' return endif enddo error = . false . endsubroutine check_x subroutine check_t ( s , n , k , t , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n integer , intent ( in ) :: k real ( wp ), dimension (:), intent ( in ) :: t integer , intent ( in ) :: ierr logical , intent ( out ) :: error integer :: i error = . true . do i = 2 , n + k if ( t ( i ) < t ( i - 1 )) then iflag = ierr write ( error_unit , '(A)' ) trim ( routine ) // ' - ' // trim ( s ) // & ' array must be non-decreasing' return endif enddo error = . false . endsubroutine check_t endsubroutine check_inputs !***************************************************************************************** !***************************************************************************************** !> dbknot chooses a knot sequence for interpolation of order k at the !  data points x(i), i=1,..,n.  the n+k knots are placed in the array !  t.  k knots are placed at each endpoint and not-a-knot end !  conditions are used.  the remaining knots are placed at data points !  if n is even and between data points if n is odd.  the rightmost !  knot is shifted slightly to the right to insure proper interpolation !  at x(n) (see page 350 of the reference). ! !# History ! !  * Jacob Williams, 2/24/2015 : Refactored this routine. subroutine dbknot ( x , n , k , t ) implicit none integer , intent ( in ) :: n integer , intent ( in ) :: k real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: t integer :: i , j , ipj , npj , ip1 , jstrt real ( wp ) :: rnot !put k knots at each endpoint !(shift right endpoints slightly -- see pg 350 of reference) rnot = x ( n ) + 0.1_wp * ( x ( n ) - x ( n - 1 ) ) do j = 1 , k t ( j ) = x ( 1 ) npj = n + j t ( npj ) = rnot enddo !distribute remaining knots if ( mod ( k , 2 ) == 1 ) then !case of odd k --  knots between data points i = ( k - 1 ) / 2 - k ip1 = i + 1 jstrt = k + 1 do j = jstrt , n ipj = i + j t ( j ) = 0.5_wp * ( x ( ipj ) + x ( ipj + 1 ) ) enddo else !case of even k --  knots at data points i = ( k / 2 ) - k jstrt = k + 1 do j = jstrt , n ipj = i + j t ( j ) = x ( ipj ) enddo endif endsubroutine dbknot !***************************************************************************************** !***************************************************************************************** !> dbtpcf computes b-spline interpolation coefficients for nf sets !  of data stored in the columns of the array fcn. the b-spline !  coefficients are stored in the rows of bcoef however. !  each interpolation is based on the n abcissa stored in the !  array x, and the n+k knots stored in the array t. the order !  of each interpolation is k. the work array must be of length !  at least 2*k*(n+1). ! !# History ! !  * Jacob Williams, 2/24/2015 : Refactored this routine. subroutine dbtpcf ( x , n , fcn , ldf , nf , t , k , bcoef , work , iflag ) integer , intent ( in ) :: n integer , intent ( in ) :: nf integer , intent ( in ) :: ldf integer , intent ( in ) :: k real ( wp ) :: x ( n ) real ( wp ) :: fcn ( ldf , nf ) real ( wp ) :: t ( * ) real ( wp ) :: bcoef ( nf , n ) real ( wp ) :: work ( * ) integer , intent ( out ) :: iflag !!   0: no errors !! 301: n should be >0 integer :: i , j , m1 , m2 , iq , iw ! check for null input if ( nf > 0 ) then ! partition work array m1 = k - 1 m2 = m1 + k iq = 1 + n iw = iq + m2 * n + 1 ! compute b-spline coefficients ! first data set call dbintk ( x , fcn , t , n , k , work , work ( iq ), work ( iw ), iflag ) if ( iflag == 0 ) then do i = 1 , n bcoef ( 1 , i ) = work ( i ) enddo !  all remaining data sets by back-substitution if ( nf == 1 ) return do j = 2 , nf do i = 1 , n work ( i ) = fcn ( i , j ) enddo call dbnslv ( work ( iq ), m2 , n , m1 , m1 , work ) do i = 1 , n bcoef ( j , i ) = work ( i ) enddo enddo endif else write ( error_unit , '(A)' ) 'dbtpcf - n should be >0' iflag = 301 endif endsubroutine dbtpcf !***************************************************************************************** !***************************************************************************************** !> dbintk produces the b-spline coefficients, bcoef, of the !  b-spline of order k with knots t(i), i=1,...,n+k, which !  takes on the value y(i) at x(i), i=1,...,n.  the spline or !  any of its derivatives can be evaluated by calls to [[dbvalu]]. ! !  the i-th equation of the linear system a*bcoef = b for the !  coefficients of the interpolant enforces interpolation at !  x(i), i=1,...,n.  hence, b(i) = y(i), for all i, and a is !  a band matrix with 2k-1 bands if a is invertible.  the matrix !  a is generated row by row and stored, diagonal by diagonal, !  in the rows of q, with the main diagonal going into row k. !  the banded system is then solved by a call to dbnfac (which !  constructs the triangular factorization for a and stores it !  again in q), followed by a call to dbnslv (which then !  obtains the solution bcoef by substitution).  dbnfac does no !  pivoting, since the total positivity of the matrix a makes !  this unnecessary.  the linear system to be solved is !  (theoretically) invertible if and only if !          t(i) < x(i) < t(i+k),        for all i. !  equality is permitted on the left for i=1 and on the right !  for i=n when k knots are used at x(1) or x(n).  otherwise, !  violation of this condition is certain to lead to an error. ! !# Error conditions ! !  * improper input !  * singular system of equations ! !# History ! !  * splint written by carl de boor [5] !  * dbintk author: amos, d. e., (snla) : date written 800901 !  * revision date 820801 !  * 000330 modified array declarations. (jec) !  * Jacob Williams, 5/10/2015 : converted to free-form Fortran. subroutine dbintk ( x , y , t , n , k , bcoef , q , work , iflag ) implicit none integer , intent ( in ) :: n !! number of data points, n >= k real ( wp ), dimension ( n ), intent ( in ) :: x !! vector of length n containing data point abscissa !! in strictly increasing order. real ( wp ), dimension ( n ), intent ( in ) :: y !! corresponding vector of length n containing data !! point ordinates. real ( wp ), dimension ( * ), intent ( in ) :: t !! knot vector of length n+k !! since t(1),..,t(k) <= x(1) and t(n+1),..,t(n+k) !! >= x(n), this leaves only n-k knots (not !! necessarily x(i) values) interior to (x(1),x(n)) integer , intent ( in ) :: k !! order of the spline, k >= 1 real ( wp ), dimension ( n ), intent ( out ) :: bcoef !! a vector of length n containing the b-spline coefficients real ( wp ), dimension ( * ), intent ( out ) :: q !! a work vector of length (2*k-1)*n, containing !! the triangular factorization of the coefficient !! matrix of the linear system being solved.  the !! coefficients for the interpolant of an !! additional data set (x(i),yy(i)), i=1,...,n !! with the same abscissa can be obtained by loading !! yy into bcoef and then executing !! call dbnslv(q,2k-1,n,k-1,k-1,bcoef) real ( wp ), dimension ( * ), intent ( out ) :: work !! work vector of length 2*k integer , intent ( out ) :: iflag !!   0: no errors. !! 100: k does not satisfy k>=1. !! 101: n does not satisfy n>=k. !! 102: x(i) does not satisfy x(i)<x(i+1) for some i. !! 103: some abscissa was not in the support of the. !! corresponding basis function and the system is singular. !! 104: the system of solver detects a singular system. !! although the theoretical conditions for a solution were satisfied. integer :: iwork , i , ilp1mx , j , jj , km1 , kpkm2 , left , lenq , np1 real ( wp ) :: xi if ( k < 1 ) then write ( error_unit , '(A)' ) 'dbintk - k does not satisfy k>=1' iflag = 100 return endif if ( n < k ) then write ( error_unit , '(A)' ) 'dbintk - n does not satisfy n>=k' iflag = 101 return endif jj = n - 1 if ( jj /= 0 ) then do i = 1 , jj if ( x ( i ) >= x ( i + 1 )) then write ( error_unit , '(A)' ) 'dbintk - x(i) does not satisfy x(i)<x(i+1) for some i' iflag = 102 return endif enddo endif np1 = n + 1 km1 = k - 1 kpkm2 = 2 * km1 left = k ! zero out all entries of q lenq = n * ( k + km1 ) do i = 1 , lenq q ( i ) = 0.0_wp enddo ! loop over i to construct the n interpolation equations do i = 1 , n xi = x ( i ) ilp1mx = min ( i + k , np1 ) ! *** find  left  in the closed interval (i,i+k-1) such that !         t(left) <= x(i) < t(left+1) ! matrix is singular if this is not possible left = max ( left , i ) if ( xi < t ( left )) then write ( error_unit , '(A)' ) 'dbintk - some abscissa was not in the support of the' // & ' corresponding basis function and the system is singular' iflag = 103 return endif do if ( xi < t ( left + 1 )) go to 30 left = left + 1 if ( left >= ilp1mx ) exit enddo left = left - 1 if ( xi > t ( left + 1 )) then write ( error_unit , '(A)' ) 'dbintk - some abscissa was not in the support of the' // & ' corresponding basis function and the system is singular' iflag = 103 return endif ! *** the i-th equation enforces interpolation at xi, hence ! a(i,j) = b(j,k,t)(xi), all j. only the  k  entries with  j = ! left-k+1,...,left actually might be nonzero. these  k  numbers ! are returned, in  bcoef (used for temp.storage here), by the ! following 30 call dbspvn ( t , k , k , 1 , xi , left , bcoef , work , iwork , iflag ) if ( iflag /= 0 ) return ! we therefore want  bcoef(j) = b(left-k+j)(xi) to go into ! a(i,left-k+j), i.e., into  q(i-(left+j)+2*k,(left+j)-k) since ! a(i+j,j)  is to go into  q(i+k,j), all i,j,  if we consider  q ! as a two-dim. array , with  2*k-1  rows (see comments in ! dbnfac). in the present program, we treat  q  as an equivalent ! one-dimensional array (because of fortran restrictions on ! dimension statements) . we therefore want  bcoef(j) to go into ! entry !     i -(left+j) + 2*k + ((left+j) - k-1)*(2*k-1) !            = i-left+1 + (left -k)*(2*k-1) + (2*k-2)*j ! of q. jj = i - left + 1 + ( left - k ) * ( k + km1 ) do j = 1 , k jj = jj + kpkm2 q ( jj ) = bcoef ( j ) enddo enddo ! obtain factorization of a, stored again in q. call dbnfac ( q , k + km1 , n , km1 , km1 , iflag ) if ( iflag == 1 ) then !success ! *** solve  a*bcoef = y  by backsubstitution do i = 1 , n bcoef ( i ) = y ( i ) enddo call dbnslv ( q , k + km1 , n , km1 , km1 , bcoef ) iflag = 0 else !failure write ( error_unit , '(A)' ) 'dbintk - the system of solver detects a singular system' // & ' although the theoretical conditions for a solution were satisfied' iflag = 104 endif endsubroutine dbintk !***************************************************************************************** !***************************************************************************************** !> Returns in w the LU-factorization (without pivoting) of the banded !  matrix a of order nrow with (nbandl + 1 + nbandu) bands or diagonals !  in the work array w . ! !  gauss elimination without pivoting is used. the routine is !  intended for use with matrices a which do not require row inter- !  changes during factorization, especially for the totally !  positive matrices which occur in spline calculations. !  the routine should not be used for an arbitrary banded matrix. ! !# Work array ! ! **Input** ! !        w array of size (nroww,nrow) contains the interesting !        part of a banded matrix  a , with the diagonals or bands of  a !        stored in the rows of  w , while columns of  a  correspond to !        columns of  w . this is the storage mode used in  linpack  and !        results in efficient innermost loops. !           explicitly,  a  has  nbandl  bands below the diagonal !                            +     1     (main) diagonal !                            +   nbandu  bands above the diagonal !        and thus, with    middle = nbandu + 1, !          a(i+j,j)  is in  w(i+middle,j)  for i=-nbandu,...,nbandl !                                              j=1,...,nrow . !        for example, the interesting entries of a (1,2)-banded matrix !        of order  9  would appear in the first  1+1+2 = 4  rows of  w !        as follows. !                          13 24 35 46 57 68 79 !                       12 23 34 45 56 67 78 89 !                    11 22 33 44 55 66 77 88 99 !                    21 32 43 54 65 76 87 98 ! !        all other entries of  w  not identified in this way with an en- !        try of  a  are never referenced . ! ! **Output** ! !  * if  iflag = 1, then !        w contains the lu-factorization of  a  into a unit lower triangu- !        lar matrix  l  and an upper triangular matrix  u (both banded) !        and stored in customary fashion over the corresponding entries !        of  a . this makes it possible to solve any particular linear !        system  a*x = b  for  x  by a !              call dbnslv ( w, nroww, nrow, nbandl, nbandu, b ) !        with the solution x  contained in  b  on return . !  * if  iflag = 2, then !        one of  nrow-1, nbandl,nbandu failed to be nonnegative, or else !        one of the potential pivots was found to be zero indicating !        that  a  does not have an lu-factorization. this implies that !        a  is singular in case it is totally positive . ! !# History ! !  * banfac written by carl de boor [5] !  * dbnfac from CMLIB [1] !  * Jacob Williams, 5/10/2015 : converted to free-form Fortran. subroutine dbnfac ( w , nroww , nrow , nbandl , nbandu , iflag ) integer , intent ( in ) :: nroww !! row dimension of the work array w. must be >= nbandl + 1 + nbandu. integer , intent ( in ) :: nrow !! matrix order integer , intent ( in ) :: nbandl !! number of bands of a below the main diagonal integer , intent ( in ) :: nbandu !! number of bands of a above the main diagonal integer , intent ( out ) :: iflag !! indicating success(=1) or failure (=2) real ( wp ), dimension ( nroww , nrow ), intent ( inout ) :: w !! work array. See header for details. integer :: i , ipk , j , jmax , k , kmax , middle , midmk , nrowm1 real ( wp ) :: factor , pivot iflag = 1 middle = nbandu + 1 ! w(middle,.) contains the main diagonal of a. nrowm1 = nrow - 1 if ( nrowm1 < 0 ) then iflag = 2 return elseif ( nrowm1 == 0 ) then if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 return endif if ( nbandl <= 0 ) then ! a is upper triangular. check that diagonal is nonzero . do i = 1 , nrowm1 if ( w ( middle , i ) == 0.0_wp ) then iflag = 2 return endif enddo if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 return endif if ( nbandu <= 0 ) then ! a is lower triangular. check that diagonal is nonzero and ! divide each column by its diagonal. do i = 1 , nrowm1 pivot = w ( middle , i ) if ( pivot == 0.0_wp ) then iflag = 2 return endif jmax = min ( nbandl , nrow - i ) do j = 1 , jmax w ( middle + j , i ) = w ( middle + j , i ) / pivot enddo enddo return endif ! a is not just a triangular matrix. construct lu factorization do i = 1 , nrowm1 ! w(middle,i)  is pivot for i-th step . pivot = w ( middle , i ) if ( pivot == 0.0_wp ) then iflag = 2 return endif ! jmax is the number of (nonzero) entries in column i ! below the diagonal. jmax = min ( nbandl , nrow - i ) ! divide each entry in column i below diagonal by pivot. do j = 1 , jmax w ( middle + j , i ) = w ( middle + j , i ) / pivot enddo ! kmax is the number of (nonzero) entries in row i to ! the right of the diagonal. kmax = min ( nbandu , nrow - i ) ! subtract a(i,i+k)*(i-th column) from (i+k)-th column ! (below row i). do k = 1 , kmax ipk = i + k midmk = middle - k factor = w ( midmk , ipk ) do j = 1 , jmax w ( midmk + j , ipk ) = w ( midmk + j , ipk ) - w ( middle + j , i ) * factor enddo enddo enddo ! check the last diagonal entry. if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 endsubroutine dbnfac !***************************************************************************************** !> Companion routine to [[dbnfac]]. it returns the solution x of the !  linear system a*x = b in place of b, given the lu-factorization !  for a in the work array w from dbnfac. ! !  (with  a = l*u , as stored in w), the unit lower triangular system !   l(u*x) = b  is solved for  y = u*x , and y stored in b. then the !  upper triangular system u*x = y  is solved for x. the calculations !  are so arranged that the innermost loops stay within columns. ! !# History ! !  * banslv written by carl de boor [5] !  * dbnslv from SLATEC library [1] !  * Jacob Williams, 5/10/2015 : converted to free-form Fortran. subroutine dbnslv ( w , nroww , nrow , nbandl , nbandu , b ) integer , intent ( in ) :: nroww !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nrow !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nbandl !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nbandu !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. real ( wp ), dimension ( nroww , nrow ), intent ( in ) :: w !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. real ( wp ), dimension ( nrow ), intent ( inout ) :: b !! **in**: right side of the system to be solved !! **out**: the solution x, of order nrow integer :: i , j , jmax , middle , nrowm1 middle = nbandu + 1 if ( nrow /= 1 ) then nrowm1 = nrow - 1 if ( nbandl /= 0 ) then ! forward pass ! for i=1,2,...,nrow-1, subtract right side(i)*(i-th column of l) !                       from right side (below i-th row). do i = 1 , nrowm1 jmax = min ( nbandl , nrow - i ) do j = 1 , jmax b ( i + j ) = b ( i + j ) - b ( i ) * w ( middle + j , i ) enddo enddo endif ! backward pass ! for i=nrow,nrow-1,...,1, divide right side(i) by i-th diagonal !                          entry of u, then subtract right side(i)*(i-th column !                          of u) from right side (above i-th row). if ( nbandu <= 0 ) then ! a is lower triangular. do i = 1 , nrow b ( i ) = b ( i ) / w ( 1 , i ) enddo return endif i = nrow do b ( i ) = b ( i ) / w ( middle , i ) jmax = min ( nbandu , i - 1 ) do j = 1 , jmax b ( i - j ) = b ( i - j ) - b ( i ) * w ( middle - j , i ) enddo i = i - 1 if ( i <= 1 ) exit enddo endif b ( 1 ) = b ( 1 ) / w ( middle , 1 ) endsubroutine dbnslv !***************************************************************************************** !***************************************************************************************** !> Calculates the value of all (possibly) nonzero basis !  functions at x of order max(jhigh,(j+1)*(index-1)), where t(k) !  <= x <= t(n+1) and j=iwork is set inside the routine on !  the first call when index=1.  ileft is such that t(ileft) <= !  x < t(ileft+1).  a call to dintrv(t,n+1,x,ilo,ileft,mflag) !  produces the proper ileft.  dbspvn calculates using the basic !  algorithm needed in dbspvd.  if only basis functions are !  desired, setting jhigh=k and index=1 can be faster than !  calling dbspvd, but extra coding is required for derivatives !  (index=2) and dbspvd is set up for this purpose. ! !  left limiting values are set up as described in dbspvd. ! !#Error Conditions ! !  * improper input ! !# History ! !  * bsplvn written by carl de boor [5] !  * dbspvn author: amos, d. e., (snla) : date written 800901 !  * revision date 820801 !  * 000330 modified array declarations.  (jec) !  * Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. subroutine dbspvn ( t , jhigh , k , index , x , ileft , vnikx , work , iwork , iflag ) implicit none real ( wp ), intent ( in ) :: t ( * ) !! knot vector of length n+k, where !! n = number of b-spline basis functions !! n = sum of knot multiplicities-k !! dimension t(ileft+jhigh) integer , intent ( in ) :: jhigh !! order of b-spline, 1 <= jhigh <= k integer , intent ( in ) :: k !! highest possible order integer , intent ( in ) :: index !! index = 1 gives basis functions of order jhigh !!       = 2 denotes previous entry with work, iwork !!         values saved for subsequent calls to !!         dbspvn. real ( wp ), intent ( in ) :: x !! argument of basis functions, t(k) <= x <= t(n+1) integer , intent ( in ) :: ileft !! largest integer such that t(ileft) <= x < t(ileft+1) real ( wp ), intent ( out ) :: vnikx ( k ) !! vector of length k for spline values. real ( wp ), intent ( out ) :: work ( * ) !! a work vector of length 2*k integer , intent ( out ) :: iwork !! a work parameter.  both work and iwork contain !! information necessary to continue for index = 2. !! when index = 1 exclusively, these are scratch !! variables and can be used for other purposes. integer , intent ( out ) :: iflag !!   0: no errors !! 201: k does not satisfy k>=1 !! 202: jhigh does not satisfy 1<=jhigh<=k !! 203: index is not 1 or 2 !! 204: x does not satisfy t(ileft)<=x<=t(ileft+1) integer :: imjp1 , ipj , jp1 , jp1ml , l real ( wp ) :: vm , vmprev ! content of j, deltam, deltap is expected unchanged between calls. ! work(i) = deltap(i), ! work(k+i) = deltam(i), i = 1,k if ( k < 1 ) then write ( error_unit , '(A)' ) 'dbspvn - k does not satisfy k>=1' iflag = 201 return endif if ( jhigh > k . or . jhigh < 1 ) then write ( error_unit , '(A)' ) 'dbspvn - jhigh does not satisfy 1<=jhigh<=k' iflag = 202 return endif if ( index < 1 . or . index > 2 ) then write ( error_unit , '(A)' ) 'dbspvn - index is not 1 or 2' iflag = 203 return endif if ( x < t ( ileft ) . or . x > t ( ileft + 1 )) then write ( error_unit , '(A)' ) 'dbspvn - x does not satisfy t(ileft)<=x<=t(ileft+1)' iflag = 204 return endif iflag = 0 if ( index == 1 ) then iwork = 1 vnikx ( 1 ) = 1.0_wp if ( iwork >= jhigh ) return endif do ipj = ileft + iwork work ( iwork ) = t ( ipj ) - x imjp1 = ileft - iwork + 1 work ( k + iwork ) = x - t ( imjp1 ) vmprev = 0.0_wp jp1 = iwork + 1 do l = 1 , iwork jp1ml = jp1 - l vm = vnikx ( l ) / ( work ( l ) + work ( k + jp1ml )) vnikx ( l ) = vm * work ( l ) + vmprev vmprev = vm * work ( k + jp1ml ) enddo vnikx ( jp1 ) = vmprev iwork = jp1 if ( iwork >= jhigh ) exit enddo endsubroutine dbspvn !***************************************************************************************** !***************************************************************************************** !> Evaluates the b-representation (t,a,n,k) of a b-spline !  at x for the function value on ideriv=0 or any of its !  derivatives on ideriv=1,2,...,k-1.  right limiting values !  (right derivatives) are returned except at the right end !  point x=t(n+1) where left limiting values are computed.  the !  spline is defined on t(k) <= x <= t(n+1).  dbvalu returns !  a fatal error message when x is outside of this interval. ! !  to compute left derivatives or left limiting values at a !  knot t(i), replace n by i-1 and set x=t(i), i=k+1,n+1. ! !#Error Conditions ! !  * improper input ! !# History ! !  * bvalue written by carl de boor [5] !  * dbvalu author: amos, d. e., (snla) : date written 800901 !  * revision date 820801 !  * 000330 modified array declarations.  (jec) !  * Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. real ( wp ) function dbvalu ( t , a , n , k , ideriv , x , inbv , work , iflag ) implicit none integer , intent ( in ) :: n !! number of b-spline coefficients. !! (sum of knot multiplicities-k) real ( wp ), dimension (:), intent ( in ) :: t !! knot vector of length n+k real ( wp ), dimension ( n ), intent ( in ) :: a !! b-spline coefficient vector of length n integer , intent ( in ) :: k !! order of the b-spline, k >= 1 integer , intent ( in ) :: ideriv !! order of the derivative, 0 <= ideriv <= k-1. !! ideriv = 0 returns the b-spline value real ( wp ), intent ( in ) :: x !! argument, t(k) <= x <= t(n+1) integer , intent ( inout ) :: inbv !! an initialization parameter which must be set !! to 1 the first time dbvalu is called. !! inbv contains information for efficient process- !! ing after the initial call and inbv must not !! be changed by the user.  distinct splines require !! distinct inbv parameters. real ( wp ), dimension (:) :: work !! work vector of length 3*k integer , intent ( out ) :: iflag !!   0: no errors !! 401: k does not satisfy k>=1 !! 402: n does not satisfy n>=k !! 403: ideriv does not satisfy 0<=ideriv<k !! 404: x is not greater than or equal to t(k) !! 405: x is not less than or equal to t(n+1) !! 406: a left limiting value cannot be obtained at t(k) integer :: i , iderp1 , ihi , ihmkmj , ilo , imk , imkpj , ipj ,& ip1 , ip1mj , j , jj , j1 , j2 , kmider , kmj , km1 , kpk , mflag real ( wp ) :: fkmj dbvalu = 0.0_wp if ( k < 1 ) then write ( error_unit , '(A)' ) 'dbvalu - k does not satisfy k>=1' iflag = 401 return endif if ( n < k ) then write ( error_unit , '(A)' ) 'dbvalu - n does not satisfy n>=k' iflag = 402 return endif if ( ideriv < 0 . or . ideriv >= k ) then write ( error_unit , '(A)' ) 'dbvalu - ideriv does not satisfy 0<=ideriv<k' iflag = 403 return endif kmider = k - ideriv ! find *i* in (k,n) such that t(i) <= x < t(i+1) ! (or, <= t(i+1) if t(i) < t(i+1) = t(n+1)). km1 = k - 1 call dintrv ( t , n + 1 , x , inbv , i , mflag ) if ( x < t ( k )) then write ( error_unit , '(A)' ) 'dbvalu - x is not greater than or equal to t(k)' iflag = 404 return endif if ( mflag /= 0 ) then if ( x > t ( i )) then write ( error_unit , '(A)' ) 'dbvalu - x is not less than or equal to t(n+1)' iflag = 405 return endif do if ( i == k ) then write ( error_unit , '(A)' ) 'dbvalu - a left limiting value cannot be obtained at t(k)' iflag = 406 return endif i = i - 1 if ( x /= t ( i )) exit enddo endif ! difference the coefficients *ideriv* times ! work(i) = aj(i), work(k+i) = dp(i), work(k+k+i) = dm(i), i=1.k imk = i - k do j = 1 , k imkpj = imk + j work ( j ) = a ( imkpj ) enddo if ( ideriv /= 0 ) then do j = 1 , ideriv kmj = k - j fkmj = real ( kmj , wp ) do jj = 1 , kmj ihi = i + jj ihmkmj = ihi - kmj work ( jj ) = ( work ( jj + 1 ) - work ( jj )) / ( t ( ihi ) - t ( ihmkmj )) * fkmj enddo enddo endif ! compute value at *x* in (t(i),(t(i+1)) of ideriv-th derivative, ! given its relevant b-spline coeff. in aj(1),...,aj(k-ideriv). if ( ideriv /= km1 ) then ip1 = i + 1 kpk = k + k j1 = k + 1 j2 = kpk + 1 do j = 1 , kmider ipj = i + j work ( j1 ) = t ( ipj ) - x ip1mj = ip1 - j work ( j2 ) = x - t ( ip1mj ) j1 = j1 + 1 j2 = j2 + 1 enddo iderp1 = ideriv + 1 do j = iderp1 , km1 kmj = k - j ilo = kmj do jj = 1 , kmj work ( jj ) = ( work ( jj + 1 ) * work ( kpk + ilo ) + work ( jj ) * & work ( k + jj )) / ( work ( kpk + ilo ) + work ( k + jj )) ilo = ilo - 1 enddo enddo endif iflag = 0 dbvalu = work ( 1 ) endfunction dbvalu !***************************************************************************************** !***************************************************************************************** !> Computes the largest integer ileft in 1 <= ileft <= lxt !  such that XT(ileft) <= x where XT(*) is a subdivision of !  the x interval. !  precisely, ! !```fortran !         if            x < XT(1)   then ileft=1,   mflag=-1 !         if   XT(i) <= x < XT(i+1) then ileft=i,   mflag=0 !         if XT(lxt) <= x           then ileft=lxt, mflag=1 !``` ! !  that is, when multiplicities are present in the break point !  to the left of x, the largest index is taken for ileft. ! !# History ! !  * interv written by carl de boor [5] !  * dintrv author: amos, d. e., (snla) : date written 800901 !  * revision date 820801 !  * Jacob Williams, 2/24/2015 : updated to free-form Fortran. subroutine dintrv ( XT , lxt , x , ilo , ileft , mflag ) implicit none integer , intent ( in ) :: lxt !! length of the XT vector real ( wp ), dimension ( lxt ), intent ( in ) :: XT !! a knot or break point vector of length lxt real ( wp ), intent ( in ) :: x !! argument integer , intent ( inout ) :: ilo !! an initialization parameter which must be set !! to 1 the first time the spline array XT is !! processed by dintrv. ilo contains information for !! efficient processing after the initial call and ilo !! must not be changed by the user.  distinct splines !! require distinct ilo parameters. integer , intent ( out ) :: ileft !! largest integer satisfying XT(ileft) <= x integer , intent ( out ) :: mflag !! signals when x lies out of bounds integer :: ihi , istep , middle ihi = ilo + 1 if ( ihi < lxt ) go to 10 if ( x >= XT ( lxt )) go to 110 if ( lxt <= 1 ) go to 90 ilo = lxt - 1 ihi = lxt 10 if ( x >= XT ( ihi )) go to 40 if ( x >= XT ( ilo )) go to 100 ! *** now x < XT(ihi) . find lower bound istep = 1 20 ihi = ilo ilo = ihi - istep if ( ilo <= 1 ) go to 30 if ( x >= XT ( ilo )) go to 70 istep = istep * 2 go to 20 30 ilo = 1 if ( x < XT ( 1 )) go to 90 go to 70 ! *** now x >= XT(ilo) . find upper bound 40 istep = 1 50 ilo = ihi ihi = ilo + istep if ( ihi >= lxt ) go to 60 if ( x < XT ( ihi )) go to 70 istep = istep * 2 go to 50 60 if ( x >= XT ( lxt )) go to 110 ihi = lxt ! *** now XT(ilo) <= x < XT(ihi) . narrow the interval 70 middle = ( ilo + ihi ) / 2 if ( middle == ilo ) go to 100 !     note. it is assumed that middle = ilo in case ihi = ilo+1 if ( x < XT ( middle )) go to 80 ilo = middle go to 70 80 ihi = middle go to 70 ! *** set output and return 90 mflag = - 1 ileft = 1 return 100 mflag = 0 ileft = ilo return 110 mflag = 1 ileft = lxt endsubroutine dintrv !***************************************************************************************** !***************************************************************************************** endmodule bspline !***************************************************************************************** !~    use bspline !~    use, intrinsic :: iso_fortran_env, only: wp => real64 !~    implicit none !~    integer, parameter :: kx = 4                          !! x bspline order !~    integer, parameter :: ky = 4                          !! y bspline order !~    integer, parameter :: idx = 0                         !! [[db2val]] input !~    integer, parameter :: idy = 0                         !! [[db2val]] input !~    integer, parameter :: nx = 2584                       !! number of points in x dimension in original grid !~    integer, parameter :: ny = 1945                       !! number of points in y dimension in original grid !~    real(wp), dimension(nx) :: x                          !! x points in original grid !~    real(wp), dimension(ny) :: y                          !! y points in original grid !~    integer, parameter :: nx_new = 4096                   !! number of points in x dimension for new grid !~    integer, parameter :: ny_new = 2048                   !! number of points in y dimension for new grid !~    real(wp), dimension(nx_new)    :: x_new               !! new grid x points !~    real(wp), dimension(ny_new)    :: y_new               !! new grid y points !~    real(wp), dimension(nx_new, ny_new) :: fcn_new        !! new grid function evaluations !~    real(wp), dimension(nx +kx) :: tx                     !! x knots !~    real(wp), dimension(ny +ky) :: ty                     !! y knots !~    real(wp), dimension(nx, ny) :: fcn_2d                 !! original grid function evaluations !~    real(wp) :: val !~    integer :: i, j !~    integer :: iflag                                      !! status flag !~    integer :: inbvx, inbvy, iloy !~    fcn_2d(i, j) = prof(i, j) !~    do i = 1, nx !~       x(i) = real(i-1,kind=wp)/(nx-1) !~    enddo !~    do j = 1, ny !~       y(j) = real(j-1,kind=wp)/(ny-1) !~    enddo !~    do i = 1, nx_new !~       x_new(i) = real(i-1,kind=wp)/(nx_new-1) !~    enddo !~    do j = 1, ny_new !~       y_new(j) = real(j-1,kind=wp)/(ny_new-1) !~    enddo !~    inbvx = 1 !~    inbvy = 1 !~    iloy  = 1 !~    iflag = 0 !~    call db2ink(x, nx, y, ny, fcn_2d, kx, ky, tx, ty, fcn_2d, iflag) !~    if (iflag/=1) error stop 'error calling db2ink' !~    errmax = 0.0_wp !~    do i = 1, nx_new !~    do j = 1, ny_new !~       call db2val(x_new(i), y_new(j), idx, idy, tx, ty, nx, ny, kx, ky, fcn_2d, val, iflag, inbvx, inbvy, iloy) !~       if (iflag/=0) error stop 'error calling db2val' !~       fcn_new(i,j) = val !~    enddo !~    enddo","loc":"sourcefile/mod_bspline.f90.html"},{"tags":"","title":"mod_sort_arrays.f90 – MUSST","text":"This file depends on sourcefile~~mod_sort_arrays.f90~~EfferentGraph sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_sort_arrays.f90~~AfferentGraph sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~mod_surfile.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_surfile.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_surfile.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_solver.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_surfile.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_solver.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 sourcefile~mod_film.f90->sourcefile~mod_surfile.f90 sourcefile~mod_film.f90->sourcefile~mod_solver.f90 var pansourcefilemod_sort_arraysf90AfferentGraph = svgPanZoom('#sourcefilemod_sort_arraysf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules sort_arrays Source Code mod_sort_arrays.f90 Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: july, 23 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **Various routines to sort real/integer arrays** !  </span> module sort_arrays use data_arch , only : I4 , R8 implicit none private public :: init_order , sort_real , sort_integer , sort_real_1real , sort_real_2real , sort_int_1real , sort_int_1int_1real , sort_real_1int contains !========================================================================================= subroutine init_order ( order ) implicit none integer ( kind = I4 ), dimension (:), intent ( out ) :: order integer ( kind = I4 ) :: i , l l = ubound ( order , 1 ) do i = 1 , l order ( i ) = i enddo return endsubroutine init_order !========================================================================================= !<@note !   Subroutine to sort a vector of integers ! @endnote !----------------------------------------------------------------------------------------- recursive subroutine sort_integer ( g , d , itabref ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d integer ( kind = I4 ), dimension (:), intent ( inout ) :: itabref integer ( kind = I4 ) :: i , j , mil integer ( kind = I4 ) :: tmp , cle i = g j = d mil = ( g + d ) / 2 cle = itabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( itabref ( i ) < cle ) i = i + 1 enddo do while ( itabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau tmp = itabref ( i ) itabref ( i ) = itabref ( j ) itabref ( j ) = tmp ! échange des éléments du vecteur position i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_integer ( g , j , itabref ) if ( d > i ) call sort_integer ( i , d , itabref ) return endsubroutine sort_integer !========================================================================================= !<@note !   Subroutine to sort a vector of reals ! @endnote !----------------------------------------------------------------------------------------- recursive subroutine sort_real ( g , d , rtabref ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d real ( kind = R8 ), dimension (:), intent ( inout ) :: rtabref integer ( kind = I4 ) :: i , j , mil real ( kind = R8 ) :: tmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau tmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = tmp ! échange des éléments du vecteur position i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_real ( g , j , rtabref ) if ( d > i ) call sort_real ( i , d , rtabref ) return endsubroutine sort_real !========================================================================================= !<@note !   Subroutine to sort a vector of reals, according a vector of reals ! @endnote !----------------------------------------------------------------------------------------- recursive subroutine sort_real_1real ( g , d , rtabref , rtab1 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d real ( kind = R8 ), dimension (:), intent ( inout ) :: rtabref real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab1 integer ( kind = I4 ) :: i , j , mil real ( kind = R8 ) :: rtmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau rtmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = rtmp ! échange des éléments du vecteur 2 rtmp = rtab1 ( i ) rtab1 ( i ) = rtab1 ( j ) rtab1 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_real_1real ( g , j , rtabref , rtab1 ) if ( d > i ) call sort_real_1real ( i , d , rtabref , rtab1 ) return endsubroutine sort_real_1real !========================================================================================= !<@note !   Subroutine to sort a vector of integers, according a vector of reals ! @endnote !----------------------------------------------------------------------------------------- recursive subroutine sort_real_1int ( g , d , rtabref , itab1 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d real ( kind = R8 ), dimension (:), intent ( inout ) :: rtabref integer ( kind = I4 ), dimension (:), intent ( inout ) :: itab1 integer ( kind = I4 ) :: i , j , mil , itmp real ( kind = R8 ) :: rtmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau rtmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = rtmp ! échange des éléments du vecteur 2 itmp = itab1 ( i ) itab1 ( i ) = itab1 ( j ) itab1 ( j ) = itmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_real_1int ( g , j , rtabref , itab1 ) if ( d > i ) call sort_real_1int ( i , d , rtabref , itab1 ) return endsubroutine sort_real_1int !========================================================================================= !<@note !   Subroutine to sort 2 vectors of reals, according a vector of reals ! @endnote !----------------------------------------------------------------------------------------- recursive subroutine sort_real_2real ( g , d , rtabref , rtab1 , rtab2 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d real ( kind = R8 ), dimension (:), intent ( inout ) :: rtabref real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab1 real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab2 integer ( kind = I4 ) :: i , j , mil real ( kind = R8 ) :: rtmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau rtmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = rtmp ! échange des éléments du vecteur 2 rtmp = rtab1 ( i ) rtab1 ( i ) = rtab1 ( j ) rtab1 ( j ) = rtmp ! échange des éléments du vecteur 3 rtmp = rtab2 ( i ) rtab2 ( i ) = rtab2 ( j ) rtab2 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_real_2real ( g , j , rtabref , rtab1 , rtab2 ) if ( d > i ) call sort_real_2real ( i , d , rtabref , rtab1 , rtab2 ) return endsubroutine sort_real_2real !========================================================================================= !<@note !   Subroutine to sort a vector of reals and a vector of integers, according a vector of integers ! @endnote !----------------------------------------------------------------------------------------- recursive subroutine sort_int_1int_1real ( g , d , itabref , itab1 , rtab2 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d integer ( kind = I4 ), dimension (:), intent ( inout ) :: itabref integer ( kind = I4 ), dimension (:), intent ( inout ) :: itab1 real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab2 integer ( kind = I4 ) :: i , j , mil , cle , itmp real ( kind = R8 ) :: rtmp i = g j = d mil = ( g + d ) / 2 cle = itabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( itabref ( i ) < cle ) i = i + 1 enddo do while ( itabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau itmp = itabref ( i ) itabref ( i ) = itabref ( j ) itabref ( j ) = itmp ! échange des éléments du vecteur 2 itmp = itab1 ( i ) itab1 ( i ) = itab1 ( j ) itab1 ( j ) = itmp ! échange des éléments du vecteur 3 rtmp = rtab2 ( i ) rtab2 ( i ) = rtab2 ( j ) rtab2 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_int_1int_1real ( g , j , itabref , itab1 , rtab2 ) if ( d > i ) call sort_int_1int_1real ( i , d , itabref , itab1 , rtab2 ) return endsubroutine sort_int_1int_1real !========================================================================================= !<@note !   Subroutine to sort a vector of reals, according a vector of integers ! @endnote !----------------------------------------------------------------------------------------- recursive subroutine sort_int_1real ( g , d , itabref , rtab1 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d integer ( kind = I4 ), dimension (:), intent ( inout ) :: itabref real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab1 integer ( kind = I4 ) :: i , j , mil , cle , itmp real ( kind = R8 ) :: rtmp i = g j = d mil = ( g + d ) / 2 cle = itabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( itabref ( i ) < cle ) i = i + 1 enddo do while ( itabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau itmp = itabref ( i ) itabref ( i ) = itabref ( j ) itabref ( j ) = itmp ! échange des éléments du vecteur 3 rtmp = rtab1 ( i ) rtab1 ( i ) = rtab1 ( j ) rtab1 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_int_1real ( g , j , itabref , rtab1 ) if ( d > i ) call sort_int_1real ( i , d , itabref , rtab1 ) return endsubroutine sort_int_1real endmodule sort_arrays","loc":"sourcefile/mod_sort_arrays.f90.html"},{"tags":"","title":"mod_data_arch.f90 – MUSST","text":"Files dependent on this one sourcefile~~mod_data_arch.f90~~AfferentGraph sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_num_par.f90 mod_num_par.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_num_par.f90 sourcefile~mod_mesh.f90 mod_mesh.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_mesh.f90 sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_surfile.f90 sourcefile~mod_fluid.f90 mod_fluid.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_fluid.f90 sourcefile~mod_data.f90 mod_data.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_data.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_solver.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_num_par.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_surfile.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_data.f90 sourcefile~mod_solver.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_gen_par.f90 mod_gen_par.f90 sourcefile~mod_solver.f90->sourcefile~mod_gen_par.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort_arrays.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_data_arch.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 sourcefile~main.f90->sourcefile~mod_solver.f90 sourcefile~main.f90->sourcefile~mod_num_par.f90 sourcefile~mod_film.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_film.f90->sourcefile~mod_num_par.f90 sourcefile~mod_film.f90->sourcefile~mod_mesh.f90 sourcefile~mod_film.f90->sourcefile~mod_surfile.f90 sourcefile~mod_elements.f90 mod_elements.f90 sourcefile~mod_film.f90->sourcefile~mod_elements.f90 sourcefile~mod_film.f90->sourcefile~mod_fluid.f90 sourcefile~mod_film.f90->sourcefile~mod_data.f90 sourcefile~mod_gen_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_num_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_mesh.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_surfile.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_surfile.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_surfile.f90 sourcefile~mod_elements.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_fluid.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_data.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_data.f90->sourcefile~mod_fluid.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 var pansourcefilemod_data_archf90AfferentGraph = svgPanZoom('#sourcefilemod_data_archf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules data_arch Source Code mod_data_arch.f90 Source Code !< author: Noël Brunetière<br/>&emsp;Arthur Francisco !  version: 1.0.0 !  date: july, 12 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **General type definition** !  </span> module data_arch use , intrinsic :: iso_fortran_env , only : output_unit , input_unit , error_unit , & int32 , int64 , & real32 , real64 implicit none public ! don't keep global iso_fortran_env parameters integer ( kind = int32 ), parameter :: I4 = int32 integer ( kind = I4 ), parameter :: I8 = int64 integer ( kind = I4 ), parameter :: R4 = real32 integer ( kind = I4 ), parameter :: R8 = real64 integer ( kind = I4 ), parameter :: HIG_I4 = huge ( 1 ) integer ( kind = I4 ), parameter :: OPU = output_unit !! *Output unit* integer ( kind = I4 ), parameter :: IPU = input_unit !! *Input unit* integer ( kind = I4 ), parameter :: ERU = error_unit !! *Error unit* real ( kind = R8 ), parameter :: UN = 1.0_R8 real ( kind = R4 ), parameter :: PI_R4 = acos ( - 1._R4 ) real ( kind = R8 ), parameter :: PI_R8 = acos ( - 1._R8 ) real ( kind = R4 ), parameter :: EPS_R4 = tiny ( 1._R4 ) real ( kind = R8 ), parameter :: EPS_R8 = tiny ( 1._R8 ) real ( kind = R8 ), parameter :: HIG_R8 = huge ( 1._R8 ) real ( kind = R8 ), parameter :: HIG_E8 = log ( HIG_R8 ) real ( kind = R8 ), parameter :: EPS_E8 = log ( EPS_R8 ) integer ( kind = I4 ), parameter :: EXPO_MAX = exponent ( HIG_R8 ) integer ( kind = I4 ) :: NB_THREADS_MAX = 1 private :: output_unit , input_unit , error_unit , int32 , int64 , real32 , real64 contains !> @note from [John Burkardt website](https://people.sc.fsu.edu/~jburkardt/f_src) subroutine get_unit ( iunit ) implicit none integer ( kind = I4 ), intent ( out ) :: iunit integer ( kind = I4 ) :: i integer ( kind = I4 ) :: ios logical ( kind = I4 ) :: lopen iunit = 0 do i = 10 , 99 if ( i /= OPU . and . i /= IPU . and . i /= ERU ) then inquire ( unit = i , opened = lopen , iostat = ios ) if ( ios == 0 ) then if ( . not . lopen ) then iunit = i return endif endif endif enddo return endsubroutine get_unit endmodule data_arch","loc":"sourcefile/mod_data_arch.f90.html"},{"tags":"","title":"dmumps_struc.f90 – MUSST","text":"Files dependent on this one sourcefile~~dmumps_struc.f90~~AfferentGraph sourcefile~dmumps_struc.f90 dmumps_struc.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~dmumps_struc.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_solver.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_solver.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 sourcefile~mod_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 var pansourcefiledmumps_strucf90AfferentGraph = svgPanZoom('#sourcefiledmumps_strucf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mumps_wrapper Source Code dmumps_struc.f90 Source Code module mumps_wrapper ! !  This file is part of MUMPS 5.1.2, released !  on Mon Oct  2 07:37:01 UTC 2017 ! ! !  Copyright 1991-2017 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria, !  University of Bordeaux. ! !  This version of MUMPS is provided to you free of charge. It is !  released under the CeCILL-C license: !  http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html ! include 'mpif.f90' INCLUDE 'dmumps_root.f90' TYPE DMUMPS_STRUC SEQUENCE ! ! This structure contains all parameters ! for the interface to the user, plus internal ! information from the solver ! ! ***************** ! INPUT PARAMETERS ! ***************** !    ----------------- !    MPI Communicator !    ----------------- INTEGER :: COMM !    ------------------ !    Problem definition !    ------------------ !    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite, !        SYM=2 general symmetric) !    Type of parallelism (PAR=1 host working, PAR=0 host not working) INTEGER :: SYM , PAR INTEGER :: JOB !    -------------------- !    Order of Input matrix !    -------------------- INTEGER :: N ! !    ---------------------------------------- !    Assembled input matrix : User interface !    ---------------------------------------- INTEGER :: NZ ! Standard integer input + bwd. compat. INTEGER ( 8 ) :: NNZ ! 64-bit integer input DOUBLE PRECISION , DIMENSION (:), POINTER :: A INTEGER , DIMENSION (:), POINTER :: IRN , JCN DOUBLE PRECISION , DIMENSION (:), POINTER :: COLSCA , ROWSCA , pad0 ! !       ------------------------------------ !       Case of distributed assembled matrix !       matrix on entry: !       ------------------------------------ INTEGER :: NZ_loc ! Standard integer input + bwd. compat. INTEGER :: pad1 INTEGER ( 8 ) :: NNZ_loc ! 64-bit integer input INTEGER , DIMENSION (:), POINTER :: IRN_loc , JCN_loc DOUBLE PRECISION , DIMENSION (:), POINTER :: A_loc , pad2 ! !    ---------------------------------------- !    Unassembled input matrix: User interface !    ---------------------------------------- INTEGER :: NELT , pad3 INTEGER , DIMENSION (:), POINTER :: ELTPTR INTEGER , DIMENSION (:), POINTER :: ELTVAR DOUBLE PRECISION , DIMENSION (:), POINTER :: A_ELT , pad4 ! !    --------------------------------------------- !    Symmetric permutation : !               PERM_IN if given by user (optional) !    --------------------------------------------- INTEGER , DIMENSION (:), POINTER :: PERM_IN ! ! ! ****************** ! INPUT/OUTPUT data ! ****************** !    -------------------------------------------------------- !    RHS / SOL_loc !    ------------- !       right-hand side and solution !    ------------------------------------------------------- DOUBLE PRECISION , DIMENSION (:), POINTER :: RHS , REDRHS DOUBLE PRECISION , DIMENSION (:), POINTER :: RHS_SPARSE DOUBLE PRECISION , DIMENSION (:), POINTER :: SOL_loc INTEGER , DIMENSION (:), POINTER :: IRHS_SPARSE INTEGER , DIMENSION (:), POINTER :: IRHS_PTR INTEGER , DIMENSION (:), POINTER :: ISOL_loc INTEGER :: LRHS , NRHS , NZ_RHS , LSOL_loc , LREDRHS INTEGER :: pad5 !    ---------------------------- !    Control parameters, !    statistics and output data !    --------------------------- INTEGER :: ICNTL ( 40 ) INTEGER :: INFO ( 40 ) INTEGER :: INFOG ( 40 ) DOUBLE PRECISION :: COST_SUBTREES DOUBLE PRECISION :: CNTL ( 15 ) DOUBLE PRECISION :: RINFO ( 40 ) DOUBLE PRECISION :: RINFOG ( 40 ) !    --------------------------------------------------------- !    Permutations computed during analysis: !       SYM_PERM: Symmetric permutation !       UNS_PERM: Column permutation (optional) !    --------------------------------------------------------- INTEGER , DIMENSION (:), POINTER :: SYM_PERM , UNS_PERM ! !    ----- !    Schur !    ----- INTEGER :: NPROW , NPCOL , MBLOCK , NBLOCK INTEGER :: SCHUR_MLOC , SCHUR_NLOC , SCHUR_LLD INTEGER :: SIZE_SCHUR DOUBLE PRECISION , DIMENSION (:), POINTER :: SCHUR DOUBLE PRECISION , DIMENSION (:), POINTER :: SCHUR_CINTERFACE INTEGER , DIMENSION (:), POINTER :: LISTVAR_SCHUR !    ------------------------------------- !    Case of distributed matrix on entry: !    DMUMPS potentially provides mapping !    ------------------------------------- INTEGER , DIMENSION (:), POINTER :: MAPPING !    -------------- !    Version number !    -------------- CHARACTER ( LEN = 30 ) :: VERSION_NUMBER !    ----------- !    Out-of-core !    ----------- CHARACTER ( LEN = 255 ) :: OOC_TMPDIR CHARACTER ( LEN = 63 ) :: OOC_PREFIX !    ------------------------------------------ !    To save the matrix in matrix market format !    ------------------------------------------ CHARACTER ( LEN = 255 ) :: WRITE_PROBLEM !    ----------- !    Save/Restore !    ----------- CHARACTER ( LEN = 255 ) :: SAVE_DIR CHARACTER ( LEN = 255 ) :: SAVE_PREFIX CHARACTER ( LEN = 7 ) :: pad8 ! ! ! ********************** ! INTERNAL Working data ! ********************* INTEGER ( 8 ) :: KEEP8 ( 150 ), MAX_SURF_MASTER INTEGER :: INST_Number !       For MPI INTEGER :: COMM_NODES , MYID_NODES , COMM_LOAD INTEGER :: MYID , NPROCS , NSLAVES INTEGER :: ASS_IRECV INTEGER :: LBUFR INTEGER :: LBUFR_BYTES INTEGER , DIMENSION (:), POINTER :: BUFR !       IS is used for the factors + workspace for contrib. blocks INTEGER , DIMENSION (:), POINTER :: IS !       IS1 (maxis1) contains working arrays computed !       and used only during analysis INTEGER , DIMENSION (:), POINTER :: IS1 !       For analysis/facto/solve phases INTEGER :: MAXIS1 , Deficiency INTEGER :: KEEP ( 500 ) !       The following data/arrays are computed during the analysis !       phase and used during the factorization and solve phases. INTEGER :: LNA INTEGER :: NBSA INTEGER , POINTER , DIMENSION (:) :: STEP , NE_STEPS , ND_STEPS !  Info for pruning tree INTEGER , POINTER , DIMENSION (:) :: Step2node !  --------------------- INTEGER , POINTER , DIMENSION (:) :: FRERE_STEPS , DAD_STEPS INTEGER , POINTER , DIMENSION (:) :: FILS , FRTPTR , FRTELT INTEGER ( 8 ), POINTER , DIMENSION (:) :: PTRAR INTEGER , POINTER , DIMENSION (:) :: NA , PROCNODE_STEPS !       The two pointer arrays computed in facto and used by the solve !          (except the factors) are PTLUST_S and PTRFAC. INTEGER , DIMENSION (:), POINTER :: PTLUST_S INTEGER ( 8 ), DIMENSION (:), POINTER :: PTRFAC !       main real working arrays for factorization/solve phases DOUBLE PRECISION , DIMENSION (:), POINTER :: S !       Information on mapping INTEGER , DIMENSION (:), POINTER :: PROCNODE !       Input matrix ready for numerical assembly !           -arrowhead format in case of assembled matrix !           -element format otherwise INTEGER , DIMENSION (:), POINTER :: INTARR DOUBLE PRECISION , DIMENSION (:), POINTER :: DBLARR !       Element entry: internal data INTEGER :: NELT_loc , LELTVAR INTEGER , DIMENSION (:), POINTER :: ELTPROC !       Candidates and node partitionning INTEGER , DIMENSION (:,:), POINTER :: CANDIDATES INTEGER , DIMENSION (:), POINTER :: ISTEP_TO_INIV2 INTEGER , DIMENSION (:), POINTER :: FUTURE_NIV2 INTEGER , DIMENSION (:,:), POINTER :: TAB_POS_IN_PERE LOGICAL , DIMENSION (:), POINTER :: I_AM_CAND !       For heterogeneous architecture INTEGER , DIMENSION (:), POINTER :: MEM_DIST !       Compressed RHS INTEGER , DIMENSION (:), POINTER :: POSINRHSCOMP_ROW LOGICAL :: POSINRHSCOMP_COL_ALLOC , pad11 INTEGER , DIMENSION (:), POINTER :: POSINRHSCOMP_COL DOUBLE PRECISION , DIMENSION (:), POINTER :: RHSCOMP !       Info on the subtrees to be used during factorization DOUBLE PRECISION , DIMENSION (:), POINTER :: MEM_SUBTREE DOUBLE PRECISION , DIMENSION (:), POINTER :: COST_TRAV INTEGER , DIMENSION (:), POINTER :: MY_ROOT_SBTR INTEGER , DIMENSION (:), POINTER :: MY_FIRST_LEAF INTEGER , DIMENSION (:), POINTER :: MY_NB_LEAF INTEGER , DIMENSION (:), POINTER :: DEPTH_FIRST INTEGER , DIMENSION (:), POINTER :: DEPTH_FIRST_SEQ INTEGER , DIMENSION (:), POINTER :: SBTR_ID INTEGER , DIMENSION (:), POINTER :: SCHED_DEP INTEGER , DIMENSION (:), POINTER :: SCHED_GRP INTEGER , DIMENSION (:), POINTER :: SCHED_SBTR INTEGER , DIMENSION (:), POINTER :: CROIX_MANU DOUBLE PRECISION , DIMENSION (:), POINTER :: WK_USER INTEGER :: NBSA_LOCAL INTEGER :: LWK_USER !    Internal control array DOUBLE PRECISION :: DKEEP ( 230 ) !    For simulating parallel out-of-core stack. DOUBLE PRECISION , DIMENSION (:), POINTER :: CB_SON_SIZE !    Instance number used/managed by the C/F77 interface INTEGER :: INSTANCE_NUMBER !    OOC management data that must persist from factorization to solve. INTEGER :: OOC_MAX_NB_NODES_FOR_ZONE INTEGER , DIMENSION (:,:), POINTER :: OOC_INODE_SEQUENCE INTEGER ( 8 ), DIMENSION (:,:), POINTER :: OOC_SIZE_OF_BLOCK INTEGER ( 8 ), DIMENSION (:,:), POINTER :: OOC_VADDR INTEGER , DIMENSION (:), POINTER :: OOC_TOTAL_NB_NODES INTEGER , DIMENSION (:), POINTER :: OOC_NB_FILES INTEGER :: OOC_NB_FILE_TYPE , pad12 INTEGER , DIMENSION (:), POINTER :: OOC_FILE_NAME_LENGTH CHARACTER , DIMENSION (:,:), POINTER :: OOC_FILE_NAMES !    Indices of nul pivots INTEGER , DIMENSION (:), POINTER :: PIVNUL_LIST !    Array needed to manage additionnal candidate processor INTEGER , DIMENSION (:,:), POINTER :: SUP_PROC , pad14 !    Lists of nodes where processors work. Built/used in solve phase. INTEGER , DIMENSION (:), POINTER :: IPTR_WORKING , WORKING !    Root structure(internal) TYPE ( DMUMPS_ROOT_STRUC ) :: root !    Low-rank INTEGER , POINTER , DIMENSION (:) :: LRGROUPS INTEGER :: NBGRP , pad13 !    Pointer encoding for FDM_F data CHARACTER ( LEN = 1 ), DIMENSION (:), POINTER :: FDM_F_ENCODING !    Pointer array encoding BLR factors pointers CHARACTER ( LEN = 1 ), DIMENSION (:), POINTER :: BLRARRAY_ENCODING !    Multicore INTEGER :: LPOOL_AFTER_L0_OMP , LPOOL_BEFORE_L0_OMP INTEGER :: L_PHYS_L0_OMP INTEGER :: L_VIRT_L0_OMP INTEGER :: LL0_OMP_MAPPING , pad15 INTEGER ( 8 ) :: THREAD_LA ! Pool before L0_OMP INTEGER , DIMENSION (:), POINTER :: IPOOL_BEFORE_L0_OMP ! Pool after L0_OMP INTEGER , DIMENSION (:), POINTER :: IPOOL_AFTER_L0_OMP ! Subtrees INTEGER , DIMENSION (:), POINTER :: PHYS_L0_OMP ! Amalgamated subtrees INTEGER , DIMENSION (:), POINTER :: VIRT_L0_OMP ! From heaviest to lowest subtree INTEGER , DIMENSION (:), POINTER :: PERM_L0_OMP ! To get leafs in global pool INTEGER , DIMENSION (:), POINTER :: PTR_LEAFS_L0_OMP ! Mapping of the subtrees INTEGER , DIMENSION (:), POINTER :: L0_OMP_MAPPING ! for RR on root DOUBLE PRECISION , DIMENSION (:), POINTER :: SINGULAR_VALUES INTEGER :: NB_SINGULAR_VALUES ! To know if OOC files are associated to a saved and so if they should be removed. LOGICAL :: ASSOCIATED_OOC_FILES END TYPE DMUMPS_STRUC endmodule mumps_wrapper","loc":"sourcefile/dmumps_struc.f90.html"},{"tags":"","title":"mod_gen_par.f90 – MUSST","text":"This file depends on sourcefile~~mod_gen_par.f90~~EfferentGraph sourcefile~mod_gen_par.f90 mod_gen_par.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_gen_par.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_gen_par.f90~~AfferentGraph sourcefile~mod_gen_par.f90 mod_gen_par.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~mod_gen_par.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_solver.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_solver.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 sourcefile~mod_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 var pansourcefilemod_gen_parf90AfferentGraph = svgPanZoom('#sourcefilemod_gen_parf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules gen_param Source Code mod_gen_par.f90 Source Code !< author: Noël Brunetière<br/>&emsp;Arthur Francisco !  version: 1.0.0 !  date: july, 12 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **MUSST general parameters** !  </span> module gen_param use data_arch , only : I4 , R8 implicit none ! codes for message integer ( kind = I4 ), parameter :: NO_MESS = 0 !! *code for no message on screen during problem solving* integer ( kind = I4 ), parameter :: PRINT_MESS = 1 !! *code for printing message during problem solving* integer ( kind = I4 ) :: SOLV_MESS = NO_MESS !! *Solver output detail control* integer ( kind = I4 ) :: VERBOSE !! *Output detail control* character ( len = 128 ) :: OUTPUT_FILE !! *When needed, output file* endmodule gen_param","loc":"sourcefile/mod_gen_par.f90.html"},{"tags":"","title":"mod_solver.f90 – MUSST","text":"This file depends on sourcefile~~mod_solver.f90~~EfferentGraph sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_gen_par.f90 mod_gen_par.f90 sourcefile~mod_solver.f90->sourcefile~mod_gen_par.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_solver.f90->sourcefile~mod_data_arch.f90 sourcefile~superlu.f90 superlu.f90 sourcefile~mod_solver.f90->sourcefile~superlu.f90 sourcefile~dmumps_struc.f90 dmumps_struc.f90 sourcefile~mod_solver.f90->sourcefile~dmumps_struc.f90 sourcefile~umfpack.f90 umfpack.f90 sourcefile~mod_solver.f90->sourcefile~umfpack.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_gen_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mod_solver.f90~~AfferentGraph sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_solver.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_solver.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 sourcefile~mod_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 var pansourcefilemod_solverf90AfferentGraph = svgPanZoom('#sourcefilemod_solverf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules solver Source Code mod_solver.f90 Source Code !< author: Noël Brunetière<br/>&emsp;Arthur Francisco !  version: 1.0.0 !  date: july, 12 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **Api for different sparse matrix solvers** !  </span> module solver use iso_c_binding , only : C_PTR , C_NULL_PTR , C_ASSOCIATED use iso_fortran_env , only : output_unit , error_unit use data_arch , only : I4 , I8 , R8 , EPS_R8 , HIG_R8 , OPU use gen_param , only : SOLV_MESS , NO_MESS , PRINT_MESS use sort_arrays , only : sort_int_1real , sort_int_1int_1real !------------------------------------------------- #if WITH_MA48 use hsl_ma48_double #endif !------------------------------------------------- use sulu_wrapper , MAT_SULU => SULU_ENV , & SULU_SAMEPATTERN => SAMEPATTERN , & SULU_FACTORED => FACTORED , & SULU_DOFACT => DOFACT !------------------------------------------------- use mumps_wrapper , MAT_MUMP => DMUMPS_STRUC !------------------------------------------------- use mumfpack , only : UMFPACK_CONTROL , & UMFPACK_STATUS , & UMFPACK_INFO , & UMFPACK_PRL , & UMFPACK_IRSTEP , & UMFPACK_NUMERIC_SIZE_ESTIMATE , & UMFPACK_PEAK_MEMORY_ESTIMATE , & UMFPACK_SIZE_OF_UNIT , & UMFPACK_DI_DEFAULTS , & UMFPACK_DI_REPORT_CONTROL , & UMFPACK_DI_FREE_NUMERIC , & UMFPACK_DI_FREE_SYMBOLIC , & UMFPACK_DI_REPORT_INFO , & S_UMFPACK_DI_SYMBOLIC , & S_UMFPACK_DI_NUMERIC , & S_UMFPACK_DI_SOLVE , & UMFPACK_A !------------------------------------------------- implicit none private #if WITH_MA48 type MAT_MA48 !! <span style=\"color:green\">All the stuff needed by *HSL_MA48*</span> type ( ZD11_TYPE ) :: zmat type ( MA48_CONTROL ) :: ctrl type ( MA48_AINFO ) :: ainf type ( MA48_FINFO ) :: finf type ( MA48_SINFO ) :: sinf type ( MA48_FACTORS ) :: fact integer ( kind = I4 ) :: fast real ( kind = R8 ), dimension ( 2 ) :: resid endtype MAT_MA48 #else type MAT_MA48 endtype MAT_MA48 #endif type MAT_UMFP !! <span style=\"color:green\">All the stuff needed by *UMFPACK*</span> type ( c_ptr ) :: c_symbolic type ( c_ptr ) :: c_numeric real ( kind = R8 ), dimension ( 0 : UMFPACK_CONTROL - 1 ) :: c_control real ( kind = R8 ), dimension ( 0 : UMFPACK_INFO - 1 ) :: c_info endtype MAT_UMFP type MAT_SOLV !! <span style=\"color:green\">MUSST high level system type</span> integer ( kind = I4 ) :: slv_t !! *solver type* logical ( kind = I4 ) :: first = . true . !! *analysis of the system to be done?* integer ( kind = I4 ) :: nn !! *number of nodes* integer ( kind = I4 ) :: ne !! *number of elements* integer ( kind = I4 ) :: nt !! *number of **a priori** non-zero terms in the matrix* integer ( kind = I4 ) :: nz !! *number of non-zero terms in the matrix* integer ( kind = I4 ) :: nvar !! *eltvar length ( if 4-nodes elt -> 2 lines X number of elemental matrices)* integer ( kind = I4 ) :: code !! *error code*   [not used yet] real ( kind = R8 ) :: error !! *error value*  [not used yet] character ( len = 1024 ) :: mess !! *message*      [not used yet] !..................................................... type ( MAT_MUMP ) :: matmump !! *matrices for mumps solver* type ( MAT_MA48 ) :: matma48 !! *matrices for ma48 solver* type ( MAT_SULU ) :: matsulu !! *matrices for SuperLu solver* type ( MAT_UMFP ) :: matumfp !! *matrices for Umfpack solver* !..................................................... integer ( kind = I4 ), dimension (:), allocatable :: eltvar !! *rows in assembled matrix* integer ( kind = I4 ), dimension (:), allocatable :: eltptr !! *element rows pointer* real ( kind = R8 ), dimension (:), allocatable :: a_elt !! *unassembled rigidity matrix* !..................................................... integer ( kind = I4 ), dimension (:), allocatable :: irow !! *line number* integer ( kind = I4 ), dimension (:), allocatable :: jcol !! *column number* integer ( kind = I4 ), dimension (:), allocatable :: jptr !! *line pointer* !..................................................... real ( kind = R8 ), dimension (:), allocatable :: b !! *right hand side vector* real ( kind = R8 ), dimension (:), allocatable :: x !! *unknwon vector* endtype MAT_SOLV !< <span style=\"color:green\">MUSST multiscale high level solver type</span> !  @note ```MS_MAT_SOLV``` is needed by MUSST, but it is useless for the present module ! type MS_MAT_SOLV type ( MAT_SOLV ) :: ts_mat !! *top-scale solver type matrices* type ( MAT_SOLV ), dimension (:), allocatable :: bs_mat !! *bottom-scale solver type matrices (table)* integer ( kind = I4 ), dimension (:), allocatable :: ass_loc_in_mat !! *table for assembly location (for parallel computation)* endtype ms_mat_solv ! Solver types integer ( kind = I4 ), parameter :: MA48 = 0 !! *code for     Ma48 solver type* integer ( kind = I4 ), parameter :: SULU = 1 !! *code for SUPER LU solver type* integer ( kind = I4 ), parameter :: MUMP = 2 !! *code for    MUMPS solver type* integer ( kind = I4 ), parameter :: UMFP = 3 !! *code for  UMFPACK solver type* ! What solver to use for bottom- or top- scale grids integer ( kind = I4 ) :: SOLVER_BS = - 1 !! *solver used for bottom scale grids* [not used by the present module] integer ( kind = I4 ) :: SOLVER_TS = - 1 !! *solver used for top scale grids* [not used by the present module] public :: MAT_SOLV , MS_MAT_SOLV , solve_syst , MUMP , UMFP , SULU , SOLVER_BS , SOLVER_TS , SOLV_MESS , convert_matrice_format contains !========================================================================================= !< @note General hat subroutine that handles the resolution steps:      <br/> !  * ```ini``` solver initialization                                    <br/> !  * ```ana``` solver analyzis when it's proposed by the solver         <br/> !  * ```fac``` solver factorization                                     <br/> !  * ```sol``` solver solution                                          <br/> !  * ```fre``` solver memory release when it's proposed by the solver   <br/> !  * ```end``` solver end !----------------------------------------------------------------------------------------- subroutine solve_syst ( mat , step ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* character ( len =* ), intent ( in ) :: step !! *'ini'=initialize, 'ana'=analyze, 'fac'=factorize, 'sol'=solve, 'fre'=free memory, 'end'=close solver* if ( index ( step , 'ini' ) /= 0 ) then ; call init_solver ( mat ) ; return ; endif if ( index ( step , 'ana' ) /= 0 ) then ; call analyse_solver ( mat ) ; return ; endif if ( index ( step , 'fac' ) /= 0 ) then ; call factorize_solver ( mat ) ; return ; endif if ( index ( step , 'sol' ) /= 0 ) then ; call solution_solver ( mat ) ; return ; endif if ( index ( step , 'fre' ) /= 0 ) then ; call freefact_solver ( mat ) ; return ; endif if ( index ( step , 'end' ) /= 0 ) then ; call close_solver ( mat ) ; return ; endif stop 'Bad step chosen in SOLVE_SYST' return endsubroutine solve_syst !========================================================================================= !> @note Subroutine to initialize the matrices of the solver !----------------------------------------------------------------------------------------- subroutine init_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr ! allocation of the system vectors: rhs and unknown allocate ( mat % b ( mat % nn ), mat % x ( mat % nn ) ) mat % b = HIG_R8 mat % x = HIG_R8 ! check solver type select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 call ma48_initialize ( factors = mat % matma48 % fact , & control = mat % matma48 % ctrl ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matma48 % ctrl % wp = - 1 mat % matma48 % ctrl % mp = - 1 mat % matma48 % ctrl % ldiag = - 1 case ( PRINT_MESS :) mat % matma48 % ctrl % ldiag = + 2 endselect #else stop 'MA48_LIB not defined' #endif case ( MUMP ) call mpi_init ( ierr ) mat % matmump % comm = MPI_COMM_WORLD mat % matmump % job = - 1 ! initialisation mat % matmump % sym = 0 ! no symetry mat % matmump % par = 1 ! MPI, host working call dmumps ( mat % matmump ) mat % matmump % icntl ( 1 ) = output_unit ! output stream for error messages mat % matmump % icntl ( 2 ) = error_unit ! output stream for diagnostic printing, statistics, and warning messages. mat % matmump % icntl ( 3 ) = error_unit ! output stream for global information, collected on the host. mat % matmump % icntl ( 4 ) = 1 ! level of printing for error, warning, and diagnostic messages. 1 : only errors mat % matmump % icntl ( 5 ) = 1 ! Specify element entry : elemental matrices if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'MUMP error, INIT_SOLVER' endif select case ( SOLV_MESS ) case ( NO_MESS ) mat % matmump % icntl ( 4 ) = 1 ! error output only case ( PRINT_MESS :) mat % matmump % icntl ( 4 ) = 3 ! all error output endselect case ( SULU ) call init_superlu ( sulu = mat % matsulu ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matsulu % options % PrintStat = 0 case ( PRINT_MESS :) mat % matsulu % options % PrintStat = 1 endselect case ( UMFP ) mat % matumfp % c_numeric = C_NULL_PTR call umfpack_di_defaults ( mat % matumfp % c_control ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matumfp % c_control ( UMFPACK_PRL ) = 1 case ( PRINT_MESS :) mat % matumfp % c_control ( UMFPACK_PRL ) = 2 endselect call umfpack_di_report_control ( mat % matumfp % c_control ) case default stop 'Unknown solver type, INIT_SOLVER' endselect return endsubroutine init_solver !========================================================================================= !> @note Subroutine to analyse, factorize (symbolic) the matrix of the system !----------------------------------------------------------------------------------------- subroutine analyse_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 mat % matma48 % zmat % row => mat % irow mat % matma48 % zmat % col => mat % jcol mat % matma48 % zmat % val => mat % a_elt mat % matma48 % zmat % n = mat % nn mat % matma48 % zmat % m = mat % nn mat % matma48 % zmat % ne = mat % nz call ma48_analyse ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & ainfo = mat % matma48 % ainf , & finfo = mat % matma48 % finf ) if ( mat % matma48 % ainf % flag < 0 ) then write ( OPU , * ) 'Failure of ma48_analyse with ainfop%flag = ' , mat % matma48 % ainf % flag stop endif #else stop 'MA48_LIB not defined' #endif case ( MUMP ) mat % matmump % eltptr => mat % eltptr mat % matmump % eltvar => mat % eltvar mat % matmump % a_elt => mat % a_elt mat % matmump % rhs => mat % b mat % matmump % n = mat % nn mat % matmump % nelt = mat % ne mat % matmump % job = 1 ! performs the analysis call dmumps ( mat % matmump ) case ( SULU ) mat % matsulu % irow => mat % irow mat % matsulu % jptr => mat % jptr mat % matsulu % a_elt => mat % a_elt mat % matsulu % b => mat % b mat % matsulu % n = mat % nn mat % matsulu % nz = mat % nz mat % matsulu % nrhs = 1 mat % matsulu % first = . true . call prep_superlu ( sulu = mat % matsulu ) case ( UMFP ) call s_umfpack_di_symbolic ( n_row = mat % nn , & n_col = mat % nn , & Ap = mat % jptr , & Ai = mat % irow , & Ax = mat % a_elt , & Symbolic = mat % matumfp % c_symbolic , & Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) case default stop 'ANALYSE_SOLVER : unknown solver type' endselect return endsubroutine analyse_solver !========================================================================================= !> @note Subroutine to factorize the matrix of the system !----------------------------------------------------------------------------------------- subroutine factorize_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 call ma48_factorize ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & finfo = mat % matma48 % finf , & fast = mat % matma48 % fast ) if ( mat % matma48 % finf % flag < 0 ) then write ( OPU , * ) 'Failure of ma48_factorize with finfo%flag = ' , mat % matma48 % finf % flag stop endif #else stop 'MA48_LIB not defined' #endif case ( MUMP ) mat % matmump % job = 2 call dmumps ( mat % matmump ) case ( SULU ) ! Just factorize once, in the case that the matrix doesn't change much if ( mat % matsulu % first ) call fact_superlu ( sulu = mat % matsulu , & verbose = ( mat % matsulu % options % PrintStat == 1 )) case ( UMFP ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! first release memory call s_umfpack_di_numeric ( Ap = mat % jptr , & Ai = mat % irow , & Ax = mat % a_elt , & Symbolic = mat % matumfp % c_symbolic , & Numeric = mat % matumfp % c_numeric , & Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) case default stop 'Unknown solver type, FACTORIZE_SOLVER' endselect return endsubroutine factorize_solver !========================================================================================= !> @note Subroutine to solve the system [A]\\{x\\} = \\{b\\} (sparse A) !----------------------------------------------------------------------------------------- subroutine solution_solver ( mat ) implicit none type ( MAT_SOLV ), target , intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 call ma48_solve ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & rhs = mat % b , & x = mat % x , & control = mat % matma48 % ctrl , & sinfo = mat % matma48 % sinf , & resid = mat % matma48 % resid , & error = mat % error ) #else stop 'MA48_LIB not defined' #endif case ( MUMP ) mat % matmump % job = 3 call dmumps ( mat % matmump ) if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'Error in SOLUTION_SOLVER' endif ! solution has been assembled on the host if ( mat % matmump % myid == 0 ) then mat % x ( 1 : mat % nn ) = mat % matmump % rhs ( 1 : mat % nn ) endif case ( SULU ) call solv_superlu ( sol_x = mat % x , & sulu = mat % matsulu , & verbose = ( mat % matsulu % options % PrintStat == 1 )) mat % matsulu % first = . false . case ( UMFP ) ! Numeric factors must exist if (. not . C_ASSOCIATED ( mat % matumfp % c_numeric )) call solve_syst ( mat , 'fac' ) mat % matumfp % c_control ( UMFPACK_IRSTEP ) = 0 ! solve ax=b, without iterative refinement ! If you want to evaluate the required RAM (Go) ! write(*,*) mat%matumfp%c_info(UMFPACK_PEAK_MEMORY_ESTIMATE)/mat%matumfp%c_info(UMFPACK_SIZE_OF_UNIT)/1e9 ! write(*,*) sizeof(mat%a_elt)/1e9 call s_umfpack_di_solve ( sys = UMFPACK_A , & x = mat % x , & b = mat % b , & numeric = mat % matumfp % c_numeric , & control = mat % matumfp % c_control , & info = mat % matumfp % c_info ) if ( mat % matumfp % c_info ( UMFPACK_STATUS ) < 0 ) then write ( OPU , * ) 'error occurred in umfpack_di_solve: ' , mat % matumfp % c_info ( UMFPACK_STATUS ) stop 'Error in SOLUTION_SOLVER' endif case default stop 'Unknown solver type, SOLUTION_SOLVER' endselect return endsubroutine solution_solver !========================================================================================= !> @note Subroutine to free the factors if applicable !----------------------------------------------------------------------------------------- subroutine freefact_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 continue #else stop 'MA48_LIB not defined' #endif case ( MUMP ) continue case ( SULU ) call free_superlu () case ( UMFP ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! free the numeric factorization case default stop 'unknown solver type, FREEFACT_SOLVER' endselect return endsubroutine freefact_solver !========================================================================================= !> @note Subroutine to close the solver !----------------------------------------------------------------------------------------- subroutine close_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr deallocate ( mat % eltptr ) deallocate ( mat % eltvar ) select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 nullify ( mat % matma48 % zmat % row ) nullify ( mat % matma48 % zmat % col ) nullify ( mat % matma48 % zmat % val ) call ma48_finalize ( factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & info = ierr ) deallocate ( mat % b , mat % x ) #else stop 'MA48_LIB not defined' #endif case ( MUMP ) if ( mat % matmump % myid == 0 ) then nullify ( mat % matmump % rhs ) nullify ( mat % matmump % eltptr ) nullify ( mat % matmump % eltvar ) nullify ( mat % matmump % a_elt ) endif ! destroy the instance (deallocate internal data structures) mat % matmump % job = - 2 call dmumps ( mat % matmump ) if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'Error MUMP in close_solver' endif call mpi_finalize ( ierr ) deallocate ( mat % b , mat % x ) case ( SULU ) call close_superlu ( sulu = mat % matsulu ) nullify ( mat % matsulu % b ) nullify ( mat % matsulu % irow ) nullify ( mat % matsulu % jptr ) nullify ( mat % matsulu % a_elt ) case ( UMFP ) deallocate ( mat % jptr , mat % irow ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! free the numeric factorization ! no lu factors (numeric) are in memory at this point. call umfpack_di_free_symbolic ( Symbolic = mat % matumfp % c_symbolic ) ! free the symbolic analysis call umfpack_di_report_info ( Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) ! print final statistics deallocate ( mat % b , mat % x ) case default stop 'Unknown solver type, close_solver' endselect return endsubroutine close_solver !========================================================================================= !> @note Subroutine to transform the Rutherford Boeing format into Harwell Boeing and triplet !----------------------------------------------------------------------------------------- subroutine convert_matrice_format ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* integer ( kind = I4 ) :: i ! ======================================================================================================================= ! Compressed Column Storage (CCS) is also called the Harwell-Boeing sparse matrix format. ! ************************************************ ! Elemental entries (example provided by MUMP): ! A1 = 1|-1  2  3| A2 = 3|2 -1  3| !      2| 2  1  1|      4|1  2 -1| !      3| 1  1  1|      5|3  2  1| => a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 1, 2, 1, 3, -1, 2, 2, 3, -1, 1) ! ! A  = 1|-1  2  3  0  0| !      2| 2  1  1  0  0| !      3| 1  1  3 -1  3| !      4| 0  0  1  2 -1| !      5| 0  0  3  2  1| => eltvar = (1, 2, 3, 3, 4, 5), it locates the elemental matrix line in the assembled matrix !                        => eltptr = (1, 4, 7), it gives the elemental matrix first entry position in eltvar (last !                                               position being size(eltvar)+1) ! ! ************************************************ ! Assembled matrix : ! A being the same, a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 3, 1, 3, -1, 2, 2, 3, -1, 1) !                    irow = ( 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5,  3, 4, 5, 3,  4, 5) !                    jptr = (1, 4, 7, 12, 15, 18) ! ! ======================================================================================================================= ! Triplet form ! ************************************************ ! For each non zero a_elt entry, returns its row and column number ! A being the same, a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 3, 1, 3, -1, 2, 2, 3, -1, 1) !                    irow = ( 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5,  3, 4, 5, 3,  4, 5) !                    jcol = ( 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3,  4, 4, 4, 5,  5, 5) call from_elemental_to_assembled ( mat = mat ) select case ( mat % slv_t ) case ( MA48 ) ! Triplet form: irow, jcol, a_elt #if WITH_MA48 continue #else stop 'MA48_LIB not defined' #endif case ( MUMP ) ! Compressed row, elemental entries chosen: eltptr, eltvar, a_elt continue case ( UMFP , SULU ) ! Compressed row, assembled form: irow, jptr, a_elt deallocate ( mat % jcol ) ! no more needed ! UMFP and SULU allocations begin at 0 (C convention) do i = 1 , mat % nn + 1 mat % jptr ( i ) = mat % jptr ( i ) - 1 enddo if ( mat % slv_t == SULU ) mat % matsulu % jptr => mat % jptr ! otherwise, matsulu%jptr will be associated to ! a deallocated part of memory do i = 1 , mat % nz mat % irow ( i ) = mat % irow ( i ) - 1 enddo case default stop 'Unknown solver type, CONVERT_MATRICE_FORMAT' endselect return endsubroutine convert_matrice_format !========================================================================================= !> @note Subroutine to transform the elemental entries into assembled CC vectors !----------------------------------------------------------------------------------------- subroutine from_elemental_to_assembled ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* integer ( kind = I4 ), pointer :: solver , nb_elt , n , ntot , nz integer ( kind = I4 ), dimension (:), pointer :: eltptr integer ( kind = I4 ), dimension (:), pointer :: eltvar real ( kind = R8 ), dimension (:), pointer :: a_elt integer ( kind = I4 ), dimension (:), pointer :: irow , jcol integer ( kind = I4 ), dimension (:), pointer :: jptr integer ( kind = I4 ) :: inelt , imatorder , i , j , ii , jj , i1 , i2 , ir1 , ir2 , jr1 , jr2 , itmp , innz , state solver => mat % slv_t nb_elt => mat % ne n => mat % nn ntot => mat % nt nz => mat % nz if ( solver == MUMP ) return ! conversion from elemental form to triplet form, perhaps with null a_elts !-------------------------------------------------------------------------- state = 0 if (. not . allocated ( mat % irow )) allocate ( mat % irow ( ntot ), stat = state ) if ( state /= 0 ) stop 'Memory allocation problem, FROM_ELEMENTAL_TO_ASSEMBLED' if (. not . allocated ( mat % jcol )) allocate ( mat % jcol ( ntot ), stat = state ) if ( state /= 0 ) stop 'Memory allocation problem, FROM_ELEMENTAL_TO_ASSEMBLED' eltptr => mat % eltptr eltvar => mat % eltvar a_elt => mat % a_elt irow => mat % irow jcol => mat % jcol jptr => mat % jptr irow ( 1 : ntot ) = - 1 jcol ( 1 : ntot ) = - 1 ii = 1 do inelt = 1 , nb_elt imatorder = eltptr ( inelt + 1 ) - eltptr ( inelt ) do i = 1 , imatorder irow ( ii :( ii + imatorder - 1 )) = eltvar ( eltptr ( inelt ): eltptr ( inelt + 1 ) - 1 ) jcol ( ii :( ii + imatorder - 1 )) = eltvar ( eltptr ( inelt ) + i - 1 ) ii = ii + imatorder enddo enddo ! where a_elt brings no contribution, rows and columns are zeroed !----------------------------------------------------------------- where ( abs ( a_elt ) < EPS_R8 ) irow = 0 jcol = 0 endwhere ! the triplet irow, jcol and a_elt is sorted according jcol !----------------------------------------------------------- call sort_int_1int_1real ( g = 1 , d = ntot , itabref = jcol ( 1 : ntot ), itab1 = irow ( 1 : ntot ), rtab2 = a_elt ( 1 : ntot )) ! column pointer determination for each new value !---------------------------------------------- if ( allocated ( mat % jptr )) deallocate ( mat % jptr ) ; allocate ( mat % jptr ( n + 1 ) ) ; jptr => mat % jptr ii = 1 do if ( jcol ( ii ) > 0 ) exit ! zeroed terms are ignored ii = ii + 1 enddo jptr ( 1 ) = ii do i = 1 , n - 1 itmp = jcol ( ii ) do ii = ii + 1 if ( jcol ( ii ) /= itmp ) exit enddo jptr ( i + 1 ) = ii enddo jptr ( n + 1 ) = ntot + 1 ! columns are already sorted; rows are now sorted for each row value !-------------------------------------------------------------------- do i = 1 , n i1 = jptr ( i ) i2 = jptr ( i + 1 ) - 1 call sort_int_1real ( g = 1 , d = i2 - i1 + 1 , itabref = irow ( i1 : i2 ), rtab1 = a_elt ( i1 : i2 )) enddo ! assembly starting from the jcol, irow and a_elt top ! for identical matrix locations, a_elts are added !----------------------------------------------------- innz = 1 jj = jptr ( 1 ) ! first non-zero element jr1 = jcol ( jj ) ir1 = irow ( jj ) jcol ( innz ) = jr1 irow ( innz ) = ir1 a_elt ( innz ) = a_elt ( jj ) do j = jj + 1 , ntot jr2 = jcol ( j ) ir2 = irow ( j ) if ( ( jr2 /= jr1 ). or .( ir2 /= ir1 ) ) then ! if row or column index has changed innz = innz + 1 ! a non-zero term is added jcol ( innz ) = jr2 irow ( innz ) = ir2 a_elt ( innz ) = a_elt ( j ) else a_elt ( innz ) = a_elt ( innz ) + a_elt ( j ) ! row and column indexes are the same, stiffness terms are added endif jr1 = jr2 ! stores (i-1) and (j-1) for further comparison ir1 = ir2 enddo nz = innz jcol ( nz + 1 : ntot ) = - 1 irow ( nz + 1 : ntot ) = - 1 a_elt ( nz + 1 : ntot ) = huge ( 1._R8 ) ! col pointer update !---------------------------------------------- jj = 1 jptr ( 1 ) = 1 do j = 1 , n - 1 itmp = jcol ( jj ) do jj = jj + 1 if ( jcol ( jj ) /= itmp ) exit enddo jptr ( j + 1 ) = jj enddo jptr ( n + 1 ) = nz + 1 nullify ( eltptr , eltvar , a_elt , irow , jcol , jptr ) return endsubroutine from_elemental_to_assembled endmodule solver","loc":"sourcefile/mod_solver.f90.html"},{"tags":"","title":"superlu.f90 – MUSST","text":"Files dependent on this one sourcefile~~superlu.f90~~AfferentGraph sourcefile~superlu.f90 superlu.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~superlu.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_solver.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_solver.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 sourcefile~mod_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 var pansourcefilesuperluf90AfferentGraph = svgPanZoom('#sourcefilesuperluf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules sulu_wrapper Source Code superlu.f90 Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: july, 12 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **A SuperLU wrapper** !  </span> module sulu_wrapper use iso_c_binding , only : C_INT , C_FLOAT , C_DOUBLE , C_CHAR , C_PTR , C_F_POINTER , C_NULL_CHAR , C_NULL_PTR implicit none private integer ( kind = 4 ), parameter :: I4 = 4 , R4 = 4 , R8 = 8 !------------------------------------------------------------------------------- ! -------------------   ENUMS -------------------------------------------------- !------------------------------------------------------------------------------- enum , bind ( c ) ! trans_t enumerator :: NOTRANS enumerator :: TRANS enumerator :: CONJ endenum enum , bind ( c ) ! fact_t enumerator :: DOFACT enumerator :: SAMEPATTERN enumerator :: SAMEPATTERN_SAMEROWPERM enumerator :: FACTORED endenum enum , bind ( c ) ! Stype_t enumerator :: SLU_NC !! *column-wise, no supernode* enumerator :: SLU_NCP !! *column-wise, column-permuted, no supernode* enumerator :: SLU_NR !! *row-wize, no supernode* enumerator :: SLU_SC !! *column-wise, supernode* enumerator :: SLU_SCP !! *supernode, column-wise, permuted* enumerator :: SLU_SR !! *row-wise, supernode* enumerator :: SLU_DN !! *Fortran style column-wise storage for dense matrix* enumerator :: SLU_NR_loc !! *distributed compressed row format* endenum enum , bind ( c ) ! Dtype_t enumerator :: SLU_S !! *single* enumerator :: SLU_D !! *double* enumerator :: SLU_C !! *single complex* enumerator :: SLU_Z !! *double complex* endenum enum , bind ( c ) ! Mtype_t enumerator :: SLU_GE !! *general* enumerator :: SLU_TRLU !! *lower triangular, unit diagonal* enumerator :: SLU_TRUU !! *upper triangular, unit diagonal* enumerator :: SLU_TRL !! *lower triangular* enumerator :: SLU_TRU !! *upper triangular* enumerator :: SLU_SYL !! *symmetric, store lower half* enumerator :: SLU_SYU !! *symmetric, store upper half* enumerator :: SLU_HEL !! *Hermitian, store lower half* enumerator :: SLU_HEU !! *Hermitian, store upper half* endenum !------------------------------------------------------------------------------- ! -------------------   DERIVED TYPES   ---------------------------------------- !------------------------------------------------------------------------------- type , bind ( c ) :: LU_STACK_T integer ( kind = C_INT ) :: size integer ( kind = C_INT ) :: used integer ( kind = C_INT ) :: top1 integer ( kind = C_INT ) :: top2 type ( C_PTR ) :: array endtype LU_STACK_T type , bind ( c ) :: EXPHEADER integer ( kind = C_INT ) :: size type ( C_PTR ) :: mem endtype EXPHEADER type , bind ( c ) :: GLOBALLU_T integer ( kind = C_INT ) :: xsup integer ( kind = C_INT ) :: supno integer ( kind = C_INT ) :: lsub integer ( kind = C_INT ) :: xlsub type ( C_PTR ) :: lusup integer ( kind = C_INT ) :: xlusup type ( C_PTR ) :: ucol integer ( kind = C_INT ) :: usub integer ( kind = C_INT ) :: xusub integer ( kind = C_INT ) :: nzlmax integer ( kind = C_INT ) :: nzumax integer ( kind = C_INT ) :: nzlumax integer ( kind = C_INT ) :: MemModel = 0 integer ( kind = C_INT ) :: num_expansions type ( EXPHEADER ) :: expanders type ( LU_STACK_T ) :: stack endtype GLOBALLU_T type , bind ( c ) :: SUPERLUSTAT_T type ( C_PTR ) :: panel_histo !! *histogram of panel size distribution* type ( C_PTR ) :: utime !! *running time at various phases* type ( C_PTR ) :: ops !! *operation count at various phases* integer ( kind = C_INT ) :: TinyPivots !! *number of tiny pivots* integer ( kind = C_INT ) :: RefineSteps !! *number of iterative refinement steps* integer ( kind = C_INT ) :: expansions !! *number of memory expansions* endtype SUPERLUSTAT_T type , bind ( c ) :: MEM_USAGE_T real ( kind = C_FLOAT ) :: for_lu real ( kind = C_FLOAT ) :: total_needed endtype MEM_USAGE_T !< @note ! Stype == ```SLU_NC``` (Also known as Harwell-Boeing sparse matrix format) ! ! Zero-based indexing is used; colptr[] has ncol+1 entries, the last one pointing beyond the last column, ! so that colptr[ncol] = nnz. ! @endnote type , bind ( c ) :: NCFORMAT integer ( kind = C_INT ) :: nnz !! *number of nonzeros in the matrix* type ( C_PTR ) :: nzval !! *pointer to array of nonzero values, packed by column* type ( C_PTR ) :: rowind !! *pointer to array of row indices of the nonzeros* type ( C_PTR ) :: colptr !! *pointer to array of beginning of columns in nzval[] and rowind[]* endtype NCFORMAT type , bind ( c ) :: SUPERMATRIX integer ( kind = C_INT ) :: Stype !! *Storage type: interprets the storage structure pointed to by Store* integer ( kind = C_INT ) :: Dtype !! *Data type* integer ( kind = C_INT ) :: Mtype !! *Matrix type: describes the mathematical property of the matrix* integer ( kind = C_INT ) :: nrow !! *number of rows* integer ( kind = C_INT ) :: ncol !! *number of columns* type ( C_PTR ) :: Store !! *pointer to the actual storage of the matrix, here, pointer to [[NCformat]]* endtype SUPERMATRIX type , bind ( c ) :: SUPERLU_OPTIONS_T !/* ! *-- This contains the options used to control the solution process. ! * ! * Fact   (fact_t) ! *        Specifies whether or not the factored form of the matrix ! *        A is supplied on entry, and if not, how the matrix A should ! *        be factorizaed. ! *        = DOFACT: The matrix A will be factorized from scratch, and the ! *             factors will be stored in L and U. ! *        = SamePattern: The matrix A will be factorized assuming ! *             that a factorization of a matrix with the same sparsity ! *             pattern was performed prior to this one. Therefore, this ! *             factorization will reuse column permutation vector ! *             ScalePermstruct->perm_c and the column elimination tree ! *             LUstruct->etree. ! *        = SamePattern_SameRowPerm: The matrix A will be factorized ! *             assuming that a factorization of a matrix with the same ! *             sparsity   pattern and similar numerical values was performed ! *             prior to this one. Therefore, this factorization will reuse ! *             both row and column scaling factors R and C, both row and ! *             column permutation vectors perm_r and perm_c, and the ! *             L & U data structures set up from the previous factorization. !! *        = FACTORED: On entry, L, U, perm_r and perm_c contain the ! *              factored form of A. If DiagScale is not NOEQUIL, the matrix ! *              A has been equilibrated with scaling factors R and C. ! * ! * Equil  (yes_no_t) ! *        Specifies whether to equilibrate the system (scale A's row and ! *        columns to have unit norm). ! * ! * ColPerm (colperm_t) ! *        Specifies what type of column permutation to use to reduce fill. ! *        = NATURAL: use the natural ordering ! *        = MMD_ATA: use minimum degree ordering on structure of A'*A ! *        = MMD_AT_PLUS_A: use minimum degree ordering on structure of A'+A ! *        = COLAMD: use approximate minimum degree column ordering ! *        = MY_PERMC: use the ordering specified by the user ! * ! * Trans  (trans_t) ! *        Specifies the form of the system of equations: ! *        = NOTRANS: A * X = B        (No transpose) ! *        = TRANS:   A**T * X = B     (Transpose) ! *        = CONJ:    A**H * X = B     (Transpose) ! * ! * IterRefine (IterRefine_t) ! *        Specifies whether to perform iterative refinement. ! *        = NO: no iterative refinement ! *        = SLU_SINGLE: perform iterative refinement in single precision ! *        = SLU_DOUBLE: perform iterative refinement in double precision ! *        = SLU_EXTRA: perform iterative refinement in extra precision ! * ! * DiagPivotThresh (double, in [0.0, 1.0]) (only for sequential SuperLU) ! *        Specifies the threshold used for a diagonal entry to be an ! *        acceptable pivot. ! * ! * SymmetricMode (yest_no_t) ! *        Specifies whether to use symmetric mode. Symmetric mode gives ! *        preference to diagonal pivots, and uses an (A'+A)-based column ! *        permutation algorithm. ! * ! * PivotGrowth (yes_no_t) ! *        Specifies whether to compute the reciprocal pivot growth. ! * ! * ConditionNumber (ues_no_t) ! *        Specifies whether to compute the reciprocal condition number. ! * ! * RowPerm (rowperm_t) (only for SuperLU_DIST or ILU) ! *        Specifies whether to permute rows of the original matrix. ! *        = NO: not to permute the rows ! *        = LargeDiag: make the diagonal large relative to the off-diagonal ! *        = MY_PERMR: use the permutation given by the user ! * ! * ILU_DropRule (int) ! *        Specifies the dropping rule: ! *     = DROP_BASIC:   Basic dropping rule, supernodal based ILUTP(tau). ! *     = DROP_PROWS:   Supernodal based ILUTP(p,tau), p = gamma * nnz(A)/n. ! *     = DROP_COLUMN:  Variant of ILUTP(p,tau), for j-th column, ! *                     p = gamma * nnz(A(:,j)). ! *     = DROP_AREA:    Variation of ILUTP, for j-th column, use ! *                     nnz(F(:,1:j)) / nnz(A(:,1:j)) to control memory. ! *     = DROP_DYNAMIC: Modify the threshold tau during factorizaion: ! *                     If nnz(L(:,1:j)) / nnz(A(:,1:j)) > gamma ! *                         tau_L(j) := MIN(tau_0, tau_L(j-1) * 2); ! *                     Otherwise ! *                         tau_L(j) := MAX(tau_0, tau_L(j-1) / 2); ! *                     tau_U(j) uses the similar rule. ! *                     NOTE: the thresholds used by L and U are separate. ! *     = DROP_INTERP:  Compute the second dropping threshold by ! *                     interpolation instead of sorting (default). ! *                     In this case, the actual fill ratio is not ! *                     guaranteed to be smaller than gamma. ! *                     Note: DROP_PROWS, DROP_COLUMN and DROP_AREA are mutually exclusive. ! *    ( Default: DROP_BASIC | DROP_AREA ) ! * ! * ILU_DropTol (double) ! *        numerical threshold for dropping. ! * ! * ILU_FillFactor (double) ! *        Gamma in the secondary dropping. ! * ! * ILU_Norm (norm_t) ! *        Specify which norm to use to measure the row size in a ! *        supernode: infinity-norm, 1-norm, or 2-norm. ! * ! * ILU_FillTol (double) ! *        numerical threshold for zero pivot perturbation. ! * ! * ILU_MILU (milu_t) ! *        Specifies which version of MILU to use. ! * ! * ILU_MILU_Dim (double) ! *        Dimension of the PDE if available. ! * ! * ReplaceTinyPivot (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether to replace the tiny diagonals by ! *        sqrt(epsilon)*||A|| during LU factorization. ! * ! * SolveInitialized (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether the initialization has been performed to the ! *        triangular solve. ! * ! * RefineInitialized (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether the initialization has been performed to the ! *        sparse matrix-vector multiplication routine needed in iterative ! *        refinement. ! * ! * PrintStat (yes_no_t) ! *        Specifies whether to print the solver's statistics. ! */ integer ( kind = C_INT ) :: Fact integer ( kind = C_INT ) :: Equil integer ( kind = C_INT ) :: ColPerm integer ( kind = C_INT ) :: Trans integer ( kind = C_INT ) :: IterRefine real ( kind = C_DOUBLE ) :: DiagPivotThresh integer ( kind = C_INT ) :: SymmetricMode integer ( kind = C_INT ) :: PivotGrowth integer ( kind = C_INT ) :: ConditionNumber integer ( kind = C_INT ) :: RowPerm integer ( kind = C_INT ) :: ILU_DropRule real ( kind = C_DOUBLE ) :: ILU_DropTol real ( kind = C_DOUBLE ) :: ILU_FillFactor integer ( kind = C_INT ) :: ILU_Norm real ( kind = C_DOUBLE ) :: ILU_FillTol integer ( kind = C_INT ) :: ILU_MILU real ( kind = C_DOUBLE ) :: ILU_MILU_Dim integer ( kind = C_INT ) :: ParSymbFact integer ( kind = C_INT ) :: ReplaceTinyPivot integer ( kind = C_INT ) :: SolveInitialized integer ( kind = C_INT ) :: RefineInitialized integer ( kind = C_INT ) :: PrintStat integer ( kind = C_INT ) :: nnzL , nnzU !! *used to store nnzs for now* integer ( kind = C_INT ) :: num_lookaheads !! *num of levels in look-ahead* integer ( kind = C_INT ) :: lookahead_etree !! *use etree computed from the serial symbolic factorization* integer ( kind = C_INT ) :: SymPattern !! *symmetric factorization* endtype SUPERLU_OPTIONS_T !------------------------------------------------------------------------------- ! -------------------   SULU GLOBAL TYPE   ------------------------------------- !------------------------------------------------------------------------------- type SULU_ENV !! <span style=\"color:green\">Global type for *SuperLU* which covers all the stuff needed</span> integer ( kind = C_INT ) :: n !! *system size* integer ( kind = C_INT ) :: nrhs !! *number of right hand sides* integer ( kind = C_INT ) :: nz !! *number on non-zero entries* integer ( kind = C_INT ) :: info !! *info returned by [[dgssvx]]* integer ( kind = C_INT ) :: lwork !! *size of workspace, not used here* logical ( kind = I4 ) :: first !! *if ```false``` the system has been factorized at least once* real ( kind = R8 ), dimension (:), pointer :: b !! *right hand side: points to [[MAT_SOLV:b]]* real ( kind = R8 ), allocatable , dimension (:) :: x !! *solution* real ( kind = R8 ), dimension (:), pointer :: a_elt !! *CC system matrix: points to [[MAT_SOLV:a_elt]]* integer ( kind = I4 ), dimension (:), pointer :: irow !! *matrix line of an a_elt element: points to [[MAT_SOLV:irow]]* integer ( kind = I4 ), dimension (:), pointer :: jptr !! *matrix column pointers: points to [[MAT_SOLV:jptr]]* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: ferr !! *estimated forward error bound for each solution vector* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: berr !! *componentwise relative backward error of each solution* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: RR !! *row scale factors for A * real ( kind = C_DOUBLE ), allocatable , dimension (:) :: CC !!*column scale factors for A* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: rpg !! *reciprocal pivot growth factor* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: rcond !!*estimate of the reciprocal condition number of the matrix A* integer ( kind = C_INT ), allocatable , dimension (:) :: perm_c !!*If A->Stype = ```SLU_NC```, Column permutation vector of size A->ncol* integer ( kind = C_INT ), allocatable , dimension (:) :: perm_r !!*If A->Stype = ```SLU_NC```, row permutation vector of size A->nrow* integer ( kind = C_INT ), allocatable , dimension (:) :: etree !! *Elimination tree* character ( len = 1 , kind = C_CHAR ) :: equed !! *form of equilibration* type ( C_PTR ) :: work !! *User supplied workspace* type ( SUPERLU_OPTIONS_T ) :: options !! *LU controls* type ( SUPERMATRIX ) :: sma !! *Matrix A in A*X=B* type ( SUPERMATRIX ) :: smb !! *On entry, the right hand side matrix* type ( SUPERMATRIX ) :: smx !! *olution matrix to the original system* type ( SUPERMATRIX ) :: sml !! *factor L from the factorization* type ( SUPERMATRIX ) :: smu !! *factor U from the factorization* type ( SUPERLUSTAT_T ) :: stat !! *statistics on runtime and floating-point operation count* type ( GLOBALLU_T ) :: Glu !! *first, an output with the whole stuff LU; next, an input for other resolutions with same sparsity* type ( MEM_USAGE_T ) :: mem_usage !! *memory usage statistics* endtype SULU_ENV !------------------------------------------------------------------------------- ! -------------------   INTERFACES   ------------------------------------------- !------------------------------------------------------------------------------- interface !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine Destroy_SuperNode_Matrix ( A ) & ! bind ( c , name = \"Destroy_SuperNode_Matrix\" ) import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( in ) :: A endsubroutine Destroy_SuperNode_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine Destroy_SuperMatrix_Store ( A ) & ! bind ( c , name = \"Destroy_SuperMatrix_Store\" ) import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( in ) :: A endsubroutine Destroy_SuperMatrix_Store !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine Destroy_CompCol_Matrix ( A ) & ! bind ( c , name = \"Destroy_CompCol_Matrix\" ) import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( in ) :: A endsubroutine Destroy_CompCol_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine Destroy_Dense_Matrix ( A ) & ! bind ( c , name = \"Destroy_Dense_Matrix\" ) import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( in ) :: A endsubroutine Destroy_Dense_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine StatInit ( stat ) & ! bind ( c , name = \"StatInit\" ) import :: SUPERLUSTAT_T implicit none type ( SUPERLUSTAT_T ), intent ( out ) :: stat endsubroutine StatInit !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine StatFree ( stat ) & ! bind ( c , name = \"StatFree\" ) import :: SUPERLUSTAT_T implicit none type ( SUPERLUSTAT_T ), intent ( in ) :: stat endsubroutine StatFree !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine dCreate_CompCol_Matrix ( A , & ! out SuperMatrix m , & ! in int n , & ! in int nnz , & ! in int nzval , & ! in double dimension() rowind , & ! in int dimension() colptr , & ! in int dimension() stype , & ! in int dtype , & ! in int mtype & ! in int ) & bind ( c , name = \"dCreate_CompCol_Matrix\" ) use , intrinsic :: iso_c_binding , only : C_INT , C_DOUBLE import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( out ) :: A integer ( kind = C_INT ), value , intent ( in ) :: m integer ( kind = C_INT ), value , intent ( in ) :: n integer ( kind = C_INT ), value , intent ( in ) :: nnz real ( kind = C_DOUBLE ), intent ( in ) :: nzval ( * ) integer ( kind = C_INT ), intent ( in ) :: rowind ( * ) integer ( kind = C_INT ), intent ( in ) :: colptr ( * ) integer ( kind = C_INT ), value , intent ( in ) :: stype integer ( kind = C_INT ), value , intent ( in ) :: dtype integer ( kind = C_INT ), value , intent ( in ) :: mtype endsubroutine dCreate_CompCol_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine dCreate_Dense_Matrix ( BX , & ! out SuperMatrix m , & ! in int n , & ! in int x , & ! in double dimension() ldx , & ! in int stype , & ! in int dtype , & ! in int mtype & ! in int ) & bind ( c , name = 'dCreate_Dense_Matrix' ) use , intrinsic :: iso_c_binding , only : C_INT , C_DOUBLE import SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( out ) :: BX integer ( kind = C_INT ), value , intent ( in ) :: m integer ( kind = C_INT ), value , intent ( in ) :: n real ( kind = C_DOUBLE ), intent ( in ) :: x ( * ) integer ( kind = C_INT ), value , intent ( in ) :: ldx integer ( kind = C_INT ), value , intent ( in ) :: stype integer ( kind = C_INT ), value , intent ( in ) :: dtype integer ( kind = C_INT ), value , intent ( in ) :: mtype endsubroutine dCreate_Dense_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine set_default_options ( options ) & ! bind ( c , name = 'set_default_options' ) use , intrinsic :: iso_c_binding import SUPERLU_OPTIONS_T implicit none type ( SUPERLU_OPTIONS_T ), intent ( inout ) :: options endsubroutine set_default_options !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . !/*! Arguments ! * ! * <pre> ! * Purpose ! * ======= ! * ! * DGSSVX solves the system of linear equations A*X=B or A'*X=B, using ! * the LU factorization from dgstrf(). Error bounds on the solution and ! * a condition estimate are also provided. It performs the following steps: ! * ! *   1. If A is stored column-wise (A->Stype = SLU_NC): ! * ! *      1.1. If options->Equil = YES, scaling factors are computed to ! *           equilibrate the system: ! *           options->Trans = NOTRANS: ! *               diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B ! *           options->Trans = TRANS: ! *               (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B ! *           options->Trans = CONJ: ! *               (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B ! *           Whether or not the system will be equilibrated depends on the ! *           scaling of the matrix A, but if equilibration is used, A is ! *           overwritten by diag(R)*A*diag(C) and B by diag(R)*B ! *           (if options->Trans=NOTRANS) or diag(C)*B (if options->Trans ! *           = TRANS or CONJ). ! * ! *      1.2. Permute columns of A, forming A*Pc, where Pc is a permutation ! *           matrix that usually preserves sparsity. ! *           For more details of this step, see sp_preorder.c. ! * ! *      1.3. If options->Fact != FACTORED, the LU decomposition is used to ! *           factor the matrix A (after equilibration if options->Equil = YES) ! *           as Pr*A*Pc = L*U, with Pr determined by partial pivoting. ! * ! *      1.4. Compute the reciprocal pivot growth factor. ! * ! *      1.5. If some U(i,i) = 0, so that U is exactly singular, then the ! *           routine returns with info = i. Otherwise, the factored form of ! *           A is used to estimate the condition number of the matrix A. If ! *           the reciprocal of the condition number is less than machine ! *           precision, info = A->ncol+1 is returned as a warning, but the ! *           routine still goes on to solve for X and computes error bounds ! *           as described below. ! * ! *      1.6. The system of equations is solved for X using the factored form ! *           of A. ! * ! *      1.7. If options->IterRefine != NOREFINE, iterative refinement is ! *           applied to improve the computed solution matrix and calculate ! *           error bounds and backward error estimates for it. ! * ! *      1.8. If equilibration was used, the matrix X is premultiplied by ! *           diag(C) (if options->Trans = NOTRANS) or diag(R) ! *           (if options->Trans = TRANS or CONJ) so that it solves the ! *           original system before equilibration. ! * ! *   2. If A is stored row-wise (A->Stype = SLU_NR), apply the above algorithm ! *      to the transpose of A: ! * ! *      2.1. If options->Equil = YES, scaling factors are computed to ! *           equilibrate the system: ! *           options->Trans = NOTRANS: ! *               diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B ! *           options->Trans = TRANS: ! *               (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B ! *           options->Trans = CONJ: ! *               (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B ! *           Whether or not the system will be equilibrated depends on the ! *           scaling of the matrix A, but if equilibration is used, A' is ! *           overwritten by diag(R)*A'*diag(C) and B by diag(R)*B ! *           (if trans='N') or diag(C)*B (if trans = 'T' or 'C'). ! * ! *      2.2. Permute columns of transpose(A) (rows of A), ! *           forming transpose(A)*Pc, where Pc is a permutation matrix that ! *           usually preserves sparsity. ! *           For more details of this step, see sp_preorder.c. ! * ! *      2.3. If options->Fact != FACTORED, the LU decomposition is used to ! *           factor the transpose(A) (after equilibration if ! *           options->Fact = YES) as Pr*transpose(A)*Pc = L*U with the ! *           permutation Pr determined by partial pivoting. ! * ! *      2.4. Compute the reciprocal pivot growth factor. ! * ! *      2.5. If some U(i,i) = 0, so that U is exactly singular, then the ! *           routine returns with info = i. Otherwise, the factored form ! *           of transpose(A) is used to estimate the condition number of the ! *           matrix A. If the reciprocal of the condition number ! *           is less than machine precision, info = A->nrow+1 is returned as ! *           a warning, but the routine still goes on to solve for X and ! *           computes error bounds as described below. ! * ! *      2.6. The system of equations is solved for X using the factored form ! *           of transpose(A). ! * ! *      2.7. If options->IterRefine != NOREFINE, iterative refinement is ! *           applied to improve the computed solution matrix and calculate ! *           error bounds and backward error estimates for it. ! * ! *      2.8. If equilibration was used, the matrix X is premultiplied by ! *           diag(C) (if options->Trans = NOTRANS) or diag(R) ! *           (if options->Trans = TRANS or CONJ) so that it solves the ! *           original system before equilibration. ! * ! *   See supermatrix.h for the definition of 'SuperMatrix' structure. ! * ! * Arguments ! * ========= ! * ! * options (input) superlu_options_t* ! *         The structure defines the input parameters to control ! *         how the LU decomposition will be performed and how the ! *         system will be solved. ! * ! * A       (input/output) SuperMatrix* ! *         Matrix A in A*X=B, of dimension (A->nrow, A->ncol). The number ! *         of the linear equations is A->nrow. Currently, the type of A can be: ! *         Stype = SLU_NC or SLU_NR, Dtype = SLU_D, Mtype = SLU_GE. ! *         In the future, more general A may be handled. ! * ! *         On entry, If options->Fact = FACTORED and equed is not 'N', ! *         then A must have been equilibrated by the scaling factors in ! *         R and/or C. ! *         On exit, A is not modified if options->Equil = NO, or if ! *         options->Equil = YES but equed = 'N' on exit. ! *         Otherwise, if options->Equil = YES and equed is not 'N', ! *         A is scaled as follows: ! *         If A->Stype = SLU_NC: ! *           equed = 'R':  A := diag(R) * A ! *           equed = 'C':  A := A * diag(C) ! *           equed = 'B':  A := diag(R) * A * diag(C). ! *         If A->Stype = SLU_NR: ! *           equed = 'R':  transpose(A) := diag(R) * transpose(A) ! *           equed = 'C':  transpose(A) := transpose(A) * diag(C) ! *           equed = 'B':  transpose(A) := diag(R) * transpose(A) * diag(C). ! * ! * perm_c  (input/output) int* ! *         If A->Stype = SLU_NC, Column permutation vector of size A->ncol, ! *         which defines the permutation matrix Pc; perm_c[i] = j means ! *         column i of A is in position j in A*Pc. ! *         On exit, perm_c may be overwritten by the product of the input ! *         perm_c and a permutation that postorders the elimination tree ! *         of Pc'*A'*A*Pc; perm_c is not changed if the elimination tree ! *         is already in postorder. ! * ! *         If A->Stype = SLU_NR, column permutation vector of size A->nrow, ! *         which describes permutation of columns of transpose(A) ! *         (rows of A) as described above. ! * ! * perm_r  (input/output) int* ! *         If A->Stype = SLU_NC, row permutation vector of size A->nrow, ! *         which defines the permutation matrix Pr, and is determined ! *         by partial pivoting.  perm_r[i] = j means row i of A is in ! *         position j in Pr*A. ! * ! *         If A->Stype = SLU_NR, permutation vector of size A->ncol, which ! *         determines permutation of rows of transpose(A) ! *         (columns of A) as described above. ! * ! *         If options->Fact = SamePattern_SameRowPerm, the pivoting routine ! *         will try to use the input perm_r, unless a certain threshold ! *         criterion is violated. In that case, perm_r is overwritten by a ! *         new permutation determined by partial pivoting or diagonal ! *         threshold pivoting. ! *         Otherwise, perm_r is output argument. ! * ! * etree   (input/output) int*,  dimension (A->ncol) ! *         Elimination tree of Pc'*A'*A*Pc. ! *         If options->Fact != FACTORED and options->Fact != DOFACT, ! *         etree is an input argument, otherwise it is an output argument. ! *         Note: etree is a vector of parent pointers for a forest whose ! *         vertices are the integers 0 to A->ncol-1; etree[root]==A->ncol. ! * ! * equed   (input/output) char* ! *         Specifies the form of equilibration that was done. ! *         = 'N': No equilibration. ! *         = 'R': Row equilibration, i.e., A was premultiplied by diag(R). ! *         = 'C': Column equilibration, i.e., A was postmultiplied by diag(C). ! *         = 'B': Both row and column equilibration, i.e., A was replaced ! *                by diag(R)*A*diag(C). ! *         If options->Fact = FACTORED, equed is an input argument, ! *         otherwise it is an output argument. ! * ! * R       (input/output) double*, dimension (A->nrow) ! *         The row scale factors for A or transpose(A). ! *         If equed = 'R' or 'B', A (if A->Stype = SLU_NC) or transpose(A) ! *             (if A->Stype = SLU_NR) is multiplied on the left by diag(R). ! *         If equed = 'N' or 'C', R is not accessed. ! *         If options->Fact = FACTORED, R is an input argument, ! *             otherwise, R is output. ! *         If options->zFact = FACTORED and equed = 'R' or 'B', each element ! *             of R must be positive. ! * ! * C       (input/output) double*, dimension (A->ncol) ! *         The column scale factors for A or transpose(A). ! *         If equed = 'C' or 'B', A (if A->Stype = SLU_NC) or transpose(A) ! *             (if A->Stype = SLU_NR) is multiplied on the right by diag(C). ! *         If equed = 'N' or 'R', C is not accessed. ! *         If options->Fact = FACTORED, C is an input argument, ! *             otherwise, C is output. ! *         If options->Fact = FACTORED and equed = 'C' or 'B', each element ! *             of C must be positive. ! * ! * L       (output) SuperMatrix* ! *         The factor L from the factorization ! *             Pr*A*Pc=L*U              (if A->Stype SLU_= NC) or ! *             Pr*transpose(A)*Pc=L*U   (if A->Stype = SLU_NR). ! *         Uses compressed row subscripts storage for supernodes, i.e., ! *         L has types: Stype = SLU_SC, Dtype = SLU_D, Mtype = SLU_TRLU. ! * ! * U       (output) SuperMatrix* ! *         The factor U from the factorization ! *             Pr*A*Pc=L*U              (if A->Stype = SLU_NC) or ! *             Pr*transpose(A)*Pc=L*U   (if A->Stype = SLU_NR). ! *         Uses column-wise storage scheme, i.e., U has types: ! *         Stype = SLU_NC, Dtype = SLU_D, Mtype = SLU_TRU. ! * ! * work    (workspace/output) void*, size (lwork) (in bytes) ! *         User supplied workspace, should be large enough ! *         to hold data structures for factors L and U. ! *         On exit, if fact is not 'F', L and U point to this array. ! * ! * lwork   (input) int ! *         Specifies the size of work array in bytes. ! *         = 0:  allocate space internally by system malloc; ! *         > 0:  use user-supplied work array of length lwork in bytes, ! *               returns error if space runs out. ! *         = -1: the routine guesses the amount of space needed without ! *               performing the factorization, and returns it in ! *               mem_usage->total_needed; no other side effects. ! * ! *         See argument 'mem_usage' for memory usage statistics. ! * ! * B       (input/output) SuperMatrix* ! *         B has types: Stype = SLU_DN, Dtype = SLU_D, Mtype = SLU_GE. ! *         On entry, the right hand side matrix. ! *         If B->ncol = 0, only LU decomposition is performed, the triangular ! *                         solve is skipped. ! *         On exit, ! *            if equed = 'N', B is not modified; otherwise ! *            if A->Stype = SLU_NC: ! *               if options->Trans = NOTRANS and equed = 'R' or 'B', ! *                  B is overwritten by diag(R)*B; ! *               if options->Trans = TRANS or CONJ and equed = 'C' of 'B', ! *                  B is overwritten by diag(C)*B; ! *            if A->Stype = SLU_NR: ! *               if options->Trans = NOTRANS and equed = 'C' or 'B', ! *                  B is overwritten by diag(C)*B; ! *               if options->Trans = TRANS or CONJ and equed = 'R' of 'B', ! *                  B is overwritten by diag(R)*B. ! * ! * X       (output) SuperMatrix* ! *         X has types: Stype = SLU_DN, Dtype = SLU_D, Mtype = SLU_GE. ! *         If info = 0 or info = A->ncol+1, X contains the solution matrix ! *         to the original system of equations. Note that A and B are modified ! *         on exit if equed is not 'N', and the solution to the equilibrated ! *         system is inv(diag(C))*X if options->Trans = NOTRANS and ! *         equed = 'C' or 'B', or inv(diag(R))*X if options->Trans = 'T' or 'C' ! *         and equed = 'R' or 'B'. ! * ! * recip_pivot_growth (output) double* ! *         The reciprocal pivot growth factor max_j( norm(A_j)/norm(U_j) ). ! *         The infinity norm is used. If recip_pivot_growth is much less ! *         than 1, the stability of the LU factorization could be poor. ! * ! * rcond   (output) double* ! *         The estimate of the reciprocal condition number of the matrix A ! *         after equilibration (if done). If rcond is less than the machine ! *         precision (in particular, if rcond = 0), the matrix is singular ! *         to working precision. This condition is indicated by a return ! *         code of info > 0. ! * ! * FERR    (output) double*, dimension (B->ncol) ! *         The estimated forward error bound for each solution vector ! *         X(j) (the j-th column of the solution matrix X). ! *         If XTRUE is the true solution corresponding to X(j), FERR(j) ! *         is an estimated upper bound for the magnitude of the largest ! *         element in (X(j) - XTRUE) divided by the magnitude of the ! *         largest element in X(j).  The estimate is as reliable as ! *         the estimate for RCOND, and is almost always a slight ! *         overestimate of the true error. ! *         If options->IterRefine = NOREFINE, ferr = 1.0. ! * ! * BERR    (output) double*, dimension (B->ncol) ! *         The componentwise relative backward error of each solution ! *         vector X(j) (i.e., the smallest relative change in ! *         any element of A or B that makes X(j) an exact solution). ! *         If options->IterRefine = NOREFINE, berr = 1.0. ! * ! * Glu      (input/output) GlobalLU_t * ! *          If options->Fact == SamePattern_SameRowPerm, it is an input; ! *              The matrix A will be factorized assuming that a ! *              factorization of a matrix with the same sparsity pattern ! *              and similar numerical values was performed prior to this one. ! *              Therefore, this factorization will reuse both row and column ! *              scaling factors R and C, both row and column permutation ! *              vectors perm_r and perm_c, and the L & U data structures ! *              set up from the previous factorization. ! *          Otherwise, it is an output. ! * ! * mem_usage (output) mem_usage_t* ! *         Record the memory usage statistics, consisting of following fields: ! *         - for_lu (float) ! *           The amount of space used in bytes for L\\U data structures. ! *         - total_needed (float) ! *           The amount of space needed in bytes to perform factorization. ! *         - expansions (int) ! *           The number of memory expansions during the LU factorization. ! * ! * stat   (output) SuperLUStat_t* ! *        Record the statistics on runtime and floating-point operation count. ! *        See slu_util.h for the definition of 'SuperLUStat_t'. ! * ! * info    (output) int* ! *         = 0: successful exit ! *         < 0: if info = -i, the i-th argument had an illegal value ! *         > 0: if info = i, and i is ! *              <= A->ncol: U(i,i) is exactly zero. The factorization has ! *                    been completed, but the factor U is exactly ! *                    singular, so the solution and error bounds ! *                    could not be computed. ! *              = A->ncol+1: U is nonsingular, but RCOND is less than machine ! *                    precision, meaning that the matrix is singular to ! *                    working precision. Nevertheless, the solution and ! *                    error bounds are computed because there are a number ! *                    of situations where the computed solution can be more ! *                    accurate than the value of RCOND would suggest. ! *              > A->ncol+1: number of bytes allocated when memory allocation ! *                    failure occurred, plus A->ncol. ! * </pre> ! */ subroutine dgssvx (& ! argument                 |     type           |   C def           |  C call options , & ! superlu_options_t   *options             &options A , & ! SuperMatrix         *A                   &A1 perm_c , & ! int                 *perm_c               perm_c perm_r , & ! int                 *perm_r               perm_r etree , & ! int                 *etree                etree equed , & ! char                *equed                equed R , & ! double              *R                    R C , & ! double              *C                    C L , & ! SuperMatrix         *L                   &L U , & ! SuperMatrix         *U                   &U work , & ! void                *work                 work lwork , & ! int                  lwork                lwork B , & ! SuperMatrix         *B                   &B1 X , & ! SuperMatrix         *X                   &X recip_pivot_growth , & ! double              *recip_pivot_growth  &rpg rcond , & ! double              *rcond               &rcond ferr , & ! double              *ferr                 ferr berr , & ! double              *berr                 berr Glu , & ! GlobalLU_t          *Glu                 &Glu mem_usage , & ! mem_usage_t         *mem_usage           &smem_usage stat , & ! SuperLUStat_t       *stat                &stat info & ! int                 *info                &info ) & bind ( c , name = 'dgssvx' ) use , intrinsic :: iso_c_binding , only : C_INT , C_CHAR , C_DOUBLE , C_PTR import :: SUPERLU_OPTIONS_T , SUPERMATRIX , SUPERLUSTAT_T , MEM_USAGE_T , GLOBALLU_T implicit none type ( SUPERLU_OPTIONS_T ), intent ( in ) :: options type ( SUPERMATRIX ), intent ( inout ) :: A integer ( kind = C_INT ), intent ( inout ) :: perm_c ( * ) integer ( kind = C_INT ), intent ( inout ) :: perm_r ( * ) integer ( kind = C_INT ), intent ( inout ) :: etree ( * ) character ( kind = C_CHAR ), intent ( inout ) :: equed ( * ) real ( kind = C_DOUBLE ), intent ( inout ) :: R ( * ) real ( kind = C_DOUBLE ), intent ( inout ) :: C ( * ) type ( SUPERMATRIX ), intent ( inout ) :: L type ( SUPERMATRIX ), intent ( inout ) :: U type ( C_PTR ), intent ( out ) :: work integer ( kind = C_INT ), value , intent ( in ) :: lwork type ( SUPERMATRIX ), intent ( inout ) :: B type ( SUPERMATRIX ), intent ( out ) :: X real ( kind = C_DOUBLE ), intent ( out ) :: recip_pivot_growth ( * ) real ( kind = C_DOUBLE ), intent ( out ) :: rcond ( * ) real ( kind = C_DOUBLE ), intent ( out ) :: ferr ( * ) real ( kind = C_DOUBLE ), intent ( out ) :: berr ( * ) type ( GLOBALLU_T ), intent ( inout ) :: Glu type ( MEM_USAGE_T ), intent ( out ) :: mem_usage type ( SUPERLUSTAT_T ), intent ( out ) :: stat integer ( kind = C_INT ), intent ( out ) :: info endsubroutine dgssvx !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine StatPrint ( stat ) & ! bind ( c , name = \"StatPrint\" ) import :: SUPERLUSTAT_T implicit none type ( SUPERLUSTAT_T ), intent ( in ) :: stat endsubroutine StatPrint !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . endinterface public :: sulu_env , init_superlu , prep_superlu , fact_superlu , solv_superlu , free_superlu , close_superlu , Destroy_CompCol_Matrix , Destroy_SuperNode_Matrix , & SAMEPATTERN , FACTORED , DOFACT contains !========================================================================================= !< @note ! **Subroutine to set the default LU behaviour** ! ! + sulu%options%Fact               = ```DOFACT``` ! + sulu%options%Equil              = ```YES``` ! + sulu%options%ColPerm            = ```COLAMD``` ! + sulu%options%DiagPivotThresh    = ```1.0``` ! + sulu%options%Trans              = ```NOTRANS``` ! + sulu%options%IterRefine         = ```NOREFINE``` ! + sulu%options%SymmetricMode      = ```NO``` ! + sulu%options%PivotGrowth        = ```NO``` ! + sulu%options%ConditionNumber    = ```NO``` ! + sulu%options%PrintStat          = ```YES``` ! ! @endnote !----------------------------------------------------------------------------------------- subroutine init_superlu ( sulu ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu call set_default_options ( sulu % options ) return endsubroutine init_superlu !========================================================================================= !> @note **Subroutine to prepare the [[SULU_ENV]] components** !----------------------------------------------------------------------------------------- subroutine prep_superlu ( sulu ) implicit none type ( sulu_env ), intent ( inout ) :: sulu integer ( kind = I4 ) :: nn , nz , nb nn = sulu % n nz = sulu % nz nb = sulu % nrhs if (. not . allocated ( sulu % perm_c )) then allocate ( sulu % perm_c ( 1 : nn ) ) allocate ( sulu % perm_r ( 1 : nn ) ) allocate ( sulu % etree ( 1 : nn ) ) allocate ( sulu % RR ( 1 : nn ) ) allocate ( sulu % CC ( 1 : nn ) ) allocate ( sulu % ferr ( 1 : nb ) ) allocate ( sulu % berr ( 1 : nb ) ) allocate ( sulu % rpg ( 1 : nb ) ) allocate ( sulu % rcond ( 1 : nb ) ) allocate ( sulu % x ( 1 : nn ) ) endif sulu % x ( 1 : nn ) = 0 call dCreate_CompCol_Matrix ( A = sulu % SMA , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % n , & ! in int nnz = sulu % nz , & ! in int nzval = sulu % a_elt , & ! in double dimension() rowind = sulu % irow , & ! in int dimension() colptr = sulu % jptr , & ! in int dimension() stype = SLU_NC , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) call dCreate_Dense_Matrix ( BX = sulu % smb , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % nrhs , & ! in int x = sulu % b , & ! in double dimension() ldx = sulu % n , & ! in int stype = SLU_DN , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) call dCreate_Dense_Matrix ( BX = sulu % smx , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % nrhs , & ! in int x = sulu % x , & ! in double dimension() ldx = sulu % n , & ! in int stype = SLU_DN , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) return endsubroutine prep_superlu !========================================================================================= !< @note ! **Subroutine to factorize the system** ! ! note the directives: ! ! + sulu%options%Fact = ```DOFACT``` ! + sulu%SMB%ncol     = ```0``` ! ! @endnote !----------------------------------------------------------------------------------------- subroutine fact_superlu ( sulu , verbose ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu logical ( kind = I4 ), intent ( in ) :: verbose sulu % lwork = 0 call StatInit ( sulu % stat ) sulu % options % Fact = DOFACT sulu % SMB % ncol = 0 call dgssvx ( options = sulu % options , & ! superlu_options_t   *options A = sulu % SMA , & ! SuperMatrix         *A perm_c = sulu % perm_c , & ! int                 *perm_c perm_r = sulu % perm_r , & ! int                 *perm_r etree = sulu % etree , & ! int                 *etree equed = sulu % equed , & ! char                *equed R = sulu % RR , & ! double              *R C = sulu % CC , & ! double              *C L = sulu % SML , & ! SuperMatrix         *L U = sulu % SMU , & ! SuperMatrix         *U work = sulu % work , & ! void                *work lwork = sulu % lwork , & ! int                  lwork B = sulu % SMB , & ! SuperMatrix         *B X = sulu % SMX , & ! SuperMatrix         *X recip_pivot_growth = sulu % rpg , & ! double              *recip_pivot_growth rcond = sulu % rcond , & ! double              *rcond ferr = sulu % ferr , & ! double              *ferr berr = sulu % berr , & ! double              *berr Glu = sulu % Glu , & ! GlobalLU_t          *Glu mem_usage = sulu % mem_usage , & ! mem_usage_t         *mem_usage stat = sulu % stat , & ! SuperLUStat_t       *stat info = sulu % info & ! int                 *info ) if ( verbose ) call StatPrint ( sulu % stat ) call StatFree ( sulu % stat ) return endsubroutine fact_superlu !========================================================================================= !< @note ! **Subroutine to solve the system** ! ! + If no resolution has yet occured, sulu%first=```true``` !     * sulu%options%Fact = ```FACTORED``` !     * sulu%SMB%ncol     = sulu%nrhs (usually ```1```) ! + otherwise !     * sulu%options%Fact = ```SAMEPATTERN``` !     * sma, smb and smx are recreated but do not forget that we still have: !         - mat%matsulu%irow   => mat%irow !         - mat%matsulu%jptr   => mat%jptr !         - mat%matsulu%a_elt  => mat%a_elt !         - mat%matsulu%b      => mat%b ! ! @endnote ! ! @note ! The solution is retrieved with the pointer *store* of type [[NCFORMAT]] which ! gives access to [[NCFORMAT:nzval]] ! @endnote ! ! @warning ! At the end, the memory is released with the dstruction of *sml* and *smu* ! @endwarning !----------------------------------------------------------------------------------------- subroutine solv_superlu ( sol_x , sulu , verbose ) implicit none real ( kind = R8 ), dimension (:), intent ( inout ) :: sol_x type ( SULU_ENV ), intent ( inout ) :: sulu logical ( kind = I4 ), intent ( in ) :: verbose type ( NCFORMAT ), pointer :: Xstore real ( kind = R8 ), pointer :: tabX (:) integer ( kind = I4 ) :: i call StatInit ( sulu % stat ) if ( sulu % first ) then sulu % options % Fact = FACTORED sulu % SMB % ncol = sulu % nrhs else sulu % options % Fact = SAMEPATTERN call prep_superlu ( sulu ) endif call dgssvx ( options = sulu % options , & ! superlu_options_t   *options A = sulu % SMA , & ! SuperMatrix         *A perm_c = sulu % perm_c , & ! int                 *perm_c perm_r = sulu % perm_r , & ! int                 *perm_r etree = sulu % etree , & ! int                 *etree equed = sulu % equed , & ! char                *equed R = sulu % RR , & ! double              *R C = sulu % CC , & ! double              *C L = sulu % SML , & ! SuperMatrix         *L U = sulu % SMU , & ! SuperMatrix         *U work = sulu % work , & ! void                *work lwork = sulu % lwork , & ! int                  lwork B = sulu % SMB , & ! SuperMatrix         *B X = sulu % SMX , & ! SuperMatrix         *X recip_pivot_growth = sulu % rpg , & ! double              *recip_pivot_growth rcond = sulu % rcond , & ! double              *rcond ferr = sulu % ferr , & ! double              *ferr berr = sulu % berr , & ! double              *berr Glu = sulu % Glu , & ! GlobalLU_t          *Glu mem_usage = sulu % mem_usage , & ! mem_usage_t         *mem_usage stat = sulu % stat , & ! SuperLUStat_t       *stat info = sulu % info & ! int                 *info ) call c_f_pointer ( sulu % SMX % Store , XStore ) call c_f_pointer ( XStore % nzval , tabX , [ XStore % nnz ]) do i = 1 , sulu % n sol_x ( i ) = tabX ( i ) enddo nullify ( Xstore , tabX ) if ( verbose ) call StatPrint ( sulu % stat ) call StatFree ( sulu % stat ) call Destroy_SuperNode_Matrix ( sulu % SML ) call Destroy_CompCol_Matrix ( sulu % SMU ) return endsubroutine solv_superlu !========================================================================================= !< @note Subroutine that actually does nothing yet. Maybe, there will be extra memory that ! could be released here? !----------------------------------------------------------------------------------------- subroutine free_superlu () implicit none !type(SULU_ENV), intent(inout) :: sulu return endsubroutine free_superlu !========================================================================================= !> @note **Subroutine to close the SuperLU process, with memory release** !----------------------------------------------------------------------------------------- subroutine close_superlu ( sulu ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu call Destroy_CompCol_Matrix ( sulu % SMA ) call Destroy_Dense_Matrix ( sulu % smb ) call Destroy_Dense_Matrix ( sulu % smx ) deallocate ( sulu % perm_c ) deallocate ( sulu % perm_r ) deallocate ( sulu % etree ) deallocate ( sulu % RR ) deallocate ( sulu % CC ) deallocate ( sulu % ferr ) deallocate ( sulu % berr ) deallocate ( sulu % rpg ) deallocate ( sulu % rcond ) return endsubroutine close_superlu endmodule sulu_wrapper","loc":"sourcefile/superlu.f90.html"},{"tags":"","title":"umfpack.f90 – MUSST","text":"Files dependent on this one sourcefile~~umfpack.f90~~AfferentGraph sourcefile~umfpack.f90 umfpack.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~umfpack.f90 sourcefile~mod_ms_film.f90 mod_ms_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_film.f90 mod_film.f90 sourcefile~mod_ms_film.f90->sourcefile~mod_film.f90 sourcefile~mod_test_musst.f90 mod_test_musst.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_solver.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_film.f90 sourcefile~mod_inout_files.f90 mod_inout_files.f90 sourcefile~mod_test_musst.f90->sourcefile~mod_inout_files.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_solver.f90 sourcefile~main.f90->sourcefile~mod_test_musst.f90 sourcefile~mod_film.f90->sourcefile~mod_solver.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_ms_film.f90 sourcefile~mod_inout_files.f90->sourcefile~mod_film.f90 var pansourcefileumfpackf90AfferentGraph = svgPanZoom('#sourcefileumfpackf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mumfpack Source Code umfpack.f90 Source Code ! ====================================================================== ! UMFPACK Fortran interface via the mUMFPACK module ! ====================================================================== ! Version 1.0 (Apr 23, 2014) for UMFPACK version 5.6.2 ! ====================================================================== ! Compile with any Fortran compiler with support of iso_c_binding module ! and link with the UMFPACK C library: ! e.g., gfortran umfpack.f90 my_code.f90 -lumfpack ! ====================================================================== module mumfpack ! ====================================================================== use iso_c_binding implicit none ! private size constants integer , parameter , private :: i4 = 4 , & ! size of default integer i8 = 8 , & ! size of long integer ip = c_intptr_t , & ! size of pointers used in basic Fortran wrappers r4 = 4 , & ! size of single precision real/complex r8 = 8 ! size of double precision real/complex ! default pointers to UMFPACK Symbolic and Numeric objects type ( c_ptr ), private :: iSymbolic = c_null_ptr , iNumeric = c_null_ptr ! ====================================================================== ! UMFPACK constants ! ====================================================================== ! size of Info and Control arrays integer , parameter :: UMFPACK_INFO = 90 , & UMFPACK_CONTROL = 20 ! Version, copyright, and license character ( 30 ), parameter :: UMFPACK_VERSION = \"UMFPACK V5.6.2 (Apr 25, 2013)\" character ( 79 ), parameter :: UMFPACK_COPYRIGHT = \"UMFPACK:  Copyright (c) 2005-2012 by Timothy A. Davis.  All Rights Reserved.\" character ( 12 ), parameter :: UMFPACK_DATE = \"Apr 25, 2013\" integer , parameter :: UMFPACK_MAIN_VERSION = 5 , & UMFPACK_SUB_VERSION = 6 , & UMFPACK_SUBSUB_VERSION = 2 ! UMFPACK_VER_CODE(main,sub) ((main) * 1000 + (sub)) ! UMFPACK_VER UMFPACK_VER_CODE(UMFPACK_MAIN_VERSION,UMFPACK_SUB_VERSION) ! contents of Info enum , bind ( c ) enumerator :: & ! returned by all routines that use Info: UMFPACK_STATUS = 0 , & ! /* UMFPACK_OK, or other result */ UMFPACK_NROW = 1 , & ! /* n_row input value */ UMFPACK_NCOL = 16 , & ! /* n_col input value */ UMFPACK_NZ = 2 , & ! /* # of entries in A */ ! computed in UMFPACK_*symbolic and UMFPACK_numeric: UMFPACK_SIZE_OF_UNIT = 3 , & ! /* sizeof (Unit) */ ! computed in UMFPACK_*symbolic: UMFPACK_SIZE_OF_INT = 4 , & ! /* sizeof (int) */ UMFPACK_SIZE_OF_LONG = 5 , & ! /* sizeof (SuiteSparse_long) */ UMFPACK_SIZE_OF_POINTER = 6 , & ! /* sizeof (void *) */ UMFPACK_SIZE_OF_ENTRY = 7 , & ! /* sizeof (Entry), real or complex */ UMFPACK_NDENSE_ROW = 8 , & ! /* number of dense rows */ UMFPACK_NEMPTY_ROW = 9 , & ! /* number of empty rows */ UMFPACK_NDENSE_COL = 10 , & ! /* number of dense rows */ UMFPACK_NEMPTY_COL = 11 , & ! /* number of empty rows */ UMFPACK_SYMBOLIC_DEFRAG = 12 , & ! /* # of memory compactions */ UMFPACK_SYMBOLIC_PEAK_MEMORY = 13 , & ! /* memory used by symbolic analysis */ UMFPACK_SYMBOLIC_SIZE = 14 , & ! /* size of Symbolic object, in Units */ UMFPACK_SYMBOLIC_TIME = 15 , & ! /* time (sec.) for symbolic analysis */ UMFPACK_SYMBOLIC_WALLTIME = 17 , & ! /* wall clock time for sym. analysis */ UMFPACK_STRATEGY_USED = 18 , & ! /* strategy used: sym, unsym */ UMFPACK_ORDERING_USED = 19 , & ! /* ordering used: colamd, amd, given */ UMFPACK_QFIXED = 31 , & ! /* whether Q is fixed or refined */ UMFPACK_DIAG_PREFERRED = 32 , & ! /* whether diagonal pivoting attempted*/ UMFPACK_PATTERN_SYMMETRY = 33 , & ! /* symmetry of pattern of S */ UMFPACK_NZ_A_PLUS_AT = 34 , & ! /* nnz (S+S'), excl. diagonal */ UMFPACK_NZDIAG = 35 , & ! /* nnz (diag (S)) */ ! AMD statistics, computed in UMFPACK_*symbolic: UMFPACK_SYMMETRIC_LUNZ = 36 , & ! /* nz in L+U, if AMD ordering used */ UMFPACK_SYMMETRIC_FLOPS = 37 , & ! /* flops for LU, if AMD ordering used */ UMFPACK_SYMMETRIC_NDENSE = 38 , & ! /* # of \"dense\" rows/cols in S+S' */ UMFPACK_SYMMETRIC_DMAX = 39 , & ! /* max nz in cols of L, for AMD */ ! 51:55 unused ! statistics for singleton pruning UMFPACK_COL_SINGLETONS = 56 , & ! /* # of column singletons */ UMFPACK_ROW_SINGLETONS = 57 , & ! /* # of row singletons */ UMFPACK_N2 = 58 , & ! /* size of S */ UMFPACK_S_SYMMETRIC = 59 , & ! /* 1 if S square and symmetricly perm.*/ ! estimates computed in UMFPACK_*symbolic: UMFPACK_NUMERIC_SIZE_ESTIMATE = 20 , & ! /* final size of Numeric->Memory */ UMFPACK_PEAK_MEMORY_ESTIMATE = 21 , & ! /* for symbolic & numeric */ UMFPACK_FLOPS_ESTIMATE = 22 , & ! /* flop count */ UMFPACK_LNZ_ESTIMATE = 23 , & ! /* nz in L, incl. diagonal */ UMFPACK_UNZ_ESTIMATE = 24 , & ! /* nz in U, incl. diagonal */ UMFPACK_VARIABLE_INIT_ESTIMATE = 25 , & ! /* initial size of Numeric->Memory*/ UMFPACK_VARIABLE_PEAK_ESTIMATE = 26 , & ! /* peak size of Numeric->Memory */ UMFPACK_VARIABLE_FINAL_ESTIMATE = 27 , & ! /* final size of Numeric->Memory */ UMFPACK_MAX_FRONT_SIZE_ESTIMATE = 28 , & ! /* max frontal matrix size */ UMFPACK_MAX_FRONT_NROWS_ESTIMATE = 29 , & ! /* max # rows in any front */ UMFPACK_MAX_FRONT_NCOLS_ESTIMATE = 30 , & ! /* max # columns in any front */ ! exact values, (estimates shown above) computed in UMFPACK_numeric: UMFPACK_NUMERIC_SIZE = 40 , & ! /* final size of Numeric->Memory */ UMFPACK_PEAK_MEMORY = 41 , & ! /* for symbolic & numeric */ UMFPACK_FLOPS = 42 , & ! /* flop count */ UMFPACK_LNZ = 43 , & ! /* nz in L, incl. diagonal */ UMFPACK_UNZ = 44 , & ! /* nz in U, incl. diagonal */ UMFPACK_VARIABLE_INIT = 45 , & ! /* initial size of Numeric->Memory*/ UMFPACK_VARIABLE_PEAK = 46 , & ! /* peak size of Numeric->Memory */ UMFPACK_VARIABLE_FINAL = 47 , & ! /* final size of Numeric->Memory */ UMFPACK_MAX_FRONT_SIZE = 48 , & ! /* max frontal matrix size */ UMFPACK_MAX_FRONT_NROWS = 49 , & ! /* max # rows in any front */ UMFPACK_MAX_FRONT_NCOLS = 50 , & ! /* max # columns in any front */ ! computed in UMFPACK_numeric: UMFPACK_NUMERIC_DEFRAG = 60 , & ! /* # of garbage collections */ UMFPACK_NUMERIC_REALLOC = 61 , & ! /* # of memory reallocations */ UMFPACK_NUMERIC_COSTLY_REALLOC = 62 , & ! /* # of costlly memory realloc's */ UMFPACK_COMPRESSED_PATTERN = 63 , & ! /* # of integers in LU pattern */ UMFPACK_LU_ENTRIES = 64 , & ! /* # of reals in LU factors */ UMFPACK_NUMERIC_TIME = 65 , & ! /* numeric factorization time */ UMFPACK_UDIAG_NZ = 66 , & ! /* nz on diagonal of U */ UMFPACK_RCOND = 67 , & ! /* est. reciprocal condition # */ UMFPACK_WAS_SCALED = 68 , & ! /* none, max row, or sum row */ UMFPACK_RSMIN = 69 , & ! /* min (max row) or min (sum row) */ UMFPACK_RSMAX = 70 , & ! /* max (max row) or max (sum row) */ UMFPACK_UMIN = 71 , & ! /* min abs diagonal entry of U */ UMFPACK_UMAX = 72 , & ! /* max abs diagonal entry of U */ UMFPACK_ALLOC_INIT_USED = 73 , & ! /* alloc_init parameter used */ UMFPACK_FORCED_UPDATES = 74 , & ! /* # of forced updates */ UMFPACK_NUMERIC_WALLTIME = 75 , & ! /* numeric wall clock time */ UMFPACK_NOFF_DIAG = 76 , & ! /* number of off-diagonal pivots */ UMFPACK_ALL_LNZ = 77 , & ! /* nz in L, if no dropped entries */ UMFPACK_ALL_UNZ = 78 , & ! /* nz in U, if no dropped entries */ UMFPACK_NZDROPPED = 79 , & ! /* # of dropped small entries */ ! computed in UMFPACK_solve: UMFPACK_IR_TAKEN = 80 , & ! /* # of iterative refinement steps taken */ UMFPACK_IR_ATTEMPTED = 81 , & ! /* # of iter. refinement steps attempted */ UMFPACK_OMEGA1 = 82 , & ! /* omega1, sparse backward error estimate */ UMFPACK_OMEGA2 = 83 , & ! /* omega2, sparse backward error estimate */ UMFPACK_SOLVE_FLOPS = 84 , & ! /* flop count for solve */ UMFPACK_SOLVE_TIME = 85 , & ! /* solve time (seconds) */ UMFPACK_SOLVE_WALLTIME = 86 ! /* solve time (wall clock, seconds) */ ! Info(87,88,89) unused ! Unused parts of Info may be used in future versions of UMFPACK. end enum ! contents of Control enum , bind ( c ) enumerator :: & ! used in all UMFPACK_report_* routines: UMFPACK_PRL = 0 , & ! /* print level */ ! used in UMFPACK_*symbolic only: UMFPACK_DENSE_ROW = 1 , & ! /* dense row parameter */ UMFPACK_DENSE_COL = 2 , & ! /* dense col parameter */ UMFPACK_BLOCK_SIZE = 4 , & ! /* BLAS-3 block size */ UMFPACK_STRATEGY = 5 , & ! /* auto, symmetric, or unsym. */ UMFPACK_ORDERING = 10 , & ! /* ordering method to use */ UMFPACK_FIXQ = 13 , & ! /* -1: no fixQ, 0: default, 1: fixQ */ UMFPACK_AMD_DENSE = 14 , & ! /* for AMD ordering */ UMFPACK_AGGRESSIVE = 19 , & ! /* whether or not to use aggressive */ UMFPACK_SINGLETONS = 11 , & ! /* singleton filter on if true */ ! used in UMFPACK_*numeric only: UMFPACK_PIVOT_TOLERANCE = 3 , & ! /* threshold partial pivoting setting */ UMFPACK_ALLOC_INIT = 6 , & ! /* initial allocation ratio */ UMFPACK_SYM_PIVOT_TOLERANCE = 15 , & ! /* threshold, only for diag. entries */ UMFPACK_SCALE = 16 , & ! /* what row scaling to do */ UMFPACK_FRONT_ALLOC_INIT = 17 , & ! /* frontal matrix allocation ratio */ UMFPACK_DROPTOL = 18 , & ! /* drop tolerance for entries in L,U */ ! used in UMFPACK_*solve only: UMFPACK_IRSTEP = 7 , & ! /* max # of iterative refinements */ ! compile-time settings - Control(8:11) cannot be changed at run time: UMFPACK_COMPILED_WITH_BLAS = 8 ! /* uses the BLAS */ end enum ! /* 9,12: unused */ ! Control(UMFPACK_STRATEGY) is one of the following: enum , bind ( c ) ; enumerator :: & UMFPACK_STRATEGY_AUTO = 0 , & ! /* use sym. or unsym. strategy */ UMFPACK_STRATEGY_UNSYMMETRIC , & ! /* COLAMD(A), coletree postorder, not prefer diag*/ UMFPACK_STRATEGY_OBSOLETE , & ! /* 2-by-2 is no longer available */ UMFPACK_STRATEGY_SYMMETRIC ! /* AMD(A+A'), no coletree postorder, prefer diagonal */ end enum ! Control(UMFPACK_SCALE) is one of the following: enum , bind ( c ) ; enumerator :: & UMFPACK_SCALE_NONE = 0 , & ! /* no scaling */ UMFPACK_SCALE_SUM , & ! /* default: divide each row by sum (abs (row))*/ UMFPACK_SCALE_MAX ! /* divide each row by max (abs (row)) */ end enum ! Control(UMFPACK_ORDERING) and Info(UMFPACK_ORDERING_USED) are one of: enum , bind ( c ) ; enumerator :: & UMFPACK_ORDERING_CHOLMOD = 0 , & ! /* use CHOLMOD (AMD/COLAMD then METIS)*/ UMFPACK_ORDERING_AMD , & ! /* use AMD/COLAMD */ UMFPACK_ORDERING_GIVEN , & ! /* user-provided Qinit */ UMFPACK_ORDERING_METIS , & ! /* use METIS */ UMFPACK_ORDERING_BEST , & ! /* try many orderings, pick best */ UMFPACK_ORDERING_NONE , & ! /* natural ordering */ UMFPACK_ORDERING_USER ! /* user-provided function */ ! /* AMD/COLAMD means: use AMD for symmetric strategy, COLAMD for unsymmetric */ end enum ! status codes enum , bind ( c ) ; enumerator :: & UMFPACK_OK = 0 , & ! /* status > 0 means a warning, but the method was successful anyway. */ ! /* A Symbolic or Numeric object was still created. */ UMFPACK_WARNING_singular_matrix = 1 , & ! /* The following warnings were added in umfpack_*_get_determinant */ UMFPACK_WARNING_determinant_underflow = 2 , & UMFPACK_WARNING_determinant_overflow = 3 , & ! /* status < 0 means an error, and the method was not successful. */ ! /* No Symbolic of Numeric object was created. */ UMFPACK_ERROR_out_of_memory =- 1 , & UMFPACK_ERROR_invalid_Numeric_object =- 3 , & UMFPACK_ERROR_invalid_Symbolic_object =- 4 , & UMFPACK_ERROR_argument_missing =- 5 , & UMFPACK_ERROR_n_nonpositive =- 6 , & UMFPACK_ERROR_invalid_matrix =- 8 , & UMFPACK_ERROR_different_pattern =- 11 , & UMFPACK_ERROR_invalid_system =- 13 , & UMFPACK_ERROR_invalid_permutation =- 15 , & UMFPACK_ERROR_internal_error =- 911 , & ! /* yes, call me if you get this! */ UMFPACK_ERROR_file_IO =- 17 , & UMFPACK_ERROR_ordering_failed =- 18 end enum ! solve codes ! /* Solve the system ( )x=b, where ( ) is defined below.  \"t\" refers to the */ ! /* linear algebraic transpose (complex conjugate if A is complex), or the (') */ ! /* operator in MATLAB.  \"at\" refers to the array transpose, or the (.') */ ! /* operator in MATLAB. */ enum , bind ( c ) ; enumerator :: & UMFPACK_A = 0 , & ! /* Ax=b    */ UMFPACK_At = 1 , & ! /* A'x=b   */ UMFPACK_Aat = 2 , & ! /* A.'x=b  */ UMFPACK_Pt_L = 3 , & ! /* P'Lx=b  */ UMFPACK_L = 4 , & ! /* Lx=b    */ UMFPACK_Lt_P = 5 , & ! /* L'Px=b  */ UMFPACK_Lat_P = 6 , & ! /* L.'Px=b */ UMFPACK_Lt = 7 , & ! /* L'x=b   */ UMFPACK_Lat = 8 , & ! /* L.'x=b  */ UMFPACK_U_Qt = 9 , & ! /* UQ'x=b  */ UMFPACK_U = 10 , & ! /* Ux=b    */ UMFPACK_Q_Ut = 11 , & ! /* QU'x=b  */ UMFPACK_Q_Uat = 12 , & ! /* QU.'x=b */ UMFPACK_Ut = 13 , & ! /* U'x=b   */ UMFPACK_Uat = 14 ! /* U.'x=b  */ end enum ! ====================================================================== ! Full UMFPACK interface: interfaces to C functions ! ====================================================================== interface ! int umfpack_di_symbolic(int n_row,int n_col,const int Ap [ ],const int Ai [ ],const double Ax [ ], ! void **Symbolic,const double Control [UMFPACK_CONTROL],double Info [UMFPACK_INFO]) ; integer ( c_int ) function c_umfpack_di_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) bind ( c , name = 'umfpack_di_symbolic' ) import c_int , c_ptr integer ( c_int ), value :: n_row , n_col type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax type ( c_ptr ) :: Symbolic type ( c_ptr ), value :: Control , Info end function integer ( c_int ) function c_umfpack_zi_symbolic ( n_row , n_col , Ap , Ai , Ax , Az , Symbolic , Control , Info ) bind ( c , name = 'umfpack_zi_symbolic' ) import c_int , c_ptr integer ( c_int ), value :: n_row , n_col type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax , Az type ( c_ptr ) :: Symbolic type ( c_ptr ), value :: Control , Info end function ! int umfpack_di_numeric(const int Ap [ ],const int Ai [ ],const double Ax [ ], ! void *Symbolic,void **Numeric,const double Control [UMFPACK_CONTROL],double Info [UMFPACK_INFO]) ; integer ( c_int ) function c_umfpack_di_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) bind ( c , name = 'umfpack_di_numeric' ) import c_int , c_ptr type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax type ( c_ptr ), value , intent ( in ) :: Symbolic type ( c_ptr ) :: Numeric type ( c_ptr ), value :: Control , Info end function integer ( c_int ) function c_umfpack_zi_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) bind ( c , name = 'umfpack_zi_numeric' ) import c_int , c_ptr type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax , Az type ( c_ptr ), value , intent ( in ) :: Symbolic type ( c_ptr ) :: Numeric type ( c_ptr ), value :: Control , Info end function ! int umfpack_di_solve(int sys,const int Ap [ ],const int Ai [ ],const double Ax [ ],double X [ ],const double B [ ], ! void *Numeric,const double Control [UMFPACK_CONTROL],double Info [UMFPACK_INFO]) ; integer ( c_int ) function c_umfpack_di_solve ( sys , Ap , Ai , Ax , X , B , Numeric , Control , Info ) bind ( c , name = 'umfpack_di_solve' ) import c_int , c_ptr integer ( c_int ), value :: sys type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax type ( c_ptr ), value :: X type ( c_ptr ), value , intent ( in ) :: B type ( c_ptr ), value , intent ( in ) :: Numeric type ( c_ptr ), value :: Control , Info end function integer ( c_int ) function c_umfpack_zi_solve ( sys , Ap , Ai , Ax , Az , Xx , Xz , Bx , Bz , Numeric , Control , Info ) bind ( c , name = 'umfpack_zi_solve' ) import c_int , c_ptr integer ( c_int ), value :: sys type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax , Az type ( c_ptr ), value :: Xx , Xz type ( c_ptr ), value , intent ( in ) :: Bx , Bz type ( c_ptr ), value , intent ( in ) :: Numeric type ( c_ptr ), value :: Control , Info end function ! void umfpack_di_free_symbolic(void **Symbolic) ; subroutine c_umfpack_di_free_symbolic ( Symbolic ) bind ( c , name = 'umfpack_di_free_symbolic' ) import c_ptr type ( c_ptr ) :: Symbolic end subroutine subroutine c_umfpack_zi_free_symbolic ( Symbolic ) bind ( c , name = 'umfpack_zi_free_symbolic' ) import c_ptr type ( c_ptr ) :: Symbolic end subroutine ! void umfpack_di_free_numeric(void **Numeric) ; subroutine c_umfpack_di_free_numeric ( Numeric ) bind ( c , name = 'umfpack_di_free_numeric' ) import c_ptr type ( c_ptr ) :: Numeric end subroutine subroutine c_umfpack_zi_free_numeric ( Numeric ) bind ( c , name = 'umfpack_zi_free_numeric' ) import c_ptr type ( c_ptr ) :: Numeric end subroutine ! void umfpack_di_defaults(double Control [UMFPACK_CONTROL]) ; subroutine c_umfpack_di_defaults ( Control ) bind ( c , name = 'umfpack_di_defaults' ) import c_ptr type ( c_ptr ), value :: Control end subroutine subroutine c_umfpack_zi_defaults ( Control ) bind ( c , name = 'umfpack_zi_defaults' ) import c_ptr type ( c_ptr ), value :: Control end subroutine ! int umfpack_di_scale(double X [ ],const double B [ ],void *Numeric) ; integer ( c_int ) function c_umfpack_di_scale ( X , B , Numeric ) bind ( c , name = 'umfpack_di_scale' ) import c_int , c_ptr type ( c_ptr ), value :: X type ( c_ptr ), value , intent ( in ) :: B type ( c_ptr ), value , intent ( in ) :: Numeric end function integer ( c_int ) function c_umfpack_zi_scale ( Xx , Xz , Bx , Bz , Numeric ) bind ( c , name = 'umfpack_zi_scale' ) import c_int , c_ptr type ( c_ptr ), value :: Xx , Xz type ( c_ptr ), value , intent ( in ) :: Bx , Bz type ( c_ptr ), value , intent ( in ) :: Numeric end function ! int umfpack_di_save_numeric(void *Numeric,char *filename) ; integer ( c_int ) function c_umfpack_di_save_numeric ( Numeric , filename ) bind ( c , name = 'umfpack_di_save_numeric' ) import c_int , c_ptr , c_char type ( c_ptr ), value :: Numeric character ( 1 , c_char ) :: filename ( * ) end function integer ( c_int ) function c_umfpack_zi_save_numeric ( Numeric , filename ) bind ( c , name = 'umfpack_zi_save_numeric' ) import c_int , c_ptr , c_char type ( c_ptr ), value :: Numeric character ( 1 , c_char ) :: filename ( * ) end function ! int umfpack_di_save_symbolic(void *Symbolic,char *filename) ; integer ( c_int ) function c_umfpack_di_save_symbolic ( Symbolic , filename ) bind ( c , name = 'umfpack_di_save_symbolic' ) import c_int , c_ptr , c_char type ( c_ptr ), value :: Symbolic character ( 1 , c_char ) :: filename ( * ) end function integer ( c_int ) function c_umfpack_zi_save_symbolic ( Symbolic , filename ) bind ( c , name = 'umfpack_zi_save_symbolic' ) import c_int , c_ptr , c_char type ( c_ptr ), value :: Symbolic character ( 1 , c_char ) :: filename ( * ) end function ! int umfpack_di_load_numeric(void **Numeric,char *filename) ; integer ( c_int ) function c_umfpack_di_load_numeric ( Numeric , filename ) bind ( c , name = 'umfpack_di_load_numeric' ) import c_int , c_ptr , c_char type ( c_ptr ) :: Numeric character ( 1 , c_char ) :: filename ( * ) end function integer ( c_int ) function c_umfpack_zi_load_numeric ( Numeric , filename ) bind ( c , name = 'umfpack_zi_load_numeric' ) import c_int , c_ptr , c_char type ( c_ptr ) :: Numeric character ( 1 , c_char ) :: filename ( * ) end function ! int umfpack_di_load_symbolic(void **Symbolic,char *filename) ; integer ( c_int ) function c_umfpack_di_load_symbolic ( Symbolic , filename ) bind ( c , name = 'umfpack_di_load_symbolic' ) import c_int , c_ptr , c_char type ( c_ptr ) :: Symbolic character ( 1 , c_char ) :: filename ( * ) end function integer ( c_int ) function c_umfpack_zi_load_symbolic ( Symbolic , filename ) bind ( c , name = 'umfpack_zi_load_symbolic' ) import c_int , c_ptr , c_char type ( c_ptr ) :: Symbolic character ( 1 , c_char ) :: filename ( * ) end function ! void umfpack_di_report_status(const double Control [UMFPACK_CONTROL],int status) ; subroutine c_umfpack_di_report_status ( Control , status ) bind ( c , name = 'umfpack_di_report_status' ) import c_ptr , c_int type ( c_ptr ), value :: Control integer ( c_int ), value :: status end subroutine subroutine c_umfpack_zi_report_status ( Control , status ) bind ( c , name = 'umfpack_zi_report_status' ) import c_ptr , c_int type ( c_ptr ), value :: Control integer ( c_int ), value :: status end subroutine ! void umfpack_di_report_control(const double Control [UMFPACK_CONTROL]) ; subroutine c_umfpack_di_report_control ( Control ) bind ( c , name = 'umfpack_di_report_control' ) import c_ptr type ( c_ptr ), value :: Control end subroutine subroutine c_umfpack_zi_report_control ( Control ) bind ( c , name = 'umfpack_zi_report_control' ) import c_ptr type ( c_ptr ), value :: Control end subroutine ! void umfpack_di_report_info(const double Control [UMFPACK_CONTROL],const double Info [UMFPACK_INFO]) ; subroutine c_umfpack_di_report_info ( Control , Info ) bind ( c , name = 'umfpack_di_report_info' ) import c_ptr type ( c_ptr ), value :: Control , Info end subroutine subroutine c_umfpack_zi_report_info ( Control , Info ) bind ( c , name = 'umfpack_zi_report_info' ) import c_ptr type ( c_ptr ), value :: Control , Info end subroutine ! int umfpack_di_report_numeric(void *Numeric,const double Control [UMFPACK_CONTROL]) ; integer ( c_int ) function c_umfpack_di_report_numeric ( Numeric , Control ) bind ( c , name = 'umfpack_di_report_numeric' ) import c_int , c_ptr type ( c_ptr ), value :: Numeric , Control end function integer ( c_int ) function c_umfpack_zi_report_numeric ( Numeric , Control ) bind ( c , name = 'umfpack_zi_report_numeric' ) import c_int , c_ptr type ( c_ptr ), value :: Numeric , Control end function ! int umfpack_di_report_symbolic(void *Symbolic,const double Control [UMFPACK_CONTROL]) ; integer ( c_int ) function c_umfpack_di_report_symbolic ( Symbolic , Control ) bind ( c , name = 'umfpack_di_report_symbolic' ) import c_int , c_ptr type ( c_ptr ), value :: Symbolic , Control end function integer ( c_int ) function c_umfpack_zi_report_symbolic ( Symbolic , Control ) bind ( c , name = 'umfpack_zi_report_symbolic' ) import c_int , c_ptr type ( c_ptr ), value :: Symbolic , Control end function end interface ! ====================================================================== ! Full UMFPACK interface: overloaded names ! ====================================================================== interface umfpack_zi_symbolic module procedure umfpack_zi_symbolic , umfpack_ci_symbolic end interface interface s_umfpack_zi_symbolic module procedure s_umfpack_zi_symbolic , s_umfpack_ci_symbolic end interface interface umfpack_symbolic module procedure umfpack_di_symbolic , umfpack_zi_symbolic , umfpack_ci_symbolic end interface interface s_umfpack_symbolic module procedure s_umfpack_di_symbolic , s_umfpack_zi_symbolic , s_umfpack_ci_symbolic end interface interface umfpack_zi_numeric module procedure umfpack_zi_numeric , umfpack_ci_numeric end interface interface s_umfpack_zi_numeric module procedure s_umfpack_zi_numeric , s_umfpack_ci_numeric end interface interface umfpack_numeric module procedure umfpack_di_numeric , umfpack_zi_numeric , umfpack_ci_numeric end interface interface s_umfpack_numeric module procedure s_umfpack_di_numeric , s_umfpack_zi_numeric , s_umfpack_ci_numeric end interface interface umfpack_zi_solve module procedure umfpack_zi_solve , umfpack_ci_solve end interface interface s_umfpack_zi_solve module procedure s_umfpack_zi_solve , s_umfpack_ci_solve end interface interface umfpack_solve module procedure umfpack_di_solve , umfpack_zi_solve , umfpack_ci_solve end interface interface s_umfpack_solve module procedure s_umfpack_di_solve , s_umfpack_zi_solve , s_umfpack_ci_solve end interface interface s_umfpack_free_symbolic module procedure umfpack_free_symbolic end interface interface s_umfpack_di_free_symbolic module procedure umfpack_di_free_symbolic end interface interface s_umfpack_zi_free_symbolic module procedure umfpack_zi_free_symbolic end interface interface s_umfpack_free_numeric module procedure umfpack_free_numeric end interface interface s_umfpack_di_free_numeric module procedure umfpack_di_free_numeric end interface interface s_umfpack_zi_free_numeric module procedure umfpack_zi_free_numeric end interface interface s_umfpack_defaults module procedure umfpack_defaults end interface interface s_umfpack_di_defaults module procedure umfpack_di_defaults end interface interface s_umfpack_zi_defaults module procedure umfpack_zi_defaults end interface ! a conflict with the constant UMFPACK_SCALE interface umfpack_zi_scale module procedure umfpack_zi_scale , umfpack_ci_scale end interface interface umfpack_scale_function module procedure umfpack_di_scale , umfpack_zi_scale , umfpack_ci_scale end interface interface s_umfpack_zi_scale module procedure s_umfpack_zi_scale , s_umfpack_ci_scale end interface interface s_umfpack_scale module procedure s_umfpack_di_scale , s_umfpack_zi_scale , s_umfpack_ci_scale end interface interface s_umfpack_report_control module procedure umfpack_report_control end interface interface s_umfpack_di_report_control module procedure umfpack_di_report_control end interface interface s_umfpack_zi_report_control module procedure umfpack_zi_report_control end interface interface s_umfpack_report_info module procedure umfpack_report_info end interface interface s_umfpack_di_report_info module procedure umfpack_di_report_info end interface interface s_umfpack_zi_report_info module procedure umfpack_zi_report_info end interface ! ====================================================================== ! Basic UMFPACK interface: overloaded names ! ====================================================================== interface umf4csym module procedure umf4csym , umf4csym_ip end interface interface umf4zsym module procedure umf4zsym , umf4zsym_ip , umf4csym , umf4csym_ip end interface interface umf4sym module procedure umf4sym , umf4sym_ip , umf4zsym , umf4zsym_ip , umf4csym , umf4csym_ip end interface interface umf4cnum module procedure umf4cnum , umf4cnum_ip end interface interface umf4znum module procedure umf4znum , umf4znum_ip , umf4cnum , umf4cnum_ip end interface interface umf4num module procedure umf4num , umf4num_ip , umf4znum , umf4znum_ip , umf4cnum , umf4cnum_ip end interface interface umf4csolr module procedure umf4csolr , umf4csolr_ip end interface interface umf4zsolr module procedure umf4zsolr , umf4zsolr_ip , umf4csolr , umf4csolr_ip end interface interface umf4solr module procedure umf4solr , umf4solr_ip , umf4zsolr , umf4zsolr_ip , umf4csolr , umf4csolr_ip end interface interface umf4csol module procedure umf4csol , umf4csol_ip end interface interface umf4zsol module procedure umf4zsol , umf4zsol_ip , umf4csol , umf4csol_ip end interface interface umf4sol module procedure umf4sol , umf4sol_ip , umf4zsol , umf4zsol_ip , umf4csol , umf4csol_ip end interface interface umf4cscal module procedure umf4cscal , umf4cscal_ip end interface interface umf4zscal module procedure umf4zscal , umf4zscal_ip , umf4cscal , umf4cscal_ip end interface interface umf4scal module procedure umf4scal , umf4scal_ip , umf4zscal , umf4zscal_ip , umf4cscal , umf4cscal_ip end interface interface umf4cfnum module procedure umf4cfnum , umf4cfnum_ip end interface interface umf4zfnum module procedure umf4zfnum , umf4zfnum_ip end interface interface umf4fnum module procedure umf4fnum , umf4fnum_ip end interface interface umf4cfsym module procedure umf4cfsym , umf4cfsym_ip end interface interface umf4zfsym module procedure umf4zfsym , umf4zfsym_ip end interface interface umf4fsym module procedure umf4fsym , umf4fsym_ip end interface interface umf4csnum module procedure umf4csnum , umf4csnum_ip end interface interface umf4zsnum module procedure umf4zsnum , umf4zsnum_ip end interface interface umf4snum module procedure umf4snum , umf4snum_ip end interface interface umf4cssym module procedure umf4cssym , umf4cssym_ip end interface interface umf4zssym module procedure umf4zssym , umf4zssym_ip end interface interface umf4ssym module procedure umf4ssym , umf4ssym_ip end interface interface umf4clnum module procedure umf4clnum , umf4clnum_ip end interface interface umf4zlnum module procedure umf4zlnum , umf4zlnum_ip end interface interface umf4lnum module procedure umf4lnum , umf4lnum_ip end interface interface umf4clsym module procedure umf4clsym , umf4clsym_ip end interface interface umf4zlsym module procedure umf4zlsym , umf4zlsym_ip end interface interface umf4lsym module procedure umf4lsym , umf4lsym_ip end interface ! ====================================================================== ! Defined operator .umfpack. ! ====================================================================== type tCSC_di integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) real ( r8 ), allocatable :: Ax (:) end type type tCSC_zi integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) real ( r8 ), allocatable :: Ax (:) real ( r8 ), allocatable :: Az (:) end type type tCSC_ci integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) complex ( r8 ), allocatable :: Ax (:) end type type tCSR_di integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) real ( r8 ), allocatable :: Ax (:) end type type tCSR_zi integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) real ( r8 ), allocatable :: Ax (:) real ( r8 ), allocatable :: Az (:) end type type tCSR_ci integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) complex ( r8 ), allocatable :: Ax (:) end type type tVec_zi real ( r8 ), allocatable :: x (:) real ( r8 ), allocatable :: z (:) end type type pCSC_di integer , pointer :: Ap (:) integer , pointer :: Ai (:) real ( r8 ), pointer :: Ax (:) end type type pCSC_zi integer , pointer :: Ap (:) integer , pointer :: Ai (:) real ( r8 ), pointer :: Ax (:) real ( r8 ), pointer :: Az (:) end type type pCSC_ci integer , pointer :: Ap (:) integer , pointer :: Ai (:) complex ( r8 ), pointer :: Ax (:) end type type pCSR_di integer , pointer :: Ap (:) integer , pointer :: Ai (:) real ( r8 ), pointer :: Ax (:) end type type pCSR_zi integer , pointer :: Ap (:) integer , pointer :: Ai (:) real ( r8 ), pointer :: Ax (:) real ( r8 ), pointer :: Az (:) end type type pCSR_ci integer , pointer :: Ap (:) integer , pointer :: Ai (:) complex ( r8 ), pointer :: Ax (:) end type type pVec_zi real ( r8 ), pointer :: x (:) real ( r8 ), pointer :: z (:) end type ! overloaded structure constructors (not implemented in g95) ! interface pCSC_di ! module procedure make_CSC_di ! end interface ! interface pCSC_zi ! module procedure make_CSC_zi ! end interface ! interface pCSC_ci ! module procedure make_CSC_ci ! end interface interface pCSC module procedure make_CSC_di , make_CSC_zi , make_CSC_ci end interface interface pCSR module procedure make_CSR_di , make_CSR_zi , make_CSR_ci end interface ! interface pVec_zi ! module procedure make_Vec_zi ! end interface interface pVec module procedure make_Vec_zi end interface interface operator (. umfpack .) module procedure umfpack_di_operator_CSC , umfpack_zi_operator_CSC , umfpack_ci_operator_CSC , & umfpack_di_operator_CSR , umfpack_zi_operator_CSR , umfpack_ci_operator_CSR , & umfpack_di_operator_pCSC , umfpack_zi_operator_pCSC , umfpack_ci_operator_pCSC , & umfpack_di_operator_pCSR , umfpack_zi_operator_pCSR , umfpack_ci_operator_pCSR end interface contains ! ====================================================================== ! Full UMFPACK interface: Fortran wrappers ! ====================================================================== integer function umfpack_di_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: n_row , n_col integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , optional , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_n_row , c_n_col type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Symbolic , c_Control , c_Info c_n_row = n_row c_n_col = n_col c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_di_symbolic = c_umfpack_di_symbolic ( c_n_row , c_n_col , c_Ap , c_Ai , c_Ax , c_Symbolic , c_Control , c_Info ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end function subroutine s_umfpack_di_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info , status ) integer , intent ( in ) :: n_row , n_col integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), optional , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_di_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_symbolic ( n_row , n_col , Ap , Ai , Ax , Az , Symbolic , Control , Info ) integer , intent ( in ) :: n_row , n_col integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , optional , intent ( in ) :: Ax ( * ) real ( r8 ), target , intent ( in ) :: Az ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_n_row , c_n_col type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Control , c_Info c_n_row = n_row c_n_col = n_col c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif c_Az = c_loc ( Az ) if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_zi_symbolic = c_umfpack_zi_symbolic ( c_n_row , c_n_col , c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Control , c_Info ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end function subroutine s_umfpack_zi_symbolic ( n_row , n_col , Ap , Ai , Ax , Az , Symbolic , Control , Info , status ) integer , intent ( in ) :: n_row , n_col integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), optional , intent ( in ) :: Ax ( * ) real ( r8 ), intent ( in ) :: Az ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_zi_symbolic ( n_row , n_col , Ap , Ai , Ax , Az , Symbolic , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_ci_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: n_row , n_col integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), target , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_n_row , c_n_col type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Control , c_Info c_n_row = n_row c_n_col = n_col c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) c_Ax = c_loc ( Ax ) c_Az = c_null_ptr if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_ci_symbolic = c_umfpack_zi_symbolic ( c_n_row , c_n_col , c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Control , c_Info ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end function subroutine s_umfpack_ci_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info , status ) integer , intent ( in ) :: n_row , n_col integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_ci_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Symbolic , c_Numeric , c_Control , c_Info c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) c_Ax = c_loc ( Ax ) if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_di_numeric = c_umfpack_di_numeric ( c_Ap , c_Ai , c_Ax , c_Symbolic , c_Numeric , c_Control , c_Info ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end function subroutine s_umfpack_di_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info , status ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_di_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , intent ( in ) :: Ax ( * ), Az ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Numeric , c_Control , c_Info c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) c_Ax = c_loc ( Ax ) c_Az = c_loc ( Az ) if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_zi_numeric = c_umfpack_zi_numeric ( c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Numeric , c_Control , c_Info ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end function subroutine s_umfpack_zi_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info , status ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_zi_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_ci_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), target , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Numeric , c_Control , c_Info c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) c_Ax = c_loc ( Ax ) c_Az = c_null_ptr if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_ci_numeric = c_umfpack_zi_numeric ( c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Numeric , c_Control , c_Info ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end function subroutine s_umfpack_ci_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info , status ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_ci_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_solve ( sys , Ap , Ai , Ax , X , B , Numeric , Control , Info ) integer , optional , intent ( in ) :: sys integer , target , optional , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , optional , intent ( in ) :: Ax ( * ) real ( r8 ), target :: X ( * ) real ( r8 ), target , intent ( in ) :: B ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_sys type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_X , c_B , c_Numeric , c_Control , c_Info if ( present ( sys )) then ; c_sys = sys ; else ; c_sys = UMFPACK_A ; endif if ( present ( Ap )) then ; c_Ap = c_loc ( Ap ) ; else ; c_Ap = c_null_ptr ; endif if ( present ( Ai )) then ; c_Ai = c_loc ( Ai ) ; else ; c_Ai = c_null_ptr ; endif if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif c_X = c_loc ( X ) c_B = c_loc ( B ) if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_di_solve = c_umfpack_di_solve ( c_sys , c_Ap , c_Ai , c_Ax , c_X , c_B , c_Numeric , c_Control , c_Info ) end function subroutine s_umfpack_di_solve ( sys , Ap , Ai , Ax , X , B , Numeric , Control , Info , status ) integer , optional , intent ( in ) :: sys integer , optional , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), optional , intent ( in ) :: Ax ( * ) real ( r8 ), intent ( out ) :: X ( * ) real ( r8 ), intent ( in ) :: B ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_di_solve ( sys , Ap , Ai , Ax , X , B , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_solve ( sys , Ap , Ai , Ax , Az , Xx , Xz , Bx , Bz , Numeric , Control , Info ) integer , optional , intent ( in ) :: sys integer , target , optional , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , optional , intent ( in ) :: Ax ( * ), Az ( * ) real ( r8 ), target :: Xx ( * ), Xz ( * ) real ( r8 ), target , intent ( in ) :: Bx ( * ), Bz ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_sys type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric , c_Control , c_Info if ( present ( sys )) then ; c_sys = sys ; else ; c_sys = UMFPACK_A ; endif if ( present ( Ap )) then ; c_Ap = c_loc ( Ap ) ; else ; c_Ap = c_null_ptr ; endif if ( present ( Ai )) then ; c_Ai = c_loc ( Ai ) ; else ; c_Ai = c_null_ptr ; endif if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif if ( present ( Az )) then ; c_Az = c_loc ( Az ) ; else ; c_Az = c_null_ptr ; endif c_Xx = c_loc ( Xx ) c_Xz = c_loc ( Xz ) c_Bx = c_loc ( Bx ) c_Bz = c_loc ( Bz ) if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_zi_solve = c_umfpack_zi_solve ( c_sys , c_Ap , c_Ai , c_Ax , c_Az , c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric , c_Control , c_Info ) end function subroutine s_umfpack_zi_solve ( sys , Ap , Ai , Ax , Az , Xx , Xz , Bx , Bz , Numeric , Control , Info , status ) integer , optional , intent ( in ) :: sys integer , optional , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), optional , intent ( in ) :: Ax ( * ), Az ( * ) real ( r8 ), intent ( out ) :: Xx ( * ), Xz ( * ) real ( r8 ), intent ( in ) :: Bx ( * ), Bz ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_zi_solve ( sys , Ap , Ai , Ax , Az , Xx , Xz , Bx , Bz , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_ci_solve ( sys , Ap , Ai , Ax , Xx , Bx , Numeric , Control , Info ) integer , optional , intent ( in ) :: sys integer , target , optional , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), target , optional , intent ( in ) :: Ax ( * ) complex ( r8 ), target :: Xx ( * ) complex ( r8 ), target , intent ( in ) :: Bx ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_sys type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric , c_Control , c_Info if ( present ( sys )) then ; c_sys = sys ; else ; c_sys = UMFPACK_A ; endif if ( present ( Ap )) then ; c_Ap = c_loc ( Ap ) ; else ; c_Ap = c_null_ptr ; endif if ( present ( Ai )) then ; c_Ai = c_loc ( Ai ) ; else ; c_Ai = c_null_ptr ; endif if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif c_Az = c_null_ptr c_Xx = c_loc ( Xx ) c_Xz = c_null_ptr c_Bx = c_loc ( Bx ) c_Bz = c_null_ptr if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_ci_solve = c_umfpack_zi_solve ( c_sys , c_Ap , c_Ai , c_Ax , c_Az , c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric , c_Control , c_Info ) end function subroutine s_umfpack_ci_solve ( sys , Ap , Ai , Ax , Xx , Bx , Numeric , Control , Info , status ) integer , optional , intent ( in ) :: sys integer , optional , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), optional , intent ( in ) :: Ax ( * ) complex ( r8 ), intent ( out ) :: Xx ( * ) complex ( r8 ), intent ( in ) :: Bx ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_ci_solve ( sys , Ap , Ai , Ax , Xx , Bx , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine subroutine umfpack_di_free_symbolic ( Symbolic ) type ( c_ptr ), optional :: Symbolic type ( c_ptr ) :: c_Symbolic if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif call c_umfpack_di_free_symbolic ( c_Symbolic ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end subroutine subroutine umfpack_zi_free_symbolic ( Symbolic ) type ( c_ptr ), optional :: Symbolic type ( c_ptr ) :: c_Symbolic if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif call c_umfpack_zi_free_symbolic ( c_Symbolic ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end subroutine subroutine umfpack_free_symbolic ( Symbolic , version ) type ( c_ptr ), optional :: Symbolic character ( * ), optional :: version type ( c_ptr ) :: c_Symbolic character ( 2 ) :: c_version if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_free_symbolic ( c_Symbolic ) case ( \"ci\" ) ; call umfpack_zi_free_symbolic ( c_Symbolic ) case default ; call umfpack_di_free_symbolic ( c_Symbolic ) end select end subroutine subroutine umfpack_di_free_numeric ( Numeric ) type ( c_ptr ), optional :: Numeric type ( c_ptr ) :: c_Numeric if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif call c_umfpack_di_free_numeric ( c_Numeric ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end subroutine subroutine umfpack_zi_free_numeric ( Numeric ) type ( c_ptr ), optional :: Numeric type ( c_ptr ) :: c_Numeric if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif call c_umfpack_zi_free_numeric ( c_Numeric ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end subroutine subroutine umfpack_free_numeric ( Numeric , version ) type ( c_ptr ), optional :: Numeric character ( * ), optional :: version type ( c_ptr ) :: c_Numeric character ( 2 ) :: c_version if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_free_numeric ( c_Numeric ) case ( \"ci\" ) ; call umfpack_zi_free_numeric ( c_Numeric ) case default ; call umfpack_di_free_numeric ( c_Numeric ) end select end subroutine integer function umfpack_di_scale ( X , B , Numeric ) real ( r8 ), target :: X ( * ) real ( r8 ), target , intent ( in ) :: B ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric type ( c_ptr ) :: c_X , c_B , c_Numeric c_X = c_loc ( X ) c_B = c_loc ( B ) if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif umfpack_di_scale = c_umfpack_di_scale ( c_X , c_B , c_Numeric ) end function subroutine s_umfpack_di_scale ( X , B , Numeric , status ) real ( r8 ), intent ( out ) :: X ( * ) real ( r8 ), intent ( in ) :: B ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric integer , optional :: status integer :: c_status c_status = umfpack_di_scale ( X , B , Numeric ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_scale ( Xx , Xz , Bx , Bz , Numeric ) real ( r8 ), target :: Xx ( * ), Xz ( * ) real ( r8 ), target , intent ( in ) :: Bx ( * ), Bz ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric type ( c_ptr ) :: c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric c_Xx = c_loc ( Xx ) c_Xz = c_loc ( Xz ) c_Bx = c_loc ( Bx ) c_Bz = c_loc ( Bz ) if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif umfpack_zi_scale = c_umfpack_zi_scale ( c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric ) end function subroutine s_umfpack_zi_scale ( Xx , Xz , Bx , Bz , Numeric , status ) real ( r8 ), intent ( out ) :: Xx ( * ), Xz ( * ) real ( r8 ), intent ( in ) :: Bx ( * ), Bz ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric integer , optional :: status integer :: c_status c_status = umfpack_zi_scale ( Xx , Xz , Bx , Bz , Numeric ) if ( present ( status )) status = c_status end subroutine integer function umfpack_ci_scale ( Xx , Bx , Numeric ) complex ( r8 ), target :: Xx ( * ) complex ( r8 ), target , intent ( in ) :: Bx ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric type ( c_ptr ) :: c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric c_Xx = c_loc ( Xx ) c_Xz = c_null_ptr c_Bx = c_loc ( Bx ) c_Bz = c_null_ptr if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif umfpack_ci_scale = c_umfpack_zi_scale ( c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric ) end function subroutine s_umfpack_ci_scale ( Xx , Bx , Numeric , status ) complex ( r8 ), intent ( out ) :: Xx ( * ) complex ( r8 ), intent ( in ) :: Bx ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric integer , optional :: status integer :: c_status c_status = umfpack_ci_scale ( Xx , Bx , Numeric ) if ( present ( status )) status = c_status end subroutine subroutine umfpack_di_defaults ( Control ) real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Control if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif call c_umfpack_di_defaults ( c_Control ) end subroutine subroutine umfpack_zi_defaults ( Control ) real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Control if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif call c_umfpack_zi_defaults ( c_Control ) end subroutine subroutine umfpack_defaults ( Control , version ) real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_defaults ( Control ) case ( \"ci\" ) ; call umfpack_zi_defaults ( Control ) case default ; call umfpack_di_defaults ( Control ) end select end subroutine subroutine umfpack_di_report_control ( Control ) use iso_fortran_env , only : output_unit real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Control logical :: isOpened if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif inquire ( output_unit , opened = isOpened ) if ( isOpened ) flush ( output_unit ) call c_umfpack_di_report_control ( c_Control ) if ( isOpened ) flush ( output_unit ) end subroutine subroutine umfpack_zi_report_control ( Control ) use iso_fortran_env , only : output_unit real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Control logical :: isOpened if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif inquire ( output_unit , opened = isOpened ) if ( isOpened ) flush ( output_unit ) call c_umfpack_zi_report_control ( c_Control ) if ( isOpened ) flush ( output_unit ) end subroutine subroutine umfpack_report_control ( Control , version ) real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_report_control ( Control ) case ( \"ci\" ) ; call umfpack_zi_report_control ( Control ) case default ; call umfpack_di_report_control ( Control ) end select end subroutine subroutine umfpack_di_report_info ( Control , Info ) use iso_fortran_env , only : output_unit real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) real ( r8 ), target :: Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Control , c_Info logical :: isOpened if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif c_Info = c_loc ( Info ) inquire ( output_unit , opened = isOpened ) if ( isOpened ) flush ( output_unit ) call c_umfpack_di_report_info ( c_Control , c_Info ) if ( isOpened ) flush ( output_unit ) end subroutine subroutine umfpack_zi_report_info ( Control , Info ) use iso_fortran_env , only : output_unit real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) real ( r8 ), target :: Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Control , c_Info logical :: isOpened if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif c_Info = c_loc ( Info ) inquire ( output_unit , opened = isOpened ) if ( isOpened ) flush ( output_unit ) call c_umfpack_zi_report_info ( c_Control , c_Info ) if ( isOpened ) flush ( output_unit ) end subroutine subroutine umfpack_report_info ( Control , Info , version ) real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) real ( r8 ) :: Info ( 0 : UMFPACK_INFO - 1 ) character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_report_info ( Control , Info ) case ( \"ci\" ) ; call umfpack_zi_report_info ( Control , Info ) case default ; call umfpack_di_report_info ( Control , Info ) end select end subroutine integer function umfpack_di_save_numeric ( Numeric , filename ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename umfpack_di_save_numeric = c_umfpack_di_save_numeric ( Numeric , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_di_save_numeric ( Numeric , filename , status ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_di_save_numeric ( Numeric , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_save_numeric ( Numeric , filename ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename umfpack_zi_save_numeric = c_umfpack_zi_save_numeric ( Numeric , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_zi_save_numeric ( Numeric , filename , status ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_zi_save_numeric ( Numeric , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_save_numeric ( Numeric , filename , version ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; umfpack_save_numeric = umfpack_zi_save_numeric ( Numeric , filename ) case ( \"ci\" ) ; umfpack_save_numeric = umfpack_zi_save_numeric ( Numeric , filename ) case default ; umfpack_save_numeric = umfpack_di_save_numeric ( Numeric , filename ) end select end function subroutine s_umfpack_save_numeric ( Numeric , filename , status , version ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status character ( * ), optional :: version integer :: c_status c_status = umfpack_save_numeric ( Numeric , filename , version ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_save_symbolic ( Symbolic , filename ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename umfpack_di_save_symbolic = c_umfpack_di_save_symbolic ( Symbolic , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_di_save_symbolic ( Symbolic , filename , status ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_di_save_symbolic ( Symbolic , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_save_symbolic ( Symbolic , filename ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename umfpack_zi_save_symbolic = c_umfpack_zi_save_symbolic ( Symbolic , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_zi_save_symbolic ( Symbolic , filename , status ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_zi_save_symbolic ( Symbolic , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_save_symbolic ( Symbolic , filename , version ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; umfpack_save_symbolic = umfpack_zi_save_symbolic ( Symbolic , filename ) case ( \"ci\" ) ; umfpack_save_symbolic = umfpack_zi_save_symbolic ( Symbolic , filename ) case default ; umfpack_save_symbolic = umfpack_di_save_symbolic ( Symbolic , filename ) end select end function subroutine s_umfpack_save_symbolic ( Symbolic , filename , status , version ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status character ( * ), optional :: version integer :: c_status c_status = umfpack_save_symbolic ( Symbolic , filename , version ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_load_numeric ( Numeric , filename ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename umfpack_di_load_numeric = c_umfpack_di_load_numeric ( Numeric , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_di_load_numeric ( Numeric , filename , status ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_di_load_numeric ( Numeric , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_load_numeric ( Numeric , filename ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename umfpack_zi_load_numeric = c_umfpack_zi_load_numeric ( Numeric , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_zi_load_numeric ( Numeric , filename , status ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_zi_load_numeric ( Numeric , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_load_numeric ( Numeric , filename , version ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; umfpack_load_numeric = umfpack_zi_load_numeric ( Numeric , filename ) case ( \"ci\" ) ; umfpack_load_numeric = umfpack_zi_load_numeric ( Numeric , filename ) case default ; umfpack_load_numeric = umfpack_di_load_numeric ( Numeric , filename ) end select end function subroutine s_umfpack_load_numeric ( Numeric , filename , status , version ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status character ( * ), optional :: version integer :: c_status c_status = umfpack_load_numeric ( Numeric , filename , version ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_load_symbolic ( Symbolic , filename ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename umfpack_di_load_symbolic = c_umfpack_di_load_symbolic ( Symbolic , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_di_load_symbolic ( Symbolic , filename , status ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_di_load_symbolic ( Symbolic , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_load_symbolic ( Symbolic , filename ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename umfpack_zi_load_symbolic = c_umfpack_zi_load_symbolic ( Symbolic , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_zi_load_symbolic ( Symbolic , filename , status ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_zi_load_symbolic ( Symbolic , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_load_symbolic ( Symbolic , filename , version ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; umfpack_load_symbolic = umfpack_zi_load_symbolic ( Symbolic , filename ) case ( \"ci\" ) ; umfpack_load_symbolic = umfpack_zi_load_symbolic ( Symbolic , filename ) case default ; umfpack_load_symbolic = umfpack_di_load_symbolic ( Symbolic , filename ) end select end function subroutine s_umfpack_load_symbolic ( Symbolic , filename , status , version ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status character ( * ), optional :: version integer :: c_status c_status = umfpack_load_symbolic ( Symbolic , filename , version ) if ( present ( status )) status = c_status end subroutine ! ====================================================================== ! Basic UMFPACK interface: Fortran wrappers ! ====================================================================== subroutine umf4def ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_defaults ( Control ) end subroutine subroutine umf4zdef ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_defaults ( Control , \"zi\" ) end subroutine subroutine umf4cdef ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_defaults ( Control , \"zi\" ) end subroutine subroutine umf4pcon ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_report_control ( Control ) end subroutine subroutine umf4zpcon ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_report_control ( Control , \"zi\" ) end subroutine subroutine umf4cpcon ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_report_control ( Control , \"zi\" ) end subroutine subroutine umf4sym ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) end subroutine subroutine umf4zsym ( m , n , Ap , Ai , Ax , Az , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) type ( c_ptr ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , Az , Symbolic , Control , Info ) end subroutine subroutine umf4csym ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) end subroutine subroutine umf4sym_ip ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) integer ( ip ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic c_Symbolic = c_null_ptr call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , c_Symbolic , Control , Info ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4zsym_ip ( m , n , Ap , Ai , Ax , Az , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) integer ( ip ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic c_Symbolic = c_null_ptr call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , Az , c_Symbolic , Control , Info ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4csym_ip ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) integer ( ip ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic c_Symbolic = c_null_ptr call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , c_Symbolic , Control , Info ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4num ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) end subroutine subroutine umf4znum ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) type ( c_ptr ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) end subroutine subroutine umf4cnum ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) end subroutine subroutine umf4num_ip ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) integer ( ip ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic , c_Numeric c_Symbolic = transfer ( Symbolic , c_Symbolic ) c_Numeric = c_null_ptr call s_umfpack_numeric ( Ap , Ai , Ax , c_Symbolic , c_Numeric , Control , Info ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4znum_ip ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) integer ( ip ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic , c_Numeric c_Symbolic = transfer ( Symbolic , c_Symbolic ) c_Numeric = c_null_ptr call s_umfpack_numeric ( Ap , Ai , Ax , Az , c_Symbolic , c_Numeric , Control , Info ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4cnum_ip ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) integer ( ip ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic , c_Numeric c_Symbolic = transfer ( Symbolic , c_Symbolic ) c_Numeric = c_null_ptr call s_umfpack_numeric ( Ap , Ai , Ax , c_Symbolic , c_Numeric , Control , Info ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4solr ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_solve ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) end subroutine subroutine umf4zsolr ( sys , Ap , Ai , Ax , Az , x , xz , b , bz , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_solve ( sys , Ap , Ai , Ax , Az , x , xz , b , bz , Numeric , Control , Info ) end subroutine subroutine umf4csolr ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_solve ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) end subroutine subroutine umf4solr_ip ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call s_umfpack_solve ( sys , Ap , Ai , Ax , x , b , c_Numeric , Control , Info ) end subroutine subroutine umf4zsolr_ip ( sys , Ap , Ai , Ax , Az , x , xz , b , bz , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call s_umfpack_solve ( sys , Ap , Ai , Ax , Az , x , xz , b , bz , c_Numeric , Control , Info ) end subroutine subroutine umf4csolr_ip ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call s_umfpack_solve ( sys , Ap , Ai , Ax , x , b , c_Numeric , Control , Info ) end subroutine subroutine umf4sol ( sys , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,b,Numeric,c_Control,Info) call s_umfpack_solve ( sys , x = x , b = b , Numeric = Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4zsol ( sys , x , xz , b , bz , Numeric , Control , Info ) integer , intent ( in ) :: sys real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,xz,b,bz,Numeric,c_Control,Info) call s_umfpack_solve ( sys , xx = x , xz = xz , bx = b , bz = bz , Numeric = Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4csol ( sys , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,b,Numeric,c_Control,Info) call s_umfpack_solve ( sys , xx = x , bx = b , Numeric = Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4sol_ip ( sys , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,b,c_Numeric,c_Control,Info) call s_umfpack_solve ( sys , x = x , b = b , Numeric = c_Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4zsol_ip ( sys , x , xz , b , bz , Numeric , Control , Info ) integer , intent ( in ) :: sys real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,xz,b,bz,c_Numeric,c_Control,Info) call s_umfpack_zi_solve ( sys , xx = x , xz = xz , bx = b , bz = bz , Numeric = c_Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4csol_ip ( sys , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,b,c_Numeric,c_Control,Info) call s_umfpack_ci_solve ( sys , xx = x , bx = b , Numeric = c_Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4scal ( x , b , Numeric , status ) real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric integer , intent ( out ) :: status status = umfpack_scale_function ( x , b , Numeric ) end subroutine subroutine umf4zscal ( x , xz , b , bz , Numeric , status ) real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) type ( c_ptr ) :: Numeric integer , intent ( out ) :: status status = umfpack_scale_function ( x , xz , b , bz , Numeric ) end subroutine subroutine umf4cscal ( x , b , Numeric , status ) complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric integer , intent ( out ) :: status status = umfpack_scale_function ( x , b , Numeric ) end subroutine subroutine umf4scal_ip ( x , b , Numeric , status ) real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_scale_function ( x , b , c_Numeric ) end subroutine subroutine umf4zscal_ip ( x , xz , b , bz , Numeric , status ) real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) integer ( ip ) :: Numeric integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_scale_function ( x , xz , b , bz , c_Numeric ) end subroutine subroutine umf4cscal_ip ( x , b , Numeric , status ) complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_scale_function ( x , b , c_Numeric ) end subroutine subroutine umf4pinf ( Control , Info ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call umfpack_report_info ( Control , Info ) end subroutine subroutine umf4zpinf ( Control , Info ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call umfpack_report_info ( Control , Info , \"zi\" ) end subroutine subroutine umf4cpinf ( Control , Info ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call umfpack_report_info ( Control , Info , \"ci\" ) end subroutine subroutine umf4fnum ( Numeric ) type ( c_ptr ) :: Numeric call umfpack_free_numeric ( Numeric ) end subroutine subroutine umf4zfnum ( Numeric ) type ( c_ptr ) :: Numeric call umfpack_free_numeric ( Numeric , \"zi\" ) end subroutine subroutine umf4cfnum ( Numeric ) type ( c_ptr ) :: Numeric call umfpack_free_numeric ( Numeric , \"ci\" ) end subroutine subroutine umf4fnum_ip ( Numeric ) integer ( ip ) :: Numeric type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call umfpack_free_numeric ( c_Numeric ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4zfnum_ip ( Numeric ) integer ( ip ) :: Numeric type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call umfpack_free_numeric ( c_Numeric , \"zi\" ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4cfnum_ip ( Numeric ) integer ( ip ) :: Numeric type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call umfpack_free_numeric ( c_Numeric , \"ci\" ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4fsym ( Symbolic ) type ( c_ptr ) :: Symbolic call umfpack_free_symbolic ( Symbolic ) end subroutine subroutine umf4zfsym ( Symbolic ) type ( c_ptr ) :: Symbolic call umfpack_free_symbolic ( Symbolic , \"zi\" ) end subroutine subroutine umf4cfsym ( Symbolic ) type ( c_ptr ) :: Symbolic call umfpack_free_symbolic ( Symbolic , \"ci\" ) end subroutine subroutine umf4fsym_ip ( Symbolic ) integer ( ip ) :: Symbolic type ( c_ptr ) :: c_Symbolic c_Symbolic = transfer ( Symbolic , c_Symbolic ) call umfpack_free_symbolic ( c_Symbolic ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4zfsym_ip ( Symbolic ) integer ( ip ) :: Symbolic type ( c_ptr ) :: c_Symbolic c_Symbolic = transfer ( Symbolic , c_Symbolic ) call umfpack_free_symbolic ( c_Symbolic , \"zi\" ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4cfsym_ip ( Symbolic ) integer ( ip ) :: Symbolic type ( c_ptr ) :: c_Symbolic c_Symbolic = transfer ( Symbolic , c_Symbolic ) call umfpack_free_symbolic ( c_Symbolic , \"ci\" ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4snum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_save_numeric ( Numeric , filename ) end subroutine subroutine umf4zsnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_save_numeric ( Numeric , filename , \"zi\" ) end subroutine subroutine umf4csnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_save_numeric ( Numeric , filename , \"ci\" ) end subroutine subroutine umf4snum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_save_numeric ( c_Numeric , filename ) end subroutine subroutine umf4zsnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_save_numeric ( c_Numeric , filename , \"zi\" ) end subroutine subroutine umf4csnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_save_numeric ( c_Numeric , filename , \"ci\" ) end subroutine subroutine umf4ssym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_save_symbolic ( Symbolic , filename ) end subroutine subroutine umf4zssym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_save_symbolic ( Symbolic , filename , \"zi\" ) end subroutine subroutine umf4cssym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_save_symbolic ( Symbolic , filename , \"ci\" ) end subroutine subroutine umf4ssym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = transfer ( Symbolic , c_Symbolic ) status = umfpack_save_symbolic ( c_Symbolic , filename ) end subroutine subroutine umf4zssym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = transfer ( Symbolic , c_Symbolic ) status = umfpack_save_symbolic ( c_Symbolic , filename , \"zi\" ) end subroutine subroutine umf4cssym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = transfer ( Symbolic , c_Symbolic ) status = umfpack_save_symbolic ( c_Symbolic , filename , \"ci\" ) end subroutine subroutine umf4lnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_load_numeric ( Numeric , filename ) end subroutine subroutine umf4zlnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_load_numeric ( Numeric , filename , \"zi\" ) end subroutine subroutine umf4clnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_load_numeric ( Numeric , filename , \"ci\" ) end subroutine subroutine umf4lnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = c_null_ptr status = umfpack_load_numeric ( c_Numeric , filename ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4zlnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = c_null_ptr status = umfpack_load_numeric ( c_Numeric , filename , \"zi\" ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4clnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = c_null_ptr status = umfpack_load_numeric ( c_Numeric , filename , \"ci\" ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4lsym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_load_symbolic ( Symbolic , filename ) end subroutine subroutine umf4zlsym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_load_symbolic ( Symbolic , filename , \"zi\" ) end subroutine subroutine umf4clsym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_load_symbolic ( Symbolic , filename , \"ci\" ) end subroutine subroutine umf4lsym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = c_null_ptr status = umfpack_load_symbolic ( c_Symbolic , filename ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4zlsym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = c_null_ptr status = umfpack_load_symbolic ( c_Symbolic , filename , \"zi\" ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4clsym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = c_null_ptr status = umfpack_load_symbolic ( c_Symbolic , filename , \"ci\" ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine ! ====================================================================== ! Defined operator .umfpack.: associated procedures ! ====================================================================== function umfpack_di_operator_CSC ( A , B ) result ( X ) type ( tCSC_di ), intent ( in ) :: A real ( c_double ), intent ( in ) :: B ( * ) real ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_di_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_di_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_di_free_symbolic ( Symbolic ) call s_umfpack_di_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_di_free_numeric ( Numeric ) end function function umfpack_zi_operator_CSC ( A , B ) result ( X ) type ( tCSC_zi ), intent ( in ) :: A type ( tVec_zi ), intent ( in ) :: B type ( tVec_zi ) :: X type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr allocate ( X % x ( n ), X % z ( n )) call s_umfpack_zi_symbolic ( n , n , A % Ap , A % Ai , A % Ax , A % Az , Symbolic ) call s_umfpack_zi_numeric ( A % Ap , A % Ai , A % Ax , A % Az , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_zi_solve ( sys , A % Ap , A % Ai , A % Ax , A % Az , X % x , X % z , B % x , B % z , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_ci_operator_CSC ( A , B ) result ( X ) type ( tCSC_ci ), intent ( in ) :: A complex ( c_double ), intent ( in ) :: B ( * ) complex ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_ci_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_ci_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_ci_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_di_operator_CSR ( A , B ) result ( X ) type ( tCSR_di ), intent ( in ) :: A real ( c_double ), intent ( in ) :: B ( * ) real ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_di_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_di_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_di_free_symbolic ( Symbolic ) call s_umfpack_di_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_di_free_numeric ( Numeric ) end function function umfpack_zi_operator_CSR ( A , B ) result ( X ) type ( tCSR_zi ), intent ( in ) :: A type ( tVec_zi ), intent ( in ) :: B type ( tVec_zi ) :: X type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr allocate ( X % x ( n ), X % z ( n )) call s_umfpack_zi_symbolic ( n , n , A % Ap , A % Ai , A % Ax , A % Az , Symbolic ) call s_umfpack_zi_numeric ( A % Ap , A % Ai , A % Ax , A % Az , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_zi_solve ( sys , A % Ap , A % Ai , A % Ax , A % Az , X % x , X % z , B % x , B % z , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_ci_operator_CSR ( A , B ) result ( X ) type ( tCSR_ci ), intent ( in ) :: A complex ( c_double ), intent ( in ) :: B ( * ) complex ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_ci_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_ci_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_ci_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_di_operator_pCSC ( A , B ) result ( X ) type ( pCSC_di ), intent ( in ) :: A real ( c_double ), intent ( in ) :: B (:) real ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_di_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_di_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_di_free_symbolic ( Symbolic ) call s_umfpack_di_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_di_free_numeric ( Numeric ) end function function umfpack_zi_operator_pCSC ( A , B ) result ( X ) type ( pCSC_zi ), intent ( in ) :: A type ( pVec_zi ), intent ( in ) :: B type ( tVec_zi ) :: X type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr allocate ( X % x ( n ), X % z ( n )) call s_umfpack_zi_symbolic ( n , n , A % Ap , A % Ai , A % Ax , A % Az , Symbolic ) call s_umfpack_zi_numeric ( A % Ap , A % Ai , A % Ax , A % Az , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_zi_solve ( sys , A % Ap , A % Ai , A % Ax , A % Az , X % x , X % z , B % x , B % z , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_ci_operator_pCSC ( A , B ) result ( X ) type ( pCSC_ci ), intent ( in ) :: A complex ( c_double ), intent ( in ) :: B ( * ) complex ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_ci_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_ci_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_ci_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_di_operator_pCSR ( A , B ) result ( X ) type ( pCSR_di ), intent ( in ) :: A real ( c_double ), intent ( in ) :: B (:) real ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_di_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_di_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_di_free_symbolic ( Symbolic ) call s_umfpack_di_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_di_free_numeric ( Numeric ) end function function umfpack_zi_operator_pCSR ( A , B ) result ( X ) type ( pCSR_zi ), intent ( in ) :: A type ( pVec_zi ), intent ( in ) :: B type ( tVec_zi ) :: X type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr allocate ( X % x ( n ), X % z ( n )) call s_umfpack_zi_symbolic ( n , n , A % Ap , A % Ai , A % Ax , A % Az , Symbolic ) call s_umfpack_zi_numeric ( A % Ap , A % Ai , A % Ax , A % Az , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_zi_solve ( sys , A % Ap , A % Ai , A % Ax , A % Az , X % x , X % z , B % x , B % z , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_ci_operator_pCSR ( A , B ) result ( X ) type ( pCSR_ci ), intent ( in ) :: A complex ( c_double ), intent ( in ) :: B ( * ) complex ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_ci_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_ci_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_ci_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function type ( pCSC_di ) function make_CSC_di ( Ap , Ai , Ax ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) real ( r8 ), target , intent ( in ) :: Ax (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax end function type ( pCSC_zi ) function make_CSC_zi ( Ap , Ai , Ax , Az ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) real ( r8 ), target , intent ( in ) :: Ax (:), Az (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax result % Az => Az end function type ( pCSC_ci ) function make_CSC_ci ( Ap , Ai , Ax ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) complex ( r8 ), target , intent ( in ) :: Ax (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax end function type ( pCSR_di ) function make_CSR_di ( Ap , Ai , Ax ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) real ( r8 ), target , intent ( in ) :: Ax (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax end function type ( pCSR_zi ) function make_CSR_zi ( Ap , Ai , Ax , Az ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) real ( r8 ), target , intent ( in ) :: Ax (:), Az (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax result % Az => Az end function type ( pCSR_ci ) function make_CSR_ci ( Ap , Ai , Ax ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) complex ( r8 ), target , intent ( in ) :: Ax (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax end function type ( pVec_zi ) function make_Vec_zi ( bx , bz ) result ( result ) real ( r8 ), target , intent ( in ) :: bx (:), bz (:) result % x => bx result % z => bz end function ! ====================================================================== endmodule mumfpack ! ======================================================================","loc":"sourcefile/umfpack.f90.html"},{"tags":"","title":"DATA_FILM – MUSST ","text":"type, public :: DATA_FILM Inherits type~~data_film~~InheritsGraph type~data_film DATA_FILM FLUID FLUID type~data_film->FLUID fl Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables h_0 h_g V_x V_y fl pb_type Source Code DATA_FILM Components Type Visibility Attributes Name Initial real(kind=R8), public :: h_0 h_0 : ambient pressure real(kind=R8), public :: h_g h_g : cavitation pressure real(kind=R8), public :: V_x V_x : surface velocity along x real(kind=R8), public :: V_y V_y : surface velocity along y type(FLUID), public :: fl fluid rheological properties integer(kind=I4), public :: pb_type problem type, e.g. HD (hydrodynamic) Source Code type DATA_FILM real ( kind = R8 ) :: h_0 !! *h_0 : ambient pressure* real ( kind = R8 ) :: h_g !! *h_g : cavitation pressure* real ( kind = R8 ) :: V_x !! *V_x : surface velocity along x* real ( kind = R8 ) :: V_y !! *V_y : surface velocity along y* type ( FLUID ) :: fl !! *fluid rheological properties* integer ( kind = I4 ) :: pb_type !! *problem type, e.g. HD (hydrodynamic)* endtype DATA_FILM","loc":"type/data_film.html"},{"tags":"","title":"PRC_TAB – MUSST ","text":"type, public :: PRC_TAB PRC_TAB stores some precomputed coefficients for the finite element matrices Inherited by type~~prc_tab~~InheritedByGraph type~prc_tab PRC_TAB type~fe_film FE_FILM type~fe_film->type~prc_tab prc Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ng pg wg vni4 vni4x vni4y vni4d vcal Source Code PRC_TAB Components Type Visibility Attributes Name Initial integer(kind=I4), public :: ng Gauss point number along a direction real(kind=R8), public, dimension(:), allocatable :: pg point coordinates in a direction real(kind=R8), public, dimension(:), allocatable :: wg point weight real(kind=R8), public, dimension(:,:,:), allocatable :: vni4 for each node, shape function at Gauss points real(kind=R8), public, dimension(:,:,:), allocatable :: vni4x for each node, shape function derivative at Gauss points real(kind=R8), public, dimension(:,:,:), allocatable :: vni4y for each node, shape function derivative at Gauss points real(kind=R8), public, dimension(:,:,:), allocatable :: vni4d for each node, upwind shape function at Gauss points real(kind=R8), public, dimension(:,:,:), allocatable :: vcal 14 values calculated at the Gauss points Source Code type PRC_TAB !! <span style=\"color:green\"> !!   *PRC_TAB* stores some precomputed coefficients for the finite element matrices !! </span> integer ( kind = I4 ) :: ng !! *Gauss point number along a direction* real ( kind = R8 ), dimension (:), allocatable :: pg !! *point coordinates in a direction* real ( kind = R8 ), dimension (:), allocatable :: wg !! *point weight* real ( kind = R8 ), dimension (:,:,:), allocatable :: vni4 !! *for each node, shape function at Gauss points* real ( kind = R8 ), dimension (:,:,:), allocatable :: vni4x !! *for each node, shape function derivative at Gauss points* real ( kind = R8 ), dimension (:,:,:), allocatable :: vni4y !! *for each node, shape function derivative at Gauss points* real ( kind = R8 ), dimension (:,:,:), allocatable :: vni4d !! *for each node, upwind shape function at Gauss points* real ( kind = R8 ), dimension (:,:,:), allocatable :: vcal !! *14 values calculated at the Gauss points* endtype PRC_TAB","loc":"type/prc_tab.html"},{"tags":"","title":"FE_FILM – MUSST ","text":"type, public :: FE_FILM FE_FILM stores the whole stuff related to a film: the nodal variables, the mesh, etc. Inherits type~~fe_film~~InheritsGraph type~fe_film FE_FILM type~prc_tab PRC_TAB type~fe_film->type~prc_tab prc NUM_PAR NUM_PAR type~fe_film->NUM_PAR num_p DATA_FILM DATA_FILM type~fe_film->DATA_FILM data_f FE_MESH FE_MESH type~fe_film->FE_MESH m Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables n_vn n_vc m data_f prc num_p vn vc bc vn_name vc_name Type-Bound Procedures fx fy fz Source Code FE_FILM Components Type Visibility Attributes Name Initial integer(kind=I4), public :: n_vn number of nodal variables integer(kind=I4), public :: n_vc number of variables on cells type(FE_MESH), public :: m mesh of the film type(DATA_FILM), public :: data_f data of the problem type( PRC_TAB ), public :: prc precomputation type(NUM_PAR), public :: num_p numerical param for iterative solution real(kind=R8), public, dimension(:,:), allocatable :: vn nodal variables table real(kind=R8), public, dimension(:,:), allocatable :: vc cell variables table integer(kind=I4), public, dimension(:,:), allocatable :: bc boundary nodes code character(len=20), public, dimension(:), allocatable :: vn_name nodal variable names character(len=20), public, dimension(:), allocatable :: vc_name cell variable names Type-Bound Procedures procedure, public :: fx force computation along x private function fx (fe_f) Read more… Arguments Type Intent Optional Attributes Name class( FE_FILM ), intent(inout) :: fe_f FE film Return Value real(kind=R8) procedure, public :: fy force computation along y private function fy (fe_f) Read more… Arguments Type Intent Optional Attributes Name class( FE_FILM ), intent(inout) :: fe_f FE film Return Value real(kind=R8) procedure, public :: fz force computation along z private function fz (fe_f) Read more… Arguments Type Intent Optional Attributes Name class( FE_FILM ), intent(inout) :: fe_f fluid type Return Value real(kind=R8) Source Code type FE_FILM !! <span style=\"color:green\"> !!   *FE_FILM* stores the whole stuff related to a film: the nodal variables, the mesh, etc. !! </span> integer ( kind = I4 ) :: n_vn !! *number of nodal variables* integer ( kind = I4 ) :: n_vc !! *number of variables on cells* type ( FE_MESH ) :: m !! *mesh of the film* type ( DATA_FILM ) :: data_f !! *data of the problem* type ( PRC_TAB ) :: prc !! *precomputation* type ( NUM_PAR ) :: num_p !! *numerical param for iterative solution* real ( kind = R8 ), dimension (:,:), allocatable :: vn !! *nodal variables table* real ( kind = R8 ), dimension (:,:), allocatable :: vc !! *cell variables table* integer ( kind = I4 ), dimension (:,:), allocatable :: bc !! *boundary nodes code* character ( len = 20 ), dimension (:), allocatable :: vn_name !! *nodal variable names* character ( len = 20 ), dimension (:), allocatable :: vc_name !! *cell variable names* contains procedure :: fx !! *force computation along* x procedure :: fy !! *force computation along* y procedure :: fz !! *force computation along* z endtype FE_FILM","loc":"type/fe_film.html"},{"tags":"","title":"FLUID – MUSST ","text":"type, public :: FLUID Contents Variables fluid_type p_0 rho_0 mu_0 T_0 rg lambda cst Type-Bound Procedures rho drhodp pres Source Code FLUID Components Type Visibility Attributes Name Initial integer(kind=I4), public :: fluid_type constant for the fluid type: INC, GP, MIXT real(kind=R8), public :: p_0 reference pressure real(kind=R8), public :: rho_0 reference liquid density real(kind=R8), public :: mu_0 reference dynamic viscosity real(kind=R8), public :: T_0 reference temperature real(kind=R8), public :: rg perfect gas constant real(kind=R8), public :: lambda gas mass fraction real(kind=R8), public, dimension(20) :: cst table of parameters for the thermodynamic and rheological laws Type-Bound Procedures procedure, public :: rho density private function rho (fl, p, t) Read more… Arguments Type Intent Optional Attributes Name class( FLUID ), intent(in) :: fl fluid type real(kind=R8), intent(in) :: p pressure real(kind=R8), intent(in) :: t absolute temperature Return Value real(kind=R8) procedure, public :: drhodp compressibility private function drhodp (fl, p, t) Read more… Arguments Type Intent Optional Attributes Name class( FLUID ), intent(in) :: fl fluid type real(kind=R8), intent(in) :: p pressure real(kind=R8), intent(in) :: t absolute temperature Return Value real(kind=R8) procedure, public :: pres pressure (perfect gas) private function pres (fl, rho, t) Read more… Arguments Type Intent Optional Attributes Name class( FLUID ), intent(in) :: fl fluid type real(kind=R8), intent(in) :: rho density real(kind=R8), intent(in) :: t absolute temperature Return Value real(kind=R8) Source Code type FLUID integer ( kind = I4 ) :: fluid_type !! *constant for the fluid type: INC, GP, MIXT* real ( kind = R8 ) :: p_0 !! *reference pressure* real ( kind = R8 ) :: rho_0 !! *reference liquid density* real ( kind = R8 ) :: mu_0 !! *reference dynamic viscosity* real ( kind = R8 ) :: T_0 !! *reference temperature* real ( kind = R8 ) :: rg !! *perfect gas constant* real ( kind = R8 ) :: lambda !! *gas mass fraction* real ( kind = R8 ), dimension ( 20 ) :: cst !! *table of parameters for the thermodynamic and rheological laws* contains procedure :: rho !! *density* procedure :: drhodp !! *compressibility* procedure :: pres !! *pressure (perfect gas)* endtype FLUID","loc":"type/fluid.html"},{"tags":"","title":"FE_EDGE – MUSST ","text":"type, public :: FE_EDGE Inherited by type~~fe_edge~~InheritedByGraph type~fe_edge FE_EDGE type~fe_mesh FE_MESH type~fe_mesh->type~fe_edge ed Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables n ne nm con Source Code FE_EDGE Components Type Visibility Attributes Name Initial integer(kind=I4), public :: n number of nodes integer(kind=I4), public :: ne number of elements integer(kind=I4), public, dimension(:), allocatable :: nm mesh node (numbers in the 2d mesh) integer(kind=I4), public, dimension(:,:), allocatable :: con connectivity table Source Code type FE_EDGE integer ( kind = I4 ) :: n !! *number of nodes* integer ( kind = I4 ) :: ne !! *number of elements* integer ( kind = I4 ), dimension (:), allocatable :: nm !! *mesh node (numbers in the 2d mesh)* integer ( kind = I4 ), dimension (:,:), allocatable :: con !! *connectivity table* endtype FE_EDGE","loc":"type/fe_edge.html"},{"tags":"","title":"FE_MESH – MUSST ","text":"type, public :: FE_MESH Inherits type~~fe_mesh~~InheritsGraph type~fe_mesh FE_MESH type~fe_edge FE_EDGE type~fe_mesh->type~fe_edge ed Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables lx ly zx zy nx ny n ne ned nc x y z con el_t el_n ed cor Source Code FE_MESH Components Type Visibility Attributes Name Initial real(kind=R8), public :: lx size of rectangle real(kind=R8), public :: ly size of rectangle real(kind=R8), public :: zx coordinates of first point real(kind=R8), public :: zy coordinates of first point integer(kind=I4), public :: nx number of nodes in x , y directions integer(kind=I4), public :: ny number of nodes in x , y directions integer(kind=I4), public :: n number of nodes integer(kind=I4), public :: ne number of elements integer(kind=I4), public :: ned number of edges integer(kind=I4), public :: nc number of corners real(kind=R8), public, dimension(:), allocatable :: x nodes coordinates real(kind=R8), public, dimension(:), allocatable :: y nodes coordinates real(kind=R8), public, dimension(:), allocatable :: z nodes coordinates integer(kind=I4), public, dimension(:,:), allocatable :: con connectivity table integer(kind=I4), public, dimension(:), allocatable :: el_t element type integer(kind=I4), public, dimension(:), allocatable :: el_n element number of lines type( FE_EDGE ), public, dimension(:), allocatable :: ed edges of the mesh integer(kind=I4), public, dimension(:), allocatable :: cor number of the corner node Source Code type FE_MESH real ( kind = R8 ) :: lx , ly !! *size of rectangle* real ( kind = R8 ) :: zx , zy !! *coordinates of first point* integer ( kind = I4 ) :: nx , ny !! *number of nodes in x, y directions* integer ( kind = I4 ) :: n !! *number of nodes* integer ( kind = I4 ) :: ne !! *number of elements* integer ( kind = I4 ) :: ned !! *number of edges* integer ( kind = I4 ) :: nc !! *number of corners* real ( kind = R8 ), dimension (:), allocatable :: x , y , z !! *nodes coordinates* integer ( kind = I4 ), dimension (:,:), allocatable :: con !! *connectivity table* integer ( kind = I4 ), dimension (:), allocatable :: el_t !! *element type* integer ( kind = I4 ), dimension (:), allocatable :: el_n !! *element number of lines* type ( FE_EDGE ), dimension (:), allocatable :: ed !! *edges of the mesh* integer ( kind = I4 ), dimension (:), allocatable :: cor !! *number of the corner node* endtype FE_MESH","loc":"type/fe_mesh.html"},{"tags":"","title":"MS_FE_FILM – MUSST ","text":"type, public :: MS_FE_FILM MS_FE_FILM is the top-scale FE_FILM plus all of the bottom-scale FE_FILM Inherits type~~ms_fe_film~~InheritsGraph type~ms_fe_film MS_FE_FILM FE_FILM FE_FILM type~ms_fe_film->FE_FILM ts_fe_f, bs_fe_f Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ts_fe_f bs_fe_f Type-Bound Procedures ms_fx ms_fy ms_fz Source Code MS_FE_FILM Components Type Visibility Attributes Name Initial type(FE_FILM), public :: ts_fe_f top-scale fe_film type(FE_FILM), public, dimension(:), allocatable :: bs_fe_f bottom-scale fe_film Type-Bound Procedures procedure, public :: ms_fx force computation along x private function ms_fx (ms_fe_f) Read more… Arguments Type Intent Optional Attributes Name class( MS_FE_FILM ), intent(inout) :: ms_fe_f Return Value real(kind=R8) procedure, public :: ms_fy force computation along y private function ms_fy (ms_fe_f) Read more… Arguments Type Intent Optional Attributes Name class( MS_FE_FILM ), intent(inout) :: ms_fe_f Return Value real(kind=R8) procedure, public :: ms_fz force computation along z private function ms_fz (ms_fe_f) Read more… Arguments Type Intent Optional Attributes Name class( MS_FE_FILM ), intent(inout) :: ms_fe_f MS FE film Return Value real(kind=R8) Source Code type MS_FE_FILM !! <span style=\"color:green\"> !!   *MS_FE_FILM* is the top-scale [[FE_FILM]] plus all of the bottom-scale [[FE_FILM]] !! </span> type ( FE_FILM ) :: ts_fe_f !! *top-scale fe_film* type ( FE_FILM ), dimension (:), allocatable :: bs_fe_f !! *bottom-scale fe_film* contains procedure :: ms_fx !! *force computation along x* procedure :: ms_fy !! *force computation along y* procedure :: ms_fz !! *force computation along z* endtype ms_fe_film","loc":"type/ms_fe_film.html"},{"tags":"","title":"NUM_PAR – MUSST ","text":"type, public :: NUM_PAR Contents Variables relax eps it_max mess Source Code NUM_PAR Components Type Visibility Attributes Name Initial real(kind=R8), public :: relax relaxation parameter real(kind=R8), public :: eps error for convergence integer(kind=I4), public :: it_max maximal number of iterations integer(kind=I4), public :: mess message Source Code type NUM_PAR real ( kind = R8 ) :: relax !! *relaxation parameter* real ( kind = R8 ) :: eps !! *error for convergence* integer ( kind = I4 ) :: it_max !! *maximal number of iterations* integer ( kind = I4 ) :: mess !! *message* endtype NUM_PAR","loc":"type/num_par.html"},{"tags":"","title":"SCALE_SURF – MUSST ","text":"type, public :: SCALE_SURF Surface object: header and heights Note Adapted from 'surffile.c', 'gwyddion' software, Copyright (C) 2005 David Necas, Petr Klapetek. Warning Must be 512 bytes long Contents Variables signature xlength_unit ylength_unit zlength_unit xaxis yaxis zaxis dx_unit dy_unit dz_unit object_name operator_name client_zone reserved reservedzone obsolete obsolete2 dx dy dz xunit_ratio yunit_ratio zunit_ratio XOffset YOffset ZOffset measurement_duration zmin zmax xres yres nofpoints format version material_code type range special_points absolute pointsize imprint inversion leveling seconds minutes hours day month year dayof comment_size private_size nobjects acquisition lx ly lz mu si Source Code SCALE_SURF Components Type Visibility Attributes Name Initial character(len=12), public :: signature character(len=16), public :: xlength_unit character(len=16), public :: ylength_unit character(len=16), public :: zlength_unit character(len=16), public :: xaxis character(len=16), public :: yaxis character(len=16), public :: zaxis character(len=16), public :: dx_unit character(len=16), public :: dy_unit character(len=16), public :: dz_unit character(len=30), public :: object_name character(len=30), public :: operator_name character(len=128), public :: client_zone character(len=8), public :: reserved character(len=34), public :: reservedzone character(len=12), public :: obsolete character(len=10), public :: obsolete2 real(kind=R4), public :: dx real(kind=R4), public :: dy real(kind=R4), public :: dz real(kind=R4), public :: xunit_ratio real(kind=R4), public :: yunit_ratio real(kind=R4), public :: zunit_ratio real(kind=R4), public :: XOffset real(kind=R4), public :: YOffset real(kind=R4), public :: ZOffset real(kind=R4), public :: measurement_duration integer(kind=I4), public :: zmin integer(kind=I4), public :: zmax integer(kind=I4), public :: xres integer(kind=I4), public :: yres integer(kind=I4), public :: nofpoints integer(kind=2), public :: format integer(kind=2), public :: version integer(kind=2), public :: material_code integer(kind=2), public :: type integer(kind=2), public :: range integer(kind=2), public :: special_points integer(kind=2), public :: absolute integer(kind=2), public :: pointsize integer(kind=2), public :: imprint integer(kind=2), public :: inversion integer(kind=2), public :: leveling integer(kind=2), public :: seconds integer(kind=2), public :: minutes integer(kind=2), public :: hours integer(kind=2), public :: day integer(kind=2), public :: month integer(kind=2), public :: year integer(kind=2), public :: dayof integer(kind=2), public :: comment_size integer(kind=2), public :: private_size integer(kind=2), public :: nobjects integer(kind=2), public :: acquisition real(kind=R8), public :: lx surface length real(kind=R8), public :: ly surface width real(kind=R8), public :: lz surface height (max -min) real(kind=R8), public :: mu surface mean height real(kind=R8), public :: si surface mean height Source Code type SCALE_SURF ! bytes below: 8+10+2*12+9*16+2*30+34+128 = 408 character ( len = 12 ) :: signature character ( len = 16 ) :: xlength_unit character ( len = 16 ) :: ylength_unit character ( len = 16 ) :: zlength_unit character ( len = 16 ) :: xaxis character ( len = 16 ) :: yaxis character ( len = 16 ) :: zaxis character ( len = 16 ) :: dx_unit character ( len = 16 ) :: dy_unit character ( len = 16 ) :: dz_unit character ( len = 30 ) :: object_name character ( len = 30 ) :: operator_name character ( len = 128 ) :: client_zone character ( len = 8 ) :: reserved character ( len = 34 ) :: reservedzone character ( len = 12 ) :: obsolete character ( len = 10 ) :: obsolete2 ! bytes below: 10*4 = 40 real ( kind = R4 ) :: dx real ( kind = R4 ) :: dy real ( kind = R4 ) :: dz real ( kind = R4 ) :: xunit_ratio real ( kind = R4 ) :: yunit_ratio real ( kind = R4 ) :: zunit_ratio real ( kind = R4 ) :: XOffset real ( kind = R4 ) :: YOffset real ( kind = R4 ) :: ZOffset real ( kind = R4 ) :: measurement_duration ! bytes below: 5*4 = 20 integer ( kind = I4 ) :: zmin integer ( kind = I4 ) :: zmax integer ( kind = I4 ) :: xres integer ( kind = I4 ) :: yres integer ( kind = I4 ) :: nofpoints ! bytes below: 22*2 = 44 integer ( kind = 2 ) :: format integer ( kind = 2 ) :: version integer ( kind = 2 ) :: material_code integer ( kind = 2 ) :: type integer ( kind = 2 ) :: range integer ( kind = 2 ) :: special_points integer ( kind = 2 ) :: absolute integer ( kind = 2 ) :: pointsize integer ( kind = 2 ) :: imprint integer ( kind = 2 ) :: inversion integer ( kind = 2 ) :: leveling integer ( kind = 2 ) :: seconds integer ( kind = 2 ) :: minutes integer ( kind = 2 ) :: hours integer ( kind = 2 ) :: day integer ( kind = 2 ) :: month integer ( kind = 2 ) :: year integer ( kind = 2 ) :: dayof integer ( kind = 2 ) :: comment_size integer ( kind = 2 ) :: private_size integer ( kind = 2 ) :: nobjects integer ( kind = 2 ) :: acquisition real ( kind = R8 ) :: lx !! *surface length* real ( kind = R8 ) :: ly !! *surface width* real ( kind = R8 ) :: lz !! *surface height (max -min)* real ( kind = R8 ) :: mu !! *surface mean height* real ( kind = R8 ) :: si !! *surface mean height* endtype SCALE_SURF","loc":"type/scale_surf.html"},{"tags":"","title":"OBJ_SURF – MUSST ","text":"type, public :: OBJ_SURF Contents Variables signature xlength_unit ylength_unit zlength_unit xaxis yaxis zaxis dx_unit dy_unit dz_unit object_name operator_name client_zone reserved reservedzone obsolete obsolete2 dx dy dz xunit_ratio yunit_ratio zunit_ratio XOffset YOffset ZOffset measurement_duration zmin zmax xres yres nofpoints format version material_code type range special_points absolute pointsize imprint inversion leveling seconds minutes hours day month year dayof comment_size private_size nobjects acquisition val Source Code OBJ_SURF Components Type Visibility Attributes Name Initial character(kind=C_CHAR), public, dimension( 12) :: signature character(kind=C_CHAR), public, dimension( 16) :: xlength_unit character(kind=C_CHAR), public, dimension( 16) :: ylength_unit character(kind=C_CHAR), public, dimension( 16) :: zlength_unit character(kind=C_CHAR), public, dimension( 16) :: xaxis character(kind=C_CHAR), public, dimension( 16) :: yaxis character(kind=C_CHAR), public, dimension( 16) :: zaxis character(kind=C_CHAR), public, dimension( 16) :: dx_unit character(kind=C_CHAR), public, dimension( 16) :: dy_unit character(kind=C_CHAR), public, dimension( 16) :: dz_unit character(kind=C_CHAR), public, dimension( 30) :: object_name character(kind=C_CHAR), public, dimension( 30) :: operator_name character(kind=C_CHAR), public, dimension(128) :: client_zone character(kind=C_CHAR), public, dimension(  8) :: reserved character(kind=C_CHAR), public, dimension( 34) :: reservedzone character(kind=C_CHAR), public, dimension( 12) :: obsolete character(kind=C_CHAR), public, dimension( 10) :: obsolete2 real(kind=C_FLOAT), public :: dx real(kind=C_FLOAT), public :: dy real(kind=C_FLOAT), public :: dz real(kind=C_FLOAT), public :: xunit_ratio real(kind=C_FLOAT), public :: yunit_ratio real(kind=C_FLOAT), public :: zunit_ratio real(kind=C_FLOAT), public :: XOffset real(kind=C_FLOAT), public :: YOffset real(kind=C_FLOAT), public :: ZOffset real(kind=C_FLOAT), public :: measurement_duration integer(kind=C_INT), public :: zmin integer(kind=C_INT), public :: zmax integer(kind=C_INT), public :: xres integer(kind=C_INT), public :: yres integer(kind=C_INT), public :: nofpoints integer(kind=C_SHORT), public :: format integer(kind=C_SHORT), public :: version integer(kind=C_SHORT), public :: material_code integer(kind=C_SHORT), public :: type integer(kind=C_SHORT), public :: range integer(kind=C_SHORT), public :: special_points integer(kind=C_SHORT), public :: absolute integer(kind=C_SHORT), public :: pointsize integer(kind=C_SHORT), public :: imprint integer(kind=C_SHORT), public :: inversion integer(kind=C_SHORT), public :: leveling integer(kind=C_SHORT), public :: seconds integer(kind=C_SHORT), public :: minutes integer(kind=C_SHORT), public :: hours integer(kind=C_SHORT), public :: day integer(kind=C_SHORT), public :: month integer(kind=C_SHORT), public :: year integer(kind=C_SHORT), public :: dayof integer(kind=C_SHORT), public :: comment_size integer(kind=C_SHORT), public :: private_size integer(kind=C_SHORT), public :: nobjects integer(kind=C_SHORT), public :: acquisition integer(kind=C_INT), public, allocatable :: val (:) heights Source Code type OBJ_SURF ! bytes below: 8+10+2*12+9*16+2*30+34+128 = 408 character ( kind = C_CHAR ), dimension ( 12 ) :: signature character ( kind = C_CHAR ), dimension ( 16 ) :: xlength_unit character ( kind = C_CHAR ), dimension ( 16 ) :: ylength_unit character ( kind = C_CHAR ), dimension ( 16 ) :: zlength_unit character ( kind = C_CHAR ), dimension ( 16 ) :: xaxis character ( kind = C_CHAR ), dimension ( 16 ) :: yaxis character ( kind = C_CHAR ), dimension ( 16 ) :: zaxis character ( kind = C_CHAR ), dimension ( 16 ) :: dx_unit character ( kind = C_CHAR ), dimension ( 16 ) :: dy_unit character ( kind = C_CHAR ), dimension ( 16 ) :: dz_unit character ( kind = C_CHAR ), dimension ( 30 ) :: object_name character ( kind = C_CHAR ), dimension ( 30 ) :: operator_name character ( kind = C_CHAR ), dimension ( 128 ) :: client_zone character ( kind = C_CHAR ), dimension ( 8 ) :: reserved character ( kind = C_CHAR ), dimension ( 34 ) :: reservedzone character ( kind = C_CHAR ), dimension ( 12 ) :: obsolete character ( kind = C_CHAR ), dimension ( 10 ) :: obsolete2 ! bytes below: 10*4 = 40 real ( kind = C_FLOAT ) :: dx real ( kind = C_FLOAT ) :: dy real ( kind = C_FLOAT ) :: dz real ( kind = C_FLOAT ) :: xunit_ratio real ( kind = C_FLOAT ) :: yunit_ratio real ( kind = C_FLOAT ) :: zunit_ratio real ( kind = C_FLOAT ) :: XOffset real ( kind = C_FLOAT ) :: YOffset real ( kind = C_FLOAT ) :: ZOffset real ( kind = C_FLOAT ) :: measurement_duration ! bytes below: 5*4 = 20 integer ( kind = C_INT ) :: zmin integer ( kind = C_INT ) :: zmax integer ( kind = C_INT ) :: xres integer ( kind = C_INT ) :: yres integer ( kind = C_INT ) :: nofpoints ! bytes below: 22*2 = 44 integer ( kind = C_SHORT ) :: format integer ( kind = C_SHORT ) :: version integer ( kind = C_SHORT ) :: material_code integer ( kind = C_SHORT ) :: type integer ( kind = C_SHORT ) :: range integer ( kind = C_SHORT ) :: special_points integer ( kind = C_SHORT ) :: absolute integer ( kind = C_SHORT ) :: pointsize integer ( kind = C_SHORT ) :: imprint integer ( kind = C_SHORT ) :: inversion integer ( kind = C_SHORT ) :: leveling integer ( kind = C_SHORT ) :: seconds integer ( kind = C_SHORT ) :: minutes integer ( kind = C_SHORT ) :: hours integer ( kind = C_SHORT ) :: day integer ( kind = C_SHORT ) :: month integer ( kind = C_SHORT ) :: year integer ( kind = C_SHORT ) :: dayof integer ( kind = C_SHORT ) :: comment_size integer ( kind = C_SHORT ) :: private_size integer ( kind = C_SHORT ) :: nobjects integer ( kind = C_SHORT ) :: acquisition integer ( kind = C_INT ), allocatable :: val (:) !! *heights* endtype OBJ_SURF","loc":"type/obj_surf.html"},{"tags":"","title":"DMUMPS_STRUC – MUSST ","text":"type, public :: DMUMPS_STRUC sequence Inherits type~~dmumps_struc~~InheritsGraph type~dmumps_struc DMUMPS_STRUC DMUMPS_ROOT_STRUC DMUMPS_ROOT_STRUC type~dmumps_struc->DMUMPS_ROOT_STRUC root Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables COMM SYM PAR JOB N NZ NNZ A IRN JCN COLSCA ROWSCA pad0 NZ_loc pad1 NNZ_loc IRN_loc JCN_loc A_loc pad2 NELT pad3 ELTPTR ELTVAR A_ELT pad4 PERM_IN RHS REDRHS RHS_SPARSE SOL_loc IRHS_SPARSE IRHS_PTR ISOL_loc LRHS NRHS NZ_RHS LSOL_loc LREDRHS pad5 ICNTL INFO INFOG COST_SUBTREES CNTL RINFO RINFOG SYM_PERM UNS_PERM NPROW NPCOL MBLOCK NBLOCK SCHUR_MLOC SCHUR_NLOC SCHUR_LLD SIZE_SCHUR SCHUR SCHUR_CINTERFACE LISTVAR_SCHUR MAPPING VERSION_NUMBER OOC_TMPDIR OOC_PREFIX WRITE_PROBLEM SAVE_DIR SAVE_PREFIX pad8 KEEP8 MAX_SURF_MASTER INST_Number COMM_NODES MYID_NODES COMM_LOAD MYID NPROCS NSLAVES ASS_IRECV LBUFR LBUFR_BYTES BUFR IS IS1 MAXIS1 Deficiency KEEP LNA NBSA STEP NE_STEPS ND_STEPS Step2node FRERE_STEPS DAD_STEPS FILS FRTPTR FRTELT PTRAR NA PROCNODE_STEPS PTLUST_S PTRFAC S PROCNODE INTARR DBLARR NELT_loc LELTVAR ELTPROC CANDIDATES ISTEP_TO_INIV2 FUTURE_NIV2 TAB_POS_IN_PERE I_AM_CAND MEM_DIST POSINRHSCOMP_ROW POSINRHSCOMP_COL_ALLOC pad11 POSINRHSCOMP_COL RHSCOMP MEM_SUBTREE COST_TRAV MY_ROOT_SBTR MY_FIRST_LEAF MY_NB_LEAF DEPTH_FIRST DEPTH_FIRST_SEQ SBTR_ID SCHED_DEP SCHED_GRP SCHED_SBTR CROIX_MANU WK_USER NBSA_LOCAL LWK_USER DKEEP CB_SON_SIZE INSTANCE_NUMBER OOC_MAX_NB_NODES_FOR_ZONE OOC_INODE_SEQUENCE OOC_SIZE_OF_BLOCK OOC_VADDR OOC_TOTAL_NB_NODES OOC_NB_FILES OOC_NB_FILE_TYPE pad12 OOC_FILE_NAME_LENGTH OOC_FILE_NAMES PIVNUL_LIST SUP_PROC pad14 IPTR_WORKING WORKING root LRGROUPS NBGRP pad13 FDM_F_ENCODING BLRARRAY_ENCODING LPOOL_AFTER_L0_OMP LPOOL_BEFORE_L0_OMP L_PHYS_L0_OMP L_VIRT_L0_OMP LL0_OMP_MAPPING pad15 THREAD_LA IPOOL_BEFORE_L0_OMP IPOOL_AFTER_L0_OMP PHYS_L0_OMP VIRT_L0_OMP PERM_L0_OMP PTR_LEAFS_L0_OMP L0_OMP_MAPPING SINGULAR_VALUES NB_SINGULAR_VALUES ASSOCIATED_OOC_FILES Source Code DMUMPS_STRUC Components Type Visibility Attributes Name Initial integer, public :: COMM integer, public :: SYM integer, public :: PAR integer, public :: JOB integer, public :: N integer, public :: NZ integer(kind=8), public :: NNZ double precision, public, DIMENSION(:), POINTER :: A integer, public, DIMENSION(:), POINTER :: IRN integer, public, DIMENSION(:), POINTER :: JCN double precision, public, DIMENSION(:), POINTER :: COLSCA double precision, public, DIMENSION(:), POINTER :: ROWSCA double precision, public, DIMENSION(:), POINTER :: pad0 integer, public :: NZ_loc integer, public :: pad1 integer(kind=8), public :: NNZ_loc integer, public, DIMENSION(:), POINTER :: IRN_loc integer, public, DIMENSION(:), POINTER :: JCN_loc double precision, public, DIMENSION(:), POINTER :: A_loc double precision, public, DIMENSION(:), POINTER :: pad2 integer, public :: NELT integer, public :: pad3 integer, public, DIMENSION(:), POINTER :: ELTPTR integer, public, DIMENSION(:), POINTER :: ELTVAR double precision, public, DIMENSION(:), POINTER :: A_ELT double precision, public, DIMENSION(:), POINTER :: pad4 integer, public, DIMENSION(:), POINTER :: PERM_IN double precision, public, DIMENSION(:), POINTER :: RHS double precision, public, DIMENSION(:), POINTER :: REDRHS double precision, public, DIMENSION(:), POINTER :: RHS_SPARSE double precision, public, DIMENSION(:), POINTER :: SOL_loc integer, public, DIMENSION(:), POINTER :: IRHS_SPARSE integer, public, DIMENSION(:), POINTER :: IRHS_PTR integer, public, DIMENSION(:), POINTER :: ISOL_loc integer, public :: LRHS integer, public :: NRHS integer, public :: NZ_RHS integer, public :: LSOL_loc integer, public :: LREDRHS integer, public :: pad5 integer, public :: ICNTL (40) integer, public :: INFO (40) integer, public :: INFOG (40) double precision, public :: COST_SUBTREES double precision, public :: CNTL (15) double precision, public :: RINFO (40) double precision, public :: RINFOG (40) integer, public, DIMENSION(:), POINTER :: SYM_PERM integer, public, DIMENSION(:), POINTER :: UNS_PERM integer, public :: NPROW integer, public :: NPCOL integer, public :: MBLOCK integer, public :: NBLOCK integer, public :: SCHUR_MLOC integer, public :: SCHUR_NLOC integer, public :: SCHUR_LLD integer, public :: SIZE_SCHUR double precision, public, DIMENSION(:), POINTER :: SCHUR double precision, public, DIMENSION(:), POINTER :: SCHUR_CINTERFACE integer, public, DIMENSION(:), POINTER :: LISTVAR_SCHUR integer, public, DIMENSION(:), POINTER :: MAPPING character(len=30), public :: VERSION_NUMBER character(len=255), public :: OOC_TMPDIR character(len=63), public :: OOC_PREFIX character(len=255), public :: WRITE_PROBLEM character(len=255), public :: SAVE_DIR character(len=255), public :: SAVE_PREFIX character(len=7), public :: pad8 integer(kind=8), public :: KEEP8 (150) integer(kind=8), public :: MAX_SURF_MASTER integer, public :: INST_Number integer, public :: COMM_NODES integer, public :: MYID_NODES integer, public :: COMM_LOAD integer, public :: MYID integer, public :: NPROCS integer, public :: NSLAVES integer, public :: ASS_IRECV integer, public :: LBUFR integer, public :: LBUFR_BYTES integer, public, DIMENSION(:), POINTER :: BUFR integer, public, DIMENSION(:), POINTER :: IS integer, public, DIMENSION(:), POINTER :: IS1 integer, public :: MAXIS1 integer, public :: Deficiency integer, public :: KEEP (500) integer, public :: LNA integer, public :: NBSA integer, public, POINTER, DIMENSION(:) :: STEP integer, public, POINTER, DIMENSION(:) :: NE_STEPS integer, public, POINTER, DIMENSION(:) :: ND_STEPS integer, public, POINTER, DIMENSION(:) :: Step2node integer, public, POINTER, DIMENSION(:) :: FRERE_STEPS integer, public, POINTER, DIMENSION(:) :: DAD_STEPS integer, public, POINTER, DIMENSION(:) :: FILS integer, public, POINTER, DIMENSION(:) :: FRTPTR integer, public, POINTER, DIMENSION(:) :: FRTELT integer(kind=8), public, POINTER, DIMENSION(:) :: PTRAR integer, public, POINTER, DIMENSION(:) :: NA integer, public, POINTER, DIMENSION(:) :: PROCNODE_STEPS integer, public, DIMENSION(:), POINTER :: PTLUST_S integer(kind=8), public, DIMENSION(:), POINTER :: PTRFAC double precision, public, DIMENSION(:), POINTER :: S integer, public, DIMENSION(:), POINTER :: PROCNODE integer, public, DIMENSION(:), POINTER :: INTARR double precision, public, DIMENSION(:), POINTER :: DBLARR integer, public :: NELT_loc integer, public :: LELTVAR integer, public, DIMENSION(:), POINTER :: ELTPROC integer, public, DIMENSION(:,:), POINTER :: CANDIDATES integer, public, DIMENSION(:), POINTER :: ISTEP_TO_INIV2 integer, public, DIMENSION(:), POINTER :: FUTURE_NIV2 integer, public, DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE logical, public, DIMENSION(:), POINTER :: I_AM_CAND integer, public, DIMENSION(:), POINTER :: MEM_DIST integer, public, DIMENSION(:), POINTER :: POSINRHSCOMP_ROW logical, public :: POSINRHSCOMP_COL_ALLOC logical, public :: pad11 integer, public, DIMENSION(:), POINTER :: POSINRHSCOMP_COL double precision, public, DIMENSION(:), POINTER :: RHSCOMP double precision, public, DIMENSION(:), POINTER :: MEM_SUBTREE double precision, public, DIMENSION(:), POINTER :: COST_TRAV integer, public, DIMENSION(:), POINTER :: MY_ROOT_SBTR integer, public, DIMENSION(:), POINTER :: MY_FIRST_LEAF integer, public, DIMENSION(:), POINTER :: MY_NB_LEAF integer, public, DIMENSION(:), POINTER :: DEPTH_FIRST integer, public, DIMENSION(:), POINTER :: DEPTH_FIRST_SEQ integer, public, DIMENSION(:), POINTER :: SBTR_ID integer, public, DIMENSION(:), POINTER :: SCHED_DEP integer, public, DIMENSION(:), POINTER :: SCHED_GRP integer, public, DIMENSION(:), POINTER :: SCHED_SBTR integer, public, DIMENSION(:), POINTER :: CROIX_MANU double precision, public, DIMENSION(:), POINTER :: WK_USER integer, public :: NBSA_LOCAL integer, public :: LWK_USER double precision, public :: DKEEP (230) double precision, public, DIMENSION(:), POINTER :: CB_SON_SIZE integer, public :: INSTANCE_NUMBER integer, public :: OOC_MAX_NB_NODES_FOR_ZONE integer, public, DIMENSION(:,:), POINTER :: OOC_INODE_SEQUENCE integer(kind=8), public, DIMENSION(:,:), POINTER :: OOC_SIZE_OF_BLOCK integer(kind=8), public, DIMENSION(:,:), POINTER :: OOC_VADDR integer, public, DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES integer, public, DIMENSION(:), POINTER :: OOC_NB_FILES integer, public :: OOC_NB_FILE_TYPE integer, public :: pad12 integer, public, DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH character, public, DIMENSION(:,:), POINTER :: OOC_FILE_NAMES integer, public, DIMENSION(:), POINTER :: PIVNUL_LIST integer, public, DIMENSION(:,:), POINTER :: SUP_PROC integer, public, DIMENSION(:,:), POINTER :: pad14 integer, public, DIMENSION(:), POINTER :: IPTR_WORKING integer, public, DIMENSION(:), POINTER :: WORKING type(DMUMPS_ROOT_STRUC), public :: root integer, public, POINTER, DIMENSION(:) :: LRGROUPS integer, public :: NBGRP integer, public :: pad13 character(len=1), public, DIMENSION(:), POINTER :: FDM_F_ENCODING character(len=1), public, DIMENSION(:), POINTER :: BLRARRAY_ENCODING integer, public :: LPOOL_AFTER_L0_OMP integer, public :: LPOOL_BEFORE_L0_OMP integer, public :: L_PHYS_L0_OMP integer, public :: L_VIRT_L0_OMP integer, public :: LL0_OMP_MAPPING integer, public :: pad15 integer(kind=8), public :: THREAD_LA integer, public, DIMENSION(:), POINTER :: IPOOL_BEFORE_L0_OMP integer, public, DIMENSION(:), POINTER :: IPOOL_AFTER_L0_OMP integer, public, DIMENSION(:), POINTER :: PHYS_L0_OMP integer, public, DIMENSION(:), POINTER :: VIRT_L0_OMP integer, public, DIMENSION(:), POINTER :: PERM_L0_OMP integer, public, DIMENSION(:), POINTER :: PTR_LEAFS_L0_OMP integer, public, DIMENSION(:), POINTER :: L0_OMP_MAPPING double precision, public, DIMENSION(:), POINTER :: SINGULAR_VALUES integer, public :: NB_SINGULAR_VALUES logical, public :: ASSOCIATED_OOC_FILES Source Code TYPE DMUMPS_STRUC SEQUENCE ! ! This structure contains all parameters ! for the interface to the user, plus internal ! information from the solver ! ! ***************** ! INPUT PARAMETERS ! ***************** !    ----------------- !    MPI Communicator !    ----------------- INTEGER :: COMM !    ------------------ !    Problem definition !    ------------------ !    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite, !        SYM=2 general symmetric) !    Type of parallelism (PAR=1 host working, PAR=0 host not working) INTEGER :: SYM , PAR INTEGER :: JOB !    -------------------- !    Order of Input matrix !    -------------------- INTEGER :: N ! !    ---------------------------------------- !    Assembled input matrix : User interface !    ---------------------------------------- INTEGER :: NZ ! Standard integer input + bwd. compat. INTEGER ( 8 ) :: NNZ ! 64-bit integer input DOUBLE PRECISION , DIMENSION (:), POINTER :: A INTEGER , DIMENSION (:), POINTER :: IRN , JCN DOUBLE PRECISION , DIMENSION (:), POINTER :: COLSCA , ROWSCA , pad0 ! !       ------------------------------------ !       Case of distributed assembled matrix !       matrix on entry: !       ------------------------------------ INTEGER :: NZ_loc ! Standard integer input + bwd. compat. INTEGER :: pad1 INTEGER ( 8 ) :: NNZ_loc ! 64-bit integer input INTEGER , DIMENSION (:), POINTER :: IRN_loc , JCN_loc DOUBLE PRECISION , DIMENSION (:), POINTER :: A_loc , pad2 ! !    ---------------------------------------- !    Unassembled input matrix: User interface !    ---------------------------------------- INTEGER :: NELT , pad3 INTEGER , DIMENSION (:), POINTER :: ELTPTR INTEGER , DIMENSION (:), POINTER :: ELTVAR DOUBLE PRECISION , DIMENSION (:), POINTER :: A_ELT , pad4 ! !    --------------------------------------------- !    Symmetric permutation : !               PERM_IN if given by user (optional) !    --------------------------------------------- INTEGER , DIMENSION (:), POINTER :: PERM_IN ! ! ! ****************** ! INPUT/OUTPUT data ! ****************** !    -------------------------------------------------------- !    RHS / SOL_loc !    ------------- !       right-hand side and solution !    ------------------------------------------------------- DOUBLE PRECISION , DIMENSION (:), POINTER :: RHS , REDRHS DOUBLE PRECISION , DIMENSION (:), POINTER :: RHS_SPARSE DOUBLE PRECISION , DIMENSION (:), POINTER :: SOL_loc INTEGER , DIMENSION (:), POINTER :: IRHS_SPARSE INTEGER , DIMENSION (:), POINTER :: IRHS_PTR INTEGER , DIMENSION (:), POINTER :: ISOL_loc INTEGER :: LRHS , NRHS , NZ_RHS , LSOL_loc , LREDRHS INTEGER :: pad5 !    ---------------------------- !    Control parameters, !    statistics and output data !    --------------------------- INTEGER :: ICNTL ( 40 ) INTEGER :: INFO ( 40 ) INTEGER :: INFOG ( 40 ) DOUBLE PRECISION :: COST_SUBTREES DOUBLE PRECISION :: CNTL ( 15 ) DOUBLE PRECISION :: RINFO ( 40 ) DOUBLE PRECISION :: RINFOG ( 40 ) !    --------------------------------------------------------- !    Permutations computed during analysis: !       SYM_PERM: Symmetric permutation !       UNS_PERM: Column permutation (optional) !    --------------------------------------------------------- INTEGER , DIMENSION (:), POINTER :: SYM_PERM , UNS_PERM ! !    ----- !    Schur !    ----- INTEGER :: NPROW , NPCOL , MBLOCK , NBLOCK INTEGER :: SCHUR_MLOC , SCHUR_NLOC , SCHUR_LLD INTEGER :: SIZE_SCHUR DOUBLE PRECISION , DIMENSION (:), POINTER :: SCHUR DOUBLE PRECISION , DIMENSION (:), POINTER :: SCHUR_CINTERFACE INTEGER , DIMENSION (:), POINTER :: LISTVAR_SCHUR !    ------------------------------------- !    Case of distributed matrix on entry: !    DMUMPS potentially provides mapping !    ------------------------------------- INTEGER , DIMENSION (:), POINTER :: MAPPING !    -------------- !    Version number !    -------------- CHARACTER ( LEN = 30 ) :: VERSION_NUMBER !    ----------- !    Out-of-core !    ----------- CHARACTER ( LEN = 255 ) :: OOC_TMPDIR CHARACTER ( LEN = 63 ) :: OOC_PREFIX !    ------------------------------------------ !    To save the matrix in matrix market format !    ------------------------------------------ CHARACTER ( LEN = 255 ) :: WRITE_PROBLEM !    ----------- !    Save/Restore !    ----------- CHARACTER ( LEN = 255 ) :: SAVE_DIR CHARACTER ( LEN = 255 ) :: SAVE_PREFIX CHARACTER ( LEN = 7 ) :: pad8 ! ! ! ********************** ! INTERNAL Working data ! ********************* INTEGER ( 8 ) :: KEEP8 ( 150 ), MAX_SURF_MASTER INTEGER :: INST_Number !       For MPI INTEGER :: COMM_NODES , MYID_NODES , COMM_LOAD INTEGER :: MYID , NPROCS , NSLAVES INTEGER :: ASS_IRECV INTEGER :: LBUFR INTEGER :: LBUFR_BYTES INTEGER , DIMENSION (:), POINTER :: BUFR !       IS is used for the factors + workspace for contrib. blocks INTEGER , DIMENSION (:), POINTER :: IS !       IS1 (maxis1) contains working arrays computed !       and used only during analysis INTEGER , DIMENSION (:), POINTER :: IS1 !       For analysis/facto/solve phases INTEGER :: MAXIS1 , Deficiency INTEGER :: KEEP ( 500 ) !       The following data/arrays are computed during the analysis !       phase and used during the factorization and solve phases. INTEGER :: LNA INTEGER :: NBSA INTEGER , POINTER , DIMENSION (:) :: STEP , NE_STEPS , ND_STEPS !  Info for pruning tree INTEGER , POINTER , DIMENSION (:) :: Step2node !  --------------------- INTEGER , POINTER , DIMENSION (:) :: FRERE_STEPS , DAD_STEPS INTEGER , POINTER , DIMENSION (:) :: FILS , FRTPTR , FRTELT INTEGER ( 8 ), POINTER , DIMENSION (:) :: PTRAR INTEGER , POINTER , DIMENSION (:) :: NA , PROCNODE_STEPS !       The two pointer arrays computed in facto and used by the solve !          (except the factors) are PTLUST_S and PTRFAC. INTEGER , DIMENSION (:), POINTER :: PTLUST_S INTEGER ( 8 ), DIMENSION (:), POINTER :: PTRFAC !       main real working arrays for factorization/solve phases DOUBLE PRECISION , DIMENSION (:), POINTER :: S !       Information on mapping INTEGER , DIMENSION (:), POINTER :: PROCNODE !       Input matrix ready for numerical assembly !           -arrowhead format in case of assembled matrix !           -element format otherwise INTEGER , DIMENSION (:), POINTER :: INTARR DOUBLE PRECISION , DIMENSION (:), POINTER :: DBLARR !       Element entry: internal data INTEGER :: NELT_loc , LELTVAR INTEGER , DIMENSION (:), POINTER :: ELTPROC !       Candidates and node partitionning INTEGER , DIMENSION (:,:), POINTER :: CANDIDATES INTEGER , DIMENSION (:), POINTER :: ISTEP_TO_INIV2 INTEGER , DIMENSION (:), POINTER :: FUTURE_NIV2 INTEGER , DIMENSION (:,:), POINTER :: TAB_POS_IN_PERE LOGICAL , DIMENSION (:), POINTER :: I_AM_CAND !       For heterogeneous architecture INTEGER , DIMENSION (:), POINTER :: MEM_DIST !       Compressed RHS INTEGER , DIMENSION (:), POINTER :: POSINRHSCOMP_ROW LOGICAL :: POSINRHSCOMP_COL_ALLOC , pad11 INTEGER , DIMENSION (:), POINTER :: POSINRHSCOMP_COL DOUBLE PRECISION , DIMENSION (:), POINTER :: RHSCOMP !       Info on the subtrees to be used during factorization DOUBLE PRECISION , DIMENSION (:), POINTER :: MEM_SUBTREE DOUBLE PRECISION , DIMENSION (:), POINTER :: COST_TRAV INTEGER , DIMENSION (:), POINTER :: MY_ROOT_SBTR INTEGER , DIMENSION (:), POINTER :: MY_FIRST_LEAF INTEGER , DIMENSION (:), POINTER :: MY_NB_LEAF INTEGER , DIMENSION (:), POINTER :: DEPTH_FIRST INTEGER , DIMENSION (:), POINTER :: DEPTH_FIRST_SEQ INTEGER , DIMENSION (:), POINTER :: SBTR_ID INTEGER , DIMENSION (:), POINTER :: SCHED_DEP INTEGER , DIMENSION (:), POINTER :: SCHED_GRP INTEGER , DIMENSION (:), POINTER :: SCHED_SBTR INTEGER , DIMENSION (:), POINTER :: CROIX_MANU DOUBLE PRECISION , DIMENSION (:), POINTER :: WK_USER INTEGER :: NBSA_LOCAL INTEGER :: LWK_USER !    Internal control array DOUBLE PRECISION :: DKEEP ( 230 ) !    For simulating parallel out-of-core stack. DOUBLE PRECISION , DIMENSION (:), POINTER :: CB_SON_SIZE !    Instance number used/managed by the C/F77 interface INTEGER :: INSTANCE_NUMBER !    OOC management data that must persist from factorization to solve. INTEGER :: OOC_MAX_NB_NODES_FOR_ZONE INTEGER , DIMENSION (:,:), POINTER :: OOC_INODE_SEQUENCE INTEGER ( 8 ), DIMENSION (:,:), POINTER :: OOC_SIZE_OF_BLOCK INTEGER ( 8 ), DIMENSION (:,:), POINTER :: OOC_VADDR INTEGER , DIMENSION (:), POINTER :: OOC_TOTAL_NB_NODES INTEGER , DIMENSION (:), POINTER :: OOC_NB_FILES INTEGER :: OOC_NB_FILE_TYPE , pad12 INTEGER , DIMENSION (:), POINTER :: OOC_FILE_NAME_LENGTH CHARACTER , DIMENSION (:,:), POINTER :: OOC_FILE_NAMES !    Indices of nul pivots INTEGER , DIMENSION (:), POINTER :: PIVNUL_LIST !    Array needed to manage additionnal candidate processor INTEGER , DIMENSION (:,:), POINTER :: SUP_PROC , pad14 !    Lists of nodes where processors work. Built/used in solve phase. INTEGER , DIMENSION (:), POINTER :: IPTR_WORKING , WORKING !    Root structure(internal) TYPE ( DMUMPS_ROOT_STRUC ) :: root !    Low-rank INTEGER , POINTER , DIMENSION (:) :: LRGROUPS INTEGER :: NBGRP , pad13 !    Pointer encoding for FDM_F data CHARACTER ( LEN = 1 ), DIMENSION (:), POINTER :: FDM_F_ENCODING !    Pointer array encoding BLR factors pointers CHARACTER ( LEN = 1 ), DIMENSION (:), POINTER :: BLRARRAY_ENCODING !    Multicore INTEGER :: LPOOL_AFTER_L0_OMP , LPOOL_BEFORE_L0_OMP INTEGER :: L_PHYS_L0_OMP INTEGER :: L_VIRT_L0_OMP INTEGER :: LL0_OMP_MAPPING , pad15 INTEGER ( 8 ) :: THREAD_LA ! Pool before L0_OMP INTEGER , DIMENSION (:), POINTER :: IPOOL_BEFORE_L0_OMP ! Pool after L0_OMP INTEGER , DIMENSION (:), POINTER :: IPOOL_AFTER_L0_OMP ! Subtrees INTEGER , DIMENSION (:), POINTER :: PHYS_L0_OMP ! Amalgamated subtrees INTEGER , DIMENSION (:), POINTER :: VIRT_L0_OMP ! From heaviest to lowest subtree INTEGER , DIMENSION (:), POINTER :: PERM_L0_OMP ! To get leafs in global pool INTEGER , DIMENSION (:), POINTER :: PTR_LEAFS_L0_OMP ! Mapping of the subtrees INTEGER , DIMENSION (:), POINTER :: L0_OMP_MAPPING ! for RR on root DOUBLE PRECISION , DIMENSION (:), POINTER :: SINGULAR_VALUES INTEGER :: NB_SINGULAR_VALUES ! To know if OOC files are associated to a saved and so if they should be removed. LOGICAL :: ASSOCIATED_OOC_FILES END TYPE DMUMPS_STRUC","loc":"type/dmumps_struc.html"},{"tags":"","title":"MAT_MA48 – MUSST ","text":"type, private :: MAT_MA48 All the stuff needed by HSL_MA48 Inherits type~~mat_ma48~2~~InheritsGraph type~mat_ma48~2 MAT_MA48 MA48_CONTROL MA48_CONTROL type~mat_ma48~2->MA48_CONTROL ctrl MA48_FACTORS MA48_FACTORS type~mat_ma48~2->MA48_FACTORS fact MA48_FINFO MA48_FINFO type~mat_ma48~2->MA48_FINFO finf MA48_SINFO MA48_SINFO type~mat_ma48~2->MA48_SINFO sinf ZD11_TYPE ZD11_TYPE type~mat_ma48~2->ZD11_TYPE zmat MA48_AINFO MA48_AINFO type~mat_ma48~2->MA48_AINFO ainf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables zmat ctrl ainf finf sinf fact fast resid Source Code MAT_MA48 Components Type Visibility Attributes Name Initial type(ZD11_TYPE), public :: zmat type(MA48_CONTROL), public :: ctrl type(MA48_AINFO), public :: ainf type(MA48_FINFO), public :: finf type(MA48_SINFO), public :: sinf type(MA48_FACTORS), public :: fact integer(kind=I4), public :: fast real(kind=R8), public, dimension(2) :: resid Source Code type MAT_MA48 !! <span style=\"color:green\">All the stuff needed by *HSL_MA48*</span> type ( ZD11_TYPE ) :: zmat type ( MA48_CONTROL ) :: ctrl type ( MA48_AINFO ) :: ainf type ( MA48_FINFO ) :: finf type ( MA48_SINFO ) :: sinf type ( MA48_FACTORS ) :: fact integer ( kind = I4 ) :: fast real ( kind = R8 ), dimension ( 2 ) :: resid endtype MAT_MA48","loc":"type/mat_ma48~2.html"},{"tags":"","title":"MAT_MA48 – MUSST ","text":"type, private :: MAT_MA48 Inherited by type~~mat_ma48~~InheritedByGraph type~mat_ma48 MAT_MA48 type~mat_solv MAT_SOLV type~mat_solv->type~mat_ma48 matma48 type~ms_mat_solv MS_MAT_SOLV type~ms_mat_solv->type~mat_solv ts_mat, bs_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MAT_MA48 Source Code type MAT_MA48 !! <span style=\"color:green\">All the stuff needed by *HSL_MA48*</span> type ( ZD11_TYPE ) :: zmat type ( MA48_CONTROL ) :: ctrl type ( MA48_AINFO ) :: ainf type ( MA48_FINFO ) :: finf type ( MA48_SINFO ) :: sinf type ( MA48_FACTORS ) :: fact integer ( kind = I4 ) :: fast real ( kind = R8 ), dimension ( 2 ) :: resid endtype MAT_MA48","loc":"type/mat_ma48.html"},{"tags":"","title":"MAT_UMFP – MUSST ","text":"type, private :: MAT_UMFP All the stuff needed by UMFPACK Inherits type~~mat_umfp~~InheritsGraph type~mat_umfp MAT_UMFP c_ptr c_ptr type~mat_umfp->c_ptr c_symbolic, c_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~mat_umfp~~InheritedByGraph type~mat_umfp MAT_UMFP type~mat_solv MAT_SOLV type~mat_solv->type~mat_umfp matumfp type~ms_mat_solv MS_MAT_SOLV type~ms_mat_solv->type~mat_solv ts_mat, bs_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables c_symbolic c_numeric c_control c_info Source Code MAT_UMFP Components Type Visibility Attributes Name Initial type(c_ptr), public :: c_symbolic type(c_ptr), public :: c_numeric real(kind=R8), public, dimension(0:UMFPACK_CONTROL-1) :: c_control real(kind=R8), public, dimension(0:UMFPACK_INFO   -1) :: c_info Source Code type MAT_UMFP !! <span style=\"color:green\">All the stuff needed by *UMFPACK*</span> type ( c_ptr ) :: c_symbolic type ( c_ptr ) :: c_numeric real ( kind = R8 ), dimension ( 0 : UMFPACK_CONTROL - 1 ) :: c_control real ( kind = R8 ), dimension ( 0 : UMFPACK_INFO - 1 ) :: c_info endtype MAT_UMFP","loc":"type/mat_umfp.html"},{"tags":"","title":"MAT_SOLV – MUSST ","text":"type, public :: MAT_SOLV MUSST high level system type Inherits type~~mat_solv~~InheritsGraph type~mat_solv MAT_SOLV MAT_MUMP MAT_MUMP type~mat_solv->MAT_MUMP matmump MAT_SULU MAT_SULU type~mat_solv->MAT_SULU matsulu type~mat_umfp MAT_UMFP type~mat_solv->type~mat_umfp matumfp type~mat_ma48 MAT_MA48 type~mat_solv->type~mat_ma48 matma48 c_ptr c_ptr type~mat_umfp->c_ptr c_symbolic, c_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~mat_solv~~InheritedByGraph type~mat_solv MAT_SOLV type~ms_mat_solv MS_MAT_SOLV type~ms_mat_solv->type~mat_solv ts_mat, bs_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables slv_t first nn ne nt nz nvar code error mess matmump matma48 matsulu matumfp eltvar eltptr a_elt irow jcol jptr b x Source Code MAT_SOLV Components Type Visibility Attributes Name Initial integer(kind=I4), public :: slv_t solver type logical(kind=I4), public :: first = .true. analysis of the system to be done? integer(kind=I4), public :: nn number of nodes integer(kind=I4), public :: ne number of elements integer(kind=I4), public :: nt number of a priori non-zero terms in the matrix integer(kind=I4), public :: nz number of non-zero terms in the matrix integer(kind=I4), public :: nvar eltvar length ( if 4-nodes elt -> 2 lines X number of elemental matrices) integer(kind=I4), public :: code error code [not used yet] real(kind=R8), public :: error error value [not used yet] character(len=1024), public :: mess message [not used yet] type(MAT_MUMP), public :: matmump matrices for mumps solver type( MAT_MA48 ), public :: matma48 matrices for ma48 solver type(MAT_SULU), public :: matsulu matrices for SuperLu solver type( MAT_UMFP ), public :: matumfp matrices for Umfpack solver integer(kind=I4), public, dimension(:), allocatable :: eltvar rows in assembled matrix integer(kind=I4), public, dimension(:), allocatable :: eltptr element rows pointer real(kind=R8), public, dimension(:), allocatable :: a_elt unassembled rigidity matrix integer(kind=I4), public, dimension(:), allocatable :: irow line number integer(kind=I4), public, dimension(:), allocatable :: jcol column number integer(kind=I4), public, dimension(:), allocatable :: jptr line pointer real(kind=R8), public, dimension(:), allocatable :: b right hand side vector real(kind=R8), public, dimension(:), allocatable :: x unknwon vector Source Code type MAT_SOLV !! <span style=\"color:green\">MUSST high level system type</span> integer ( kind = I4 ) :: slv_t !! *solver type* logical ( kind = I4 ) :: first = . true . !! *analysis of the system to be done?* integer ( kind = I4 ) :: nn !! *number of nodes* integer ( kind = I4 ) :: ne !! *number of elements* integer ( kind = I4 ) :: nt !! *number of **a priori** non-zero terms in the matrix* integer ( kind = I4 ) :: nz !! *number of non-zero terms in the matrix* integer ( kind = I4 ) :: nvar !! *eltvar length ( if 4-nodes elt -> 2 lines X number of elemental matrices)* integer ( kind = I4 ) :: code !! *error code*   [not used yet] real ( kind = R8 ) :: error !! *error value*  [not used yet] character ( len = 1024 ) :: mess !! *message*      [not used yet] !..................................................... type ( MAT_MUMP ) :: matmump !! *matrices for mumps solver* type ( MAT_MA48 ) :: matma48 !! *matrices for ma48 solver* type ( MAT_SULU ) :: matsulu !! *matrices for SuperLu solver* type ( MAT_UMFP ) :: matumfp !! *matrices for Umfpack solver* !..................................................... integer ( kind = I4 ), dimension (:), allocatable :: eltvar !! *rows in assembled matrix* integer ( kind = I4 ), dimension (:), allocatable :: eltptr !! *element rows pointer* real ( kind = R8 ), dimension (:), allocatable :: a_elt !! *unassembled rigidity matrix* !..................................................... integer ( kind = I4 ), dimension (:), allocatable :: irow !! *line number* integer ( kind = I4 ), dimension (:), allocatable :: jcol !! *column number* integer ( kind = I4 ), dimension (:), allocatable :: jptr !! *line pointer* !..................................................... real ( kind = R8 ), dimension (:), allocatable :: b !! *right hand side vector* real ( kind = R8 ), dimension (:), allocatable :: x !! *unknwon vector* endtype MAT_SOLV","loc":"type/mat_solv.html"},{"tags":"","title":"MS_MAT_SOLV – MUSST ","text":"type, public :: MS_MAT_SOLV MUSST multiscale high level solver type Note MS_MAT_SOLV is needed by MUSST, but it is useless for the present module Inherits type~~ms_mat_solv~~InheritsGraph type~ms_mat_solv MS_MAT_SOLV type~mat_solv MAT_SOLV type~ms_mat_solv->type~mat_solv ts_mat, bs_mat MAT_MUMP MAT_MUMP type~mat_solv->MAT_MUMP matmump MAT_SULU MAT_SULU type~mat_solv->MAT_SULU matsulu type~mat_umfp MAT_UMFP type~mat_solv->type~mat_umfp matumfp type~mat_ma48 MAT_MA48 type~mat_solv->type~mat_ma48 matma48 c_ptr c_ptr type~mat_umfp->c_ptr c_symbolic, c_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ts_mat bs_mat ass_loc_in_mat Source Code MS_MAT_SOLV Components Type Visibility Attributes Name Initial type( MAT_SOLV ), public :: ts_mat top-scale solver type matrices type( MAT_SOLV ), public, dimension(:), allocatable :: bs_mat bottom-scale solver type matrices (table) integer(kind=I4), public, dimension(:), allocatable :: ass_loc_in_mat table for assembly location (for parallel computation) Source Code type MS_MAT_SOLV type ( MAT_SOLV ) :: ts_mat !! *top-scale solver type matrices* type ( MAT_SOLV ), dimension (:), allocatable :: bs_mat !! *bottom-scale solver type matrices (table)* integer ( kind = I4 ), dimension (:), allocatable :: ass_loc_in_mat !! *table for assembly location (for parallel computation)* endtype ms_mat_solv","loc":"type/ms_mat_solv.html"},{"tags":"","title":"LU_STACK_T – MUSST ","text":"type, private, bind(c) :: LU_STACK_T Inherits type~~lu_stack_t~~InheritsGraph type~lu_stack_t LU_STACK_T C_PTR C_PTR type~lu_stack_t->C_PTR array Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~lu_stack_t~~InheritedByGraph type~lu_stack_t LU_STACK_T type~globallu_t GLOBALLU_T type~globallu_t->type~lu_stack_t stack type~sulu_env SULU_ENV type~sulu_env->type~globallu_t Glu Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables size used top1 top2 array Source Code LU_STACK_T Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: size integer(kind=C_INT), public :: used integer(kind=C_INT), public :: top1 integer(kind=C_INT), public :: top2 type(C_PTR), public :: array Source Code type , bind ( c ) :: LU_STACK_T integer ( kind = C_INT ) :: size integer ( kind = C_INT ) :: used integer ( kind = C_INT ) :: top1 integer ( kind = C_INT ) :: top2 type ( C_PTR ) :: array endtype LU_STACK_T","loc":"type/lu_stack_t.html"},{"tags":"","title":"EXPHEADER – MUSST ","text":"type, private, bind(c) :: EXPHEADER Inherits type~~expheader~~InheritsGraph type~expheader EXPHEADER C_PTR C_PTR type~expheader->C_PTR mem Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~expheader~~InheritedByGraph type~expheader EXPHEADER type~globallu_t GLOBALLU_T type~globallu_t->type~expheader expanders type~sulu_env SULU_ENV type~sulu_env->type~globallu_t Glu Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables size mem Source Code EXPHEADER Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: size type(C_PTR), public :: mem Source Code type , bind ( c ) :: EXPHEADER integer ( kind = C_INT ) :: size type ( C_PTR ) :: mem endtype EXPHEADER","loc":"type/expheader.html"},{"tags":"","title":"GLOBALLU_T – MUSST ","text":"type, private, bind(c) :: GLOBALLU_T Inherits type~~globallu_t~~InheritsGraph type~globallu_t GLOBALLU_T type~lu_stack_t LU_STACK_T type~globallu_t->type~lu_stack_t stack C_PTR C_PTR type~globallu_t->C_PTR lusup, ucol type~expheader EXPHEADER type~globallu_t->type~expheader expanders type~lu_stack_t->C_PTR array type~expheader->C_PTR mem Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~globallu_t~~InheritedByGraph type~globallu_t GLOBALLU_T type~sulu_env SULU_ENV type~sulu_env->type~globallu_t Glu Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables xsup supno lsub xlsub lusup xlusup ucol usub xusub nzlmax nzumax nzlumax MemModel num_expansions expanders stack Source Code GLOBALLU_T Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: xsup integer(kind=C_INT), public :: supno integer(kind=C_INT), public :: lsub integer(kind=C_INT), public :: xlsub type(C_PTR), public :: lusup integer(kind=C_INT), public :: xlusup type(C_PTR), public :: ucol integer(kind=C_INT), public :: usub integer(kind=C_INT), public :: xusub integer(kind=C_INT), public :: nzlmax integer(kind=C_INT), public :: nzumax integer(kind=C_INT), public :: nzlumax integer(kind=C_INT), public :: MemModel = 0 integer(kind=C_INT), public :: num_expansions type( EXPHEADER ), public :: expanders type( LU_STACK_T ), public :: stack Source Code type , bind ( c ) :: GLOBALLU_T integer ( kind = C_INT ) :: xsup integer ( kind = C_INT ) :: supno integer ( kind = C_INT ) :: lsub integer ( kind = C_INT ) :: xlsub type ( C_PTR ) :: lusup integer ( kind = C_INT ) :: xlusup type ( C_PTR ) :: ucol integer ( kind = C_INT ) :: usub integer ( kind = C_INT ) :: xusub integer ( kind = C_INT ) :: nzlmax integer ( kind = C_INT ) :: nzumax integer ( kind = C_INT ) :: nzlumax integer ( kind = C_INT ) :: MemModel = 0 integer ( kind = C_INT ) :: num_expansions type ( EXPHEADER ) :: expanders type ( LU_STACK_T ) :: stack endtype GLOBALLU_T","loc":"type/globallu_t.html"},{"tags":"","title":"SUPERLUSTAT_T – MUSST ","text":"type, private, bind(c) :: SUPERLUSTAT_T Inherits type~~superlustat_t~~InheritsGraph type~superlustat_t SUPERLUSTAT_T C_PTR C_PTR type~superlustat_t->C_PTR panel_histo, utime, ops Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~superlustat_t~~InheritedByGraph type~superlustat_t SUPERLUSTAT_T type~sulu_env SULU_ENV type~sulu_env->type~superlustat_t stat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables panel_histo utime ops TinyPivots RefineSteps expansions Source Code SUPERLUSTAT_T Components Type Visibility Attributes Name Initial type(C_PTR), public :: panel_histo histogram of panel size distribution type(C_PTR), public :: utime running time at various phases type(C_PTR), public :: ops operation count at various phases integer(kind=C_INT), public :: TinyPivots number of tiny pivots integer(kind=C_INT), public :: RefineSteps number of iterative refinement steps integer(kind=C_INT), public :: expansions number of memory expansions Source Code type , bind ( c ) :: SUPERLUSTAT_T type ( C_PTR ) :: panel_histo !! *histogram of panel size distribution* type ( C_PTR ) :: utime !! *running time at various phases* type ( C_PTR ) :: ops !! *operation count at various phases* integer ( kind = C_INT ) :: TinyPivots !! *number of tiny pivots* integer ( kind = C_INT ) :: RefineSteps !! *number of iterative refinement steps* integer ( kind = C_INT ) :: expansions !! *number of memory expansions* endtype SUPERLUSTAT_T","loc":"type/superlustat_t.html"},{"tags":"","title":"MEM_USAGE_T – MUSST ","text":"type, private, bind(c) :: MEM_USAGE_T Inherited by type~~mem_usage_t~~InheritedByGraph type~mem_usage_t MEM_USAGE_T type~sulu_env SULU_ENV type~sulu_env->type~mem_usage_t mem_usage Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables for_lu total_needed Source Code MEM_USAGE_T Components Type Visibility Attributes Name Initial real(kind=C_FLOAT), public :: for_lu real(kind=C_FLOAT), public :: total_needed Source Code type , bind ( c ) :: MEM_USAGE_T real ( kind = C_FLOAT ) :: for_lu real ( kind = C_FLOAT ) :: total_needed endtype MEM_USAGE_T","loc":"type/mem_usage_t.html"},{"tags":"","title":"NCFORMAT – MUSST ","text":"type, private, bind(c) :: NCFORMAT Note Stype == SLU_NC (Also known as Harwell-Boeing sparse matrix format) Zero-based indexing is used; colptr[] has ncol+1 entries, the last one pointing beyond the last column,\n so that colptr[ncol] = nnz. Inherits type~~ncformat~~InheritsGraph type~ncformat NCFORMAT C_PTR C_PTR type~ncformat->C_PTR nzval, rowind, colptr Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables nnz nzval rowind colptr Source Code NCFORMAT Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: nnz number of nonzeros in the matrix type(C_PTR), public :: nzval pointer to array of nonzero values, packed by column type(C_PTR), public :: rowind pointer to array of row indices of the nonzeros type(C_PTR), public :: colptr pointer to array of beginning of columns in nzval[] and rowind[] Source Code type , bind ( c ) :: NCFORMAT integer ( kind = C_INT ) :: nnz !! *number of nonzeros in the matrix* type ( C_PTR ) :: nzval !! *pointer to array of nonzero values, packed by column* type ( C_PTR ) :: rowind !! *pointer to array of row indices of the nonzeros* type ( C_PTR ) :: colptr !! *pointer to array of beginning of columns in nzval[] and rowind[]* endtype NCFORMAT","loc":"type/ncformat.html"},{"tags":"","title":"SUPERMATRIX – MUSST ","text":"type, private, bind(c) :: SUPERMATRIX Inherits type~~supermatrix~~InheritsGraph type~supermatrix SUPERMATRIX C_PTR C_PTR type~supermatrix->C_PTR Store Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~supermatrix~~InheritedByGraph type~supermatrix SUPERMATRIX type~sulu_env SULU_ENV type~sulu_env->type~supermatrix sma, smb, smx, sml, smu Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Stype Dtype Mtype nrow ncol Store Source Code SUPERMATRIX Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: Stype Storage type: interprets the storage structure pointed to by Store integer(kind=C_INT), public :: Dtype Data type integer(kind=C_INT), public :: Mtype Matrix type: describes the mathematical property of the matrix integer(kind=C_INT), public :: nrow number of rows integer(kind=C_INT), public :: ncol number of columns type(C_PTR), public :: Store pointer to the actual storage of the matrix, here, pointer to NCFORMAT Source Code type , bind ( c ) :: SUPERMATRIX integer ( kind = C_INT ) :: Stype !! *Storage type: interprets the storage structure pointed to by Store* integer ( kind = C_INT ) :: Dtype !! *Data type* integer ( kind = C_INT ) :: Mtype !! *Matrix type: describes the mathematical property of the matrix* integer ( kind = C_INT ) :: nrow !! *number of rows* integer ( kind = C_INT ) :: ncol !! *number of columns* type ( C_PTR ) :: Store !! *pointer to the actual storage of the matrix, here, pointer to [[NCformat]]* endtype SUPERMATRIX","loc":"type/supermatrix.html"},{"tags":"","title":"SUPERLU_OPTIONS_T – MUSST ","text":"type, private, bind(c) :: SUPERLU_OPTIONS_T = FACTORED: On entry, L, U, perm_r and perm_c contain the Inherited by type~~superlu_options_t~~InheritedByGraph type~superlu_options_t SUPERLU_OPTIONS_T type~sulu_env SULU_ENV type~sulu_env->type~superlu_options_t options Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Fact Equil ColPerm Trans IterRefine DiagPivotThresh SymmetricMode PivotGrowth ConditionNumber RowPerm ILU_DropRule ILU_DropTol ILU_FillFactor ILU_Norm ILU_FillTol ILU_MILU ILU_MILU_Dim ParSymbFact ReplaceTinyPivot SolveInitialized RefineInitialized PrintStat nnzL nnzU num_lookaheads lookahead_etree SymPattern Source Code SUPERLU_OPTIONS_T Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: Fact integer(kind=C_INT), public :: Equil integer(kind=C_INT), public :: ColPerm integer(kind=C_INT), public :: Trans integer(kind=C_INT), public :: IterRefine real(kind=C_DOUBLE), public :: DiagPivotThresh integer(kind=C_INT), public :: SymmetricMode integer(kind=C_INT), public :: PivotGrowth integer(kind=C_INT), public :: ConditionNumber integer(kind=C_INT), public :: RowPerm integer(kind=C_INT), public :: ILU_DropRule real(kind=C_DOUBLE), public :: ILU_DropTol real(kind=C_DOUBLE), public :: ILU_FillFactor integer(kind=C_INT), public :: ILU_Norm real(kind=C_DOUBLE), public :: ILU_FillTol integer(kind=C_INT), public :: ILU_MILU real(kind=C_DOUBLE), public :: ILU_MILU_Dim integer(kind=C_INT), public :: ParSymbFact integer(kind=C_INT), public :: ReplaceTinyPivot integer(kind=C_INT), public :: SolveInitialized integer(kind=C_INT), public :: RefineInitialized integer(kind=C_INT), public :: PrintStat integer(kind=C_INT), public :: nnzL used to store nnzs for now integer(kind=C_INT), public :: nnzU used to store nnzs for now integer(kind=C_INT), public :: num_lookaheads num of levels in look-ahead integer(kind=C_INT), public :: lookahead_etree use etree computed from the serial symbolic factorization integer(kind=C_INT), public :: SymPattern symmetric factorization Source Code type , bind ( c ) :: SUPERLU_OPTIONS_T !/* ! *-- This contains the options used to control the solution process. ! * ! * Fact   (fact_t) ! *        Specifies whether or not the factored form of the matrix ! *        A is supplied on entry, and if not, how the matrix A should ! *        be factorizaed. ! *        = DOFACT: The matrix A will be factorized from scratch, and the ! *             factors will be stored in L and U. ! *        = SamePattern: The matrix A will be factorized assuming ! *             that a factorization of a matrix with the same sparsity ! *             pattern was performed prior to this one. Therefore, this ! *             factorization will reuse column permutation vector ! *             ScalePermstruct->perm_c and the column elimination tree ! *             LUstruct->etree. ! *        = SamePattern_SameRowPerm: The matrix A will be factorized ! *             assuming that a factorization of a matrix with the same ! *             sparsity   pattern and similar numerical values was performed ! *             prior to this one. Therefore, this factorization will reuse ! *             both row and column scaling factors R and C, both row and ! *             column permutation vectors perm_r and perm_c, and the ! *             L & U data structures set up from the previous factorization. !! *        = FACTORED: On entry, L, U, perm_r and perm_c contain the ! *              factored form of A. If DiagScale is not NOEQUIL, the matrix ! *              A has been equilibrated with scaling factors R and C. ! * ! * Equil  (yes_no_t) ! *        Specifies whether to equilibrate the system (scale A's row and ! *        columns to have unit norm). ! * ! * ColPerm (colperm_t) ! *        Specifies what type of column permutation to use to reduce fill. ! *        = NATURAL: use the natural ordering ! *        = MMD_ATA: use minimum degree ordering on structure of A'*A ! *        = MMD_AT_PLUS_A: use minimum degree ordering on structure of A'+A ! *        = COLAMD: use approximate minimum degree column ordering ! *        = MY_PERMC: use the ordering specified by the user ! * ! * Trans  (trans_t) ! *        Specifies the form of the system of equations: ! *        = NOTRANS: A * X = B        (No transpose) ! *        = TRANS:   A**T * X = B     (Transpose) ! *        = CONJ:    A**H * X = B     (Transpose) ! * ! * IterRefine (IterRefine_t) ! *        Specifies whether to perform iterative refinement. ! *        = NO: no iterative refinement ! *        = SLU_SINGLE: perform iterative refinement in single precision ! *        = SLU_DOUBLE: perform iterative refinement in double precision ! *        = SLU_EXTRA: perform iterative refinement in extra precision ! * ! * DiagPivotThresh (double, in [0.0, 1.0]) (only for sequential SuperLU) ! *        Specifies the threshold used for a diagonal entry to be an ! *        acceptable pivot. ! * ! * SymmetricMode (yest_no_t) ! *        Specifies whether to use symmetric mode. Symmetric mode gives ! *        preference to diagonal pivots, and uses an (A'+A)-based column ! *        permutation algorithm. ! * ! * PivotGrowth (yes_no_t) ! *        Specifies whether to compute the reciprocal pivot growth. ! * ! * ConditionNumber (ues_no_t) ! *        Specifies whether to compute the reciprocal condition number. ! * ! * RowPerm (rowperm_t) (only for SuperLU_DIST or ILU) ! *        Specifies whether to permute rows of the original matrix. ! *        = NO: not to permute the rows ! *        = LargeDiag: make the diagonal large relative to the off-diagonal ! *        = MY_PERMR: use the permutation given by the user ! * ! * ILU_DropRule (int) ! *        Specifies the dropping rule: ! *     = DROP_BASIC:   Basic dropping rule, supernodal based ILUTP(tau). ! *     = DROP_PROWS:   Supernodal based ILUTP(p,tau), p = gamma * nnz(A)/n. ! *     = DROP_COLUMN:  Variant of ILUTP(p,tau), for j-th column, ! *                     p = gamma * nnz(A(:,j)). ! *     = DROP_AREA:    Variation of ILUTP, for j-th column, use ! *                     nnz(F(:,1:j)) / nnz(A(:,1:j)) to control memory. ! *     = DROP_DYNAMIC: Modify the threshold tau during factorizaion: ! *                     If nnz(L(:,1:j)) / nnz(A(:,1:j)) > gamma ! *                         tau_L(j) := MIN(tau_0, tau_L(j-1) * 2); ! *                     Otherwise ! *                         tau_L(j) := MAX(tau_0, tau_L(j-1) / 2); ! *                     tau_U(j) uses the similar rule. ! *                     NOTE: the thresholds used by L and U are separate. ! *     = DROP_INTERP:  Compute the second dropping threshold by ! *                     interpolation instead of sorting (default). ! *                     In this case, the actual fill ratio is not ! *                     guaranteed to be smaller than gamma. ! *                     Note: DROP_PROWS, DROP_COLUMN and DROP_AREA are mutually exclusive. ! *    ( Default: DROP_BASIC | DROP_AREA ) ! * ! * ILU_DropTol (double) ! *        numerical threshold for dropping. ! * ! * ILU_FillFactor (double) ! *        Gamma in the secondary dropping. ! * ! * ILU_Norm (norm_t) ! *        Specify which norm to use to measure the row size in a ! *        supernode: infinity-norm, 1-norm, or 2-norm. ! * ! * ILU_FillTol (double) ! *        numerical threshold for zero pivot perturbation. ! * ! * ILU_MILU (milu_t) ! *        Specifies which version of MILU to use. ! * ! * ILU_MILU_Dim (double) ! *        Dimension of the PDE if available. ! * ! * ReplaceTinyPivot (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether to replace the tiny diagonals by ! *        sqrt(epsilon)*||A|| during LU factorization. ! * ! * SolveInitialized (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether the initialization has been performed to the ! *        triangular solve. ! * ! * RefineInitialized (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether the initialization has been performed to the ! *        sparse matrix-vector multiplication routine needed in iterative ! *        refinement. ! * ! * PrintStat (yes_no_t) ! *        Specifies whether to print the solver's statistics. ! */ integer ( kind = C_INT ) :: Fact integer ( kind = C_INT ) :: Equil integer ( kind = C_INT ) :: ColPerm integer ( kind = C_INT ) :: Trans integer ( kind = C_INT ) :: IterRefine real ( kind = C_DOUBLE ) :: DiagPivotThresh integer ( kind = C_INT ) :: SymmetricMode integer ( kind = C_INT ) :: PivotGrowth integer ( kind = C_INT ) :: ConditionNumber integer ( kind = C_INT ) :: RowPerm integer ( kind = C_INT ) :: ILU_DropRule real ( kind = C_DOUBLE ) :: ILU_DropTol real ( kind = C_DOUBLE ) :: ILU_FillFactor integer ( kind = C_INT ) :: ILU_Norm real ( kind = C_DOUBLE ) :: ILU_FillTol integer ( kind = C_INT ) :: ILU_MILU real ( kind = C_DOUBLE ) :: ILU_MILU_Dim integer ( kind = C_INT ) :: ParSymbFact integer ( kind = C_INT ) :: ReplaceTinyPivot integer ( kind = C_INT ) :: SolveInitialized integer ( kind = C_INT ) :: RefineInitialized integer ( kind = C_INT ) :: PrintStat integer ( kind = C_INT ) :: nnzL , nnzU !! *used to store nnzs for now* integer ( kind = C_INT ) :: num_lookaheads !! *num of levels in look-ahead* integer ( kind = C_INT ) :: lookahead_etree !! *use etree computed from the serial symbolic factorization* integer ( kind = C_INT ) :: SymPattern !! *symmetric factorization* endtype SUPERLU_OPTIONS_T","loc":"type/superlu_options_t.html"},{"tags":"","title":"SULU_ENV – MUSST ","text":"type, public :: SULU_ENV Global type for SuperLU which covers all the stuff needed Inherits type~~sulu_env~~InheritsGraph type~sulu_env SULU_ENV type~globallu_t GLOBALLU_T type~sulu_env->type~globallu_t Glu type~superlustat_t SUPERLUSTAT_T type~sulu_env->type~superlustat_t stat type~superlu_options_t SUPERLU_OPTIONS_T type~sulu_env->type~superlu_options_t options type~mem_usage_t MEM_USAGE_T type~sulu_env->type~mem_usage_t mem_usage C_PTR C_PTR type~sulu_env->C_PTR work type~supermatrix SUPERMATRIX type~sulu_env->type~supermatrix sma, smb, smx, sml, smu type~globallu_t->C_PTR lusup, ucol type~lu_stack_t LU_STACK_T type~globallu_t->type~lu_stack_t stack type~expheader EXPHEADER type~globallu_t->type~expheader expanders type~superlustat_t->C_PTR panel_histo, utime, ops type~supermatrix->C_PTR Store type~lu_stack_t->C_PTR array type~expheader->C_PTR mem var pantypesulu_envInheritsGraph = svgPanZoom('#typesulu_envInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables n nrhs nz info lwork first b x a_elt irow jptr ferr berr RR CC rpg rcond perm_c perm_r etree equed work options sma smb smx sml smu stat Glu mem_usage Source Code SULU_ENV Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n system size integer(kind=C_INT), public :: nrhs number of right hand sides integer(kind=C_INT), public :: nz number on non-zero entries integer(kind=C_INT), public :: info info returned by dgssvx integer(kind=C_INT), public :: lwork size of workspace, not used here logical(kind=I4), public :: first if false the system has been factorized at least once real(kind=R8), public, dimension(:), pointer :: b right hand side: points to b real(kind=R8), public, allocatable, dimension(:) :: x solution real(kind=R8), public, dimension(:), pointer :: a_elt CC system matrix: points to a_elt integer(kind=I4), public, dimension(:), pointer :: irow matrix line of an a_elt element: points to irow integer(kind=I4), public, dimension(:), pointer :: jptr matrix column pointers: points to jptr real(kind=C_DOUBLE), public, allocatable, dimension(:) :: ferr estimated forward error bound for each solution vector real(kind=C_DOUBLE), public, allocatable, dimension(:) :: berr componentwise relative backward error of each solution real(kind=C_DOUBLE), public, allocatable, dimension(:) :: RR *row scale factors for A * real(kind=C_DOUBLE), public, allocatable, dimension(:) :: CC column scale factors for A real(kind=C_DOUBLE), public, allocatable, dimension(:) :: rpg reciprocal pivot growth factor real(kind=C_DOUBLE), public, allocatable, dimension(:) :: rcond estimate of the reciprocal condition number of the matrix A integer(kind=C_INT), public, allocatable, dimension(:) :: perm_c If A->Stype = SLU_NC , Column permutation vector of size A->ncol integer(kind=C_INT), public, allocatable, dimension(:) :: perm_r If A->Stype = SLU_NC , row permutation vector of size A->nrow integer(kind=C_INT), public, allocatable, dimension(:) :: etree Elimination tree character(kind=len=1,C_CHAR), public :: equed form of equilibration type(C_PTR), public :: work User supplied workspace type( SUPERLU_OPTIONS_T ), public :: options LU controls type( SUPERMATRIX ), public :: sma Matrix A in A X=B* type( SUPERMATRIX ), public :: smb On entry, the right hand side matrix type( SUPERMATRIX ), public :: smx olution matrix to the original system type( SUPERMATRIX ), public :: sml factor L from the factorization type( SUPERMATRIX ), public :: smu factor U from the factorization type( SUPERLUSTAT_T ), public :: stat statistics on runtime and floating-point operation count type( GLOBALLU_T ), public :: Glu first, an output with the whole stuff LU; next, an input for other resolutions with same sparsity type( MEM_USAGE_T ), public :: mem_usage memory usage statistics Source Code type SULU_ENV !! <span style=\"color:green\">Global type for *SuperLU* which covers all the stuff needed</span> integer ( kind = C_INT ) :: n !! *system size* integer ( kind = C_INT ) :: nrhs !! *number of right hand sides* integer ( kind = C_INT ) :: nz !! *number on non-zero entries* integer ( kind = C_INT ) :: info !! *info returned by [[dgssvx]]* integer ( kind = C_INT ) :: lwork !! *size of workspace, not used here* logical ( kind = I4 ) :: first !! *if ```false``` the system has been factorized at least once* real ( kind = R8 ), dimension (:), pointer :: b !! *right hand side: points to [[MAT_SOLV:b]]* real ( kind = R8 ), allocatable , dimension (:) :: x !! *solution* real ( kind = R8 ), dimension (:), pointer :: a_elt !! *CC system matrix: points to [[MAT_SOLV:a_elt]]* integer ( kind = I4 ), dimension (:), pointer :: irow !! *matrix line of an a_elt element: points to [[MAT_SOLV:irow]]* integer ( kind = I4 ), dimension (:), pointer :: jptr !! *matrix column pointers: points to [[MAT_SOLV:jptr]]* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: ferr !! *estimated forward error bound for each solution vector* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: berr !! *componentwise relative backward error of each solution* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: RR !! *row scale factors for A * real ( kind = C_DOUBLE ), allocatable , dimension (:) :: CC !!*column scale factors for A* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: rpg !! *reciprocal pivot growth factor* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: rcond !!*estimate of the reciprocal condition number of the matrix A* integer ( kind = C_INT ), allocatable , dimension (:) :: perm_c !!*If A->Stype = ```SLU_NC```, Column permutation vector of size A->ncol* integer ( kind = C_INT ), allocatable , dimension (:) :: perm_r !!*If A->Stype = ```SLU_NC```, row permutation vector of size A->nrow* integer ( kind = C_INT ), allocatable , dimension (:) :: etree !! *Elimination tree* character ( len = 1 , kind = C_CHAR ) :: equed !! *form of equilibration* type ( C_PTR ) :: work !! *User supplied workspace* type ( SUPERLU_OPTIONS_T ) :: options !! *LU controls* type ( SUPERMATRIX ) :: sma !! *Matrix A in A*X=B* type ( SUPERMATRIX ) :: smb !! *On entry, the right hand side matrix* type ( SUPERMATRIX ) :: smx !! *olution matrix to the original system* type ( SUPERMATRIX ) :: sml !! *factor L from the factorization* type ( SUPERMATRIX ) :: smu !! *factor U from the factorization* type ( SUPERLUSTAT_T ) :: stat !! *statistics on runtime and floating-point operation count* type ( GLOBALLU_T ) :: Glu !! *first, an output with the whole stuff LU; next, an input for other resolutions with same sparsity* type ( MEM_USAGE_T ) :: mem_usage !! *memory usage statistics* endtype SULU_ENV","loc":"type/sulu_env.html"},{"tags":"","title":"tCSC_di – MUSST ","text":"type, public :: tCSC_di Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:)","loc":"type/tcsc_di.html"},{"tags":"","title":"tCSC_zi – MUSST ","text":"type, public :: tCSC_zi Contents Variables Ap Ai Ax Az Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:) real(kind=r8), public, allocatable :: Az (:)","loc":"type/tcsc_zi.html"},{"tags":"","title":"tCSC_ci – MUSST ","text":"type, public :: tCSC_ci Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) complex(kind=r8), public, allocatable :: Ax (:)","loc":"type/tcsc_ci.html"},{"tags":"","title":"tCSR_di – MUSST ","text":"type, public :: tCSR_di Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:)","loc":"type/tcsr_di.html"},{"tags":"","title":"tCSR_zi – MUSST ","text":"type, public :: tCSR_zi Contents Variables Ap Ai Ax Az Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:) real(kind=r8), public, allocatable :: Az (:)","loc":"type/tcsr_zi.html"},{"tags":"","title":"tCSR_ci – MUSST ","text":"type, public :: tCSR_ci Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) complex(kind=r8), public, allocatable :: Ax (:)","loc":"type/tcsr_ci.html"},{"tags":"","title":"tVec_zi – MUSST ","text":"type, public :: tVec_zi Contents Variables x z Components Type Visibility Attributes Name Initial real(kind=r8), public, allocatable :: x (:) real(kind=r8), public, allocatable :: z (:)","loc":"type/tvec_zi.html"},{"tags":"","title":"pCSC_di – MUSST ","text":"type, public :: pCSC_di Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:)","loc":"type/pcsc_di.html"},{"tags":"","title":"pCSC_zi – MUSST ","text":"type, public :: pCSC_zi Contents Variables Ap Ai Ax Az Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:) real(kind=r8), public, pointer :: Az (:)","loc":"type/pcsc_zi.html"},{"tags":"","title":"pCSC_ci – MUSST ","text":"type, public :: pCSC_ci Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) complex(kind=r8), public, pointer :: Ax (:)","loc":"type/pcsc_ci.html"},{"tags":"","title":"pCSR_di – MUSST ","text":"type, public :: pCSR_di Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:)","loc":"type/pcsr_di.html"},{"tags":"","title":"pCSR_zi – MUSST ","text":"type, public :: pCSR_zi Contents Variables Ap Ai Ax Az Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:) real(kind=r8), public, pointer :: Az (:)","loc":"type/pcsr_zi.html"},{"tags":"","title":"pCSR_ci – MUSST ","text":"type, public :: pCSR_ci Contents Variables Ap Ai Ax Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) complex(kind=r8), public, pointer :: Ax (:)","loc":"type/pcsr_ci.html"},{"tags":"","title":"pVec_zi – MUSST ","text":"type, public :: pVec_zi Contents Variables x z Components Type Visibility Attributes Name Initial real(kind=r8), public, pointer :: x (:) real(kind=r8), public, pointer :: z (:)","loc":"type/pvec_zi.html"},{"tags":"","title":"fz – MUSST","text":"private function fz(fe_f) Note function to calculate the generated load in a fluid film \\int_\\Omega p d\\Omega Arguments Type Intent Optional Attributes Name class( FE_FILM ), intent(inout) :: fe_f fluid type Return Value real(kind=R8) Calls proc~~fz~~CallsGraph proc~fz fz proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~fz->proc~compute_prc_tables_reynolds_supg proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/fz.html"},{"tags":"","title":"fx – MUSST","text":"private function fx(fe_f) Note function to calculate the friction force along x in a fluid film \\int_\\Omega \\tau_{xz} d\\Omega Arguments Type Intent Optional Attributes Name class( FE_FILM ), intent(inout) :: fe_f FE film Return Value real(kind=R8) Calls proc~~fx~~CallsGraph proc~fx fx proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~fx->proc~compute_prc_tables_reynolds_supg proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/fx.html"},{"tags":"","title":"fy – MUSST","text":"private function fy(fe_f) Note function to calculate the friction force along y in a fluid film \\int_\\Omega \\tau_{yz} d\\Omega Arguments Type Intent Optional Attributes Name class( FE_FILM ), intent(inout) :: fe_f FE film Return Value real(kind=R8) Calls proc~~fy~~CallsGraph proc~fy fy proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~fy->proc~compute_prc_tables_reynolds_supg proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/fy.html"},{"tags":"","title":"create_rect_FE_film – MUSST","text":"public subroutine create_rect_FE_film(data_f, num_p, fe_f) Note Subroutine to create a FE_FILM Arguments Type Intent Optional Attributes Name type(DATA_FILM), intent(inout) :: data_f data of the film type(NUM_PAR), intent(in) :: num_p numerical param for iterative solution type( FE_FILM ), intent(inout) :: fe_f FE film data type Calls proc~~create_rect_fe_film~~CallsGraph proc~create_rect_fe_film create_rect_FE_film proc~create_rect_x_ymesh create_rect_x_ymesh proc~create_rect_fe_film->proc~create_rect_x_ymesh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~create_rect_fe_film~~CalledByGraph proc~create_rect_fe_film create_rect_FE_film proc~multi_scale_create_rect_fe_film multi_scale_create_rect_fe_film proc~multi_scale_create_rect_fe_film->proc~create_rect_fe_film proc~init_fe_prob init_fe_prob proc~init_fe_prob->proc~create_rect_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~init_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~init_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~init_fe_prob proc~init_ms_prob init_ms_prob proc~init_ms_prob->proc~multi_scale_create_rect_fe_film proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~init_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~init_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_rough_ms->proc~init_ms_prob proc~test_slider_ms->proc~init_ms_prob program~main main program~main->proc~run_test var panproccreate_rect_fe_filmCalledByGraph = svgPanZoom('#proccreate_rect_fe_filmCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code create_rect_FE_film Source Code subroutine create_rect_FE_film ( data_f , num_p , fe_f ) implicit none type ( DATA_FILM ), intent ( inout ) :: data_f !! *data of the film* type ( NUM_PAR ), intent ( in ) :: num_p !! *numerical param for iterative solution* type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film data type* ! mesh creation call create_rect_x_ymesh ( fe_f % m ) ! copy of data fe_f % data_f = data_f ! allocation and initialisation of the variables and bc table select case ( fe_f % data_f % pb_type ) case ( HD ) ! nodal tables fe_f % n_vn = 10 allocate ( fe_f % vn ( fe_f % m % n , fe_f % n_vn ), fe_f % vn_name ( fe_f % n_vn )) fe_f % vn_name ( H1_N ) = 'h1(m)' fe_f % vn_name ( H2_N ) = 'h2(m)' fe_f % vn_name ( H_N ) = 'h(m)' fe_f % vn_name ( P_N ) = 'p(Pa)' fe_f % vn_name ( RHO_N ) = 'rho(kg.m-3)' fe_f % vn_name ( T_N ) = 'T(K)' fe_f % vn_name ( DRHODP_N ) = 'drhodp(kg.m-3.Pa-1)' fe_f % vn_name ( MU_N ) = 'mu(Pa.s)' fe_f % vn_name ( VX_N ) = 'Vx(m.s-1)' fe_f % vn_name ( VY_N ) = 'Vy(m.s-1)' fe_f % vn = 0._R8 fe_f % vn (:, H2_N ) = fe_f % data_f % h_0 fe_f % vn (:, H_N ) = fe_f % vn (:, H2_N ) - fe_f % vn (:, H1_N ) fe_f % vn (:, P_N ) = fe_f % data_f % fl % p_0 fe_f % vn (:, RHO_N ) = fe_f % data_f % fl % rho ( fe_f % data_f % fl % p_0 , fe_f % data_f % fl % T_0 ) fe_f % vn (:, T_N ) = fe_f % data_f % fl % T_0 fe_f % vn (:, MU_N ) = fe_f % data_f % fl % mu_0 fe_f % vn (:, VX_N ) = fe_f % data_f % v_x fe_f % vn (:, VY_N ) = fe_f % data_f % v_y fe_f % vn (:, DRHODP_N ) = fe_f % data_f % fl % drhodp ( fe_f % data_f % fl % p_0 , fe_f % data_f % fl % T_0 ) ! bondary condition table allocate ( fe_f % bc ( fe_f % m % n , 1 )) ! all the nodes are initialized as unknown fe_f % bc = 1 ! cell variable fe_f % n_vc = 3 allocate ( fe_f % vc ( fe_f % m % ne , fe_f % n_vc ), fe_f % vc_name ( fe_f % n_vc )) fe_f % vc_name ( HG_C ) = 'h_grv(m)' fe_f % vc_name ( PEK_C ) = 'Pek' fe_f % vc_name ( PEE_C ) = 'Pee' fe_f % vc = 0._R8 ! numerical parameters for iterative problems fe_f % num_p = num_p case default stop 'the problem type is undefined in create_rect_FE_film' endselect return endsubroutine create_rect_FE_film","loc":"proc/create_rect_fe_film.html"},{"tags":"","title":"solve_FE_film – MUSST","text":"public subroutine solve_FE_film(fe_f, mat, bc, flag_ass) Note Subroutine to solve a FE_FILM Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE film data type type(MAT_SOLV), intent(inout) :: mat matrices for solving real(kind=R8), intent(in), dimension(MAX_NNC) :: bc boundary conditions at the corners logical(kind=I4), intent(in), optional :: flag_ass optional flag for assembly Calls proc~~solve_fe_film~~CallsGraph proc~solve_fe_film solve_FE_film omp_get_thread_num omp_get_thread_num proc~solve_fe_film->omp_get_thread_num proc~solve_syst solve_syst proc~solve_fe_film->proc~solve_syst proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~convert_matrice_format convert_matrice_format proc~solve_fe_film->proc~convert_matrice_format proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled dmumps dmumps proc~init_solver->dmumps mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panprocsolve_fe_filmCallsGraph = svgPanZoom('#procsolve_fe_filmCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solve_fe_film~~CalledByGraph proc~solve_fe_film solve_FE_film proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_slider_ms->proc~solve_ms_prob program~main main program~main->proc~run_test var panprocsolve_fe_filmCalledByGraph = svgPanZoom('#procsolve_fe_filmCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code solve_FE_film Source Code subroutine solve_FE_film ( fe_f , mat , bc , flag_ass ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film data type* type ( MAT_SOLV ), intent ( inout ) :: mat !! *matrices for solving* real ( kind = R8 ), intent ( in ), dimension ( MAX_NNC ) :: bc !! *boundary conditions at the corners* logical ( kind = I4 ), intent ( in ), optional :: flag_ass !! *optional flag for assembly* logical ( kind = I4 ) :: decomp integer ( kind = I4 ) :: ass_c , i , it , e logical ( kind = I4 ) :: conv real ( kind = R8 ) :: error integer ( kind = I4 ), dimension ( 2 ) :: compt ! solution parameters ass_c = ASS if ( present ( flag_ass )) then if (. not . flag_ass ) ass_c = NO_ASS endif decomp = ( ass_c == ASS ) ! apply boundary conditions if ( BC_SPLINE ) then call apply_bc_FE_film ( fe_f = fe_f , & bc = bc ) else call apply_bc_FE_film_simple ( fe_f = fe_f , & bc = bc ) endif if ( VERBOSE >= 20 ) write ( OPU , * ) 'bc applied' ! update fluid properties do i = 1 , fe_f % m % n fe_f % vn ( i , RHO_N ) = fe_f % data_f % fl % rho ( fe_f % vn ( i , P_N ) , fe_f % vn ( i , T_N )) fe_f % vn ( i , DRHODP_N ) = fe_f % data_f % fl % drhodp ( fe_f % vn ( i , P_N ) , fe_f % vn ( i , T_N )) enddo if ( VERBOSE >= 20 ) write ( OPU , * ) 'fluid properties updated' if ( mat % first ) then mat % nn = fe_f % m % n mat % ne = fe_f % m % ne call solve_syst ( mat = mat , & step = 'ini' ) if ( VERBOSE >= 10 ) write ( OPU , * ) 'Matrix initialized, thread ' , omp_get_thread_num () ! matrices allocation compt (:) = 0 do e = 1 , fe_f % m % ne compt ( 1 ) = compt ( 1 ) + fe_f % m % el_n ( e ) ! for each element, the number of lines is added do i = 1 , fe_f % m % el_t ( e ) compt ( 2 ) = compt ( 2 ) + fe_f % m % el_t ( e ) ! \" \", for each node, the number of contributions is added enddo enddo mat % nvar = compt ( 1 ) mat % nt = compt ( 2 ) if (. not . allocated ( mat % eltvar )) allocate ( mat % eltvar ( mat % nvar ) ) if (. not . allocated ( mat % a_elt )) allocate ( mat % a_elt ( mat % nt ) ) if (. not . allocated ( mat % eltptr )) allocate ( mat % eltptr ( mat % ne + 1 ) ) endif ! check of precomputed tables allocation if (. not . allocated ( fe_f % prc % vcal )) call init_prc_tab ( fe_f ) ! convergence is false at zero iteration conv = . false . it = 0 ! solution loop do if ( VERBOSE >= 20 ) write ( OPU , * ) '   Loop FE ' , it if ( conv ) exit ! assembly of the system call assembly_FE_film_reynolds ( fe_f , mat , ass_c ) if ( VERBOSE >= 30 ) write ( OPU , * ) '   System assembled, thread ' , omp_get_thread_num () if ( ass_c == ASS ) then ! some stuff can be saved here, provided the reloading of jptr, irow, ... (instead of convert_matrice_format) call convert_matrice_format ( mat ) if ( VERBOSE >= 30 ) write ( OPU , * ) '   Matrix converted, thread ' , omp_get_thread_num () endif if ( mat % first ) then call solve_syst ( mat = mat , & step = 'ana' ) mat % first = . false . if ( VERBOSE >= 10 ) write ( OPU , * ) '   Matrix analyzed, thread ' , omp_get_thread_num () endif ! solution of the system if ( ass_c == ASS ) then call solve_syst ( mat = mat , & step = 'fac' ) if ( VERBOSE >= 30 ) write ( OPU , * ) '   Matrix factorized, thread ' , omp_get_thread_num () endif call solve_syst ( mat = mat , & step = 'sol' ) if ( VERBOSE >= 30 ) write ( OPU , * ) '   System solved, thread ' , omp_get_thread_num () if ( ass_c == ASS ) then call solve_syst ( mat = mat , & step = 'fre' ) if ( VERBOSE >= 30 ) write ( OPU , * ) '   Matrix factors freed, thread ' , omp_get_thread_num () endif ! error computation error = ( sum ( mat % x ** 2 ) / sum ( fe_f % vn (:, P_N ) ** 2 )) ** ( 0.5_R8 ) it = it + 1 if ( VERBOSE >= 20 ) write ( OPU , * ) '   Error ' , error ! convergence check if ( error <= fe_f % num_p % eps ) conv = . true . ! update of variables if ( fe_f % data_f % fl % fluid_type == MIXT ) then do i = 1 , fe_f % m % n if ( mat % x ( i ) < 0. ) then fe_f % vn ( i , RHO_N ) = fe_f % vn ( i , RHO_N ) + fe_f % vn ( i , DRHODP_N ) * mat % x ( i ) * fe_f % num_p % relax if ( fe_f % vn ( i , RHO_N ) < 0. ) then fe_f % vn ( i , P_N ) = fe_f % data_f % fl % P_0 / 100 else fe_f % vn ( i , P_N ) = fe_f % data_f % fl % pres ( fe_f % vn ( i , RHO_N ), & ! fe_f % vn ( i , T_N ) ) endif else fe_f % vn ( i , P_N ) = fe_f % vn ( i , P_N ) + mat % x ( i ) * fe_f % num_p % relax endif enddo else fe_f % vn (:, P_N ) = fe_f % vn (:, P_N ) + mat % x * fe_f % num_p % relax endif ! check pressure if ( fe_f % data_f % fl % fluid_type == GP ) then if ( minval ( fe_f % vn (:, P_N )) < 0._R8 ) then if ( VERBOSE >= 30 ) write ( OPU , * ) 'P negative' endif where ( fe_f % vn (:, P_N ) < 0._R8 ) fe_f % vn (:, P_N ) = fe_f % data_f % fl % p_0 / 1.e3_R8 endif do i = 1 , fe_f % m % n fe_f % vn ( i , RHO_N ) = fe_f % data_f % fl % rho ( fe_f % vn ( i , P_N ) , fe_f % vn ( i , T_N )) fe_f % vn ( i , DRHODP_N ) = fe_f % data_f % fl % drhodp ( fe_f % vn ( i , P_N ) , fe_f % vn ( i , T_N )) enddo if ( it >= fe_f % num_p % it_max ) then conv = . true . if ( VERBOSE >= 20 ) write ( OPU , * ) 'maximum number of iteration reached before convergence' endif enddo return endsubroutine solve_FE_film","loc":"proc/solve_fe_film.html"},{"tags":"","title":"apply_bc_FE_film – MUSST","text":"public subroutine apply_bc_FE_film(fe_f, bc) Note Subroutine to apply boundary conditions on a FE_FILM Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE film data type real(kind=R8), intent(in), dimension(MAX_NNC) :: bc boundary conditions at the corners Called by proc~~apply_bc_fe_film~~CalledByGraph proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_slider_ms->proc~solve_ms_prob program~main main program~main->proc~run_test var panprocapply_bc_fe_filmCalledByGraph = svgPanZoom('#procapply_bc_fe_filmCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_bc_FE_film Source Code subroutine apply_bc_FE_film ( fe_f , bc ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film data type* real ( kind = R8 ), intent ( in ), dimension ( MAX_NNC ) :: bc !! *boundary conditions at the corners* integer ( kind = I4 ) :: e , i , ind , ind_var logical ( kind = I4 ) :: mixture real ( kind = R8 ) :: v , v1 , v2 , x1 , x2 , y1 , y2 , l , d mixture = ( fe_f % data_f % fl % fluid_type == MIXT ) ! case of hd problem: unknown is p if ( fe_f % data_f % pb_type == HD ) ind_var = P_N ! copy of the bc values on the node values do i = 1 , fe_f % m % nc fe_f % vn ( fe_f % m % cor ( i ), ind_var ) = fe_f % vn ( fe_f % m % cor ( i ), ind_var ) + bc ( i ) enddo ! loop on edges if ( mixture ) then v1 = bc ( 1 ) / fe_f % vn ( fe_f % m % cor ( 1 ), ind_var ) else v1 = bc ( 1 ) endif x1 = fe_f % m % x ( fe_f % m % cor ( 1 )) y1 = fe_f % m % y ( fe_f % m % cor ( 1 )) do e = fe_f % m % ned , 1 , - 1 v2 = v1 x2 = x1 y2 = y1 if ( mixture ) then v1 = bc ( e ) / fe_f % vn ( fe_f % m % cor ( e ), ind_var ) else v1 = bc ( e ) endif x1 = fe_f % m % x ( fe_f % m % cor ( e )) y1 = fe_f % m % y ( fe_f % m % cor ( e )) ! length of the edge l = (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ** 0.5_R8 do i = 2 , fe_f % m % ed ( e )% n - 1 ind = fe_f % m % ed ( e )% nm ( i ) ! distance to point 2 d = (( x2 - fe_f % m % x ( ind )) ** 2 + ( y2 - fe_f % m % y ( ind )) ** 2 ) ** 0.5_R8 d = d / l v = d * v1 + ( 1._R8 - d ) * v2 ! linear distribution along the edge if ( mixture ) then fe_f % vn ( ind , ind_var ) = exp ( log ( fe_f % vn ( ind , ind_var )) + v ) else fe_f % vn ( ind , ind_var ) = fe_f % vn ( ind , ind_var ) + v endif enddo do i = 1 , fe_f % m % ed ( e )% n ind = fe_f % m % ed ( e )% nm ( i ) ! boundary nodes are set as imposed fe_f % bc ( ind , REY ) = 0 enddo enddo return endsubroutine apply_bc_FE_film","loc":"proc/apply_bc_fe_film.html"},{"tags":"","title":"apply_bc_FE_film_simple – MUSST","text":"public subroutine apply_bc_FE_film_simple(fe_f, bc) Note Subroutine to apply boundary conditions on a FE_FILM Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE film data type real(kind=R8), intent(in), dimension(MAX_NNC) :: bc boundary conditions at the corners Called by proc~~apply_bc_fe_film_simple~~CalledByGraph proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~apply_bc_fe_film_simple proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocapply_bc_fe_film_simpleCalledByGraph = svgPanZoom('#procapply_bc_fe_film_simpleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_bc_FE_film_simple Source Code subroutine apply_bc_FE_film_simple ( fe_f , bc ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film data type* real ( kind = R8 ), intent ( in ), dimension ( MAX_NNC ) :: bc !! *boundary conditions at the corners* integer ( kind = I4 ) :: e , i , ind , ind_var logical ( kind = I4 ) :: mixture real ( kind = R8 ) :: v , v1 , v2 , x1 , x2 , y1 , y2 , l , d mixture = ( fe_f % data_f % fl % fluid_type == MIXT ) ! case of hd problem: unknown is p if ( fe_f % data_f % pb_type == HD ) ind_var = P_N ! copy of the bc values on the node values do i = 1 , fe_f % m % nc fe_f % vn ( fe_f % m % cor ( i ), ind_var ) = bc ( i ) enddo ! loop on edges if ( mixture ) then v1 = log ( fe_f % vn ( fe_f % m % cor ( 1 ), ind_var )) else v1 = fe_f % vn ( fe_f % m % cor ( 1 ), ind_var ) endif x1 = fe_f % m % x ( fe_f % m % cor ( 1 )) y1 = fe_f % m % y ( fe_f % m % cor ( 1 )) do e = fe_f % m % ned , 1 , - 1 v2 = v1 x2 = x1 y2 = y1 if ( mixture ) then v1 = log ( fe_f % vn ( fe_f % m % cor ( e ), ind_var )) else v1 = fe_f % vn ( fe_f % m % cor ( e ), ind_var ) endif x1 = fe_f % m % x ( fe_f % m % cor ( e )) y1 = fe_f % m % y ( fe_f % m % cor ( e )) ! length of the edge l = (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ** 0.5_R8 do i = 2 , fe_f % m % ed ( e )% n - 1 ind = fe_f % m % ed ( e )% nm ( i ) ! distance to point 2 d = (( x2 - fe_f % m % x ( ind )) ** 2 + ( y2 - fe_f % m % y ( ind )) ** 2 ) ** 0.5_R8 d = d / l v = d * v1 + ( 1._R8 - d ) * v2 ! linear distribution along the edge if ( mixture ) then fe_f % vn ( ind , ind_var ) = exp ( v ) else fe_f % vn ( ind , ind_var ) = v endif enddo do i = 1 , fe_f % m % ed ( e )% n ind = fe_f % m % ed ( e )% nm ( i ) ! boundary nodes are set as imposed fe_f % bc ( ind , REY ) = 0 enddo enddo return endsubroutine apply_bc_FE_film_simple","loc":"proc/apply_bc_fe_film_simple.html"},{"tags":"","title":"assembly_FE_film_reynolds – MUSST","text":"public subroutine assembly_FE_film_reynolds(fe_f, mat, ass_c) Note Subroutine to to solve a FE_FILM Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE_film data type type(MAT_SOLV), intent(inout) :: mat matrices for solving integer(kind=I4), intent(in) :: ass_c assembly type Calls proc~~assembly_fe_film_reynolds~~CallsGraph proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d var panprocassembly_fe_film_reynoldsCallsGraph = svgPanZoom('#procassembly_fe_film_reynoldsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assembly_fe_film_reynolds~~CalledByGraph proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~compute_corner_fluxes compute_corner_fluxes proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~solve_fe_prob->proc~compute_corner_fluxes proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds->proc~compute_corner_fluxes proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_slider_ms->proc~solve_ms_prob program~main main program~main->proc~run_test var panprocassembly_fe_film_reynoldsCalledByGraph = svgPanZoom('#procassembly_fe_film_reynoldsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code assembly_FE_film_reynolds Source Code subroutine assembly_FE_film_reynolds ( fe_f , mat , ass_c ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE_film data type* type ( MAT_SOLV ), intent ( inout ) :: mat !! *matrices for solving* integer ( kind = I4 ), intent ( in ) :: ass_c !! *assembly type* integer ( kind = I4 ), dimension ( 2 ) :: compt integer ( kind = I4 ), dimension ( MAX_NNE ) :: tind4 real ( kind = R8 ), dimension ( MAX_NNE ) :: b4 real ( kind = R8 ), dimension ( MAX_NNE , MAX_NNE ) :: k4 integer ( kind = I4 ) :: e , i , ii , el_t , el_n ! assembly compt ( 1 : 2 ) = 1 mat % b = 0._R8 do e = 1 , fe_f % m % ne call elementary_assembly_FE_film_reynolds ( fe_f = fe_f , & ! ke_ij = k4 , & ! elementary matrix         : OUT be_i = b4 , & ! elementary rhs member     : OUT ind_e = tind4 , & ! elementary index member   : OUT e = e , & ! element number ass_c = ass_c ) ! assembly type do i = 1 , 4 ii = tind4 ( i ) mat % b ( ii ) = mat % b ( ii ) + b4 ( i ) enddo el_t = fe_f % m % el_t ( e ) el_n = fe_f % m % el_n ( e ) ! assembly of the elemental matrix in the solver matrix if ( ass_c == ASS ) then call assemble_in_mat_sol ( mat = mat , & num = e , & nelt = el_t , & nline = el_n , & tind = tind4 , & m_elt = k4 , & compt = compt ) endif enddo if ( ass_c == ASS ) mat % eltptr ( 1 ) = 1 return endsubroutine assembly_FE_film_reynolds","loc":"proc/assembly_fe_film_reynolds.html"},{"tags":"","title":"assemble_in_mat_sol – MUSST","text":"public subroutine assemble_in_mat_sol(mat, num, nelt, nline, tind, m_elt, compt) Note Subroutine to assemble elemental matrices in the solver matrices Arguments Type Intent Optional Attributes Name type(MAT_SOLV), intent(inout) :: mat mat_solv type integer(kind=I4), intent(in) :: num element number integer(kind=I4), intent(in) :: nelt size of elemental matrix integer(kind=I4), intent(in) :: nline number of lines integer(kind=I4), intent(in), dimension(nelt) :: tind index table of elemental matrix real(kind=R8), intent(in), dimension(nelt, nelt) :: m_elt elemental matrix integer(kind=I4), intent(inout), dimension(2) :: compt number to index the position in the solver matrix Called by proc~~assemble_in_mat_sol~~CalledByGraph proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~compute_corner_fluxes compute_corner_fluxes proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~solve_fe_prob->proc~compute_corner_fluxes proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds->proc~compute_corner_fluxes proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_slider_ms->proc~solve_ms_prob program~main main program~main->proc~run_test var panprocassemble_in_mat_solCalledByGraph = svgPanZoom('#procassemble_in_mat_solCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code assemble_in_mat_sol Source Code subroutine assemble_in_mat_sol ( mat , num , nelt , nline , tind , m_elt , compt ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *mat_solv type* integer ( kind = I4 ), intent ( in ) :: num !! *element number* integer ( kind = I4 ), intent ( in ) :: nelt !! *size of elemental matrix* integer ( kind = I4 ), intent ( in ) :: nline !! *number of lines* integer ( kind = I4 ), intent ( in ), dimension ( nelt ) :: tind !! *index table of elemental matrix* real ( kind = R8 ), intent ( in ), dimension ( nelt , nelt ) :: m_elt !! *elemental matrix* integer ( kind = I4 ), intent ( inout ), dimension ( 2 ) :: compt !! *number to index the position in the solver matrix* integer ( kind = I4 ) :: i , j ! check compt if ( compt ( 2 ) > mat % nt ) stop 'compt > matrix size in assemble_in_mat_sol' do j = 1 , nline mat % eltvar ( compt ( 1 )) = tind ( j ) compt ( 1 ) = compt ( 1 ) + 1 enddo mat % eltptr ( num + 1 ) = compt ( 1 ) do j = 1 , nelt do i = 1 , nelt mat % a_elt ( compt ( 2 )) = m_elt ( i , j ) compt ( 2 ) = compt ( 2 ) + 1 enddo enddo return endsubroutine assemble_in_mat_sol","loc":"proc/assemble_in_mat_sol.html"},{"tags":"","title":"elementary_assembly_FE_film_reynolds – MUSST","text":"private subroutine elementary_assembly_FE_film_reynolds(fe_f, ke_ij, be_i, ind_e, e, ass_c) Note Subroutine to solve a FE_FILM Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE film real(kind=R8), intent(out), dimension(MAX_NNE, MAX_NNE) :: ke_ij elementary matrix real(kind=R8), intent(out), dimension(MAX_NNE) :: be_i elementary rhs member integer(kind=I4), intent(out), dimension(MAX_NNE) :: ind_e elementary index member integer(kind=I4), intent(in) :: e element number integer(kind=I4), intent(in) :: ass_c assembly type Calls proc~~elementary_assembly_fe_film_reynolds~~CallsGraph proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d var panprocelementary_assembly_fe_film_reynoldsCallsGraph = svgPanZoom('#procelementary_assembly_fe_film_reynoldsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~elementary_assembly_fe_film_reynolds~~CalledByGraph proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~compute_corner_fluxes compute_corner_fluxes proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~solve_fe_prob->proc~compute_corner_fluxes proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds->proc~compute_corner_fluxes proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_slider_ms->proc~solve_ms_prob program~main main program~main->proc~run_test var panprocelementary_assembly_fe_film_reynoldsCalledByGraph = svgPanZoom('#procelementary_assembly_fe_film_reynoldsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elementary_assembly_FE_film_reynolds Source Code subroutine elementary_assembly_FE_film_reynolds ( fe_f , ke_ij , be_i , ind_e , e , ass_c ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film* real ( kind = R8 ), intent ( out ), dimension ( MAX_NNE , MAX_NNE ) :: ke_ij !! *elementary matrix* real ( kind = R8 ), intent ( out ), dimension ( MAX_NNE ) :: be_i !! *elementary rhs member* integer ( kind = I4 ), intent ( out ), dimension ( MAX_NNE ) :: ind_e !! *elementary index member* integer ( kind = I4 ), intent ( in ) :: e !! *element number* integer ( kind = I4 ), intent ( in ) :: ass_c !! *assembly type* real ( kind = R8 ), dimension ( MAX_NNG , MAX_NNG ) :: vni4x , vni4y integer ( kind = I4 ), dimension ( MAX_NNE ) :: con integer ( kind = I4 ) :: i , j , ii , jj , ng , ne ng = fe_f % prc % ng ne = fe_f % m % el_t ( e ) ! check of precomputed tables allocation !~ if (.not.allocated(fe_f%prc%vcal)) call init_prc_tab(fe_f) ! assembly call compute_prc_tables_reynolds_supg ( fe_f , e ) con ( 1 : ne ) = fe_f % m % con ( e , 1 : ne ) ke_ij = 0._R8 ind_e = 0 be_i = 0._R8 do i = 1 , ne ii = con ( i ) ind_e ( i ) = ii ! case of nodes on the boundary if (( fe_f % bc ( ii , REY ) == 0 ) . and . ( ass_c /= NO_BC )) then ke_ij ( i , i ) = 1.0e10 ! case of nodes where the pressure is unknown else vni4x ( 1 : ng , 1 : ng ) = fe_f % prc % vni4x ( i , 1 : ng , 1 : ng ) vni4y ( 1 : ng , 1 : ng ) = fe_f % prc % vni4y ( i , 1 : ng , 1 : ng ) be_i ( i ) = be_i ( i ) - sum ( vni4x ( 1 : ng , 1 : ng ) * ( fe_f % prc % vcal ( 6 , 1 : ng , 1 : ng ) - fe_f % prc % vcal ( 8 , 1 : ng , 1 : ng )) ) & ! - sum ( vni4y ( 1 : ng , 1 : ng ) * ( fe_f % prc % vcal ( 7 , 1 : ng , 1 : ng ) - fe_f % prc % vcal ( 9 , 1 : ng , 1 : ng )) ) do j = 1 , fe_f % m % el_t ( e ) jj = con ( j ) ke_ij ( i , j ) = sum ( ( vni4x ( 1 : ng , 1 : ng ) * fe_f % prc % vni4x ( j , 1 : ng , 1 : ng ) & + vni4y ( 1 : ng , 1 : ng ) * fe_f % prc % vni4y ( j , 1 : ng , 1 : ng )) * fe_f % prc % vcal ( 2 , 1 : ng , 1 : ng ) ) & + sum ( ( vni4x ( 1 : ng , 1 : ng ) * fe_f % prc % vcal ( 10 , 1 : ng , 1 : ng ) & + vni4y ( 1 : ng , 1 : ng ) * fe_f % prc % vcal ( 11 , 1 : ng , 1 : ng )) * fe_f % prc % vni4 ( j , 1 : ng , 1 : ng )) * fe_f % vn ( jj , DRHODP_N ) & - sum ( ( vni4x ( 1 : ng , 1 : ng ) * fe_f % prc % vcal ( 3 , 1 : ng , 1 : ng ) & + vni4y ( 1 : ng , 1 : ng ) * fe_f % prc % vcal ( 4 , 1 : ng , 1 : ng )) & * fe_f % prc % vni4d ( j , 1 : ng , 1 : ng ) * fe_f % vn ( jj , DRHODP_N ) ) !better convergence enddo endif enddo return endsubroutine elementary_assembly_FE_film_reynolds","loc":"proc/elementary_assembly_fe_film_reynolds.html"},{"tags":"","title":"elementary_full_domain_FE_film_reynolds – MUSST","text":"public subroutine elementary_full_domain_FE_film_reynolds(fe_f, mat, ke_ij, be_i, ind_e) Note Calculate the elementary matrices on a full domain Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE film type(MAT_SOLV), intent(inout) :: mat solver type matrices real(kind=R8), intent(out), dimension(MAX_NNC, MAX_NNC) :: ke_ij elementary matrix real(kind=R8), intent(inout), dimension(MAX_NNC         ) :: be_i elementary rhs member integer(kind=I4), intent(out), dimension(MAX_NNC         ) :: ind_e elementary index member Calls proc~~elementary_full_domain_fe_film_reynolds~~CallsGraph proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~solve_fe_film solve_FE_film proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~compute_corner_fluxes compute_corner_fluxes proc~elementary_full_domain_fe_film_reynolds->proc~compute_corner_fluxes omp_get_thread_num omp_get_thread_num proc~solve_fe_film->omp_get_thread_num proc~solve_syst solve_syst proc~solve_fe_film->proc~solve_syst proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~convert_matrice_format convert_matrice_format proc~solve_fe_film->proc~convert_matrice_format proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled dmumps dmumps proc~init_solver->dmumps mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panprocelementary_full_domain_fe_film_reynoldsCallsGraph = svgPanZoom('#procelementary_full_domain_fe_film_reynoldsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elementary_full_domain_FE_film_reynolds Source Code subroutine elementary_full_domain_FE_film_reynolds ( fe_f , mat , ke_ij , be_i , ind_e ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film* type ( MAT_SOLV ), intent ( inout ) :: mat !! *solver type matrices* real ( kind = R8 ), intent ( out ), dimension ( MAX_NNC , MAX_NNC ) :: ke_ij !! *elementary matrix* real ( kind = R8 ), intent ( inout ), dimension ( MAX_NNC ) :: be_i !! *elementary rhs member* integer ( kind = I4 ), intent ( out ), dimension ( MAX_NNC ) :: ind_e !! *elementary index member* integer ( kind = I4 ) :: e , ee , i , j , ii , nbc , nc logical ( kind = I4 ) :: flag integer ( kind = I4 ), dimension ( MAX_NBS ) :: ind_n real ( kind = R8 ), dimension ( MAX_NBS ) :: sav_vn real ( kind = R8 ), dimension ( MAX_NNC ) :: bc , dp nc = fe_f % m % nc ! check of precomputed tables allocation if (. not . allocated ( fe_f % prc % vcal )) call init_prc_tab ( fe_f ) ! boundary condition initialization if ( BC_SPLINE ) then bc ( 1 : nc ) = 0 else bc ( 1 : nc ) = be_i ( 1 : nc ) endif j = 1 do e = 1 , fe_f % m % ned do ee = 1 , fe_f % m % ed ( e )% n ind_n ( j ) = fe_f % m % ed ( e )% nm ( ee ) sav_vn ( j ) = fe_f % vn ( ind_n ( j ), P_N ) j = j + 1 enddo enddo nbc = j - 1 ! matrices ke_ij = 0._R8 ind_e = 0 be_i = 0._R8 ! calculation of the elementary matrix do i = 1 , nc ! number of corners ii = fe_f % m % cor ( i ) ind_e ( i ) = ii dp ( i ) = fe_f % vn ( ii , P_N ) / 1000 if ( BC_SPLINE ) then bc ( i ) = dp ( i ) else bc ( i ) = bc ( i ) + dp ( i ) endif if ( i == 1 ) flag = . true . call solve_FE_film ( fe_f = fe_f , & ! mat = mat , & ! bc = bc , & ! in flag_ass = flag ) ! flag = . false . call compute_corner_fluxes ( fe_f = fe_f , & ! mat = mat , & ! bf = be_i ) ! out ke_ij ( 1 : nc , i ) = - be_i ( 1 : nc ) / dp ( i ) if ( BC_SPLINE ) then bc ( i ) = 0 else bc ( i ) = bc ( i ) - dp ( i ) endif do j = 1 , nbc fe_f % vn ( ind_n ( j ), P_N ) = sav_vn ( j ) enddo enddo ! calculation of the RHS table call solve_FE_film ( fe_f = fe_f , & ! mat = mat , & ! bc = bc , & ! flag_ass = . false .) ! call compute_corner_fluxes ( fe_f = fe_f , & ! mat = mat , & ! bf = be_i ) ! out ! update of the matrix: the derivative is the difference ! between the residuals divided by the delta p do i = 1 , nc ke_ij ( 1 : nc , i ) = ke_ij ( 1 : nc , i ) + be_i ( 1 : nc ) / dp ( i ) enddo return endsubroutine elementary_full_domain_FE_film_reynolds","loc":"proc/elementary_full_domain_fe_film_reynolds.html"},{"tags":"","title":"init_prc_tab – MUSST","text":"public subroutine init_prc_tab(fe_f) Note Subroutine to calculate the precomputed tables on a FE_film Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f Calls proc~~init_prc_tab~~CallsGraph proc~init_prc_tab init_prc_tab proc~ni4 ni4 proc~init_prc_tab->proc~ni4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_prc_tab Source Code subroutine init_prc_tab ( fe_f ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f ! *FE film* integer ( kind = I4 ) :: i , j , k , ng real ( kind = R8 ), dimension (:), allocatable :: pg , wg ! number of Gauss points ng = 2 ! table allocation allocate ( pg ( ng ), wg ( ng )) fe_f % prc % ng = ng allocate ( fe_f % prc % pg ( ng ), & fe_f % prc % wg ( ng ), & fe_f % prc % vni4 ( 4 , ng , ng ), & fe_f % prc % vni4x ( 4 , ng , ng ), & fe_f % prc % vni4y ( 4 , ng , ng ), & fe_f % prc % vni4d ( 4 , ng , ng ), & fe_f % prc % vcal ( 20 , ng , ng ) ) ! Gauss points definition pg ( 1 ) = - 1._R8 / sqrt ( 3._R8 ) pg ( 2 ) = - pg ( 1 ) wg = 1._R8 fe_f % prc % pg = pg fe_f % prc % wg = wg ! precomputation of shape functions and derivatives at the Gauss points do i = 1 , ng do j = 1 , ng do k = 1 , 4 fe_f % prc % vni4 ( k , i , j ) = ni4 ( k , pg ( i ), pg ( j )) enddo enddo enddo deallocate ( pg , wg ) return endsubroutine init_prc_tab","loc":"proc/init_prc_tab.html"},{"tags":"","title":"compute_prc_tables_reynolds_supg – MUSST","text":"private subroutine compute_prc_tables_reynolds_supg(fe_f, e) Note Subroutine to calculate the precomputed tables on a FE_FILM REYNOLDS EQUATION DISCRETIZATION Reynolds equation discretization \n   \\def\\scall{{ \\, \\tiny{\\bullet} \\, }}\n\n\nThe Reynolds' equation writes:\n\n\n\\text{div}\\left( \\frac{\\rho h&#94;3}{\\mu} \\overrightarrow{\\text{grad}} \\, p \\right) = 6 \\, \\text{div}\\left( \\rho h \\, \\vec{u} \\right)\n\n\nOver each element  \\Omega_e , the equation is multiplied by the weighting function  W_i .\n\nOwing the relationship:\n\n\nb \\, \\text{div}\\vec{a} = \\text{div} (b\\,\\vec{a}) - \\vec{a} \\scall \\overrightarrow{\\text{grad}}b\n\n\nthe equation becomes:\n\n\n\\begin{split}\n\\int \\!\\!\\! \\int_{\\Omega_e} \\text{div} \\left( \\frac{\\rho h&#94;3}{\\mu}  W_i \\, \\overrightarrow{\\text{grad}} \\, p \\right) d\\Omega_e &-\n\\int \\!\\!\\! \\int_{\\Omega_e} \\frac{\\rho h&#94;3}{\\mu} \\overrightarrow{\\text{grad}} \\, p \\, \\scall \\, \\overrightarrow{\\text{grad}} \\, W_i \\, \\mathrm{d}\\Omega_e = \\\\\n\\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\text{div} \\left( \\rho h  W_i \\, \\vec{u} \\right) \\, \\mathrm{d}\\Omega_e &-\n\\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\rho h  \\, \\vec{u} \\, \\scall \\, \\overrightarrow{\\text{grad}} \\, W_i \\, \\mathrm{d}\\Omega_e\n\\end{split}\n\n\n W_i  vanishes on  \\Omega_e  frontier  \\Gamma_e , then according Green's formula:\n\n\n\\int \\!\\!\\! \\int_{\\Omega_e} \\text{div} \\left( \\frac{\\rho h&#94;3}{\\mu}  W_i \\, \\overrightarrow{\\text{grad}} \\, p \\right) \\mathrm{d}\\Omega_e =\n\\oint_{\\Gamma_e} \\frac{\\rho h&#94;3}{\\mu}  W_i \\, \\overrightarrow{\\text{grad}} \\, p \\scall \\vec{n} \\, \\mathrm{d}\\Gamma_e = 0\n\n\nIn the same manner, if the right handside is handled likewise:\n\n\n\\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\text{div} \\left( \\rho h  W_i \\, \\vec{u} \\right) \\, \\mathrm{d}\\Omega_e =\n\\oint_{\\Gamma_e} 6 \\, \\rho h  W_i \\, \\vec{u} \\scall \\vec{n} \\, \\mathrm{d}\\Gamma_e = 0\n\n\nand then:\n\n\\begin{equation} \\label{trans}\n\\int \\!\\!\\! \\int_{\\Omega_e} \\frac{\\rho h&#94;3}{\\mu} \\overrightarrow{\\text{grad}} \\, p \\scall \\overrightarrow{\\text{grad}} \\, W_i \\, \\mathrm{d}\\Omega_e =\n\\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\rho h  \\, \\vec{u} \\scall \\overrightarrow{\\text{grad}} \\, W_i \\, \\mathrm{d}\\Omega_e\n\\end{equation}\n\nIf the right handside isn't transformed:\n\n\\begin{equation} \\label{notrans}\n\\int \\!\\!\\! \\int_{\\Omega_e} \\frac{\\rho h&#94;3}{\\mu} \\overrightarrow{\\text{grad}} \\, p \\scall \\overrightarrow{\\text{grad}} \\, W_i \\, \\mathrm{d}\\Omega_e =\n\\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\text{div}\\left( \\rho h \\, \\vec{u} \\right) \\, W_i \\, \\mathrm{d}\\Omega_e\n\\end{equation}\n\nEquation \\eqref{notrans} is more suitable when linear shape functions are use with SUPG, otherwise, using equation \\eqref{trans},  \\overrightarrow{\\text{grad}} \\, W_i = \\overrightarrow{\\text{grad}} \\, N_i .\n\nAs:\n\n\\begin{align*}\n\\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\text{div}\\left( \\rho h \\, \\vec{u} \\right) \\, N_i \\, \\mathrm{d}\\Omega_e & = -\\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\rho h  \\, \\vec{u} \\scall \\overrightarrow{\\text{grad}} \\, N_i \\, \\mathrm{d}\\Omega_e \\\\\n\\vec{\\alpha} & = a \\, \\vec{u}\n\\end{align*}\n\nthen:\n\n\\begin{align*}\n\\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\text{div}\\left( \\rho h \\, \\vec{u} \\right) \\, W_i \\, \\mathrm{d}\\Omega_e\n& = + \\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\text{div}\\left( \\rho h \\, \\vec{u} \\right) \\, \\left( N_i + \\vec{\\alpha} \\scall \\overrightarrow{\\text{grad}} \\, N_i \\right) \\mathrm{d}\\Omega_e \\\\\n& = - \\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\rho h  \\, \\vec{u} \\scall \\overrightarrow{\\text{grad}} \\, N_i \\, \\mathrm{d}\\Omega_e \\\\\n&  \\phantom{ = } + \\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\text{div}\\left( \\rho h \\, \\vec{u} \\right) \\, \\vec{\\alpha} \\scall \\overrightarrow{\\text{grad}} \\, N_i \\, \\mathrm{d}\\Omega_e \\\\\n& = -\\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\vec{u} \\scall \\overrightarrow{\\text{grad}} \\, N_i \\left( \\rho h - \\vec{\\alpha} \\scall \\overrightarrow{\\text{grad}} \\, \\rho h \\right) \\mathrm{d}\\Omega_e\n\\end{align*}\n\nApproximating  \\rho h  with the shape functions,  \\rho h = [\\rho h]_k \\, N_k , leads to:\n\n\\begin{align*}\n\\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\text{div}\\left( \\rho h \\, \\vec{u} \\right) \\, W_i \\, \\mathrm{d}\\Omega_e & = -\\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\vec{u} \\scall \\overrightarrow{\\text{grad}} \\, N_i \\, [\\rho h]_k \\, \\left( N_k - \\vec{\\alpha} \\scall \\overrightarrow{\\text{grad}} \\, N_k \\right) \\mathrm{d}\\Omega_e\n\\end{align*}\n\nLet  \\tilde{N_k}  be the upwind shape function, so that  \\tilde{N_k} = N_k - \\vec{\\alpha} \\scall \\overrightarrow{\\text{grad}} \\, N_k  thus:\n\n\\begin{equation} \\label{reynolds}\n\\int \\!\\!\\! \\int_{\\Omega_e} \\frac{\\rho h&#94;3}{\\mu} \\overrightarrow{\\text{grad}} \\, p \\scall \\overrightarrow{\\text{grad}} \\, W_i \\, \\mathrm{d}\\Omega_e =\n-\\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\widetilde{\\rho h} \\; \\vec{u} \\scall \\overrightarrow{\\text{grad}} \\, N_i \\, \\mathrm{d}\\Omega_e\n\\end{equation}\n\nprovided that  \\widetilde{\\rho h} = [\\rho h]_k \\, \\tilde{N}_k .\n\nLet  R_i  be the residual of equation \\eqref{reynolds} defined as:\n\n\\begin{equation*}\nR_i = \\int \\!\\!\\! \\int_{\\Omega_e} \\frac{\\rho h&#94;3}{\\mu} \\overrightarrow{\\text{grad}} \\, p \\scall \\overrightarrow{\\text{grad}} \\, N_i \\, \\mathrm{d}\\Omega_e\n- \\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\widetilde{\\rho h} \\; \\vec{u} \\scall \\overrightarrow{\\text{grad}} \\, N_i \\, \\mathrm{d}\\Omega_e\n\\end{equation*}\n\nHence, defining  \\frac{\\partial \\rho}{\\partial p_j}  as  \\left[ \\frac{\\partial \\rho}{\\partial p} \\right]_j N_j  :\n\n\\begin{align}\n\\frac{\\partial R_i}{\\partial p_j} = R_{ij} =\n+ & \\int \\!\\!\\! \\int_{\\Omega_e} \\frac{\\rho h&#94;3}{\\mu}                                                              \\overrightarrow{\\text{grad}} \\, N_j \\, \\scall \\, \\overrightarrow{\\text{grad}} \\, N_i \\, \\mathrm{d}\\Omega_e \\nonumber \\\\\n+ & \\int \\!\\!\\! \\int_{\\Omega_e} \\frac{     h&#94;3}{\\mu} \\left[ \\frac{\\partial \\rho}{\\partial p} \\right]_j \\!  N_j \\, \\overrightarrow{\\text{grad}} \\, p   \\, \\scall \\, \\overrightarrow{\\text{grad}} \\, N_i \\, \\mathrm{d}\\Omega_e \\nonumber \\\\\n- & \\int \\!\\!\\! \\int_{\\Omega_e} 6 \\, \\left[ h \\frac{\\partial \\rho}{\\partial p} \\right]_j \\tilde{N_j} \\; \\vec{u} \\, \\scall \\, \\overrightarrow{\\text{grad}} \\, N_i \\, \\mathrm{d}\\Omega_e\n\\end{align}\n\nand  b_i = -R_i . UPWINDING COEFFICIENTS Convection-Diffusion-Reaction Equation Zienkiewicz, \"The Finite Element Method for Fluid Dynamics\", 7th, p30, p50\n\nThe simplest form of Convection-Diffusion-Reaction Equation is one in which the unknown is a scalar.\nIt is a set of conservation laws arising from a balance of the quantity with fluxes entering and leaving a control volume:\n\n   \\frac{\\partial \\phi}{\\partial t} +\\frac{\\partial (U_i \\phi)}{\\partial x_i} -\n   \\frac{\\partial}{\\partial x_i} \\left( k\\frac{\\partial \\phi}{\\partial x_i} \\right) +Q =0\n\n\nU_i is a known velocity field and \\phi is a scalar quantity being transported by this velocity.\nDiffusion can also exist and k is the diffusion coefficient. The term Q represents any external\nsources of the quantity \\phi. Reynolds Equation Using the fact that h/L\\ll 1, that the fluid is Newtonian, and that the viscosity and density are constant\nthrough the film direction, the following Reynolds equation is obtained:\n\n   \\frac{\\partial }{\\partial x}\\left(\\frac{\\rho h&#94;3}{12\\mu}\\frac{\\partial p}{\\partial x} \\right) +\n   \\frac{\\partial }{\\partial y}\\left(\\frac{\\rho h&#94;3}{12\\mu}\\frac{\\partial p}{\\partial y} \\right)= \\\\\n   \\frac{1}{2}\\frac{\\partial }{\\partial x}\\left[ \\left(U_1+U_2\\right)\\rho h \\right]+\n   \\frac{1}{2}\\frac{\\partial }{\\partial y}\\left[ \\left(V_1+V_2\\right)\\rho h \\right]+\n              \\frac{\\partial }{\\partial t}\\left(\\rho h \\right)\n\n\nIdentifying the different terms leads to:\n\n   k=\\frac{\\rho h&#94;3}{\\mu} \\text{ ; } \\phi = p \\text{ ; } U_i = 6 v_i h\\frac{\\partial \\rho}{\\partial p} \\text{ with } \\boldsymbol{v}=\n   \\begin{pmatrix}\n      U_2 \\\\\n      V_2\n   \\end{pmatrix}\n Streamline Petrov-Galerkin weighting (SUPG) In the bidimensional case, the Peclet parameter is a vector:\n\n   \\boldsymbol{Pe} = \\frac{1}{k} \\left( \\boldsymbol{U}\\frac{Le}{2} \\right)=\n   \\begin{pmatrix}\n      Pe_x \\\\\n      Pe_y\n   \\end{pmatrix}\n\nwhere Le is the element length.\n\nThe Peclet numbers of the Reynolds equation are therefore defined as:\n\n   Pe_x = \\frac{6\\mu(Le/2) U_2}{\\rho h&#94;2} \\frac{\\partial \\rho}{\\partial p} \\\\\n   Pe_y = \\frac{6\\mu(Le/2) V_2}{\\rho h&#94;2} \\frac{\\partial \\rho}{\\partial p}\n\n\nThe optimal upwinding coefficient is:\n\n   \\alpha = \\coth{Pe} -\\frac{1}{Pe}\n\nwith Pe=||\\boldsymbol{Pe}|| The element length Le Using Zienkiewicz scheme: which can be adapted like this: PRECOMPUTED INTEGRATION PARTS Coefficients for the transformation from (\\xi, \\eta) to (x,y) \n   x(\\xi,\\eta) = \\sum\\limits_{nodes \\; i} x_i \\times N_{i}(\\xi,\\eta) \\\\\n   y(\\xi,\\eta) = \\sum\\limits_{nodes \\; i} y_i \\times N_{i}(\\xi,\\eta)\n\n\nLet c_i be defined by:\n\n   c_1 = \\frac{\\partial x}{\\partial \\xi } \\; ; \\;\n   c_2 = \\frac{\\partial y}{\\partial \\xi } \\; ; \\;\n   c_3 = \\frac{\\partial x}{\\partial \\eta} \\; ; \\;\n   c_4 = \\frac{\\partial y}{\\partial \\eta} \\\\\n   c_5 = det \\begin{pmatrix}\n              c_1 & c_2 \\\\\n              c_3 & c_4\n            \\end{pmatrix} = c_1 c_4 - c_2 c_3\n\n\nIt must be remembered that the functions are first order, *ie* the x derivative with respect to \\xi only depends on \\eta. Computation of the coefficients for the Reynolds equation \n   h(x,y)&#94;3 = \\sum\\limits_{nodes \\; k} h&#94;3_{k} \\times N_{k}(x,y)\n\n\nThe same goes for \\rho and \\mu. Therefore, at Gauss point (i,j), \\rho h&#94;3 /\\mu can be precalculated:\n\n\\begin{align*}\n   vcal(2, i, j) &= \\left( \\sum\\limits_{nodes \\; k} h&#94;3_{k}           \\times N_{k}(x_i, y_j) \\right).\n                    \\left( \\sum\\limits_{nodes \\; k} \\rho_{k}          \\times N_{k}(x_i, y_j) \\right).\n                    \\left( \\sum\\limits_{nodes \\; k} \\frac{1}{\\mu_{k}} \\times N_{k}(x_i, y_j) \\right)\\\\\n                 &= (h&#94;3)_{ij} \\; (\\rho)_{ij} \\; \\left(\\frac{1}{\\mu}\\right)_{ij}\n\\end{align*}\n\n\nLikewise:\n\n\\begin{align*}\n   vcal( 3, i, j) &= 6\\, (V\\!x)_{ij} \\\\\n   vcal( 4, i, j) &= 6\\, (V\\!y)_{ij} \\\\\n   vcal( 5, i, j) &= -\\rho_k h_k   \\,.\\, \\tilde{N}_{k}(x_i, y_j) \\\\\n   vcal( 6, i, j) &= K_{ij}\\left[ (\\rho)_{ij}  (h&#94;3)_{ij} \\left(\\frac{1}{\\mu}\\right)_{ij} \\left(\\frac{\\partial p}{\\partial x}\\right)_{ij} \\right] \\\\\n   vcal( 7, i, j) &= K_{ij}\\left[ (\\rho)_{ij}  (h&#94;3)_{ij} \\left(\\frac{1}{\\mu}\\right)_{ij} \\left(\\frac{\\partial p}{\\partial y}\\right)_{ij} \\right] \\\\\n   vcal( 8, i, j) &= K_{ij}\\left[ 6 \\; (V\\!x)_{ij} \\left(\\rho_k h_k \\tilde{N}_k (x_i, y_j)\\right) \\right] \\\\\n   vcal( 9, i, j) &= K_{ij}\\left[ 6 \\; (V\\!y)_{ij} \\left(\\rho_k h_k \\tilde{N}_k (x_i, y_j)\\right) \\right] \\\\\n   vcal(10, i, j) &= K_{ij}\\left[ (h&#94;3)_{ij} \\left(\\frac{1}{\\mu}\\right)_{ij} \\left(\\frac{\\partial p}{\\partial x}\\right)_{ij} \\right] \\\\\n   vcal(11, i, j) &= K_{ij}\\left[ (h&#94;3)_{ij} \\left(\\frac{1}{\\mu}\\right)_{ij} \\left(\\frac{\\partial p}{\\partial y}\\right)_{ij} \\right] \\\\\n   vcal(12, i, j) &= K_{ij}\\left[ (p)_{ij} \\right]\\\\\n   vcal(13, i, j) &= K_{ij}\\left[ -\\frac{1}{2} (h)_{ij} \\left(\\frac{\\partial p}{\\partial x}\\right)_{ij} -(\\mu)_{ij} (V\\!x)_{ij} \\left( \\frac{1}{h} \\right)_{ij} \\right]\n\\end{align*}\n\n\nwith:\n\n   vcal(1, i, j) = K_{ij} = c_5  w_i w_j \\text{ ; } w_i \\text{ Gauss ith weighting coefficient}\n var coll = document.getElementsByClassName(\"collapsible\");\nvar i;\n\nfor (i = 0; i < coll.length; i++) {\n  coll[i].addEventListener(\"click\", function() {\n    this.classList.toggle(\"active\");\n    var content = this.nextElementSibling;\n    if (content.style.maxHeight){\n      content.style.maxHeight = null;\n    } else {\n      content.style.maxHeight = content.scrollHeight + \"px\";\n    }\n  });\n} Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE film integer(kind=I4), intent(in) :: e element number Calls proc~~compute_prc_tables_reynolds_supg~~CallsGraph proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_prc_tables_reynolds_supg~~CalledByGraph proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~fx fx proc~fx->proc~compute_prc_tables_reynolds_supg proc~fz fz proc~fz->proc~compute_prc_tables_reynolds_supg proc~fy fy proc~fy->proc~compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~compute_corner_fluxes compute_corner_fluxes proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~solve_fe_prob->proc~compute_corner_fluxes proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds->proc~compute_corner_fluxes proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_slider_ms->proc~solve_ms_prob program~main main program~main->proc~run_test var panproccompute_prc_tables_reynolds_supgCalledByGraph = svgPanZoom('#proccompute_prc_tables_reynolds_supgCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_prc_tables_reynolds_supg Source Code subroutine compute_prc_tables_reynolds_supg ( fe_f , e ) implicit none type ( FE_film ), intent ( inout ) :: fe_f !! *FE film* integer ( kind = I4 ), intent ( in ) :: e !! *element number* integer ( kind = I4 ) :: i , j , k , ng , nne logical ( kind = I4 ) :: gaz real ( kind = R8 ), dimension ( MAX_NNE ) :: tvx , tvy , th , tp , trho , tmu , tdrdp , tx , ty , tnix , tniy real ( kind = R8 ), dimension ( MAX_NNG ) :: wg , pg real ( kind = R8 ) :: c5 , vc1 real ( kind = R8 ) :: Pe_ux , Pe_uy , Pe_u , Pe_vx , Pe_vy , Pe_v , coeff_x , coeff_y , kk real ( kind = R8 ) :: sx , sy , alpha_u , alpha_ux , alpha_uy , alpha_vx , alpha_vy , alpha_v real ( kind = R8 ) :: dNidx_p , dNidy_p , Nid_rho_h , Ni_p , Ni_h , Ni_h3 , Ni_vx , Ni_vy , Ni_mu , Ni_rho , Ni_inv_h , Ni_inv_mu real ( kind = R8 ) :: lu , wu , lv , wv real ( kind = R8 ) :: Ni_drhodp , gradh , gradhx , gradhy , gradp , gradpx , gradpy real ( kind = R8 ) :: drdp , h , mu , rho , u , ux , uy , v , vx , vy real ( kind = R8 ), dimension ( MAX_NNE ) :: vni4 , vni4x , vni4y , vni4d real ( kind = R8 ), dimension ( 14 ) :: vcal !============================================ !> {!MUSST/src/inc_doc/Reynolds_discretization.md!} !============================================ !============================================ !> {!MUSST/src/inc_doc/upwinding_coefficients.md!} !============================================ gaz = ( fe_f % data_f % fl % fluid_type == GP ) nne = fe_f % m % el_t ( e ) ! values on the nodes do i = 1 , nne j = fe_f % m % con ( e , i ) tx ( i ) = fe_f % m % x ( j ) ! coordinates ty ( i ) = fe_f % m % y ( j ) tvx ( i ) = fe_f % vn ( j , VX_N ) ! velocities tvy ( i ) = fe_f % vn ( j , VY_N ) th ( i ) = fe_f % vn ( j , H_N ) ! heigth tp ( i ) = fe_f % vn ( j , P_N ) ! pressure trho ( i ) = fe_f % vn ( j , RHO_N ) ! density tmu ( i ) = fe_f % vn ( j , MU_N ) ! viscosity tdrdp ( i ) = fe_f % vn ( j , DRHODP_N ) ! viscosity derivative regarding P enddo c5 = dj4 ( ksi = 0._R8 , eta = 0._R8 , x = tx ( 1 : nne ), y = ty ( 1 : nne )) call calc_ni4_xy_derivatives ( ni4x = tnix ( 1 : nne ), & ni4y = tniy ( 1 : nne ), & ksi = 0._R8 , & eta = 0._R8 , & x = tx ( 1 : nne ), & y = ty ( 1 : nne ), & dj = c5 ) ! addition of the groove depth th ( 1 : nne ) = th ( 1 : nne ) + fe_f % vc ( e , HG_C ) ux = sum ( tvx ( 1 : nne )) / nne uy = sum ( tvy ( 1 : nne )) / nne u = sqrt ( ux ** 2 + uy ** 2 ) h = sum ( th ( 1 : nne )) / nne drdp = sum ( tdrdp ( 1 : nne )) / nne mu = sum ( tmu ( 1 : nne )) / nne rho = sum ( trho ( 1 : nne )) / nne gradpx = sum ( tp ( 1 : nne ) * tnix ( 1 : nne ) ) gradpy = sum ( tp ( 1 : nne ) * tniy ( 1 : nne ) ) gradp = sqrt ( gradpx ** 2 + gradpy ** 2 ) gradhx = sum ( th ( 1 : nne ) * tnix ( 1 : nne ) ) gradhy = sum ( th ( 1 : nne ) * tniy ( 1 : nne ) ) gradh = sqrt ( gradhx ** 2 + gradhy ** 2 ) kk = 6 * ( drdp / rho ) * mu * ( 1. / h ** 2 ) ! Gauss points ng = fe_f % prc % ng pg ( 1 : ng ) = fe_f % prc % pg ( 1 : ng ) wg ( 1 : ng ) = fe_f % prc % wg ( 1 : ng ) if ( gaz ) then v = - ( h ** 2 ) / ( 6 * mu ) vx = v * gradpx vy = v * gradpy v = sqrt ( vx ** 2 + vy ** 2 ) call length_width_elem ( spdx = ux , & !  in, speed u along x spdy = uy , & !  in, speed u along y x = tx , & !  in, element x coordinates y = ty , & !  in, element y coordinates length = lu , & ! out, length along u width = wu ) ! out,  width call length_width_elem ( spdx = vx , & !  in, speed v along x spdy = vy , & !  in, speed v along y x = tx , & !  in, element x coordinates y = ty , & !  in, element y coordinates length = lv , & ! out, length along v width = wv ) ! out,  width ! Peclet number related to u Pe_ux = ux * ( lu / 2 ) * kk Pe_uy = uy * ( lu / 2 ) * kk Pe_u = sqrt ( Pe_ux ** 2 + Pe_uy ** 2 ) ! Peclet number related to v Pe_vx = vx * ( wu / 2 ) * kk Pe_vy = vy * ( wu / 2 ) * kk Pe_v = sqrt ( Pe_vx ** 2 + Pe_vy ** 2 ) alpha_ux = Pe_ux alpha_uy = Pe_uy alpha_u = Pe_u alpha_v = ( h / 1.e6 ) * ( u / 1.e2 ) * ( mu / 1.e-5 ) * ( wu / lu ) * ( Pe_vx * ( - uy ) + Pe_vy * ( + ux ) ) / u alpha_vx = alpha_v * ( - uy ) / u alpha_vy = alpha_v * ( + ux ) / u alpha_v = sqrt ( alpha_vx ** 2 + alpha_vy ** 2 ) coeff_x = alpha_ux + alpha_vx ; sx = sign ( 1._R8 , coeff_x ) ; coeff_x = abs ( coeff_x ) coeff_y = alpha_uy + alpha_vy ; sy = sign ( 1._R8 , coeff_y ) ; coeff_y = abs ( coeff_y ) fe_f % vc ( e , PEK_C ) = sx * coeff_x fe_f % vc ( e , PEE_C ) = sy * coeff_y else lu = maxval ( tx ( 1 : nne )) - minval ( tx ( 1 : nne )) wu = maxval ( ty ( 1 : nne )) - minval ( ty ( 1 : nne )) lv = lu * ux + wu * uy Pe_ux = kk * ( lv / 2 ) Pe_uy = 0._R8 if ( abs ( Pe_ux ) < 1.e-2_R8 ) then Pe_ux = Pe_ux / 3 else Pe_ux = 1._R8 / ( tanh ( Pe_ux )) - 1._R8 / Pe_ux endif alpha_vx = 1._r8 alpha_vy = 1._r8 if ( u > 0._r8 ) then alpha_vx = lv * ux / ( 2 * ( u ** 2 )) alpha_vy = lv * uy / ( 2 * ( u ** 2 )) endif fe_f % vc ( e , Pek_c ) = alpha_vx fe_f % vc ( e , Pee_c ) = alpha_vy endif !============================================= !> {!MUSST/src/inc_doc/precomputed_integrations.md!} !============================================= do i = 1 , ng do j = 1 , ng vni4 ( 1 : nne ) = fe_f % prc % vni4 ( 1 : nne , i , j ) ! computation of the shape function derivatives c5 = dj4 ( ksi = pg ( i ), eta = pg ( j ), x = tx ( 1 : nne ), y = ty ( 1 : nne )) call calc_ni4_xy_derivatives ( ni4x = vni4x ( 1 : nne ), & ni4y = vni4y ( 1 : nne ), & ksi = pg ( i ), & eta = pg ( j ), & x = tx ( 1 : nne ), & y = ty ( 1 : nne ), & dj = c5 ) if ( c5 < 0 ) stop 'compute_prc_tables_reynolds_supg: jacobian negative for elt' if ( gaz ) then do k = 1 , nne vni4d ( k ) = ni4_up_2d ( k , pg ( i ), pg ( j ), ( / coeff_x , coeff_y / ), ( / sx , sy / )) enddo else vni4d ( 1 : nne ) = vni4 ( 1 : nne ) - alpha_vx * Pe_ux * vni4x ( 1 : nne ) - alpha_vy * Pe_ux * vni4y ( 1 : nne ) endif fe_f % prc % vni4x ( 1 : nne , i , j ) = vni4x ( 1 : nne ) fe_f % prc % vni4y ( 1 : nne , i , j ) = vni4y ( 1 : nne ) fe_f % prc % vni4d ( 1 : nne , i , j ) = vni4d ( 1 : nne ) ! computation of the coefficients for the Reynolds equation vc1 = wg ( i ) * wg ( j ) * c5 dNidx_p = sum ( vni4x ( 1 : nne ) * tp ( 1 : nne )) dNidy_p = sum ( vni4y ( 1 : nne ) * tp ( 1 : nne )) Nid_rho_h = sum ( vni4d ( 1 : nne ) * trho ( 1 : nne ) * th ( 1 : nne )) Ni_p = sum ( vni4 ( 1 : nne ) * tp ( 1 : nne )) Ni_h = sum ( vni4 ( 1 : nne ) * th ( 1 : nne )) Ni_h3 = sum ( vni4 ( 1 : nne ) * th ( 1 : nne ) ** 3 ) Ni_vx = sum ( vni4 ( 1 : nne ) * tvx ( 1 : nne )) Ni_vy = sum ( vni4 ( 1 : nne ) * tvy ( 1 : nne )) Ni_mu = sum ( vni4 ( 1 : nne ) * tmu ( 1 : nne )) Ni_rho = sum ( vni4 ( 1 : nne ) * trho ( 1 : nne )) Ni_inv_h = sum ( vni4 ( 1 : nne ) * ( 1._R8 / th ( 1 : nne ))) Ni_inv_mu = sum ( vni4 ( 1 : nne ) * ( 1._R8 / tmu ( 1 : nne ))) Ni_drhodp = sum ( vni4 ( 1 : nne ) * tdrdp ( 1 : nne )) vcal ( 1 ) = vc1 vcal ( 2 ) = vc1 * Ni_h3 * Ni_rho * Ni_inv_mu vcal ( 3 ) = vc1 * 6 * Ni_vx * Ni_h vcal ( 4 ) = vc1 * 6 * Ni_vy * Ni_h vcal ( 5 ) = 0 vcal ( 6 ) = vc1 * Ni_h3 * Ni_inv_mu * Ni_rho * dNidx_p vcal ( 7 ) = vc1 * Ni_h3 * Ni_inv_mu * Ni_rho * dNidy_p vcal ( 8 ) = vc1 * 6 * Ni_vx * Nid_rho_h vcal ( 9 ) = vc1 * 6 * Ni_vy * Nid_rho_h vcal ( 10 ) = vc1 * Ni_h3 * Ni_inv_mu * dNidx_p vcal ( 11 ) = vc1 * Ni_h3 * Ni_inv_mu * dNidy_p vcal ( 12 ) = vc1 * Ni_p vcal ( 13 ) = vc1 * ( - dNidx_p * Ni_h / 2 - Ni_mu * Ni_vx * Ni_inv_h ) vcal ( 14 ) = vc1 * ( - dNidy_p * Ni_h / 2 - Ni_mu * Ni_vy * Ni_inv_h ) fe_f % prc % vcal ( 1 : 14 , i , j ) = vcal ( 1 : 14 ) enddo enddo !============================================= !> {!MUSST/css/button.html!} !============================================= return endsubroutine compute_prc_tables_reynolds_supg","loc":"proc/compute_prc_tables_reynolds_supg.html"},{"tags":"","title":"length_width_elem – MUSST","text":"private subroutine length_width_elem(spdx, spdy, x, y, length, width) Note Subroutine to calculate the characteristic length of an element, giving Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: spdx fluid velocity along x axis real(kind=R8), intent(in) :: spdy fluid velocity along y axis real(kind=R8), intent(in), dimension(4) :: x corner abscissae real(kind=R8), intent(in), dimension(4) :: y corner ordinates real(kind=R8), intent(out) :: length fluid element length real(kind=R8), intent(out) :: width fluid element width Called by proc~~length_width_elem~~CalledByGraph proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~fx fx proc~fx->proc~compute_prc_tables_reynolds_supg proc~fz fz proc~fz->proc~compute_prc_tables_reynolds_supg proc~fy fy proc~fy->proc~compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~compute_corner_fluxes compute_corner_fluxes proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~solve_fe_prob->proc~compute_corner_fluxes proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds->proc~compute_corner_fluxes proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_slider_ms->proc~solve_ms_prob program~main main program~main->proc~run_test var panproclength_width_elemCalledByGraph = svgPanZoom('#proclength_width_elemCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code length_width_elem Source Code subroutine length_width_elem ( spdx , spdy , x , y , length , width ) implicit none real ( kind = R8 ), intent ( in ) :: spdx !! *fluid velocity along x axis* real ( kind = R8 ), intent ( in ) :: spdy !! *fluid velocity along y axis* real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: x !! *corner abscissae* real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: y !! *corner ordinates* real ( kind = R8 ), intent ( out ) :: length !! *fluid element length* real ( kind = R8 ), intent ( out ) :: width !! *fluid element width* real ( kind = R8 ) :: abx , adx , cbx , cdx , & aby , ady , cby , cdy , & acx , bdx , acy , bdy , & el_S , px , py , pm , spd , & ac_dot_p , bd_dot_p , ab_dot_p , & ad_dot_p , cb_dot_p , cd_dot_p , & x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4 length = 0. width = 0. spd = sqrt ( spdx ** 2 + spdy ** 2 ) if ( spd > EPS_R8 ) then px = - spdy ! direction perpendicular to vector v py = + spdx pm = spd x1 = x ( 1 ) ; y1 = y ( 1 ) x2 = x ( 2 ) ; y2 = y ( 2 ) x3 = x ( 3 ) ; y3 = y ( 3 ) x4 = x ( 4 ) ; y4 = y ( 4 ) acx = x3 - x1 ; acy = y3 - y1 bdx = x4 - x2 ; bdy = y4 - y2 abx = x2 - x1 ; aby = y2 - y1 adx = x4 - x1 ; ady = y4 - y1 cbx = x2 - x3 ; cby = y2 - y3 cdx = x4 - x3 ; cdy = y4 - y3 ac_dot_p = abs ( px * acx + py * acy ) bd_dot_p = abs ( px * bdx + py * bdy ) ab_dot_p = abs ( px * abx + py * aby ) ad_dot_p = abs ( px * adx + py * ady ) cb_dot_p = abs ( px * cbx + py * cby ) cd_dot_p = abs ( px * cdx + py * cdy ) ! quadrangle projection on the perpendicular to v width = max ( ac_dot_p , bd_dot_p , ab_dot_p , & ad_dot_p , cb_dot_p , cd_dot_p ) / pm ! quadrangle area el_S = 0.5 * ( abs ( cbx * cdy - cdx * cby ) + abs ( abx * ady - adx * aby ) ) ! element length length = el_S / width endif return endsubroutine length_width_elem","loc":"proc/length_width_elem.html"},{"tags":"","title":"compute_corner_fluxes – MUSST","text":"public subroutine compute_corner_fluxes(fe_f, mat, bf) Note Subroutine to calculate the fluxes at the corner of the domain Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE film type(MAT_SOLV), intent(inout) :: mat solver type matrices real(kind=R8), intent(out), dimension(MAX_NNC) :: bf table of fluxes at the corner Calls proc~~compute_corner_fluxes~~CallsGraph proc~compute_corner_fluxes compute_corner_fluxes proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d var panproccompute_corner_fluxesCallsGraph = svgPanZoom('#proccompute_corner_fluxesCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_corner_fluxes~~CalledByGraph proc~compute_corner_fluxes compute_corner_fluxes proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~compute_corner_fluxes proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~compute_corner_fluxes proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe program~main main program~main->proc~run_test var panproccompute_corner_fluxesCalledByGraph = svgPanZoom('#proccompute_corner_fluxesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_corner_fluxes Source Code subroutine compute_corner_fluxes ( fe_f , mat , bf ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f !! *FE film* type ( MAT_SOLV ), intent ( inout ) :: mat !! *solver type matrices* real ( kind = R8 ), intent ( out ), dimension ( MAX_NNC ) :: bf !! *table of fluxes at the corner* integer ( kind = I4 ) :: ind2 , ind1 , ind , e , i real ( kind = R8 ) :: x1 , x2 , y1 , y2 , d , l ! calculation of the fluxes on the boundaries by assembly ass_c = no_bc call assembly_FE_film_reynolds ( fe_f = fe_f , & ! mat = mat , & ! ass_c = NO_BC ) ! ! projection of the fluxes on the corners ! loop on edges bf = 0.0_R8 ind1 = 1 x1 = fe_f % m % x ( fe_f % m % cor ( 1 )) y1 = fe_f % m % y ( fe_f % m % cor ( 1 )) do e = fe_f % m % ned , 1 , - 1 ind2 = ind1 x2 = x1 y2 = y1 ind1 = e x1 = fe_f % m % x ( fe_f % m % cor ( e )) y1 = fe_f % m % y ( fe_f % m % cor ( e )) ! length of the edge l = (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ** 0.5_R8 ! loop on all the nodes - 1 on the edge ! without -1, the corner contribution is counted two times do i = 1 , fe_f % m % ed ( e )% n - 1 ind = fe_f % m % ed ( e )% nm ( i ) ! distance to point 2 d = (( x2 - fe_f % m % x ( ind )) ** 2 + ( y2 - fe_f % m % y ( ind )) ** 2 ) ** 0.5_R8 d = d / l ! linear projection along the edge of the local flux bf ( ind1 ) = bf ( ind1 ) + d * mat % b ( ind ) bf ( ind2 ) = bf ( ind2 ) + ( 1._R8 - d ) * mat % b ( ind ) enddo enddo return endsubroutine compute_corner_fluxes","loc":"proc/compute_corner_fluxes.html"},{"tags":"","title":"save_fe_field – MUSST","text":"public subroutine save_fe_field(fe_f, file_name, code, nodal) Note Subroutine to save a FE_FILM in a .sur file Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(in) :: fe_f character(len=*), intent(in) :: file_name integer(kind=I4), intent(in) :: code logical(kind=I4), intent(in) :: nodal if false : cell value, if true : nodal value Calls proc~~save_fe_field~~CallsGraph proc~save_fe_field save_fe_field proc~empty empty proc~save_fe_field->proc~empty proc~init_scal init_scal proc~save_fe_field->proc~init_scal proc~write_surf write_surf proc~save_fe_field->proc~write_surf proc~init_scal->proc~empty proc~get_unit get_unit proc~write_surf->proc~get_unit proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~lower lower proc~write_surf->proc~lower proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string proc~c_f_string->proc~empty Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~save_fe_field~~CalledByGraph proc~save_fe_field save_fe_field proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~save_fe_field proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code save_fe_field Source Code subroutine save_fe_field ( fe_f , file_name , code , nodal ) implicit none type ( FE_FILM ), intent ( in ) :: fe_f character ( len =* ), intent ( in ) :: file_name integer ( kind = I4 ), intent ( in ) :: code logical ( kind = I4 ), intent ( in ) :: nodal !! if false : cell value, if true : nodal value integer ( kind = I4 ) :: nx , ny integer ( kind = I4 ), dimension ( 1 ) :: i1 , i2 real ( kind = R8 ), allocatable , dimension (:,:) :: tab_s real ( kind = R8 ) :: lx , ly character ( len = 8 ) :: unit_z nx = fe_f % m % nx ny = fe_f % m % ny lx = fe_f % m % lx ly = fe_f % m % ly call empty ( unit_z ) if (. not . nodal ) then nx = nx - 1 ny = ny - 1 endif allocate ( tab_s ( 1 : nx , 1 : ny ) ) ; tab_s = - 1. if ( nodal ) then tab_s = reshape ( fe_f % vn (:, code ), ( / nx , ny / ) ) i1 = index ( fe_f % vn_name ( code ), '(' ) + 1 i2 = index ( fe_f % vn_name ( code ), ')' ) - 1 unit_z = fe_f % vn_name ( code )( i1 ( 1 ): i2 ( 1 )) else tab_s = reshape ( fe_f % vc (:, code ), ( / nx , ny / ) ) i1 = index ( fe_f % vc_name ( code ), '(' ) + 1 i2 = index ( fe_f % vc_name ( code ), ')' ) - 1 unit_z = fe_f % vc_name ( code )( i1 ( 1 ): i2 ( 1 )) endif call init_scal ( scal = scal_tmp , & ! nx = nx , & ! ny = ny , & ! lx = lx , & ! default unit : m ly = ly , & ! unit_z = unit_z ) ! call write_surf ( nom_fic = file_name , & ! tab_s = tab_s , & ! scal = scal_tmp ) deallocate ( tab_s ) return endsubroutine save_fe_field","loc":"proc/save_fe_field.html"},{"tags":"","title":"rho – MUSST","text":"private function rho(fl, p, t) Note Function to calculate the density of the fluid based on t and p if fl is set to INC (incompressible) \\rho=\\rho_0 where \\rho_0 is a member of fl FLUID if fl is set to GP (perfect gas) \\rho=\\frac{p}{r_g T} where r_g is a member of fl FLUID if fl is set to MIXT (mixture) \\rho=\\frac{1}{\\frac{1-\\lambda}{\\rho_0}+\\frac{\\lambda r_g T}{p}} where \\lambda \\text{ and } r_g are members of fl FLUID Arguments Type Intent Optional Attributes Name class( FLUID ), intent(in) :: fl fluid type real(kind=R8), intent(in) :: p pressure real(kind=R8), intent(in) :: t absolute temperature Return Value real(kind=R8) Contents None","loc":"proc/rho.html"},{"tags":"","title":"drhodp – MUSST","text":"private function drhodp(fl, p, t) Note Function to calculate compressibility (drdp)T based on T and p if fl is set to INC (incompressible) \\rho=0 if fl is set to GP (perfect gas) \\rho=\\frac{1}{r_g T} where r_g is a member of fl FLUID if fl is set to MIXT (mixture) \\rho=\\frac{\\lambda \\rho_0&#94;2 r_g T}{(p(1-\\lambda) +\n                  \\lambda r_g T \\rho_0)&#94;2} where \\lambda \\' , \\' \\rho_0 \\text{ and } r_g are members of fl FLUID Arguments Type Intent Optional Attributes Name class( FLUID ), intent(in) :: fl fluid type real(kind=R8), intent(in) :: p pressure real(kind=R8), intent(in) :: t absolute temperature Return Value real(kind=R8) Contents None","loc":"proc/drhodp.html"},{"tags":"","title":"pres – MUSST","text":"private function pres(fl, rho, t) Note Function to calculate pressure (pres) based on T and density if fl is set to GP (perfect gas) pres=\\rho r_g T where r_g is a member of fl FLUID if fl is set to MIXT (mixture) pres=\\frac{\\lambda r_g T}{\\frac{1}{\\rho} -\n                                           \\frac{1-\\lambda}{\\rho_0}} are members of fl FLUID Arguments Type Intent Optional Attributes Name class( FLUID ), intent(in) :: fl fluid type real(kind=R8), intent(in) :: rho density real(kind=R8), intent(in) :: t absolute temperature Return Value real(kind=R8) Contents None","loc":"proc/pres.html"},{"tags":"","title":"save_fe_f_vtk – MUSST","text":"public subroutine save_fe_f_vtk(fe_f, nom_fic) Note Subroutine to save deterministic data following VTK model Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(in) :: fe_f FE_FILM element to store character(len=*), intent(in) :: nom_fic filename Calls proc~~save_fe_f_vtk~~CallsGraph proc~save_fe_f_vtk save_fe_f_vtk proc~vtk_con VTK_CON proc~save_fe_f_vtk->proc~vtk_con interface~vtk_var VTK_VAR proc~save_fe_f_vtk->interface~vtk_var proc~vtk_ini VTK_INI proc~save_fe_f_vtk->proc~vtk_ini interface~vtk_geo VTK_GEO proc~save_fe_f_vtk->interface~vtk_geo proc~vtk_dat VTK_DAT proc~save_fe_f_vtk->proc~vtk_dat proc~vtk_end VTK_END proc~save_fe_f_vtk->proc~vtk_end proc~vtk_var_scal_r8 VTK_VAR_SCAL_R8 interface~vtk_var->proc~vtk_var_scal_r8 proc~vtk_var_scal_i4 VTK_VAR_SCAL_I4 interface~vtk_var->proc~vtk_var_scal_i4 proc~vtk_var_vect_i4 VTK_VAR_VECT_I4 interface~vtk_var->proc~vtk_var_vect_i4 proc~vtk_var_text_r8 VTK_VAR_TEXT_R8 interface~vtk_var->proc~vtk_var_text_r8 proc~vtk_var_vect_r4 VTK_VAR_VECT_R4 interface~vtk_var->proc~vtk_var_vect_r4 proc~vtk_var_vect_r8 VTK_VAR_VECT_R8 interface~vtk_var->proc~vtk_var_vect_r8 proc~vtk_var_text_r4 VTK_VAR_TEXT_R4 interface~vtk_var->proc~vtk_var_text_r4 proc~vtk_var_scal_r4 VTK_VAR_SCAL_R4 interface~vtk_var->proc~vtk_var_scal_r4 proc~upper_case Upper_Case proc~vtk_ini->proc~upper_case proc~getunit GetUnit proc~vtk_ini->proc~getunit proc~vtk_geo_unst_r8 VTK_GEO_UNST_R8 interface~vtk_geo->proc~vtk_geo_unst_r8 proc~vtk_geo_strp_r8 VTK_GEO_STRP_R8 interface~vtk_geo->proc~vtk_geo_strp_r8 proc~vtk_geo_strg_r8 VTK_GEO_STRG_R8 interface~vtk_geo->proc~vtk_geo_strg_r8 proc~vtk_geo_rect_r4 VTK_GEO_RECT_R4 interface~vtk_geo->proc~vtk_geo_rect_r4 proc~vtk_geo_strg_r4 VTK_GEO_STRG_R4 interface~vtk_geo->proc~vtk_geo_strg_r4 proc~vtk_geo_unst_r4 VTK_GEO_UNST_R4 interface~vtk_geo->proc~vtk_geo_unst_r4 proc~vtk_geo_strp_r4 VTK_GEO_STRP_R4 interface~vtk_geo->proc~vtk_geo_strp_r4 proc~vtk_geo_rect_r8 VTK_GEO_RECT_R8 interface~vtk_geo->proc~vtk_geo_rect_r8 proc~vtk_dat->proc~upper_case proc~vtk_var_vect_r4->proc~upper_case proc~vtk_var_vect_r8->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code save_fe_f_vtk Source Code subroutine save_fe_f_vtk ( fe_f , nom_fic ) implicit none type ( FE_FILM ), intent ( in ) :: fe_f !! [[FE_FILM]] *element to store* character ( len =* ), intent ( in ) :: nom_fic !! *filename* integer ( kind = I4 ) :: E_IO ! parametre identification vtk integer ( kind = I4 ) :: i , k real ( kind = R8 ), dimension (:), allocatable :: z ! tableau supplementaire pour la sortie integer ( kind = I4 ), dimension (:), allocatable :: connec , tipo allocate ( z ( fe_f % m % n ), connec ( fe_f % m % ne * ( 1 + 4 )), tipo ( fe_f % m % ne )) z = 0._R8 tipo = 9 ! elements a quatre noeuds: 9 dans le formalisme vtk k = 0 do i = 1 , fe_f % m % ne connec ( k + 1 ) = 4 connec ( k + 2 ) = fe_f % m % con ( i , 1 ) - 1 connec ( k + 3 ) = fe_f % m % con ( i , 2 ) - 1 connec ( k + 4 ) = fe_f % m % con ( i , 3 ) - 1 connec ( k + 5 ) = fe_f % m % con ( i , 4 ) - 1 k = k + 5 enddo ! ouverture du fichier E_IO = VTK_INI ( output_format = 'binary' , & filename = nom_fic , & title = 'Resultats fe_f fluide' , & mesh_topology = 'UNSTRUCTURED_GRID' ) ! ecriture des coordonnees E_IO = VTK_GEO ( NN = fe_f % m % n , & X = fe_f % m % x , & Y = fe_f % m % y , & Z = Z ) ! definition des cellules E_IO = VTK_CON ( NC = fe_f % m % ne , & connect = connec , & cell_type = tipo ) ! choix du type de variable (elementaire) E_IO = VTK_DAT ( NC_NN = fe_f % m % ne , & var_location = 'cell' ) ! passage des variables cellules do i = 1 , fe_f % n_vc E_IO = VTK_VAR ( NC_NN = fe_f % m % ne , & varname = fe_f % vc_name ( i ), & var = fe_f % vc (:, i )) enddo ! choix du type de variable (nodale) E_IO = VTK_DAT ( NC_NN = fe_f % m % n , & var_location = 'node' ) ! passage des variables nodales do i = 1 , fe_f % n_vn E_IO = VTK_VAR ( NC_NN = fe_f % m % n , & varname = fe_f % vn_name ( i ), & var = fe_f % vn (:, i )) enddo ! fermeture du fichier vtk E_IO = VTK_END () ! liberation des tableaux deallocate ( z , connec , tipo ) return endsubroutine save_fe_f_vtk","loc":"proc/save_fe_f_vtk.html"},{"tags":"","title":"save_ms_fe_f_vtk – MUSST","text":"public subroutine save_ms_fe_f_vtk(ms_fe_f, nom_fic) Note Subroutine to save the top scale data following VTK model Arguments Type Intent Optional Attributes Name type(MS_FE_FILM), intent(in) :: ms_fe_f MS_FE_FILM element to store character(len=*), intent(in) :: nom_fic filename Contents Source Code save_ms_fe_f_vtk Source Code subroutine save_ms_fe_f_vtk ( ms_fe_f , nom_fic ) implicit none type ( MS_FE_FILM ), intent ( in ) :: ms_fe_f !! [[MS_FE_FILM]] *element to store* character ( len =* ), intent ( in ) :: nom_fic !! *filename* integer ( kind = I4 ) :: e , ne , i , l character ( len = 256 ) :: nom_fic_bs , nom_fic_ts character ( len = 128 ) :: suff nom_fic_bs = repeat ( \" \" , len ( nom_fic_bs )) nom_fic_ts = repeat ( \" \" , len ( nom_fic_bs )) suff = repeat ( \" \" , len ( suff ) ) i = index ( trim ( nom_fic ), \"/\" , back = . true .) l = len_trim ( nom_fic ) if ( s_vtk > NO_VTK ) then nom_fic_ts = nom_fic ( 1 : i ) // \"ts_\" // nom_fic ( i + 1 : l ) call save_fe_f_vtk ( ms_fe_f % ts_fe_f , trim ( nom_fic_ts )) write ( * , * ) trim ( nom_fic_ts ) endif if ( s_vtk == BS_VTK ) then ne = ms_fe_f % ts_fe_f % m % ne do e = 1 , ne write ( suff , '(i5.5, 2a)' ) e , \"_\" , nom_fic ( i + 1 : l ) nom_fic_bs = nom_fic ( 1 : i ) // trim ( suff ) call save_fe_f_vtk ( ms_fe_f % bs_fe_f ( e ), trim ( nom_fic_bs )) enddo endif return endsubroutine save_ms_fe_f_vtk","loc":"proc/save_ms_fe_f_vtk.html"},{"tags":"","title":"save_profile_x_fe – MUSST","text":"public subroutine save_profile_x_fe(fe_f, file_name, lx, zy) Note Subroutine to save the pressures along a line following the flow, at distance zy from a border. Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(in) :: fe_f FE_FILM element character(len=*), intent(in) :: file_name filename real(kind=R8), intent(in) :: lx surface length real(kind=R8), intent(in) :: zy distance from a border Calls proc~~save_profile_x_fe~~CallsGraph proc~save_profile_x_fe save_profile_x_fe proc~get_unit get_unit proc~save_profile_x_fe->proc~get_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code save_profile_x_fe Source Code subroutine save_profile_x_fe ( fe_f , file_name , lx , zy ) implicit none type ( FE_FILM ), intent ( in ) :: fe_f !! [[FE_FILM]] *element* character ( len =* ), intent ( in ) :: file_name !! *filename* real ( kind = R8 ), intent ( in ) :: lx !! *surface length* real ( kind = R8 ), intent ( in ) :: zy !! *distance from a border* real ( kind = R8 ) :: dr integer ( kind = I4 ) :: i , k dr = lx / fe_f % m % n dr = dr / 10 call get_unit ( k ) open ( k , file = file_name , status = 'unknown' ) do i = 1 , fe_f % m % n if ((( fe_f % m % y ( i ) - zy ) ** 2 ) < ( dr ** 2 )) then write ( k , * ) fe_f % m % x ( i ), fe_f % vn ( i , H_N ), fe_f % vn ( i , P_N ) endif enddo close ( k ) return endsubroutine save_profile_x_fe","loc":"proc/save_profile_x_fe.html"},{"tags":"","title":"save_profile_x_ms – MUSST","text":"public subroutine save_profile_x_ms(ms_fe_f, file_name, lx, zy) Note Subroutine to save the pressures along a line following the flow, at distance zy from a border. Arguments Type Intent Optional Attributes Name type(MS_FE_FILM), intent(in) :: ms_fe_f MS_FE_FILM element character(len=*), intent(in) :: file_name filename real(kind=R8), intent(in) :: lx surface length real(kind=R8), intent(in) :: zy distance from a border Calls proc~~save_profile_x_ms~~CallsGraph proc~save_profile_x_ms save_profile_x_ms proc~get_unit get_unit proc~save_profile_x_ms->proc~get_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code save_profile_x_ms Source Code subroutine save_profile_x_ms ( ms_fe_f , file_name , lx , zy ) implicit none type ( MS_FE_FILM ), intent ( in ) :: ms_fe_f !! [[MS_FE_FILM]] *element* character ( len =* ), intent ( in ) :: file_name !! *filename* real ( kind = R8 ), intent ( in ) :: lx !! *surface length* real ( kind = R8 ), intent ( in ) :: zy !! *distance from a border* real ( kind = R8 ) :: dr integer ( kind = I4 ) :: i , e , k dr = lx / ms_fe_f % bs_fe_f ( 1 )% m % n dr = dr / 10 call get_unit ( k ) open ( k , file = file_name , status = 'unknown' ) do e = 1 , ms_fe_f % ts_fe_f % m % ne do i = 1 , ms_fe_f % bs_fe_f ( e )% m % n if ((( ms_fe_f % bs_fe_f ( e )% m % y ( i ) - zy ) ** 2 ) < ( dr ** 2 )) then write ( k , * ) ms_fe_f % bs_fe_f ( e )% m % x ( i ), ms_fe_f % bs_fe_f ( e )% vn ( i , H_N ), & ms_fe_f % bs_fe_f ( e )% vn ( i , P_N ) endif enddo enddo close ( k ) return endsubroutine save_profile_x_ms","loc":"proc/save_profile_x_ms.html"},{"tags":"","title":"save_profile_x_comp_slider – MUSST","text":"public subroutine save_profile_x_comp_slider(fe_f, file_name, lx, zy) Note Subroutine to save the pressures along a line following the flow, at distance zy from a border. The theoretical values are also stored. Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(in) :: fe_f FE_FILM element character(len=*), intent(in) :: file_name filename real(kind=R8), intent(in) :: lx slider length real(kind=R8), intent(in) :: zy distance from a border Calls proc~~save_profile_x_comp_slider~~CallsGraph proc~save_profile_x_comp_slider save_profile_x_comp_slider proc~get_unit get_unit proc~save_profile_x_comp_slider->proc~get_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code save_profile_x_comp_slider Source Code subroutine save_profile_x_comp_slider ( fe_f , file_name , lx , zy ) implicit none type ( FE_FILM ), intent ( in ) :: fe_f !! [[FE_FILM]] *element* character ( len =* ), intent ( in ) :: file_name !! *filename* real ( kind = R8 ), intent ( in ) :: lx !! *slider length* real ( kind = R8 ), intent ( in ) :: zy !! *distance from a border* real ( kind = R8 ) :: pref , K , dr , hr , hb , p0 integer ( kind = I4 ) :: i , kk dr = lx / fe_f % m % n dr = dr / 10 K = maxval ( fe_f % vn (:, H_N )) / minval ( fe_f % vn (:, H_N )) hr = minval ( fe_f % vn (:, H_N )) pref = 6 * fe_f % data_f % fl % mu_0 * fe_f % data_f % V_x * lx / ( hr ** 2 ) p0 = minval ( fe_f % vn (:, P_N )) call get_unit ( kk ) open ( kk , file = file_name , status = 'unknown' ) do i = 1 , fe_f % m % n if ((( fe_f % m % y ( i ) - zy ) ** 2 ) < ( dr ** 2 )) then hb = fe_f % vn ( i , H_N ) / hr write ( kk , * ) fe_f % m % x ( i ) / lx , hb , ( fe_f % vn ( i , P_N ) - p0 ) / pref , & 1.0 / ( K - 1 ) * ( 1.0 / hb - K / ( K + 1 ) * ( hb ** ( - 2 ) - K ** ( - 2 )) - 1.0 / K ) endif enddo close ( kk ) return endsubroutine save_profile_x_comp_slider","loc":"proc/save_profile_x_comp_slider.html"},{"tags":"","title":"save_profile_x_comp_air_pocket – MUSST","text":"public subroutine save_profile_x_comp_air_pocket(fe_f, file_name, lx, zy, bc) Note Subroutine to save the pressures along a line following the flow, at distance zy from a border Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(in) :: fe_f FE_FILM element character(len=*), intent(in) :: file_name filename real(kind=R8), intent(in) :: lx pocket length real(kind=R8), intent(in) :: zy distance from a border real(kind=R8), intent(in), dimension(4) :: bc pressure boundaries Calls proc~~save_profile_x_comp_air_pocket~~CallsGraph proc~save_profile_x_comp_air_pocket save_profile_x_comp_air_pocket proc~get_unit get_unit proc~save_profile_x_comp_air_pocket->proc~get_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code save_profile_x_comp_air_pocket Source Code subroutine save_profile_x_comp_air_pocket ( fe_f , file_name , lx , zy , bc ) implicit none type ( FE_FILM ), intent ( in ) :: fe_f !! [[FE_FILM]] *element* character ( len =* ), intent ( in ) :: file_name !! *filename* real ( kind = R8 ), intent ( in ) :: lx !! *pocket length* real ( kind = R8 ), intent ( in ) :: zy !! *distance from a border* real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: bc !! *pressure boundaries* real ( kind = R8 ) :: dr , hr , hb , p0 integer ( kind = I4 ) :: i , k dr = lx / fe_f % m % n dr = dr / 10 hr = minval ( fe_f % vn (:, H_N )) p0 = bc ( 1 ) call get_unit ( k ) open ( k , file = file_name , status = 'unknown' ) do i = 1 , fe_f % m % n if ((( fe_f % m % y ( i ) - zy ) ** 2 ) < ( dr ** 2 )) then hb = ( fe_f % vn ( i , H_N ) + fe_f % vc ( i , HG_C )) / hr write ( k , * ) fe_f % m % x ( i ) / lx , hb , fe_f % vn ( i , P_N ) / p0 , hb endif enddo close ( k ) return endsubroutine save_profile_x_comp_air_pocket","loc":"proc/save_profile_x_comp_air_pocket.html"},{"tags":"","title":"save_profile_y_comp_air_pocket – MUSST","text":"public subroutine save_profile_y_comp_air_pocket(fe_f, file_name, ly, zx, bc) Note Subroutine to save the pressures along a line perpendicular to the flow, at distance zx Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(in) :: fe_f FE_FILM element character(len=*), intent(in) :: file_name filename real(kind=R8), intent(in) :: ly pocket width real(kind=R8), intent(in) :: zx distance from the pocket entry real(kind=R8), intent(in), dimension(4) :: bc pressure boundaries Calls proc~~save_profile_y_comp_air_pocket~~CallsGraph proc~save_profile_y_comp_air_pocket save_profile_y_comp_air_pocket proc~get_unit get_unit proc~save_profile_y_comp_air_pocket->proc~get_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code save_profile_y_comp_air_pocket Source Code subroutine save_profile_y_comp_air_pocket ( fe_f , file_name , ly , zx , bc ) implicit none type ( FE_FILM ), intent ( in ) :: fe_f !! [[FE_FILM]] *element* character ( len =* ), intent ( in ) :: file_name !! *filename* real ( kind = R8 ), intent ( in ) :: ly !! *pocket width* real ( kind = R8 ), intent ( in ) :: zx !! *distance from the pocket entry* real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: bc !! *pressure boundaries* real ( kind = R8 ) :: dr , hr , hb , p0 integer ( kind = I4 ) :: i , ii , jj , k logical ( kind = I4 ), allocatable , dimension (:) :: done dr = ly / fe_f % m % n dr = dr / 10 hr = minval ( fe_f % vn (:, H_N )) p0 = bc ( 1 ) allocate ( done ( 1 : fe_f % m % n )) ; done = . false . call get_unit ( k ) open ( k , file = file_name , status = 'unknown' ) do ii = 1 , fe_f % m % ne do jj = 1 , fe_f % m % el_t ( ii ) i = fe_f % m % con ( ii , jj ) if ( done ( i )) cycle done ( i ) = . true . if ((( fe_f % m % x ( i ) - zx ) ** 2 ) < ( dr ** 2 )) then hb = ( fe_f % vn ( i , H_N ) + fe_f % vc ( ii , HG_C )) / hr write ( k , * ) fe_f % m % y ( i ) / ly , hb , fe_f % vn ( i , P_N ) / p0 , hb endif enddo enddo close ( k ) deallocate ( done ) return endsubroutine save_profile_y_comp_air_pocket","loc":"proc/save_profile_y_comp_air_pocket.html"},{"tags":"","title":"str_R16P – MUSST","text":"private elemental function str_R16P(no_sign, n) result(str) The function str_R16P converts real to string. This function achieves casting of real to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign real(kind=R16P), intent(in) :: n Return Value character(len=DR16P) Called by proc~~str_r16p~~CalledByGraph proc~str_r16p str_R16P interface~str str interface~str->proc~str_r16p proc~vtk_var_xml_list_i8 VTK_VAR_XML_LIST_I8 proc~vtk_var_xml_list_i8->interface~str proc~vtk_var_xml_list_r8 VTK_VAR_XML_LIST_R8 proc~vtk_var_xml_list_r8->interface~str proc~vtk_var_xml_vect_r4 VTK_VAR_XML_VECT_R4 proc~vtk_var_xml_vect_r4->interface~str proc~vtk_var_xml_list_i1 VTK_VAR_XML_LIST_I1 proc~vtk_var_xml_list_i1->interface~str proc~vtk_var_xml_vect_i4 VTK_VAR_XML_VECT_I4 proc~vtk_var_xml_vect_i4->interface~str proc~vtk_var_xml_scal_i1 VTK_VAR_XML_SCAL_I1 proc~vtk_var_xml_scal_i1->interface~str proc~vtk_geo_xml_unst_r4 VTK_GEO_XML_UNST_R4 proc~vtk_geo_xml_unst_r4->interface~str proc~vtk_var_xml_scal_r4 VTK_VAR_XML_SCAL_R4 proc~vtk_var_xml_scal_r4->interface~str proc~vtk_geo_xml_strg_r4 VTK_GEO_XML_STRG_R4 proc~vtk_geo_xml_strg_r4->interface~str proc~vtk_var_xml_scal_i4 VTK_VAR_XML_SCAL_I4 proc~vtk_var_xml_scal_i4->interface~str proc~vtk_geo_xml_rect_r4 VTK_GEO_XML_RECT_R4 proc~vtk_geo_xml_rect_r4->interface~str proc~vtk_var_xml_scal_r8 VTK_VAR_XML_SCAL_R8 proc~vtk_var_xml_scal_r8->interface~str proc~vtk_var_xml_vect_i8 VTK_VAR_XML_VECT_I8 proc~vtk_var_xml_vect_i8->interface~str proc~vtk_var_xml_scal_i8 VTK_VAR_XML_SCAL_I8 proc~vtk_var_xml_scal_i8->interface~str proc~vtk_geo_xml_strg_r8 VTK_GEO_XML_STRG_R8 proc~vtk_geo_xml_strg_r8->interface~str proc~vtk_var_xml_list_i4 VTK_VAR_XML_LIST_I4 proc~vtk_var_xml_list_i4->interface~str proc~vtk_geo_xml_unst_r8 VTK_GEO_XML_UNST_R8 proc~vtk_geo_xml_unst_r8->interface~str proc~vtk_con_xml VTK_CON_XML proc~vtk_con_xml->interface~str proc~vtk_var_xml_vect_r8 VTK_VAR_XML_VECT_R8 proc~vtk_var_xml_vect_r8->interface~str proc~vtk_var_xml_vect_i1 VTK_VAR_XML_VECT_I1 proc~vtk_var_xml_vect_i1->interface~str proc~vtk_var_xml_list_r4 VTK_VAR_XML_LIST_R4 proc~vtk_var_xml_list_r4->interface~str proc~vtk_var_xml_scal_i2 VTK_VAR_XML_SCAL_I2 proc~vtk_var_xml_scal_i2->interface~str proc~vtk_var_xml_list_i2 VTK_VAR_XML_LIST_I2 proc~vtk_var_xml_list_i2->interface~str proc~vtk_geo_xml_rect_r8 VTK_GEO_XML_RECT_R8 proc~vtk_geo_xml_rect_r8->interface~str proc~vtk_var_xml_vect_i2 VTK_VAR_XML_VECT_I2 proc~vtk_var_xml_vect_i2->interface~str interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_list_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_r4 interface~vtk_var_xml->proc~vtk_var_xml_list_i1 interface~vtk_var_xml->proc~vtk_var_xml_vect_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i1 interface~vtk_var_xml->proc~vtk_var_xml_scal_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i8 interface~vtk_var_xml->proc~vtk_var_xml_scal_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_i4 interface~vtk_var_xml->proc~vtk_var_xml_vect_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i1 interface~vtk_var_xml->proc~vtk_var_xml_list_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i2 interface~vtk_var_xml->proc~vtk_var_xml_list_i2 interface~vtk_var_xml->proc~vtk_var_xml_vect_i2 interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code str_R16P Source Code elemental function str_R16P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function str\\_R16P converts real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign ! Flag for leaving out the sign. real ( R16P ), intent ( IN ) :: n ! Real to be converted. character ( DR16P ) :: str ! Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P","loc":"proc/str_r16p.html"},{"tags":"","title":"str_R8P – MUSST","text":"private elemental function str_R8P(no_sign, n) result(str) The function str_R8P converts real to string. This function achieves casting of real to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign real(kind=R8P), intent(in) :: n Return Value character(len=DR8P) Called by proc~~str_r8p~~CalledByGraph proc~str_r8p str_R8P interface~str str interface~str->proc~str_r8p proc~vtk_var_xml_list_i8 VTK_VAR_XML_LIST_I8 proc~vtk_var_xml_list_i8->interface~str proc~vtk_var_xml_list_r8 VTK_VAR_XML_LIST_R8 proc~vtk_var_xml_list_r8->interface~str proc~vtk_var_xml_vect_r4 VTK_VAR_XML_VECT_R4 proc~vtk_var_xml_vect_r4->interface~str proc~vtk_var_xml_list_i1 VTK_VAR_XML_LIST_I1 proc~vtk_var_xml_list_i1->interface~str proc~vtk_var_xml_vect_i4 VTK_VAR_XML_VECT_I4 proc~vtk_var_xml_vect_i4->interface~str proc~vtk_var_xml_scal_i1 VTK_VAR_XML_SCAL_I1 proc~vtk_var_xml_scal_i1->interface~str proc~vtk_geo_xml_unst_r4 VTK_GEO_XML_UNST_R4 proc~vtk_geo_xml_unst_r4->interface~str proc~vtk_var_xml_scal_r4 VTK_VAR_XML_SCAL_R4 proc~vtk_var_xml_scal_r4->interface~str proc~vtk_geo_xml_strg_r4 VTK_GEO_XML_STRG_R4 proc~vtk_geo_xml_strg_r4->interface~str proc~vtk_var_xml_scal_i4 VTK_VAR_XML_SCAL_I4 proc~vtk_var_xml_scal_i4->interface~str proc~vtk_geo_xml_rect_r4 VTK_GEO_XML_RECT_R4 proc~vtk_geo_xml_rect_r4->interface~str proc~vtk_var_xml_scal_r8 VTK_VAR_XML_SCAL_R8 proc~vtk_var_xml_scal_r8->interface~str proc~vtk_var_xml_vect_i8 VTK_VAR_XML_VECT_I8 proc~vtk_var_xml_vect_i8->interface~str proc~vtk_var_xml_scal_i8 VTK_VAR_XML_SCAL_I8 proc~vtk_var_xml_scal_i8->interface~str proc~vtk_geo_xml_strg_r8 VTK_GEO_XML_STRG_R8 proc~vtk_geo_xml_strg_r8->interface~str proc~vtk_var_xml_list_i4 VTK_VAR_XML_LIST_I4 proc~vtk_var_xml_list_i4->interface~str proc~vtk_geo_xml_unst_r8 VTK_GEO_XML_UNST_R8 proc~vtk_geo_xml_unst_r8->interface~str proc~vtk_con_xml VTK_CON_XML proc~vtk_con_xml->interface~str proc~vtk_var_xml_vect_r8 VTK_VAR_XML_VECT_R8 proc~vtk_var_xml_vect_r8->interface~str proc~vtk_var_xml_vect_i1 VTK_VAR_XML_VECT_I1 proc~vtk_var_xml_vect_i1->interface~str proc~vtk_var_xml_list_r4 VTK_VAR_XML_LIST_R4 proc~vtk_var_xml_list_r4->interface~str proc~vtk_var_xml_scal_i2 VTK_VAR_XML_SCAL_I2 proc~vtk_var_xml_scal_i2->interface~str proc~vtk_var_xml_list_i2 VTK_VAR_XML_LIST_I2 proc~vtk_var_xml_list_i2->interface~str proc~vtk_geo_xml_rect_r8 VTK_GEO_XML_RECT_R8 proc~vtk_geo_xml_rect_r8->interface~str proc~vtk_var_xml_vect_i2 VTK_VAR_XML_VECT_I2 proc~vtk_var_xml_vect_i2->interface~str interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_list_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_r4 interface~vtk_var_xml->proc~vtk_var_xml_list_i1 interface~vtk_var_xml->proc~vtk_var_xml_vect_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i1 interface~vtk_var_xml->proc~vtk_var_xml_scal_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i8 interface~vtk_var_xml->proc~vtk_var_xml_scal_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_i4 interface~vtk_var_xml->proc~vtk_var_xml_vect_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i1 interface~vtk_var_xml->proc~vtk_var_xml_list_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i2 interface~vtk_var_xml->proc~vtk_var_xml_list_i2 interface~vtk_var_xml->proc~vtk_var_xml_vect_i2 interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code str_R8P Source Code elemental function str_R8P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function str\\_R8P converts real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign ! Flag for leaving out the sign. real ( R8P ), intent ( IN ) :: n ! Real to be converted. character ( DR8P ) :: str ! Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P","loc":"proc/str_r8p.html"},{"tags":"","title":"str_R4P – MUSST","text":"private elemental function str_R4P(no_sign, n) result(str) The function str_R4P converts real to string. This function achieves casting of real to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign real(kind=R4P), intent(in) :: n Return Value character(len=DR4P) Called by proc~~str_r4p~~CalledByGraph proc~str_r4p str_R4P interface~str str interface~str->proc~str_r4p proc~vtk_var_xml_list_i8 VTK_VAR_XML_LIST_I8 proc~vtk_var_xml_list_i8->interface~str proc~vtk_var_xml_list_r8 VTK_VAR_XML_LIST_R8 proc~vtk_var_xml_list_r8->interface~str proc~vtk_var_xml_vect_r4 VTK_VAR_XML_VECT_R4 proc~vtk_var_xml_vect_r4->interface~str proc~vtk_var_xml_list_i1 VTK_VAR_XML_LIST_I1 proc~vtk_var_xml_list_i1->interface~str proc~vtk_var_xml_vect_i4 VTK_VAR_XML_VECT_I4 proc~vtk_var_xml_vect_i4->interface~str proc~vtk_var_xml_scal_i1 VTK_VAR_XML_SCAL_I1 proc~vtk_var_xml_scal_i1->interface~str proc~vtk_geo_xml_unst_r4 VTK_GEO_XML_UNST_R4 proc~vtk_geo_xml_unst_r4->interface~str proc~vtk_var_xml_scal_r4 VTK_VAR_XML_SCAL_R4 proc~vtk_var_xml_scal_r4->interface~str proc~vtk_geo_xml_strg_r4 VTK_GEO_XML_STRG_R4 proc~vtk_geo_xml_strg_r4->interface~str proc~vtk_var_xml_scal_i4 VTK_VAR_XML_SCAL_I4 proc~vtk_var_xml_scal_i4->interface~str proc~vtk_geo_xml_rect_r4 VTK_GEO_XML_RECT_R4 proc~vtk_geo_xml_rect_r4->interface~str proc~vtk_var_xml_scal_r8 VTK_VAR_XML_SCAL_R8 proc~vtk_var_xml_scal_r8->interface~str proc~vtk_var_xml_vect_i8 VTK_VAR_XML_VECT_I8 proc~vtk_var_xml_vect_i8->interface~str proc~vtk_var_xml_scal_i8 VTK_VAR_XML_SCAL_I8 proc~vtk_var_xml_scal_i8->interface~str proc~vtk_geo_xml_strg_r8 VTK_GEO_XML_STRG_R8 proc~vtk_geo_xml_strg_r8->interface~str proc~vtk_var_xml_list_i4 VTK_VAR_XML_LIST_I4 proc~vtk_var_xml_list_i4->interface~str proc~vtk_geo_xml_unst_r8 VTK_GEO_XML_UNST_R8 proc~vtk_geo_xml_unst_r8->interface~str proc~vtk_con_xml VTK_CON_XML proc~vtk_con_xml->interface~str proc~vtk_var_xml_vect_r8 VTK_VAR_XML_VECT_R8 proc~vtk_var_xml_vect_r8->interface~str proc~vtk_var_xml_vect_i1 VTK_VAR_XML_VECT_I1 proc~vtk_var_xml_vect_i1->interface~str proc~vtk_var_xml_list_r4 VTK_VAR_XML_LIST_R4 proc~vtk_var_xml_list_r4->interface~str proc~vtk_var_xml_scal_i2 VTK_VAR_XML_SCAL_I2 proc~vtk_var_xml_scal_i2->interface~str proc~vtk_var_xml_list_i2 VTK_VAR_XML_LIST_I2 proc~vtk_var_xml_list_i2->interface~str proc~vtk_geo_xml_rect_r8 VTK_GEO_XML_RECT_R8 proc~vtk_geo_xml_rect_r8->interface~str proc~vtk_var_xml_vect_i2 VTK_VAR_XML_VECT_I2 proc~vtk_var_xml_vect_i2->interface~str interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_list_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_r4 interface~vtk_var_xml->proc~vtk_var_xml_list_i1 interface~vtk_var_xml->proc~vtk_var_xml_vect_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i1 interface~vtk_var_xml->proc~vtk_var_xml_scal_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i8 interface~vtk_var_xml->proc~vtk_var_xml_scal_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_i4 interface~vtk_var_xml->proc~vtk_var_xml_vect_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i1 interface~vtk_var_xml->proc~vtk_var_xml_list_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i2 interface~vtk_var_xml->proc~vtk_var_xml_list_i2 interface~vtk_var_xml->proc~vtk_var_xml_vect_i2 interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code str_R4P Source Code elemental function str_R4P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function str\\_R4P converts real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign ! Flag for leaving out the sign. real ( R4P ), intent ( IN ) :: n ! Real to be converted. character ( DR4P ) :: str ! Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P","loc":"proc/str_r4p.html"},{"tags":"","title":"str_I8P – MUSST","text":"private elemental function str_I8P(no_sign, n) result(str) The function str_I8P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I8P), intent(in) :: n Return Value character(len=DI8P) Called by proc~~str_i8p~~CalledByGraph proc~str_i8p str_I8P interface~str str interface~str->proc~str_i8p proc~vtk_var_xml_list_i8 VTK_VAR_XML_LIST_I8 proc~vtk_var_xml_list_i8->interface~str proc~vtk_var_xml_list_r8 VTK_VAR_XML_LIST_R8 proc~vtk_var_xml_list_r8->interface~str proc~vtk_var_xml_vect_r4 VTK_VAR_XML_VECT_R4 proc~vtk_var_xml_vect_r4->interface~str proc~vtk_var_xml_list_i1 VTK_VAR_XML_LIST_I1 proc~vtk_var_xml_list_i1->interface~str proc~vtk_var_xml_vect_i4 VTK_VAR_XML_VECT_I4 proc~vtk_var_xml_vect_i4->interface~str proc~vtk_var_xml_scal_i1 VTK_VAR_XML_SCAL_I1 proc~vtk_var_xml_scal_i1->interface~str proc~vtk_geo_xml_unst_r4 VTK_GEO_XML_UNST_R4 proc~vtk_geo_xml_unst_r4->interface~str proc~vtk_var_xml_scal_r4 VTK_VAR_XML_SCAL_R4 proc~vtk_var_xml_scal_r4->interface~str proc~vtk_geo_xml_strg_r4 VTK_GEO_XML_STRG_R4 proc~vtk_geo_xml_strg_r4->interface~str proc~vtk_var_xml_scal_i4 VTK_VAR_XML_SCAL_I4 proc~vtk_var_xml_scal_i4->interface~str proc~vtk_geo_xml_rect_r4 VTK_GEO_XML_RECT_R4 proc~vtk_geo_xml_rect_r4->interface~str proc~vtk_var_xml_scal_r8 VTK_VAR_XML_SCAL_R8 proc~vtk_var_xml_scal_r8->interface~str proc~vtk_var_xml_vect_i8 VTK_VAR_XML_VECT_I8 proc~vtk_var_xml_vect_i8->interface~str proc~vtk_var_xml_scal_i8 VTK_VAR_XML_SCAL_I8 proc~vtk_var_xml_scal_i8->interface~str proc~vtk_geo_xml_strg_r8 VTK_GEO_XML_STRG_R8 proc~vtk_geo_xml_strg_r8->interface~str proc~vtk_var_xml_list_i4 VTK_VAR_XML_LIST_I4 proc~vtk_var_xml_list_i4->interface~str proc~vtk_geo_xml_unst_r8 VTK_GEO_XML_UNST_R8 proc~vtk_geo_xml_unst_r8->interface~str proc~vtk_con_xml VTK_CON_XML proc~vtk_con_xml->interface~str proc~vtk_var_xml_vect_r8 VTK_VAR_XML_VECT_R8 proc~vtk_var_xml_vect_r8->interface~str proc~vtk_var_xml_vect_i1 VTK_VAR_XML_VECT_I1 proc~vtk_var_xml_vect_i1->interface~str proc~vtk_var_xml_list_r4 VTK_VAR_XML_LIST_R4 proc~vtk_var_xml_list_r4->interface~str proc~vtk_var_xml_scal_i2 VTK_VAR_XML_SCAL_I2 proc~vtk_var_xml_scal_i2->interface~str proc~vtk_var_xml_list_i2 VTK_VAR_XML_LIST_I2 proc~vtk_var_xml_list_i2->interface~str proc~vtk_geo_xml_rect_r8 VTK_GEO_XML_RECT_R8 proc~vtk_geo_xml_rect_r8->interface~str proc~vtk_var_xml_vect_i2 VTK_VAR_XML_VECT_I2 proc~vtk_var_xml_vect_i2->interface~str interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_list_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_r4 interface~vtk_var_xml->proc~vtk_var_xml_list_i1 interface~vtk_var_xml->proc~vtk_var_xml_vect_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i1 interface~vtk_var_xml->proc~vtk_var_xml_scal_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i8 interface~vtk_var_xml->proc~vtk_var_xml_scal_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_i4 interface~vtk_var_xml->proc~vtk_var_xml_vect_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i1 interface~vtk_var_xml->proc~vtk_var_xml_list_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i2 interface~vtk_var_xml->proc~vtk_var_xml_list_i2 interface~vtk_var_xml->proc~vtk_var_xml_vect_i2 interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code str_I8P Source Code elemental function str_I8P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function str\\_I8P converts integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign ! Flag for leaving out the sign. integer ( I8P ), intent ( IN ) :: n ! Integer to be converted. character ( DI8P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P","loc":"proc/str_i8p.html"},{"tags":"","title":"str_I4P – MUSST","text":"private elemental function str_I4P(no_sign, n) result(str) The function str_I4P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I4P), intent(in) :: n Return Value character(len=DI4P) Called by proc~~str_i4p~~CalledByGraph proc~str_i4p str_I4P interface~str str interface~str->proc~str_i4p proc~vtk_var_xml_list_i8 VTK_VAR_XML_LIST_I8 proc~vtk_var_xml_list_i8->interface~str proc~vtk_var_xml_list_r8 VTK_VAR_XML_LIST_R8 proc~vtk_var_xml_list_r8->interface~str proc~vtk_var_xml_vect_r4 VTK_VAR_XML_VECT_R4 proc~vtk_var_xml_vect_r4->interface~str proc~vtk_var_xml_list_i1 VTK_VAR_XML_LIST_I1 proc~vtk_var_xml_list_i1->interface~str proc~vtk_var_xml_vect_i4 VTK_VAR_XML_VECT_I4 proc~vtk_var_xml_vect_i4->interface~str proc~vtk_var_xml_scal_i1 VTK_VAR_XML_SCAL_I1 proc~vtk_var_xml_scal_i1->interface~str proc~vtk_geo_xml_unst_r4 VTK_GEO_XML_UNST_R4 proc~vtk_geo_xml_unst_r4->interface~str proc~vtk_var_xml_scal_r4 VTK_VAR_XML_SCAL_R4 proc~vtk_var_xml_scal_r4->interface~str proc~vtk_geo_xml_strg_r4 VTK_GEO_XML_STRG_R4 proc~vtk_geo_xml_strg_r4->interface~str proc~vtk_var_xml_scal_i4 VTK_VAR_XML_SCAL_I4 proc~vtk_var_xml_scal_i4->interface~str proc~vtk_geo_xml_rect_r4 VTK_GEO_XML_RECT_R4 proc~vtk_geo_xml_rect_r4->interface~str proc~vtk_var_xml_scal_r8 VTK_VAR_XML_SCAL_R8 proc~vtk_var_xml_scal_r8->interface~str proc~vtk_var_xml_vect_i8 VTK_VAR_XML_VECT_I8 proc~vtk_var_xml_vect_i8->interface~str proc~vtk_var_xml_scal_i8 VTK_VAR_XML_SCAL_I8 proc~vtk_var_xml_scal_i8->interface~str proc~vtk_geo_xml_strg_r8 VTK_GEO_XML_STRG_R8 proc~vtk_geo_xml_strg_r8->interface~str proc~vtk_var_xml_list_i4 VTK_VAR_XML_LIST_I4 proc~vtk_var_xml_list_i4->interface~str proc~vtk_geo_xml_unst_r8 VTK_GEO_XML_UNST_R8 proc~vtk_geo_xml_unst_r8->interface~str proc~vtk_con_xml VTK_CON_XML proc~vtk_con_xml->interface~str proc~vtk_var_xml_vect_r8 VTK_VAR_XML_VECT_R8 proc~vtk_var_xml_vect_r8->interface~str proc~vtk_var_xml_vect_i1 VTK_VAR_XML_VECT_I1 proc~vtk_var_xml_vect_i1->interface~str proc~vtk_var_xml_list_r4 VTK_VAR_XML_LIST_R4 proc~vtk_var_xml_list_r4->interface~str proc~vtk_var_xml_scal_i2 VTK_VAR_XML_SCAL_I2 proc~vtk_var_xml_scal_i2->interface~str proc~vtk_var_xml_list_i2 VTK_VAR_XML_LIST_I2 proc~vtk_var_xml_list_i2->interface~str proc~vtk_geo_xml_rect_r8 VTK_GEO_XML_RECT_R8 proc~vtk_geo_xml_rect_r8->interface~str proc~vtk_var_xml_vect_i2 VTK_VAR_XML_VECT_I2 proc~vtk_var_xml_vect_i2->interface~str interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_list_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_r4 interface~vtk_var_xml->proc~vtk_var_xml_list_i1 interface~vtk_var_xml->proc~vtk_var_xml_vect_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i1 interface~vtk_var_xml->proc~vtk_var_xml_scal_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i8 interface~vtk_var_xml->proc~vtk_var_xml_scal_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_i4 interface~vtk_var_xml->proc~vtk_var_xml_vect_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i1 interface~vtk_var_xml->proc~vtk_var_xml_list_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i2 interface~vtk_var_xml->proc~vtk_var_xml_list_i2 interface~vtk_var_xml->proc~vtk_var_xml_vect_i2 interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code str_I4P Source Code elemental function str_I4P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function str\\_I4P converts integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign ! Flag for leaving out the sign. integer ( I4P ), intent ( IN ) :: n ! Integer to be converted. character ( DI4P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P","loc":"proc/str_i4p.html"},{"tags":"","title":"str_I2P – MUSST","text":"private elemental function str_I2P(no_sign, n) result(str) The function str_I2P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I2P), intent(in) :: n Return Value character(len=DI2P) Called by proc~~str_i2p~~CalledByGraph proc~str_i2p str_I2P interface~str str interface~str->proc~str_i2p proc~vtk_var_xml_list_i8 VTK_VAR_XML_LIST_I8 proc~vtk_var_xml_list_i8->interface~str proc~vtk_var_xml_list_r8 VTK_VAR_XML_LIST_R8 proc~vtk_var_xml_list_r8->interface~str proc~vtk_var_xml_vect_r4 VTK_VAR_XML_VECT_R4 proc~vtk_var_xml_vect_r4->interface~str proc~vtk_var_xml_list_i1 VTK_VAR_XML_LIST_I1 proc~vtk_var_xml_list_i1->interface~str proc~vtk_var_xml_vect_i4 VTK_VAR_XML_VECT_I4 proc~vtk_var_xml_vect_i4->interface~str proc~vtk_var_xml_scal_i1 VTK_VAR_XML_SCAL_I1 proc~vtk_var_xml_scal_i1->interface~str proc~vtk_geo_xml_unst_r4 VTK_GEO_XML_UNST_R4 proc~vtk_geo_xml_unst_r4->interface~str proc~vtk_var_xml_scal_r4 VTK_VAR_XML_SCAL_R4 proc~vtk_var_xml_scal_r4->interface~str proc~vtk_geo_xml_strg_r4 VTK_GEO_XML_STRG_R4 proc~vtk_geo_xml_strg_r4->interface~str proc~vtk_var_xml_scal_i4 VTK_VAR_XML_SCAL_I4 proc~vtk_var_xml_scal_i4->interface~str proc~vtk_geo_xml_rect_r4 VTK_GEO_XML_RECT_R4 proc~vtk_geo_xml_rect_r4->interface~str proc~vtk_var_xml_scal_r8 VTK_VAR_XML_SCAL_R8 proc~vtk_var_xml_scal_r8->interface~str proc~vtk_var_xml_vect_i8 VTK_VAR_XML_VECT_I8 proc~vtk_var_xml_vect_i8->interface~str proc~vtk_var_xml_scal_i8 VTK_VAR_XML_SCAL_I8 proc~vtk_var_xml_scal_i8->interface~str proc~vtk_geo_xml_strg_r8 VTK_GEO_XML_STRG_R8 proc~vtk_geo_xml_strg_r8->interface~str proc~vtk_var_xml_list_i4 VTK_VAR_XML_LIST_I4 proc~vtk_var_xml_list_i4->interface~str proc~vtk_geo_xml_unst_r8 VTK_GEO_XML_UNST_R8 proc~vtk_geo_xml_unst_r8->interface~str proc~vtk_con_xml VTK_CON_XML proc~vtk_con_xml->interface~str proc~vtk_var_xml_vect_r8 VTK_VAR_XML_VECT_R8 proc~vtk_var_xml_vect_r8->interface~str proc~vtk_var_xml_vect_i1 VTK_VAR_XML_VECT_I1 proc~vtk_var_xml_vect_i1->interface~str proc~vtk_var_xml_list_r4 VTK_VAR_XML_LIST_R4 proc~vtk_var_xml_list_r4->interface~str proc~vtk_var_xml_scal_i2 VTK_VAR_XML_SCAL_I2 proc~vtk_var_xml_scal_i2->interface~str proc~vtk_var_xml_list_i2 VTK_VAR_XML_LIST_I2 proc~vtk_var_xml_list_i2->interface~str proc~vtk_geo_xml_rect_r8 VTK_GEO_XML_RECT_R8 proc~vtk_geo_xml_rect_r8->interface~str proc~vtk_var_xml_vect_i2 VTK_VAR_XML_VECT_I2 proc~vtk_var_xml_vect_i2->interface~str interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_list_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_r4 interface~vtk_var_xml->proc~vtk_var_xml_list_i1 interface~vtk_var_xml->proc~vtk_var_xml_vect_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i1 interface~vtk_var_xml->proc~vtk_var_xml_scal_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i8 interface~vtk_var_xml->proc~vtk_var_xml_scal_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_i4 interface~vtk_var_xml->proc~vtk_var_xml_vect_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i1 interface~vtk_var_xml->proc~vtk_var_xml_list_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i2 interface~vtk_var_xml->proc~vtk_var_xml_list_i2 interface~vtk_var_xml->proc~vtk_var_xml_vect_i2 interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code str_I2P Source Code elemental function str_I2P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function str\\_I2P converts integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign ! Flag for leaving out the sign. integer ( I2P ), intent ( IN ) :: n ! Integer to be converted. character ( DI2P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P","loc":"proc/str_i2p.html"},{"tags":"","title":"str_I1P – MUSST","text":"private elemental function str_I1P(no_sign, n) result(str) The function str_I1P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I1P), intent(in) :: n Return Value character(len=DI1P) Called by proc~~str_i1p~~CalledByGraph proc~str_i1p str_I1P interface~str str interface~str->proc~str_i1p proc~vtk_var_xml_list_i8 VTK_VAR_XML_LIST_I8 proc~vtk_var_xml_list_i8->interface~str proc~vtk_var_xml_list_r8 VTK_VAR_XML_LIST_R8 proc~vtk_var_xml_list_r8->interface~str proc~vtk_var_xml_vect_r4 VTK_VAR_XML_VECT_R4 proc~vtk_var_xml_vect_r4->interface~str proc~vtk_var_xml_list_i1 VTK_VAR_XML_LIST_I1 proc~vtk_var_xml_list_i1->interface~str proc~vtk_var_xml_vect_i4 VTK_VAR_XML_VECT_I4 proc~vtk_var_xml_vect_i4->interface~str proc~vtk_var_xml_scal_i1 VTK_VAR_XML_SCAL_I1 proc~vtk_var_xml_scal_i1->interface~str proc~vtk_geo_xml_unst_r4 VTK_GEO_XML_UNST_R4 proc~vtk_geo_xml_unst_r4->interface~str proc~vtk_var_xml_scal_r4 VTK_VAR_XML_SCAL_R4 proc~vtk_var_xml_scal_r4->interface~str proc~vtk_geo_xml_strg_r4 VTK_GEO_XML_STRG_R4 proc~vtk_geo_xml_strg_r4->interface~str proc~vtk_var_xml_scal_i4 VTK_VAR_XML_SCAL_I4 proc~vtk_var_xml_scal_i4->interface~str proc~vtk_geo_xml_rect_r4 VTK_GEO_XML_RECT_R4 proc~vtk_geo_xml_rect_r4->interface~str proc~vtk_var_xml_scal_r8 VTK_VAR_XML_SCAL_R8 proc~vtk_var_xml_scal_r8->interface~str proc~vtk_var_xml_vect_i8 VTK_VAR_XML_VECT_I8 proc~vtk_var_xml_vect_i8->interface~str proc~vtk_var_xml_scal_i8 VTK_VAR_XML_SCAL_I8 proc~vtk_var_xml_scal_i8->interface~str proc~vtk_geo_xml_strg_r8 VTK_GEO_XML_STRG_R8 proc~vtk_geo_xml_strg_r8->interface~str proc~vtk_var_xml_list_i4 VTK_VAR_XML_LIST_I4 proc~vtk_var_xml_list_i4->interface~str proc~vtk_geo_xml_unst_r8 VTK_GEO_XML_UNST_R8 proc~vtk_geo_xml_unst_r8->interface~str proc~vtk_con_xml VTK_CON_XML proc~vtk_con_xml->interface~str proc~vtk_var_xml_vect_r8 VTK_VAR_XML_VECT_R8 proc~vtk_var_xml_vect_r8->interface~str proc~vtk_var_xml_vect_i1 VTK_VAR_XML_VECT_I1 proc~vtk_var_xml_vect_i1->interface~str proc~vtk_var_xml_list_r4 VTK_VAR_XML_LIST_R4 proc~vtk_var_xml_list_r4->interface~str proc~vtk_var_xml_scal_i2 VTK_VAR_XML_SCAL_I2 proc~vtk_var_xml_scal_i2->interface~str proc~vtk_var_xml_list_i2 VTK_VAR_XML_LIST_I2 proc~vtk_var_xml_list_i2->interface~str proc~vtk_geo_xml_rect_r8 VTK_GEO_XML_RECT_R8 proc~vtk_geo_xml_rect_r8->interface~str proc~vtk_var_xml_vect_i2 VTK_VAR_XML_VECT_I2 proc~vtk_var_xml_vect_i2->interface~str interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_list_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_r4 interface~vtk_var_xml->proc~vtk_var_xml_list_i1 interface~vtk_var_xml->proc~vtk_var_xml_vect_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i1 interface~vtk_var_xml->proc~vtk_var_xml_scal_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i8 interface~vtk_var_xml->proc~vtk_var_xml_scal_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_i4 interface~vtk_var_xml->proc~vtk_var_xml_vect_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i1 interface~vtk_var_xml->proc~vtk_var_xml_list_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i2 interface~vtk_var_xml->proc~vtk_var_xml_list_i2 interface~vtk_var_xml->proc~vtk_var_xml_vect_i2 interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code str_I1P Source Code elemental function str_I1P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function str\\_I1P converts integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign ! Flag for leaving out the sign. integer ( I1P ), intent ( IN ) :: n ! Integer to be converted. character ( DI1P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P","loc":"proc/str_i1p.html"},{"tags":"","title":"strz_I8P – MUSST","text":"private elemental function strz_I8P(nz_pad, n) result(str) The function strz_I8P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I8P), intent(in) :: n Return Value character(len=DI8P) Called by proc~~strz_i8p~~CalledByGraph proc~strz_i8p strz_I8P interface~strz strz interface~strz->proc~strz_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code strz_I8P Source Code elemental function strz_I8P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function strz\\_I8P converts integer to string, prefixing with the right number of zeros. This function achieves casting of !!integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad ! Number of zeros padding. integer ( I8P ), intent ( IN ) :: n ! Integer to be converted. character ( DI8P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P","loc":"proc/strz_i8p.html"},{"tags":"","title":"strz_I4P – MUSST","text":"private elemental function strz_I4P(nz_pad, n) result(str) The function strz_I4P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I4P), intent(in) :: n Return Value character(len=DI4P) Called by proc~~strz_i4p~~CalledByGraph proc~strz_i4p strz_I4P interface~strz strz interface~strz->proc~strz_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code strz_I4P Source Code elemental function strz_I4P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function strz\\_I4P converts integer to string, prefixing with the right number of zeros. This function achieves casting of !!integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad ! Number of zeros padding. integer ( I4P ), intent ( IN ) :: n ! Integer to be converted. character ( DI4P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P","loc":"proc/strz_i4p.html"},{"tags":"","title":"strz_I2P – MUSST","text":"private elemental function strz_I2P(nz_pad, n) result(str) The function strz_I2P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I2P), intent(in) :: n Return Value character(len=DI2P) Called by proc~~strz_i2p~~CalledByGraph proc~strz_i2p strz_I2P interface~strz strz interface~strz->proc~strz_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code strz_I2P Source Code elemental function strz_I2P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function strz\\_I2P converts integer to string, prefixing with the right number of zeros. This function achieves casting of !!integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad ! Number of zeros padding. integer ( I2P ), intent ( IN ) :: n ! Integer to be converted. character ( DI2P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P","loc":"proc/strz_i2p.html"},{"tags":"","title":"strz_I1P – MUSST","text":"private elemental function strz_I1P(nz_pad, n) result(str) The function strz_I1P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I1P), intent(in) :: n Return Value character(len=DI1P) Called by proc~~strz_i1p~~CalledByGraph proc~strz_i1p strz_I1P interface~strz strz interface~strz->proc~strz_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code strz_I1P Source Code elemental function strz_I1P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function strz\\_I1P converts integer to string, prefixing with the right number of zeros. This function achieves casting of !!integer to string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad ! Number of zeros padding. integer ( I1P ), intent ( IN ) :: n ! Integer to be converted. character ( DI1P ) :: str ! Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P","loc":"proc/strz_i1p.html"},{"tags":"","title":"ctor_R16P – MUSST","text":"private function ctor_R16P(str, knd) result(n) The function ctor_R16P converts string to real. This function achieves casting of string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R16P), intent(in) :: knd Return Value real(kind=R16P) Called by proc~~ctor_r16p~~CalledByGraph proc~ctor_r16p ctor_R16P interface~cton cton interface~cton->proc~ctor_r16p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ctor_R16P Source Code function ctor_R16P ( str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function ctor\\_R16P converts string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: str ! String containing input number. real ( R16P ), intent ( IN ) :: knd ! Number kind. real ( R16P ) :: n ! Number returned. integer ( I4P ) :: E_IO ! Input/Output debug flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = E_IO ) n ! Casting of str to n. if ( E_IO /= 0 ) then write ( 6 , '(A)' ) 'Conversion of string \"' // str // '\" to real failed' write ( 6 , '(A,' // FR16P // ')' ) 'Kind parameter ' , knd write ( 6 , '(A)' ) 'Function used \"ctor_R16P\"' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P","loc":"proc/ctor_r16p.html"},{"tags":"","title":"ctor_R8P – MUSST","text":"private function ctor_R8P(str, knd) result(n) The function ctor_R8P converts string to real. This function achieves casting of string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R8P), intent(in) :: knd Return Value real(kind=R8P) Called by proc~~ctor_r8p~~CalledByGraph proc~ctor_r8p ctor_R8P interface~cton cton interface~cton->proc~ctor_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ctor_R8P Source Code function ctor_R8P ( str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function ctor\\_R8P converts string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: str ! String containing input number. real ( R8P ), intent ( IN ) :: knd ! Number kind. real ( R8P ) :: n ! Number returned. integer ( I4P ) :: E_IO ! Input/Output debug flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = E_IO ) n ! Casting of str to n. if ( E_IO /= 0 ) then write ( 6 , '(A)' ) 'Conversion of string \"' // str // '\" to real failed' write ( 6 , '(A,' // FR8P // ')' ) 'Kind parameter ' , knd write ( 6 , '(A)' ) 'Function used \"ctor_R8P\"' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P","loc":"proc/ctor_r8p.html"},{"tags":"","title":"ctor_R4P – MUSST","text":"private function ctor_R4P(str, knd) result(n) The function ctor_R4P converts string to real. This function achieves casting of string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R4P), intent(in) :: knd Return Value real(kind=R4P) Called by proc~~ctor_r4p~~CalledByGraph proc~ctor_r4p ctor_R4P interface~cton cton interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ctor_R4P Source Code function ctor_R4P ( str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function ctor\\_R4P converts string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: str ! String containing input number. real ( R4P ), intent ( IN ) :: knd ! Number kind. real ( R4P ) :: n ! Number returned. integer ( I4P ) :: E_IO ! Input/Output debug flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = E_IO ) n ! Casting of str to n. if ( E_IO /= 0 ) then write ( 6 , '(A)' ) 'Conversion of string \"' // str // '\" to real failed' write ( 6 , '(A,' // FR4P // ')' ) 'Kind parameter ' , knd write ( 6 , '(A)' ) 'Function used \"ctor_R4P\"' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P","loc":"proc/ctor_r4p.html"},{"tags":"","title":"ctoi_I8P – MUSST","text":"private function ctoi_I8P(str, knd) result(n) The function ctoi_I8P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I8P), intent(in) :: knd Return Value integer(kind=I8P) Called by proc~~ctoi_i8p~~CalledByGraph proc~ctoi_i8p ctoi_I8P interface~cton cton interface~cton->proc~ctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ctoi_I8P Source Code function ctoi_I8P ( str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function ctoi\\_I8P converts string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: str ! String containing input number. integer ( I8P ), intent ( IN ) :: knd ! Number kind. integer ( I8P ) :: n ! Number returned. integer ( I4P ) :: E_IO ! Input/Output debug flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = E_IO ) n ! Casting of str to n. if ( E_IO /= 0 ) then write ( 6 , '(A)' ) 'Conversion of string \"' // str // '\" to integer failed' write ( 6 , '(A,' // FI8P // ')' ) 'Kind parameter ' , knd write ( 6 , '(A)' ) 'Function used \"ctoi_I8P\"' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P","loc":"proc/ctoi_i8p.html"},{"tags":"","title":"ctoi_I4P – MUSST","text":"private function ctoi_I4P(str, knd) result(n) The function ctoi_I4P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I4P), intent(in) :: knd Return Value integer(kind=I4P) Called by proc~~ctoi_i4p~~CalledByGraph proc~ctoi_i4p ctoi_I4P interface~cton cton interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ctoi_I4P Source Code function ctoi_I4P ( str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function ctoi\\_I4P converts string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: str ! String containing input number. integer ( I4P ), intent ( IN ) :: knd ! Number kind. integer ( I4P ) :: n ! Number returned. integer ( I4P ) :: E_IO ! Input/Output debug flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = E_IO ) n ! Casting of str to n. if ( E_IO /= 0 ) then write ( 6 , '(A)' ) 'Conversion of string \"' // str // '\" to integer failed' write ( 6 , '(A,' // FI4P // ')' ) 'Kind parameter ' , knd write ( 6 , '(A)' ) 'Function used \"ctoi_I4P\"' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P","loc":"proc/ctoi_i4p.html"},{"tags":"","title":"ctoi_I2P – MUSST","text":"private function ctoi_I2P(str, knd) result(n) The function ctoi_I2P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I2P), intent(in) :: knd Return Value integer(kind=I2P) Called by proc~~ctoi_i2p~~CalledByGraph proc~ctoi_i2p ctoi_I2P interface~cton cton interface~cton->proc~ctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ctoi_I2P Source Code function ctoi_I2P ( str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function ctoi\\_I2P converts string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: str ! String containing input number. integer ( I2P ), intent ( IN ) :: knd ! Number kind. integer ( I2P ) :: n ! Number returned. integer ( I4P ) :: E_IO ! Input/Output debug flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = E_IO ) n ! Casting of str to n. if ( E_IO /= 0 ) then write ( 6 , '(A)' ) 'Conversion of string \"' // str // '\" to integer failed' write ( 6 , '(A,' // FI2P // ')' ) 'Kind parameter ' , knd write ( 6 , '(A)' ) 'Function used \"ctoi_I2P\"' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P","loc":"proc/ctoi_i2p.html"},{"tags":"","title":"ctoi_I1P – MUSST","text":"private function ctoi_I1P(str, knd) result(n) The function ctoi_I1P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I1P), intent(in) :: knd Return Value integer(kind=I1P) Called by proc~~ctoi_i1p~~CalledByGraph proc~ctoi_i1p ctoi_I1P interface~cton cton interface~cton->proc~ctoi_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ctoi_I1P Source Code function ctoi_I1P ( str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !!The function ctoi\\_I1P converts string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: str ! String containing input number. integer ( I1P ), intent ( IN ) :: knd ! Number kind. integer ( I1P ) :: n ! Number returned. integer ( I4P ) :: E_IO ! Input/Output debug flag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = E_IO ) n ! Casting of str to n. if ( E_IO /= 0 ) then write ( 6 , '(A)' ) 'Conversion of string \"' // str // '\" to integer failed' write ( 6 , '(A,' // FI1P // ')' ) 'Kind parameter ' , knd write ( 6 , '(A)' ) 'Function used \"ctoi_I1P\"' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P","loc":"proc/ctoi_i1p.html"},{"tags":"","title":"IR_Print – MUSST","text":"public subroutine IR_Print() The subroutine IR_Print print to the standard output the kind definition of reals and integers and the utility variables. Arguments None Contents Source Code IR_Print Source Code subroutine IR_Print () !--------------------------------------------------------------------------------------------------------------------------------- !!The subroutine IR\\_Print print to the standard output the kind definition of reals and integers and the utility variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( * , '(A)' ) ' Reals kind precision definition' #ifdef r16p write ( * , '(A,I2,A,I2)' ) ' R16P Kind \"' , R16P , '\" | FR16P format \"' // FR16P // '\" | DR16P chars ' , DR16P #endif write ( * , '(A,I2,A,I2)' ) ' R8P  Kind \"' , R8P , '\" | FR8P  format \"' // FR8P // '\" | DR8P  chars ' , DR8P write ( * , '(A,I2,A,I2)' ) ' R4P  Kind \"' , R4P , '\" | FR4P  format \"' // FR4P // '\"  | DR4P  chars ' , DR4P write ( * , '(A)' ) ' Integers kind precision definition' write ( * , '(A,I2,A,I2)' ) ' I8P Kind \"' , I8P , '\" | FI8P format \"' // FI8P // '\" | DI8P chars ' , DI8P write ( * , '(A,I2,A,I2)' ) ' I4P Kind \"' , I4P , '\" | FI4P format \"' // FI4P // '\" | DI4P chars ' , DI4P write ( * , '(A,I2,A,I2)' ) ' I2P Kind \"' , I2P , '\" | FI2P format \"' // FI2P // '\"  | DI2P chars ' , DI2P write ( * , '(A,I2,A,I2)' ) ' I1P Kind \"' , I1P , '\" | FI1P format \"' // FI1P // '\"  | DI1P chars ' , DI1P write ( * , '(A)' ) ' Reals minimum and maximum values' #ifdef r16p write ( * , '(A,' // FR16P // ',A,' // FR16P // ',A)' ) ' MinR16P \"' , MinR16P , '\" | MaxR16P \"' , MaxR16P , '\"' #endif write ( * , '(A,' // FR8P // ',A,19X,A,' // FR8P // ',A)' ) ' MinR8P  \"' , MinR8P , '\"' , ' | MaxR8P  \"' , MaxR8P , '\"' write ( * , '(A,' // FR4P // ',A,29X,A,' // FR4P // ',A)' ) ' MinR4P  \"' , MinR4P , '\"' , ' | MaxR4P  \"' , MaxR4P , '\"' write ( * , '(A)' ) ' Integers minimum and maximum values' write ( * , '(A,' // FI8P // ',A,' // FI8P // ',A)' ) ' MinI8P  \"' , MinI8P , '\" | MaxI8P  \"' , MaxI8P , '\"' write ( * , '(A,' // FI4P // ',A,9X,A,' // FI4P // ',A)' ) ' MinI4P  \"' , MinI4P , '\"' , ' | MaxI4P  \"' , MaxI4P , '\"' write ( * , '(A,' // FI2P // ',A,14X,A,' // FI2P // ',A)' ) ' MinI2P  \"' , MinI2P , '\"' , ' | MaxI2P  \"' , MaxI2P , '\"' write ( * , '(A,' // FI1P // ',A,16X,A,' // FI1P // ',A)' ) ' MinI1P  \"' , MinI1P , '\"' , ' | MaxI1P  \"' , MaxI1P , '\"' write ( * , '(A)' ) ' Machine precions' #ifdef r16p write ( * , '(A,' // FR16P // ')' ) ' ZeroR16 \"' , ZeroR16 #endif write ( * , '(A,' // FR8P // ')' ) ' ZeroR8  \"' , ZeroR8 write ( * , '(A,' // FR4P // ')' ) ' ZeroR4  \"' , ZeroR4 !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine IR_Print","loc":"proc/ir_print.html"},{"tags":"","title":"str – MUSST","text":"public interface str Calls interface~~str~~CallsGraph interface~str str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~str~~CalledByGraph interface~str str proc~vtk_var_xml_list_i8 VTK_VAR_XML_LIST_I8 proc~vtk_var_xml_list_i8->interface~str proc~vtk_var_xml_list_r8 VTK_VAR_XML_LIST_R8 proc~vtk_var_xml_list_r8->interface~str proc~vtk_var_xml_vect_r4 VTK_VAR_XML_VECT_R4 proc~vtk_var_xml_vect_r4->interface~str proc~vtk_var_xml_list_i1 VTK_VAR_XML_LIST_I1 proc~vtk_var_xml_list_i1->interface~str proc~vtk_var_xml_vect_i4 VTK_VAR_XML_VECT_I4 proc~vtk_var_xml_vect_i4->interface~str proc~vtk_var_xml_scal_i1 VTK_VAR_XML_SCAL_I1 proc~vtk_var_xml_scal_i1->interface~str proc~vtk_geo_xml_unst_r4 VTK_GEO_XML_UNST_R4 proc~vtk_geo_xml_unst_r4->interface~str proc~vtk_var_xml_scal_r4 VTK_VAR_XML_SCAL_R4 proc~vtk_var_xml_scal_r4->interface~str proc~vtk_geo_xml_strg_r4 VTK_GEO_XML_STRG_R4 proc~vtk_geo_xml_strg_r4->interface~str proc~vtk_var_xml_scal_i4 VTK_VAR_XML_SCAL_I4 proc~vtk_var_xml_scal_i4->interface~str proc~vtk_geo_xml_rect_r4 VTK_GEO_XML_RECT_R4 proc~vtk_geo_xml_rect_r4->interface~str proc~vtk_var_xml_scal_r8 VTK_VAR_XML_SCAL_R8 proc~vtk_var_xml_scal_r8->interface~str proc~vtk_var_xml_vect_i8 VTK_VAR_XML_VECT_I8 proc~vtk_var_xml_vect_i8->interface~str proc~vtk_var_xml_scal_i8 VTK_VAR_XML_SCAL_I8 proc~vtk_var_xml_scal_i8->interface~str proc~vtk_geo_xml_strg_r8 VTK_GEO_XML_STRG_R8 proc~vtk_geo_xml_strg_r8->interface~str proc~vtk_var_xml_list_i4 VTK_VAR_XML_LIST_I4 proc~vtk_var_xml_list_i4->interface~str proc~vtk_geo_xml_unst_r8 VTK_GEO_XML_UNST_R8 proc~vtk_geo_xml_unst_r8->interface~str proc~vtk_con_xml VTK_CON_XML proc~vtk_con_xml->interface~str proc~vtk_var_xml_vect_r8 VTK_VAR_XML_VECT_R8 proc~vtk_var_xml_vect_r8->interface~str proc~vtk_var_xml_vect_i1 VTK_VAR_XML_VECT_I1 proc~vtk_var_xml_vect_i1->interface~str proc~vtk_var_xml_list_r4 VTK_VAR_XML_LIST_R4 proc~vtk_var_xml_list_r4->interface~str proc~vtk_var_xml_scal_i2 VTK_VAR_XML_SCAL_I2 proc~vtk_var_xml_scal_i2->interface~str proc~vtk_var_xml_list_i2 VTK_VAR_XML_LIST_I2 proc~vtk_var_xml_list_i2->interface~str proc~vtk_geo_xml_rect_r8 VTK_GEO_XML_RECT_R8 proc~vtk_geo_xml_rect_r8->interface~str proc~vtk_var_xml_vect_i2 VTK_VAR_XML_VECT_I2 proc~vtk_var_xml_vect_i2->interface~str interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_list_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_r4 interface~vtk_var_xml->proc~vtk_var_xml_list_i1 interface~vtk_var_xml->proc~vtk_var_xml_vect_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i1 interface~vtk_var_xml->proc~vtk_var_xml_scal_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i4 interface~vtk_var_xml->proc~vtk_var_xml_scal_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i8 interface~vtk_var_xml->proc~vtk_var_xml_scal_i8 interface~vtk_var_xml->proc~vtk_var_xml_list_i4 interface~vtk_var_xml->proc~vtk_var_xml_vect_r8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i1 interface~vtk_var_xml->proc~vtk_var_xml_list_r4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i2 interface~vtk_var_xml->proc~vtk_var_xml_list_i2 interface~vtk_var_xml->proc~vtk_var_xml_vect_i2 interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r8 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures str_R16P str_R8P str_R4P str_I8P str_I4P str_I2P str_I1P Module Procedures private elemental function str_R16P (no_sign, n) result(str) The function str_R16P converts real to string. This function achieves casting of real to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign real(kind=R16P), intent(in) :: n Return Value character(len=DR16P) private elemental function str_R8P (no_sign, n) result(str) The function str_R8P converts real to string. This function achieves casting of real to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign real(kind=R8P), intent(in) :: n Return Value character(len=DR8P) private elemental function str_R4P (no_sign, n) result(str) The function str_R4P converts real to string. This function achieves casting of real to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign real(kind=R4P), intent(in) :: n Return Value character(len=DR4P) private elemental function str_I8P (no_sign, n) result(str) The function str_I8P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I8P), intent(in) :: n Return Value character(len=DI8P) private elemental function str_I4P (no_sign, n) result(str) The function str_I4P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I4P), intent(in) :: n Return Value character(len=DI4P) private elemental function str_I2P (no_sign, n) result(str) The function str_I2P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I2P), intent(in) :: n Return Value character(len=DI2P) private elemental function str_I1P (no_sign, n) result(str) The function str_I1P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I1P), intent(in) :: n Return Value character(len=DI1P)","loc":"interface/str.html"},{"tags":"","title":"strz – MUSST","text":"public interface strz Calls interface~~strz~~CallsGraph interface~strz strz proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures strz_I8P strz_I4P strz_I2P strz_I1P Module Procedures private elemental function strz_I8P (nz_pad, n) result(str) The function strz_I8P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I8P), intent(in) :: n Return Value character(len=DI8P) private elemental function strz_I4P (nz_pad, n) result(str) The function strz_I4P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I4P), intent(in) :: n Return Value character(len=DI4P) private elemental function strz_I2P (nz_pad, n) result(str) The function strz_I2P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I2P), intent(in) :: n Return Value character(len=DI2P) private elemental function strz_I1P (nz_pad, n) result(str) The function strz_I1P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I1P), intent(in) :: n Return Value character(len=DI1P)","loc":"interface/strz.html"},{"tags":"","title":"cton – MUSST","text":"public interface cton Calls interface~~cton~~CallsGraph interface~cton cton proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctor_r16p ctor_R16P interface~cton->proc~ctor_r16p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures ctor_R16P ctor_R8P ctor_R4P ctoi_I8P ctoi_I4P ctoi_I2P ctoi_I1P Module Procedures private function ctor_R16P (str, knd) result(n) The function ctor_R16P converts string to real. This function achieves casting of string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R16P), intent(in) :: knd Return Value real(kind=R16P) private function ctor_R8P (str, knd) result(n) The function ctor_R8P converts string to real. This function achieves casting of string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R8P), intent(in) :: knd Return Value real(kind=R8P) private function ctor_R4P (str, knd) result(n) The function ctor_R4P converts string to real. This function achieves casting of string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R4P), intent(in) :: knd Return Value real(kind=R4P) private function ctoi_I8P (str, knd) result(n) The function ctoi_I8P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I8P), intent(in) :: knd Return Value integer(kind=I8P) private function ctoi_I4P (str, knd) result(n) The function ctoi_I4P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I4P), intent(in) :: knd Return Value integer(kind=I4P) private function ctoi_I2P (str, knd) result(n) The function ctoi_I2P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I2P), intent(in) :: knd Return Value integer(kind=I2P) private function ctoi_I1P (str, knd) result(n) The function ctoi_I1P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I1P), intent(in) :: knd Return Value integer(kind=I1P)","loc":"interface/cton.html"},{"tags":"","title":"create_rect_x_ymesh – MUSST","text":"public subroutine create_rect_x_ymesh(m) Note Subroutine to create a rectangular mesh in the x , y directions Arguments Type Intent Optional Attributes Name type( FE_MESH ), intent(inout) :: m FE mesh Called by proc~~create_rect_x_ymesh~~CalledByGraph proc~create_rect_x_ymesh create_rect_x_ymesh proc~create_rect_fe_film create_rect_FE_film proc~create_rect_fe_film->proc~create_rect_x_ymesh proc~multi_scale_create_rect_fe_film multi_scale_create_rect_fe_film proc~multi_scale_create_rect_fe_film->proc~create_rect_fe_film proc~init_fe_prob init_fe_prob proc~init_fe_prob->proc~create_rect_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~init_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~init_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~init_fe_prob proc~init_ms_prob init_ms_prob proc~init_ms_prob->proc~multi_scale_create_rect_fe_film proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~init_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~init_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_rough_ms->proc~init_ms_prob proc~test_slider_ms->proc~init_ms_prob program~main main program~main->proc~run_test var panproccreate_rect_x_ymeshCalledByGraph = svgPanZoom('#proccreate_rect_x_ymeshCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code create_rect_x_ymesh Source Code subroutine create_rect_x_ymesh ( m ) implicit none type ( FE_MESH ), intent ( inout ) :: m !! *FE mesh* integer ( kind = I4 ) :: i , j , ind , inde real ( kind = R8 ) :: lx , ly , zx , zy integer ( kind = I4 ) :: nx , ny lx = m % lx ly = m % ly zx = m % zx zy = m % zy nx = m % nx ny = m % ny ! mesh size definition ! number of nodes m % n = nx * ny ! number of elements m % ne = ( nx - 1 ) * ( ny - 1 ) ! nodes and elements table allocation allocate ( m % x ( m % n ), m % y ( m % n ), m % z ( m % n ), m % con ( m % ne , 4 ), m % el_t ( m % ne ), m % el_n ( m % ne ) ) ! all the elements are qua_4 m % el_t = 4 ! 4 nodes m % el_n = 4 ! number of different lines ! tables initialisation m % con = 0 m % x = 0._R8 m % y = 0._R8 m % z = 0._R8 ! nodes coordinates do j = 1 , ny do i = 1 , nx ind = ( j - 1 ) * nx + i m % x ( ind ) = zx + lx * ( i - 1 ) / ( nx - 1 ) m % y ( ind ) = zy + ly * ( j - 1 ) / ( ny - 1 ) enddo enddo ! connectivity table do j = 1 , ny - 1 do i = 1 , nx - 1 inde = ( j - 1 ) * ( nx - 1 ) + i ind = ( j - 1 ) * nx + i m % con ( inde , 1 ) = ind m % con ( inde , 2 ) = ind + 1 m % con ( inde , 3 ) = ind + 1 + nx m % con ( inde , 4 ) = ind + nx enddo enddo !---- ! edges definition ! number of edges m % ned = 4 ! allocattion of the edges table allocate ( m % ed ( m % ned ) ) ! number of nodes and elements of each edge m % ed ( 1 )% n = nx m % ed ( 1 )% ne = nx - 1 m % ed ( 2 )% n = ny m % ed ( 2 )% ne = ny - 1 m % ed ( 3 )% n = nx m % ed ( 3 )% ne = nx - 1 m % ed ( 4 )% n = ny m % ed ( 4 )% ne = ny - 1 ! allocation of the edges nodes table do j = 1 , m % ned allocate ( m % ed ( j )% nm ( m % ed ( j )% n ) ) m % ed ( j )% nm = 0 enddo ! nodes number of the edges from the 2D mesh do i = 1 , nx m % ed ( 1 )% nm ( i ) = i m % ed ( 3 )% nm ( i ) = ( ny - 1 ) * nx + ( nx - i + 1 ) enddo do j = 1 , ny m % ed ( 2 )% nm ( j ) = nx * j m % ed ( 4 )% nm ( j ) = nx * ( ny - j ) + 1 enddo ! edges connectivity table allocation and creation do j = 1 , m % ned allocate ( m % ed ( j )% con ( m % ed ( j )% ne , 2 )) m % ed ( j )% con = 0 do i = 1 , m % ed ( j )% ne m % ed ( j )% con ( i , 1 ) = m % ed ( j )% nm ( i ) m % ed ( j )% con ( i , 2 ) = m % ed ( j )% nm ( i ) + 1 enddo enddo !---- ! corners of the mesh ! number of corners ( = 4) m % nc = m % ned ! allocation of corner nodes table allocate ( m % cor ( m % nc )) ! value of the corner nodes table do j = 1 , m % nc m % cor ( j ) = m % ed ( j )% nm ( 1 ) enddo return endsubroutine create_rect_x_ymesh","loc":"proc/create_rect_x_ymesh.html"},{"tags":"","title":"ms_fz – MUSST","text":"private function ms_fz(ms_fe_f) Note Function to calculate the generated load in a fluid MS film \\int_\\Omega p d\\Omega Arguments Type Intent Optional Attributes Name class( MS_FE_FILM ), intent(inout) :: ms_fe_f MS FE film Return Value real(kind=R8) Contents None","loc":"proc/ms_fz.html"},{"tags":"","title":"ms_fx – MUSST","text":"private function ms_fx(ms_fe_f) Note Function to calculate the friction force along x in a fluid MS film \\int_\\Omega \\tau_{xz} d\\Omega Arguments Type Intent Optional Attributes Name class( MS_FE_FILM ), intent(inout) :: ms_fe_f Return Value real(kind=R8) Contents None","loc":"proc/ms_fx.html"},{"tags":"","title":"ms_fy – MUSST","text":"private function ms_fy(ms_fe_f) Note Function to calculate the friction force along y in a fluid MS film \\int_\\Omega \\tau_{yz} d\\Omega Arguments Type Intent Optional Attributes Name class( MS_FE_FILM ), intent(inout) :: ms_fe_f Return Value real(kind=R8) Contents None","loc":"proc/ms_fy.html"},{"tags":"","title":"multi_scale_create_rect_fe_film – MUSST","text":"public subroutine multi_scale_create_rect_fe_film(data_f, bs_nx, bs_ny, num_pts, num_pbs, ms_fe_f) Note Subroutine to create a MS_FE_FILM Arguments Type Intent Optional Attributes Name type(DATA_FILM), intent(inout) :: data_f data of the film integer(kind=I4), intent(in) :: bs_nx number of nodes in x direction for the bottom scale integer(kind=I4), intent(in) :: bs_ny number of nodes in y direction for the bottom scale type(NUM_PAR), intent(in) :: num_pts numerical parameters for iterative solution, top scale type(NUM_PAR), intent(in) :: num_pbs numerical parameters for iterative solution, bottom scale type( MS_FE_FILM ), intent(inout) :: ms_fe_f MS FE film Calls proc~~multi_scale_create_rect_fe_film~~CallsGraph proc~multi_scale_create_rect_fe_film multi_scale_create_rect_fe_film proc~create_rect_fe_film create_rect_FE_film proc~multi_scale_create_rect_fe_film->proc~create_rect_fe_film proc~create_rect_x_ymesh create_rect_x_ymesh proc~create_rect_fe_film->proc~create_rect_x_ymesh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~multi_scale_create_rect_fe_film~~CalledByGraph proc~multi_scale_create_rect_fe_film multi_scale_create_rect_fe_film proc~init_ms_prob init_ms_prob proc~init_ms_prob->proc~multi_scale_create_rect_fe_film proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~init_ms_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~init_ms_prob proc~run_test run_test proc~run_test->proc~test_slider_ms proc~run_test->proc~test_rough_ms program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code multi_scale_create_rect_fe_film Source Code subroutine multi_scale_create_rect_fe_film ( data_f , bs_nx , bs_ny , num_pts , num_pbs , ms_fe_f ) implicit none type ( DATA_FILM ), intent ( inout ) :: data_f !! *data of the film* integer ( kind = I4 ), intent ( in ) :: bs_nx !! *number of nodes in x direction for the bottom scale* integer ( kind = I4 ), intent ( in ) :: bs_ny !! *number of nodes in y direction for the bottom scale* type ( NUM_PAR ), intent ( in ) :: num_pts !! *numerical parameters for iterative solution, top scale* type ( NUM_PAR ), intent ( in ) :: num_pbs !! *numerical parameters for iterative solution, bottom scale* type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f !! *MS FE film* integer ( kind = I4 ) :: e , ne , i1 , i3 ! creation of the top scale fe film call create_rect_FE_film ( data_f = data_f , & num_p = num_pts , & fe_f = ms_fe_f % ts_fe_f ) ! allocation of the bottom scale table ne = ms_fe_f % ts_fe_f % m % ne allocate ( ms_fe_f % bs_fe_f ( ne )) ! creation of the bottom scale fe_film do e = 1 , ne i1 = ms_fe_f % ts_fe_f % m % con ( e , 1 ) i3 = ms_fe_f % ts_fe_f % m % con ( e , 3 ) ms_fe_f % bs_fe_f ( e )% m % nx = bs_nx ms_fe_f % bs_fe_f ( e )% m % ny = bs_ny ms_fe_f % bs_fe_f ( e )% m % zx = ms_fe_f % ts_fe_f % m % x ( i1 ) ms_fe_f % bs_fe_f ( e )% m % zy = ms_fe_f % ts_fe_f % m % y ( i1 ) ms_fe_f % bs_fe_f ( e )% m % lx = ms_fe_f % ts_fe_f % m % x ( i3 ) - ms_fe_f % bs_fe_f ( e )% m % zx ms_fe_f % bs_fe_f ( e )% m % ly = ms_fe_f % ts_fe_f % m % y ( i3 ) - ms_fe_f % bs_fe_f ( e )% m % zy call create_rect_FE_film ( data_f = data_f , & num_p = num_pbs , & fe_f = ms_fe_f % bs_fe_f ( e )) enddo return endsubroutine multi_scale_create_rect_fe_film","loc":"proc/multi_scale_create_rect_fe_film.html"},{"tags":"","title":"multi_scale_solve_fe_film – MUSST","text":"public subroutine multi_scale_solve_fe_film(ms_fe_f, ms_mat, bc) Note Subroutine to solve a MS_FE_FILM Arguments Type Intent Optional Attributes Name type( MS_FE_FILM ), intent(inout) :: ms_fe_f multi-scale FE film type(MS_MAT_SOLV), intent(inout) :: ms_mat multi-scale solver matrices real(kind=R8), intent(in), dimension(MAX_NNC) :: bc boundary conditions at the corners Calls proc~~multi_scale_solve_fe_film~~CallsGraph proc~multi_scale_solve_fe_film multi_scale_solve_fe_film omp_get_thread_num omp_get_thread_num proc~multi_scale_solve_fe_film->omp_get_thread_num proc~solve_syst solve_syst proc~multi_scale_solve_fe_film->proc~solve_syst proc~solve_fe_film solve_FE_film proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~convert_matrice_format convert_matrice_format proc~multi_scale_solve_fe_film->proc~convert_matrice_format proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~multi_scale_solve_fe_film->proc~apply_bc_fe_film_simple proc~multi_scale_assembly_fe_film_reynolds multi_scale_assembly_fe_film_reynolds proc~multi_scale_solve_fe_film->proc~multi_scale_assembly_fe_film_reynolds proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~solve_fe_film->omp_get_thread_num proc~solve_fe_film->proc~solve_syst proc~solve_fe_film->proc~convert_matrice_format proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~multi_scale_assembly_fe_film_reynolds->omp_get_thread_num dmumps dmumps proc~init_solver->dmumps mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d var panprocmulti_scale_solve_fe_filmCallsGraph = svgPanZoom('#procmulti_scale_solve_fe_filmCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~multi_scale_solve_fe_film~~CalledByGraph proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~run_test run_test proc~run_test->proc~test_slider_ms proc~run_test->proc~test_rough_ms program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code multi_scale_solve_fe_film Source Code subroutine multi_scale_solve_fe_film ( ms_fe_f , ms_mat , bc ) implicit none type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f !! *multi-scale FE film* type ( MS_MAT_SOLV ), intent ( inout ) :: ms_mat !! *multi-scale solver matrices* real ( kind = R8 ), intent ( in ), dimension ( MAX_NNC ) :: bc !! *boundary conditions at the corners* logical ( kind = I4 ) :: decomp integer ( kind = I4 ) :: i , e , it , fluid logical ( kind = I4 ) :: conv , ts_init real ( kind = R8 ) :: error , relax integer ( kind = I4 ) :: ass_c integer ( kind = I4 ), dimension ( 2 ) :: compt relax = ms_fe_f % ts_fe_f % num_p % relax fluid = ms_fe_f % ts_fe_f % data_f % fl % fluid_type VERBOSE = nint ( VERBOSE / 1 0. ) ! open mp instructions (parallele computation) if ( VERBOSE >= 1 ) write ( OPU , * ) 'nb_threads_max' , NB_THREADS_MAX if ( NB_THREADS_MAX <= 0 ) NB_THREADS_MAX = 1 !$ call omp_set_num_threads(NB_THREADS_MAX) if ( VERBOSE >= 1 ) write ( OPU , * ) 'nb_threads_used' , NB_THREADS_MAX ! check of matrices allocation allocate ( ms_mat % bs_mat ( ms_fe_f % ts_fe_f % m % ne )) ms_mat % bs_mat (:)% slv_t = SOLVER_BS ms_mat % bs_mat (:)% first = . true . ! solution parameters ass_c = ASS decomp = ( ass_c == ASS ) ! update fluid properties do i = 1 , ms_fe_f % ts_fe_f % m % n ms_fe_f % ts_fe_f % vn ( i , RHO_N ) = ms_fe_f % ts_fe_f % data_f % fl % rho ( ms_fe_f % ts_fe_f % vn ( i , P_N ), & ms_fe_f % ts_fe_f % vn ( i , T_N ) ) ms_fe_f % ts_fe_f % vn ( i , DRHODP_N ) = ms_fe_f % ts_fe_f % data_f % fl % drhodp ( ms_fe_f % ts_fe_f % vn ( i , P_N ), & ms_fe_f % ts_fe_f % vn ( i , T_N ) ) enddo if ( VERBOSE >= 2 ) write ( OPU , * ) 'fluid properties updated' ms_mat % ts_mat % slv_t = SOLVER_TS ms_mat % ts_mat % first = . true . ms_mat % ts_mat % nn = ms_fe_f % ts_fe_f % m % n ms_mat % ts_mat % ne = ms_fe_f % ts_fe_f % m % ne ! matrices allocation compt (:) = 0 do e = 1 , ms_fe_f % ts_fe_f % m % ne compt ( 1 ) = compt ( 1 ) + ms_fe_f % ts_fe_f % m % el_n ( e ) ! for each element, the number of lines is added do i = 1 , ms_fe_f % ts_fe_f % m % el_t ( e ) compt ( 2 ) = compt ( 2 ) + ms_fe_f % ts_fe_f % m % el_t ( e ) ! \" \", for each node, the number of contributions is added enddo enddo ms_mat % ts_mat % nvar = compt ( 1 ) ms_mat % ts_mat % nt = compt ( 2 ) allocate ( ms_mat % ts_mat % eltvar ( ms_mat % ts_mat % nvar ) ) allocate ( ms_mat % ts_mat % a_elt ( ms_mat % ts_mat % nt ) ) allocate ( ms_mat % ts_mat % eltptr ( ms_mat % ts_mat % ne + 1 ) ) ! check of precomputed tables allocation if (. not . allocated ( ms_fe_f % ts_fe_f % prc % vcal )) call init_prc_tab ( ms_fe_f % ts_fe_f ) ! convergence is false at zero iteration conv = . false . it = 0 ts_init = . false . if ( ts_init ) then call solve_FE_film ( fe_f = ms_fe_f % ts_fe_f , & mat = ms_mat % ts_mat , & bc = bc , & flag_ass = . true .) else ! apply boundary conditions call apply_bc_FE_film_simple ( fe_f = ms_fe_f % ts_fe_f , & bc = bc ) if ( VERBOSE >= 2 ) write ( OPU , * ) 'bc applied' call solve_syst ( mat = ms_mat % ts_mat , & step = 'ini' ) if ( VERBOSE >= 2 ) write ( OPU , * ) 'TS solver initialized' endif if ( sum ( ms_fe_f % bs_fe_f ( 1 )% m % ed (:)% n ) > MAX_NBS ) stop 'MAX_NBS under estimated' ! solution loop do if ( VERBOSE >= 3 ) write ( OPU , * ) \"loop MS *******************\" , it if ( conv ) then do e = 1 , ms_fe_f % ts_fe_f % m % ne call solve_syst ( mat = ms_mat % bs_mat ( e ), & ! step = 'end' ) if ( VERBOSE >= 3 ) write ( OPU , * ) '   Matrix BS released, thread ' , omp_get_thread_num () enddo exit endif if ( SMOOTH_MS ) call smooth_ms_fe_f ( ms_fe_f , code = P_N , nodal = . true .) if ( BC_SPLINE ) call interp_ts_bs_splin ( ms_fe_f ) ! assembly of the system call multi_scale_assembly_fe_film_reynolds ( ms_fe_f = ms_fe_f , & ms_mat = ms_mat , & ass_c = ass_c ) if ( VERBOSE >= 3 ) write ( OPU , * ) 'ms reynolds assembled' if ( VERBOSE >= 3 ) write ( OPU , * ) 'ass_c' , ass_c , 'first' , ms_mat % ts_mat % first !~          if (ass_c == ASS) then ! some stuff can be saved here, provided the reloading of jptr, irow, ... (instead of convert_matrice_format) call convert_matrice_format ( mat = ms_mat % ts_mat ) if ( VERBOSE >= 3 ) write ( OPU , * ) 'Matrix TS formated, thread ' , omp_get_thread_num () !~          endif if ( ms_mat % ts_mat % first ) then call solve_syst ( mat = ms_mat % ts_mat , & step = 'ana' ) ms_mat % ts_mat % first = . false . if ( VERBOSE >= 3 ) write ( OPU , * ) 'Matrix TS analyzed, thread ' , omp_get_thread_num () endif ! solution of the system !~          if (ass_c == ASS) then call solve_syst ( mat = ms_mat % ts_mat , & step = 'fac' ) if ( VERBOSE >= 3 ) write ( OPU , * ) 'Matrix TS factorized, thread ' , omp_get_thread_num () !~          endif call solve_syst ( mat = ms_mat % ts_mat , & step = 'sol' ) if ( VERBOSE >= 3 ) write ( OPU , * ) 'System TS solved, thread ' , omp_get_thread_num () !if (ass_c == ASS) then call solve_syst ( mat = ms_mat % ts_mat , & step = 'fre' ) if ( VERBOSE >= 3 ) write ( OPU , * ) 'Matrix factors freed, thread ' , omp_get_thread_num () !endif ! error computation error = ( sum ( ms_mat % ts_mat % x ** 2 ) / sum ( ms_fe_f % ts_fe_f % vn (:, P_N ) ** 2 )) ** ( 0.5 ) it = it + 1 if ( VERBOSE >= 1 ) write ( OPU , * ) 'Iteration ' , it , 'error TS' , error ! convergence check if ( error <= ms_fe_f % ts_fe_f % num_p % eps ) conv = . true . ! update of variables if ( fluid == MIXT ) then do i = 1 , ms_fe_f % ts_fe_f % m % n if ( ms_mat % ts_mat % x ( i ) < 0. ) then ms_fe_f % ts_fe_f % vn ( i , RHO_N ) = ms_fe_f % ts_fe_f % vn ( i , RHO_N ) + ms_fe_f % ts_fe_f % vn ( i , DRHODP_N ) * ms_mat % ts_mat % x ( i ) * relax if ( ms_fe_f % ts_fe_f % vn ( i , RHO_N ) < 0. ) then ms_fe_f % ts_fe_f % vn ( i , P_N ) = ms_fe_f % ts_fe_f % data_f % fl % p_0 / 100 else ms_fe_f % ts_fe_f % vn ( i , P_N ) = ms_fe_f % ts_fe_f % data_f % fl % pres ( ms_fe_f % ts_fe_f % vn ( i , RHO_N ), & ! ms_fe_f % ts_fe_f % vn ( i , T_N ) ) endif else ms_fe_f % ts_fe_f % vn ( i , P_N ) = ms_fe_f % ts_fe_f % vn ( i , P_N ) + ms_mat % ts_mat % x ( i ) * relax endif enddo else ms_fe_f % ts_fe_f % vn (:, P_N ) = ms_fe_f % ts_fe_f % vn (:, P_N ) + ms_mat % ts_mat % x * relax endif ! check pressure if ( fluid == GP ) then if ( minval ( ms_fe_f % ts_fe_f % vn (:, P_N )) < 0._R8 ) write ( OPU , * ) 'MS p negative' where ( ms_fe_f % ts_fe_f % vn (:, P_N ) < 0._R8 ) ms_fe_f % ts_fe_f % vn (:, P_N ) = ms_fe_f % ts_fe_f % data_f % fl % p_0 / 1.e2_R8 endif ! update fluid properties do i = 1 , ms_fe_f % ts_fe_f % m % n ms_fe_f % ts_fe_f % vn ( i , RHO_N ) = ms_fe_f % ts_fe_f % data_f % fl % rho ( ms_fe_f % ts_fe_f % vn ( i , P_N ), & ms_fe_f % ts_fe_f % vn ( i , T_N ) ) ms_fe_f % ts_fe_f % vn ( i , DRHODP_N ) = ms_fe_f % ts_fe_f % data_f % fl % drhodp ( ms_fe_f % ts_fe_f % vn ( i , P_N ), & ms_fe_f % ts_fe_f % vn ( i , T_N ) ) enddo if ( it >= ms_fe_f % ts_fe_f % num_p % it_max ) then conv = . true . write ( OPU , * ) 'maximum number of iteration reached before convergence' endif enddo call solve_syst ( mat = ms_mat % ts_mat , & ! step = 'end' ) if ( VERBOSE >= 2 ) write ( OPU , * ) 'Matrix TS released, thread ' , omp_get_thread_num () return endsubroutine multi_scale_solve_fe_film","loc":"proc/multi_scale_solve_fe_film.html"},{"tags":"","title":"interp_ts_bs_splin – MUSST","text":"private subroutine interp_ts_bs_splin(ms_fe_f) Note Subroutine to interpolate the top-scale nodes for the bottom-scale boundaries Arguments Type Intent Optional Attributes Name type( MS_FE_FILM ), intent(inout) :: ms_fe_f Contents Source Code interp_ts_bs_splin Source Code subroutine interp_ts_bs_splin ( ms_fe_f ) implicit none type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f integer ( kind = I4 ) :: i , j , inbvx , inbvy , iloy , iflag , ts_nx , ts_ny , e , ed , bs_nx , bs_ny , n_edg , n_nod , nn , node_number real ( kind = R8 ) :: x_n , y_n , val real ( kind = R8 ), dimension (:,:), allocatable :: log_press real ( kind = R8 ), dimension (:,:), allocatable :: coeff real ( kind = R8 ), dimension (:), allocatable :: tx ! x knots real ( kind = R8 ), dimension (:), allocatable :: ty ! y knots real ( kind = R8 ), dimension (:), allocatable :: x real ( kind = R8 ), dimension (:), allocatable :: y integer ( kind = I4 ), parameter :: deg = 2 logical ( kind = I4 ) :: mixture mixture = ( ms_fe_f % ts_fe_f % data_f % fl % fluid_type == MIXT ) ts_nx = ms_fe_f % ts_fe_f % m % nx ts_ny = ms_fe_f % ts_fe_f % m % ny allocate ( coeff ( 1 : ts_nx , 1 : ts_ny ) ) allocate ( tx ( 1 :( ts_nx + deg )), & ty ( 1 :( ts_ny + deg )) ) allocate ( x ( 1 : ts_nx ), & y ( 1 : ts_ny ) ) allocate ( log_press ( 1 : ts_nx , 1 : ts_ny ) ) log_press = reshape ( ms_fe_f % ts_fe_f % vn (:, P_N ), ( / ts_nx , ts_ny / ) ) if ( mixture ) log_press = log ( log_press ) x ( 1 : ts_nx ) = ms_fe_f % ts_fe_f % m % x ( 1 : ts_nx ) i = 0 do j = 1 , ts_nx * ( ts_ny - 1 ) + 1 , ts_nx i = i + 1 y ( i ) = ms_fe_f % ts_fe_f % m % y ( j ) enddo iflag = 0 call db2ink ( x = x ( 1 : ts_nx ), & ! Array of x abcissae. Must be strictly increasing. nx = ts_nx , & ! Number of x abcissae y = y ( 1 : ts_ny ), & ! Array of y abcissae. Must be strictly increasing. ny = ts_ny , & ! Number of y abcissae fcn = log_press ( 1 : ts_nx , 1 : ts_ny ), & ! Array of function values to interpolate. fcn(i,j) should !    contain the function value at the point (x(i),y(j)) kx = deg , & ! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) ky = deg , & ! The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) tx = tx ( 1 :( ts_nx + deg )), & ! The knots in the x direction for the spline interpolant. !    If iflag=0 these are chosen by [[db2ink]]. !    If iflag=1 these are specified by the user. !    Must be non-decreasing. ty = ty ( 1 :( ts_ny + deg )), & ! The knots in the y direction for the spline interpolant. !    If iflag=0 these are chosen by [[db2ink]]. !    If iflag=1 these are specified by the user. !    Must be non-decreasing. bcoef = coeff ( 1 : ts_nx , 1 : ts_ny ), & ! Array of coefficients of the b-spline interpolant. iflag = iflag ) ! **on input:**  0 = knot sequence chosen by [[db2ink]]. !                1 = knot sequence chosen by user. ! **on output:** 1 = successful execution. !                2 = iflag out of range. !                3 = nx out of range. !                4 = kx out of range. !                5 = x not strictly increasing. !                6 = tx not non-decreasing. !                7 = ny out of range. !                8 = ky out of range. !                9 = y not strictly increasing. !               10 = ty not non-decreasing. if ( iflag /= 1 ) error stop 'error calling db2ink' inbvx = 1 inbvy = 1 iloy = 1 do e = 1 , ms_fe_f % ts_fe_f % m % ne bs_nx = ms_fe_f % bs_fe_f ( e )% m % nx bs_ny = ms_fe_f % bs_fe_f ( e )% m % ny n_edg = ms_fe_f % bs_fe_f ( e )% m % ned do ed = 1 , n_edg n_nod = ms_fe_f % bs_fe_f ( e )% m % ed ( ed )% n do nn = 1 , n_nod node_number = ms_fe_f % bs_fe_f ( e )% m % ed ( ed )% nm ( nn ) x_n = ms_fe_f % bs_fe_f ( e )% m % x ( node_number ) y_n = ms_fe_f % bs_fe_f ( e )% m % y ( node_number ) call db2val ( xval = x_n , & ! xval     !! x coordinate of evaluation point. yval = y_n , & ! yval     !! y coordinate of evaluation point. idx = 0 , & ! idx      !! x derivative of piecewise polynomial to evaluate. idy = 0 , & ! idy      !! y derivative of piecewise polynomial to evaluate. tx = tx ( 1 :( ts_nx + deg )), & ! tx       !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db2ink]]) ty = ty ( 1 :( ts_ny + deg )), & ! ty       !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db2ink]]) nx = ts_nx , & ! nx       !! the number of interpolation points in x. (same as in last call to [[db2ink]]) ny = ts_ny , & ! ny       !! the number of interpolation points in y. (same as in last call to [[db2ink]]) kx = deg , & ! kx       !! order of polynomial pieces in x. (same as in last call to [[db2ink]]) ky = deg , & ! ky       !! order of polynomial pieces in y. (same as in last call to [[db2ink]]) bcoef = coeff ( 1 : ts_nx , 1 : ts_ny ), & ! bcoef    !! the b-spline coefficients computed by [[db2ink]]. f = val , & ! f        !! interpolated value & iflag = iflag , & ! iflag    !! status flag: 0 : no errors, /=0 : error inbvx = inbvx , & ! inbvx    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. inbvy = inbvy , & ! inbvy    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. iloy = iloy ) ! iloy     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. if ( iflag /= 0 ) error stop 'error' if ( mixture ) val = exp ( val ) ms_fe_f % bs_fe_f ( e )% vn ( node_number , P_N ) = val ms_fe_f % bs_fe_f ( e )% bc ( node_number , REY ) = 0 enddo enddo enddo deallocate ( log_press , coeff , tx , ty , x , y ) return endsubroutine interp_ts_bs_splin","loc":"proc/interp_ts_bs_splin.html"},{"tags":"","title":"save_ms_field – MUSST","text":"public subroutine save_ms_field(ms_fe_f, file_name, code, nodal) Note Subroutine to save the information controlled by code of the whole mesh. The genertaed file is a ```.sur``` file. Arguments Type Intent Optional Attributes Name type( MS_FE_FILM ), intent(in) :: ms_fe_f character(len=*), intent(in) :: file_name filename like \"./out/pressure.sur\" integer(kind=I4), intent(in) :: code saved information like P_N logical(kind=I4), intent(in) :: nodal if false : cell value, if true : nodal value Calls proc~~save_ms_field~~CallsGraph proc~save_ms_field save_ms_field proc~empty empty proc~save_ms_field->proc~empty proc~ms_fe_f_2_mat ms_fe_f_2_mat proc~save_ms_field->proc~ms_fe_f_2_mat proc~init_scal init_scal proc~save_ms_field->proc~init_scal proc~write_surf write_surf proc~save_ms_field->proc~write_surf proc~init_scal->proc~empty proc~get_unit get_unit proc~write_surf->proc~get_unit proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~lower lower proc~write_surf->proc~lower proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string proc~c_f_string->proc~empty Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~save_ms_field~~CalledByGraph proc~save_ms_field save_ms_field proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~save_ms_field proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~run_test run_test proc~run_test->proc~test_slider_ms proc~run_test->proc~test_rough_ms program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code save_ms_field Source Code subroutine save_ms_field ( ms_fe_f , file_name , code , nodal ) implicit none type ( MS_FE_FILM ), intent ( in ) :: ms_fe_f character ( len =* ), intent ( in ) :: file_name !! *filename like \"./out/pressure.sur\"* integer ( kind = I4 ), intent ( in ) :: code !! *saved information like P_N* logical ( kind = I4 ), intent ( in ) :: nodal !! *if false : cell value, if true : nodal value* integer ( kind = I4 ) :: nnx , nny character ( len = 8 ) :: unit_z , string integer ( kind = I4 ), dimension ( 1 ) :: i1 , i2 real ( kind = R8 ), allocatable , dimension (:,:) :: mat call ms_fe_f_2_mat ( ms_fe_f , code , nodal , mat ) nnx = ubound ( mat , 1 ) nny = ubound ( mat , 2 ) call empty ( unit_z ) if ( nodal ) then string = trim ( ms_fe_f % ts_fe_f % vn_name ( code )) else string = trim ( ms_fe_f % ts_fe_f % vc_name ( code )) endif i1 = index ( string , '(' ) + 1 i2 = index ( string , ')' ) - 1 unit_z = string ( i1 ( 1 ): i2 ( 1 )) call init_scal ( scal = scal_tmp , & ! nx = nnx , & ! ny = nny , & ! lx = ms_fe_f % ts_fe_f % m % lx , & ! default unit : m ly = ms_fe_f % ts_fe_f % m % ly , & ! unit_z = unit_z ) ! call write_surf ( nom_fic = file_name , & ! tab_s = mat , & ! scal = scal_tmp ) deallocate ( mat ) return endsubroutine save_ms_field","loc":"proc/save_ms_field.html"},{"tags":"","title":"ms_fe_f_2_mat – MUSST","text":"public subroutine ms_fe_f_2_mat(ms_fe_f, code, nodal, mat) Note Subroutine to transform a MS_FE_FILM information into a matrix Arguments Type Intent Optional Attributes Name type( MS_FE_FILM ), intent(in) :: ms_fe_f integer(kind=I4), intent(in) :: code saved information like P_N logical(kind=I4), intent(in) :: nodal if false : cell value, if true : nodal value real(kind=R8), intent(inout), allocatable :: mat (:,:) output matrix containing the information Called by proc~~ms_fe_f_2_mat~~CalledByGraph proc~ms_fe_f_2_mat ms_fe_f_2_mat proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~ms_fe_f_2_mat proc~save_ms_field save_ms_field proc~solve_ms_prob->proc~save_ms_field proc~save_ms_field->proc~ms_fe_f_2_mat proc~smooth_ms_fe_f smooth_ms_fe_f proc~smooth_ms_fe_f->proc~ms_fe_f_2_mat proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~run_test run_test proc~run_test->proc~test_slider_ms proc~run_test->proc~test_rough_ms program~main main program~main->proc~run_test var panprocms_fe_f_2_matCalledByGraph = svgPanZoom('#procms_fe_f_2_matCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ms_fe_f_2_mat Source Code subroutine ms_fe_f_2_mat ( ms_fe_f , code , nodal , mat ) implicit none type ( MS_FE_FILM ), intent ( in ) :: ms_fe_f integer ( kind = I4 ), intent ( in ) :: code !! *saved information like P_N* logical ( kind = I4 ), intent ( in ) :: nodal !! *if false : cell value, if true : nodal value* real ( kind = R8 ), intent ( inout ), allocatable :: mat (:,:) !! *output matrix containing the information* integer ( kind = I4 ) :: ts_nx , ts_ny , ex , ey , e , ne_x , ne_y , nnx , nny , c integer ( kind = I4 ), allocatable , dimension (:) :: bs_nx , bs_ny ts_nx = ms_fe_f % ts_fe_f % m % nx - 1 ts_ny = ms_fe_f % ts_fe_f % m % ny - 1 allocate ( bs_nx ( ts_nx * ts_ny ), bs_ny ( ts_nx * ts_ny )) bs_nx (:) = ms_fe_f % bs_fe_f (:)% m % nx - 1 bs_ny (:) = ms_fe_f % bs_fe_f (:)% m % ny - 1 nnx = sum ( bs_nx ( 1 : ts_nx ) ) nny = sum ( bs_ny ( 1 : ts_ny ) ) if ( nodal ) then nnx = nnx + 1 nny = nny + 1 endif allocate ( mat ( 1 : nnx , 1 : nny ) ) ; mat = - 1. c = 0 if ( nodal ) c = 1 do ey = 1 , ts_ny do ex = 1 , ts_nx e = ts_nx * ( ey - 1 ) + ex ne_x = bs_nx ( e ) * ( ex - 1 ) + 1 ne_y = bs_ny ( e ) * ( ey - 1 ) + 1 mat ( ne_x :( ne_x + bs_nx ( e ) - 1 + c ), & ne_y :( ne_y + bs_ny ( e ) - 1 + c ) ) = reshape ( ms_fe_f % bs_fe_f ( e )% vn (:, code ), ( / bs_nx ( e ) + c , bs_ny ( e ) + c / ) ) enddo enddo deallocate ( bs_nx , bs_ny ) return endsubroutine ms_fe_f_2_mat","loc":"proc/ms_fe_f_2_mat.html"},{"tags":"","title":"mat_2_ms_fe_f – MUSST","text":"private subroutine mat_2_ms_fe_f(ms_fe_f, code, nodal, mat) Note Subroutine to transform a matrix into a MS_FE_FILM Arguments Type Intent Optional Attributes Name type( MS_FE_FILM ), intent(inout) :: ms_fe_f integer(kind=I4), intent(in) :: code saved information like P_N logical(kind=I4), intent(in) :: nodal if false : cell value, if true : nodal value real(kind=R8), intent(in), dimension(:,:) :: mat input matrix containing the information Called by proc~~mat_2_ms_fe_f~~CalledByGraph proc~mat_2_ms_fe_f mat_2_ms_fe_f proc~smooth_ms_fe_f smooth_ms_fe_f proc~smooth_ms_fe_f->proc~mat_2_ms_fe_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code mat_2_ms_fe_f Source Code subroutine mat_2_ms_fe_f ( ms_fe_f , code , nodal , mat ) implicit none type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f integer ( kind = I4 ), intent ( in ) :: code !! *saved information like P_N* logical ( kind = I4 ), intent ( in ) :: nodal !! *if false : cell value, if true : nodal value* real ( kind = R8 ), intent ( in ), dimension (:,:) :: mat !! *input matrix containing the information* integer ( kind = I4 ) :: ts_nx , ts_ny , ex , ey , e , ne_x , ne_y , nnx , nny , c integer ( kind = I4 ), allocatable , dimension (:) :: bs_nx , bs_ny ts_nx = ms_fe_f % ts_fe_f % m % nx - 1 ts_ny = ms_fe_f % ts_fe_f % m % ny - 1 allocate ( bs_nx ( ts_nx * ts_ny ), bs_ny ( ts_nx * ts_ny )) bs_nx (:) = ms_fe_f % bs_fe_f (:)% m % nx - 1 bs_ny (:) = ms_fe_f % bs_fe_f (:)% m % ny - 1 nnx = sum ( bs_nx ( 1 : ts_nx ) ) nny = sum ( bs_ny ( 1 : ts_ny ) ) if ( nodal ) then nnx = nnx + 1 nny = nny + 1 endif c = 0 if ( nodal ) c = 1 do ey = 1 , ts_ny do ex = 1 , ts_nx e = ts_nx * ( ey - 1 ) + ex ne_x = bs_nx ( e ) * ( ex - 1 ) + 1 ne_y = bs_ny ( e ) * ( ey - 1 ) + 1 ms_fe_f % bs_fe_f ( e )% vn (:, code ) = reshape ( mat ( ne_x :( ne_x + bs_nx ( e ) - 1 + c ), & ! ne_y :( ne_y + bs_ny ( e ) - 1 + c ) ), ( / ( bs_nx ( e ) + c ) * ( bs_ny ( e ) + c ) / ) ) enddo enddo deallocate ( bs_nx , bs_ny ) return endsubroutine mat_2_ms_fe_f","loc":"proc/mat_2_ms_fe_f.html"},{"tags":"","title":"smooth_ms_fe_f – MUSST","text":"private subroutine smooth_ms_fe_f(ms_fe_f, code, nodal) Note Subroutine to smooth a MS_FE_FILM field, the pressure for instance. By default, the smoothing kernel is a 5x5 Gaussian filter Arguments Type Intent Optional Attributes Name type( MS_FE_FILM ), intent(inout) :: ms_fe_f integer(kind=I4), intent(in) :: code saved information like P_N logical(kind=I4), intent(in) :: nodal if false : cell value, if true : nodal value Calls proc~~smooth_ms_fe_f~~CallsGraph proc~smooth_ms_fe_f smooth_ms_fe_f proc~smooth_mat smooth_mat proc~smooth_ms_fe_f->proc~smooth_mat proc~ms_fe_f_2_mat ms_fe_f_2_mat proc~smooth_ms_fe_f->proc~ms_fe_f_2_mat proc~mat_2_ms_fe_f mat_2_ms_fe_f proc~smooth_ms_fe_f->proc~mat_2_ms_fe_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code smooth_ms_fe_f Source Code subroutine smooth_ms_fe_f ( ms_fe_f , code , nodal ) implicit none type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f integer ( kind = I4 ), intent ( in ) :: code !! *saved information like P_N* logical ( kind = I4 ), intent ( in ) :: nodal !! *if false : cell value, if true : nodal value* integer ( kind = I4 ) :: nx , ny real ( kind = R8 ), allocatable , dimension (:,:) :: mat call ms_fe_f_2_mat ( ms_fe_f , code , nodal , mat ) nx = ubound ( mat , 1 ) ; ny = ubound ( mat , 2 ) call smooth_mat ( mat , nx , ny , s = 5 ) call mat_2_ms_fe_f ( ms_fe_f , code , nodal , mat ) deallocate ( mat ) return endsubroutine smooth_ms_fe_f","loc":"proc/smooth_ms_fe_f.html"},{"tags":"","title":"smooth_mat – MUSST","text":"private subroutine smooth_mat(mat, nx, ny, s) Note Subroutine to smooth a matrix form field, the pressure for instance. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(nx, ny) :: mat matrix integer(kind=I4), intent(in) :: nx matrix x size integer(kind=I4), intent(in) :: ny matrix y size integer(kind=I4), intent(in) :: s kernel size Called by proc~~smooth_mat~~CalledByGraph proc~smooth_mat smooth_mat proc~smooth_ms_fe_f smooth_ms_fe_f proc~smooth_ms_fe_f->proc~smooth_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code smooth_mat Source Code subroutine smooth_mat ( mat , nx , ny , s ) implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *matrix x size* integer ( kind = I4 ), intent ( in ) :: ny !! *matrix y size* integer ( kind = I4 ), intent ( in ) :: s !! *kernel size* real ( kind = R8 ), intent ( inout ), dimension ( nx , ny ) :: mat !! *matrix* integer ( kind = I4 ), dimension ( 3 , 3 ) :: kernel3 integer ( kind = I4 ), dimension ( 5 , 5 ) :: kernel5 real ( kind = R8 ), dimension ( 5 , 5 ) :: mi_mat real ( kind = R8 ), dimension (:,:), allocatable :: mat_tmp integer ( kind = I4 ) :: i , j allocate ( mat_tmp ( nx , ny ) ) if ( s == 3 ) then kernel3 ( 1 : 3 , 1 : 3 ) = reshape (( / 1 , 2 , 1 , & ! 2 , 4 , 2 , & ! 1 , 2 , 1 / ), ( / 3 , 3 / )) do j = 1 + 1 , nx - 1 do i = 1 + 1 , ny - 1 mi_mat ( 1 : 3 , 1 : 3 ) = mat ( i - 1 : i + 1 , j - 1 : j + 1 ) mat_tmp ( i , j ) = sum ( mi_mat ( 1 : 3 , 1 : 3 ) * kernel3 ( 1 : 3 , 1 : 3 ) ) / 1 6. enddo enddo do j = 1 + 1 , nx - 1 do i = 1 + 1 , ny - 1 mat ( i , j ) = mat_tmp ( i , j ) enddo enddo endif if ( s == 5 ) then kernel5 ( 1 : 5 , 1 : 5 ) = reshape (( / 1 , 4 , 6 , 4 , 1 , & ! 4 , 16 , 24 , 16 , 4 , & ! 6 , 24 , 36 , 24 , 6 , & ! 4 , 16 , 24 , 16 , 4 , & ! 1 , 4 , 6 , 4 , 1 / ), ( / 5 , 5 / )) do j = 1 + 2 , nx - 2 do i = 1 + 2 , ny - 2 mi_mat ( 1 : 5 , 1 : 5 ) = mat ( i - 2 : i + 2 , j - 2 : j + 2 ) mat_tmp ( i , j ) = sum ( mi_mat ( 1 : 5 , 1 : 5 ) * kernel5 ( 1 : 5 , 1 : 5 ) ) / 25 6. enddo enddo do j = 1 + 2 , nx - 2 do i = 1 + 2 , ny - 2 mat ( i , j ) = mat_tmp ( i , j ) enddo enddo endif deallocate ( mat_tmp ) return endsubroutine smooth_mat","loc":"proc/smooth_mat.html"},{"tags":"","title":"multi_scale_assembly_fe_film_reynolds – MUSST","text":"private subroutine multi_scale_assembly_fe_film_reynolds(ms_fe_f, ms_mat, ass_c) Note Subroutine to assemble the top-scale system, all of the bottom-scale systems being solved. Arguments Type Intent Optional Attributes Name type( MS_FE_FILM ), intent(inout) :: ms_fe_f type(MS_MAT_SOLV), intent(inout) :: ms_mat solver type matrices table integer(kind=I4), intent(in) :: ass_c assembly type Calls proc~~multi_scale_assembly_fe_film_reynolds~~CallsGraph proc~multi_scale_assembly_fe_film_reynolds multi_scale_assembly_fe_film_reynolds omp_get_thread_num omp_get_thread_num proc~multi_scale_assembly_fe_film_reynolds->omp_get_thread_num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~multi_scale_assembly_fe_film_reynolds~~CalledByGraph proc~multi_scale_assembly_fe_film_reynolds multi_scale_assembly_fe_film_reynolds proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~multi_scale_assembly_fe_film_reynolds proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~run_test run_test proc~run_test->proc~test_slider_ms proc~run_test->proc~test_rough_ms program~main main program~main->proc~run_test var panprocmulti_scale_assembly_fe_film_reynoldsCalledByGraph = svgPanZoom('#procmulti_scale_assembly_fe_film_reynoldsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code multi_scale_assembly_fe_film_reynolds Source Code subroutine multi_scale_assembly_fe_film_reynolds ( ms_fe_f , ms_mat , ass_c ) implicit none type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f !! type ( MS_MAT_SOLV ), intent ( inout ) :: ms_mat !! *solver type matrices table* integer ( kind = I4 ), intent ( in ) :: ass_c !! *assembly type* real ( kind = R8 ), dimension (:,:,:), allocatable :: ke_ij real ( kind = R8 ), dimension (:,:) , allocatable :: be_i integer ( kind = I4 ), dimension (:,:) , allocatable :: ind_e integer ( kind = I4 ), dimension ( 2 ) :: compt integer ( kind = I4 ) :: e , i , ii , ne real ( kind = R8 ) :: val_t logical ( kind = I4 ) :: first_assembly ne = ms_fe_f % ts_fe_f % m % ne allocate ( ke_ij ( ne , MAX_NNC , MAX_NNC ) ) allocate ( be_i ( ne , MAX_NNC ) ) allocate ( ind_e ( ne , MAX_NNC ) ) ! assembly compt (:) = 1 ms_mat % ts_mat % b = 0._R8 if (. not . allocated ( ms_mat % ass_loc_in_mat )) then allocate ( ms_mat % ass_loc_in_mat ( ne )) ms_mat % ass_loc_in_mat = - 1 endif ! check for first assembly: save the assembly location in ass_loc_in_mat if ( ms_mat % ass_loc_in_mat ( 1 ) == - 1 ) then first_assembly = . true . ms_mat % ass_loc_in_mat ( 1 ) = 1 else first_assembly = . false . endif do e = 1 , ne ! copy of the boundary conditions do i = 1 , 4 ii = ms_fe_f % ts_fe_f % m % con ( e , i ) be_i ( e , i ) = ms_fe_f % ts_fe_f % vn ( ii , P_N ) enddo enddo ! elementary matrices calculation !------------------------------------------- !open mp instructions (parallele computation) !$omp parallel !$omp do schedule(runtime) do e = 1 , ms_fe_f % ts_fe_f % m % ne if ( VERBOSE >= 3 ) write ( OPU , * ) \"MS elements \" , e , ' thread ' , omp_get_thread_num () call elementary_full_domain_FE_film_reynolds ( fe_f = ms_fe_f % bs_fe_f ( e ), & mat = ms_mat % bs_mat ( e ), & ke_ij = ke_ij ( e , :, :), & be_i = be_i ( e , :), & ind_e = ind_e ( e , :)) enddo !$OMP end do !$OMP end parallel !end open mp instructions !------------------------------------------- do e = 1 , ne ! consideration of the bc condition do i = 1 , 4 ii = ms_fe_f % ts_fe_f % m % con ( e , i ) ind_e ( e , i ) = ii if ( ms_fe_f % ts_fe_f % bc ( ii , REY ) == 0 ) then val_t = ke_ij ( e , i , i ) ke_ij ( e , i , :) = 0._R8 ke_ij ( e , i , i ) = val_t be_i ( e , i ) = 0._R8 endif enddo ! copy of the rhs member do i = 1 , 4 ii = ms_fe_f % ts_fe_f % m % con ( e , i ) ms_mat % ts_mat % b ( ii ) = ms_mat % ts_mat % b ( ii ) + be_i ( e , i ) enddo enddo ! assembly of the elemental matrix in the solver matrix if ( ass_c == ASS ) then do e = 1 , ne call assemble_in_mat_sol ( mat = ms_mat % ts_mat , & num = e , & nelt = 4 , & nline = 4 , & tind = ind_e ( e , :), & m_elt = ke_ij ( e , :, :), & compt = compt ) enddo ms_mat % ts_mat % eltptr ( 1 ) = 1 endif deallocate ( ke_ij , be_i , ind_e ) return endsubroutine multi_scale_assembly_fe_film_reynolds","loc":"proc/multi_scale_assembly_fe_film_reynolds.html"},{"tags":"","title":"run_test – MUSST","text":"public subroutine run_test() Note Subroutine to run the specified test Arguments None Calls proc~~run_test~~CallsGraph proc~run_test run_test proc~test_slider_fe test_slider_fe proc~run_test->proc~test_slider_fe proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_bearing_x_fe test_bearing_x_fe proc~run_test->proc~test_bearing_x_fe proc~test_bearing_y_fe test_bearing_y_fe proc~run_test->proc~test_bearing_y_fe proc~get_unit get_unit proc~run_test->proc~get_unit proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_pocket_fe test_pocket_fe proc~run_test->proc~test_pocket_fe proc~test_rough_fe test_rough_fe proc~run_test->proc~test_rough_fe proc~solve_fe_prob solve_fe_prob proc~test_slider_fe->proc~solve_fe_prob proc~modify_h_slider modify_h_slider proc~test_slider_fe->proc~modify_h_slider proc~init_fe_prob init_fe_prob proc~test_slider_fe->proc~init_fe_prob proc~modify_h_slider_ms modify_h_slider_MS proc~test_slider_ms->proc~modify_h_slider_ms proc~init_ms_prob init_ms_prob proc~test_slider_ms->proc~init_ms_prob proc~solve_ms_prob solve_ms_prob proc~test_slider_ms->proc~solve_ms_prob proc~modify_h_bearing modify_h_bearing proc~test_bearing_x_fe->proc~modify_h_bearing proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_x_fe->proc~init_fe_prob proc~modify_h_bearing_y modify_h_bearing_y proc~test_bearing_y_fe->proc~modify_h_bearing_y proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_bearing_y_fe->proc~init_fe_prob proc~apply_roughness_ms apply_roughness_MS proc~test_rough_ms->proc~apply_roughness_ms proc~test_rough_ms->proc~init_ms_prob proc~test_rough_ms->proc~solve_ms_prob proc~init_rough_prob init_rough_prob proc~test_rough_ms->proc~init_rough_prob proc~test_pocket_fe->proc~solve_fe_prob proc~modify_h_pocket modify_h_pocket proc~test_pocket_fe->proc~modify_h_pocket proc~test_pocket_fe->proc~init_fe_prob proc~test_rough_fe->proc~solve_fe_prob proc~apply_roughness apply_roughness proc~test_rough_fe->proc~apply_roughness proc~test_rough_fe->proc~init_rough_prob proc~test_rough_fe->proc~init_fe_prob proc~apply_roughness_ms->proc~apply_roughness proc~compute_corner_fluxes compute_corner_fluxes proc~solve_fe_prob->proc~compute_corner_fluxes proc~solve_fe_film solve_FE_film proc~solve_fe_prob->proc~solve_fe_film proc~save_fe_field save_fe_field proc~solve_fe_prob->proc~save_fe_field proc~modify_h_slider_ms->proc~modify_h_slider proc~multi_scale_create_rect_fe_film multi_scale_create_rect_fe_film proc~init_ms_prob->proc~multi_scale_create_rect_fe_film proc~save_ms_field save_ms_field proc~solve_ms_prob->proc~save_ms_field proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~ms_fe_f_2_mat ms_fe_f_2_mat proc~solve_ms_prob->proc~ms_fe_f_2_mat proc~create_rect_fe_film create_rect_FE_film proc~init_fe_prob->proc~create_rect_fe_film proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~multi_scale_create_rect_fe_film->proc~create_rect_fe_film proc~save_ms_field->proc~ms_fe_f_2_mat proc~init_scal init_scal proc~save_ms_field->proc~init_scal proc~empty empty proc~save_ms_field->proc~empty proc~write_surf write_surf proc~save_ms_field->proc~write_surf omp_get_thread_num omp_get_thread_num proc~solve_fe_film->omp_get_thread_num proc~solve_syst solve_syst proc~solve_fe_film->proc~solve_syst proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~convert_matrice_format convert_matrice_format proc~solve_fe_film->proc~convert_matrice_format proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~multi_scale_solve_fe_film->omp_get_thread_num proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~convert_matrice_format proc~multi_scale_solve_fe_film->proc~apply_bc_fe_film_simple proc~multi_scale_assembly_fe_film_reynolds multi_scale_assembly_fe_film_reynolds proc~multi_scale_solve_fe_film->proc~multi_scale_assembly_fe_film_reynolds proc~save_fe_field->proc~init_scal proc~save_fe_field->proc~empty proc~save_fe_field->proc~write_surf proc~create_rect_x_ymesh create_rect_x_ymesh proc~create_rect_fe_film->proc~create_rect_x_ymesh proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~init_scal->proc~empty proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~write_surf->proc~get_unit proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~lower lower proc~write_surf->proc~lower proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~multi_scale_assembly_fe_film_reynolds->omp_get_thread_num proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string dmumps dmumps proc~init_solver->dmumps mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~c_f_string->proc~empty interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panprocrun_testCallsGraph = svgPanZoom('#procrun_testCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~run_test~~CalledByGraph proc~run_test run_test program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code run_test Source Code subroutine run_test implicit none mat % slv_t = SOLVER_TS call get_unit ( unit_num_res ) ; open ( unit = unit_num_res , file = trim ( res_file ), status = 'unknown' ) select case ( test_num ) case ( 1 ); call test_slider_fe case ( 11 ); call test_slider_ms case ( 2 ); call test_bearing_x_fe case ( 3 ); call test_bearing_y_fe case ( 4 ); call test_rough_fe case ( 14 ); call test_rough_ms case ( 5 ); call test_pocket_fe case default ; stop 'Bad test number' endselect close ( unit_num_res ) return endsubroutine run_test","loc":"proc/run_test.html"},{"tags":"","title":"read_data – MUSST","text":"public subroutine read_data(iunit, dir) Note Subroutine to read the 'EXEC_MUSST' section Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: iunit character(len=15), intent(in) :: dir output directory Calls proc~~read_data~~CallsGraph proc~read_data read_data num_par num_par proc~read_data->num_par Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_data~~CalledByGraph proc~read_data read_data proc~read_config read_config proc~read_config->proc~read_data program~main main program~main->proc~read_config Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_data Source Code subroutine read_data ( iunit , dir ) implicit none integer ( kind = I4 ), intent ( in ) :: iunit character ( len = 15 ), intent ( in ) :: dir !! *output directory* integer ( kind = I4 ) :: err_read character ( len = 064 ) :: word res_dir = dir compare_solution_file = 0 data_f % h_0 = - 1._R8 data_f % h_g = - 1._R8 data_f % V_x = 0._R8 data_f % V_y = 0._R8 data_f % pb_type = 0 data_f % fl % fluid_type = - 1 data_f % fl % p_0 = - 1.e10_R8 data_f % fl % rho_0 = - 1.e10_R8 data_f % fl % mu_0 = - 1.e10_R8 data_f % fl % rg = 28 7._R8 data_f % fl % lambda = 1.e-5_R8 data_f % fl % T_0 = 27 3._R8 surface_file = \"no_file\" compare_solution_file = 0 pressure_solution_file = \"no_file\" lx = - 1._R8 ly = - 1._R8 nx = - 1 ny = - 1 n_mac = - 1 bc ( 1 : 4 ) = [ 1.e5_R8 , 1.e5_R8 , 1.e5_R8 , 1.e5_R8 ] num_pts = NUM_PAR ( 0._R8 , 1.e10_R8 , 0 , 0 ) num_pbs = NUM_PAR ( 0._R8 , 1.e10_R8 , 0 , 0 ) sq = 0._R8 s_vtk = 0 ms_vtk = \"no_file\" prof_ts = \"no_file\" prof_bs = \"no_file\" res_file = \"no_file\" do word = repeat ( ' ' , len ( word )) read ( iunit , * , iostat = err_read ) word if ( index ( word , '[END_MUSST]' ) /= 0 ) exit if ( index ( word , '[PROBLEM_TYPE]' ) /= 0 ) then read ( iunit , * ) test_num cycle endif if ( index ( word , '[GAP]' ) /= 0 ) then read ( iunit , * ) data_f % h_0 , data_f % h_g cycle endif if ( index ( word , '[SPEED]' ) /= 0 ) then read ( iunit , * ) data_f % V_x , data_f % V_y cycle endif if ( index ( word , '[ELASTICITY]' ) /= 0 ) then read ( iunit , * ) data_f % pb_type cycle endif if ( index ( word , '[FLUID_TYPE]' ) /= 0 ) then read ( iunit , * ) data_f % fl % fluid_type cycle endif if ( index ( word , '[AMBIENT_PRESSURE]' ) /= 0 ) then read ( iunit , * ) data_f % fl % p_0 cycle endif if ( index ( word , '[DENSITY]' ) /= 0 ) then read ( iunit , * ) data_f % fl % rho_0 cycle endif if ( index ( word , '[VISCOSITY]' ) /= 0 ) then read ( iunit , * ) data_f % fl % mu_0 cycle endif if ( index ( word , '[GAZ_CONSTANT]' ) /= 0 ) then read ( iunit , * ) data_f % fl % rg cycle endif if ( index ( word , '[MIXTURE_TRANSITION]' ) /= 0 ) then read ( iunit , * ) data_f % fl % lambda cycle endif if ( index ( word , '[AMBIENT_TEMPERATURE]' ) /= 0 ) then read ( iunit , * ) data_f % fl % T_0 cycle endif if ( index ( word , '[ROUGH_SURFACE]' ) /= 0 ) then read ( iunit , * ) surface_file cycle endif if ( index ( word , '[ROUGH_SURFACE_SOLUTION]' ) /= 0 ) then read ( iunit , * ) compare_solution_file read ( iunit , * ) pressure_solution_file cycle endif if ( index ( word , '[LENGTH]' ) /= 0 ) then read ( iunit , * ) lx , ly cycle endif if ( index ( word , '[NUMBER_NODES]' ) /= 0 ) then read ( iunit , * ) nx , ny cycle endif if ( index ( word , '[NUMBER_MACRO_ELEMENTS]' ) /= 0 ) then read ( iunit , * ) n_mac cycle endif if ( index ( word , '[BOUNDARY_PRESSURES]' ) /= 0 ) then read ( iunit , * ) bc ( 1 : 4 ) cycle endif if ( index ( word , '[NUMERICAL_TS_PARAMETERS]' ) /= 0 ) then read ( iunit , * ) num_pts cycle endif if ( index ( word , '[NUMERICAL_BS_PARAMETERS]' ) /= 0 ) then read ( iunit , * ) num_pbs cycle endif if ( index ( word , '[HEIGHT_STD_DEV]' ) /= 0 ) then read ( iunit , * ) sq cycle endif if ( index ( word , '[VTK_OUTPUT]' ) /= 0 ) then read ( iunit , * ) s_vtk , ms_vtk read ( iunit , * ) prof_ts read ( iunit , * ) prof_bs read ( iunit , * ) res_file cycle endif enddo ms_vtk = \"out/\" // res_dir // \"/\" // trim ( ms_vtk ) prof_ts = \"out/\" // res_dir // \"/\" // trim ( prof_ts ) prof_bs = \"out/\" // res_dir // \"/\" // trim ( prof_bs ) res_file = \"out/\" // res_dir // \"/\" // trim ( res_file ) return endsubroutine read_data","loc":"proc/read_data.html"},{"tags":"","title":"modify_h_slider – MUSST","text":"private subroutine modify_h_slider(fe_f, lx) Note Subroutine to define the slider geometry Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(inout) :: fe_f real(kind=R8), intent(in) :: lx Called by proc~~modify_h_slider~~CalledByGraph proc~modify_h_slider modify_h_slider proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~modify_h_slider proc~modify_h_slider_ms modify_h_slider_MS proc~modify_h_slider_ms->proc~modify_h_slider proc~run_test run_test proc~run_test->proc~test_slider_fe proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_slider_ms->proc~modify_h_slider_ms program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code modify_h_slider Source Code subroutine modify_h_slider ( fe_f , lx ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f real ( kind = R8 ), intent ( in ) :: lx integer ( kind = I4 ) :: i do i = 1 , fe_f % m % n fe_f % vn ( i , H2_N ) = fe_f % data_f % h_0 + fe_f % data_f % h_0 * ( lx - fe_f % m % x ( i )) / lx enddo fe_f % vn (:, H_N ) = fe_f % vn (:, H2_N ) - fe_f % vn (:, H1_N ) return endsubroutine modify_h_slider","loc":"proc/modify_h_slider.html"},{"tags":"","title":"modify_h_pocket – MUSST","text":"private subroutine modify_h_pocket(fe_f, lx) Note Subroutine to define the pocket geometry Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(inout) :: fe_f real(kind=R8), intent(in) :: lx Called by proc~~modify_h_pocket~~CalledByGraph proc~modify_h_pocket modify_h_pocket proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~modify_h_pocket proc~run_test run_test proc~run_test->proc~test_pocket_fe program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code modify_h_pocket Source Code subroutine modify_h_pocket ( fe_f , lx ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f real ( kind = R8 ), intent ( in ) :: lx integer ( kind = I4 ) :: e , i logical ( kind = I4 ) :: groove fe_f % vn (:, H2_N ) = fe_f % data_f % h_0 fe_f % vn (:, H1_N ) = 0._R8 do e = 1 , fe_f % m % ne groove = . true . do i = 1 , 4 if ( fe_f % m % x ( fe_f % m % con ( e , i )) > ( lx / 2._R8 )) groove = . false . enddo if ( groove ) then fe_f % vc ( e , HG_C ) = fe_f % data_f % h_g endif enddo fe_f % vn (:, H_N ) = fe_f % vn (:, H2_N ) - fe_f % vn (:, H1_N ) return endsubroutine modify_h_pocket","loc":"proc/modify_h_pocket.html"},{"tags":"","title":"modify_h_slider_MS – MUSST","text":"private subroutine modify_h_slider_MS(ms_fe_f, lx) Note Subroutine to define the slider, in a multiscale problem Arguments Type Intent Optional Attributes Name type(MS_FE_FILM), intent(inout) :: ms_fe_f real(kind=R8), intent(in) :: lx Calls proc~~modify_h_slider_ms~~CallsGraph proc~modify_h_slider_ms modify_h_slider_MS proc~modify_h_slider modify_h_slider proc~modify_h_slider_ms->proc~modify_h_slider Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~modify_h_slider_ms~~CalledByGraph proc~modify_h_slider_ms modify_h_slider_MS proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~modify_h_slider_ms proc~run_test run_test proc~run_test->proc~test_slider_ms program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code modify_h_slider_MS Source Code subroutine modify_h_slider_MS ( ms_fe_f , lx ) implicit none type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f real ( kind = R8 ), intent ( in ) :: lx integer ( kind = I4 ) :: e call modify_h_slider ( ms_fe_f % ts_fe_f , lx ) do e = 1 , ms_fe_f % ts_fe_f % m % ne call modify_h_slider ( ms_fe_f % bs_fe_f ( e ), lx ) enddo return endsubroutine modify_h_slider_MS","loc":"proc/modify_h_slider_ms.html"},{"tags":"","title":"modify_h_bearing – MUSST","text":"private subroutine modify_h_bearing(fe_f, lx) Note Subroutine to define the bearing geometry Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(inout) :: fe_f real(kind=R8), intent(in) :: lx Called by proc~~modify_h_bearing~~CalledByGraph proc~modify_h_bearing modify_h_bearing proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~modify_h_bearing proc~run_test run_test proc~run_test->proc~test_bearing_x_fe program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code modify_h_bearing Source Code subroutine modify_h_bearing ( fe_f , lx ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f real ( kind = R8 ), intent ( in ) :: lx integer ( kind = I4 ) :: i do i = 1 , fe_f % m % n fe_f % vn ( i , H2_N ) = fe_f % data_f % h_0 + 0.5_R8 * fe_f % data_f % h_0 * cos ( 2 * PI_R8 * fe_f % m % x ( i ) / lx ) enddo fe_f % vn (:, H_N ) = fe_f % vn (:, H2_N ) - fe_f % vn (:, H1_N ) return endsubroutine modify_h_bearing","loc":"proc/modify_h_bearing.html"},{"tags":"","title":"modify_h_bearing_y – MUSST","text":"private subroutine modify_h_bearing_y(fe_f, ly) Note Subroutine to define the bearing geometry Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(inout) :: fe_f real(kind=R8), intent(in) :: ly Called by proc~~modify_h_bearing_y~~CalledByGraph proc~modify_h_bearing_y modify_h_bearing_y proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~modify_h_bearing_y proc~run_test run_test proc~run_test->proc~test_bearing_y_fe program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code modify_h_bearing_y Source Code subroutine modify_h_bearing_y ( fe_f , ly ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f real ( kind = R8 ), intent ( in ) :: ly integer ( kind = I4 ) :: i do i = 1 , fe_f % m % n fe_f % vn ( i , H2_N ) = fe_f % data_f % h_0 + 0.5_R8 * fe_f % data_f % h_0 * cos ( 2 * PI_R8 * fe_f % m % y ( i ) / ly ) enddo fe_f % vn (:, H_N ) = fe_f % vn (:, H2_N ) - fe_f % vn (:, H1_N ) return endsubroutine modify_h_bearing_y","loc":"proc/modify_h_bearing_y.html"},{"tags":"","title":"apply_roughness – MUSST","text":"private subroutine apply_roughness(fe_f, tab_s) Note Subroutine to apply a roughness table to a surface Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(inout) :: fe_f real(kind=R8), intent(in), dimension(:,:) :: tab_s Called by proc~~apply_roughness~~CalledByGraph proc~apply_roughness apply_roughness proc~apply_roughness_ms apply_roughness_MS proc~apply_roughness_ms->proc~apply_roughness proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~apply_roughness proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~apply_roughness_ms proc~run_test run_test proc~run_test->proc~test_rough_fe proc~run_test->proc~test_rough_ms program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_roughness Source Code subroutine apply_roughness ( fe_f , tab_s ) implicit none type ( FE_FILM ), intent ( inout ) :: fe_f real ( kind = R8 ), intent ( in ), dimension (:,:) :: tab_s real ( kind = R8 ) :: xp , yp integer ( kind = I4 ) :: k , i , j do k = 1 , fe_f % m % n xp = fe_f % m % x ( k ) yp = fe_f % m % y ( k ) i = int (( fe_f % m % nx - 1 ) * xp / fe_f % m % lx ) + 1 j = int (( fe_f % m % ny - 1 ) * yp / fe_f % m % ly ) + 1 fe_f % vn ( k , H2_N ) = fe_f % data_f % h_0 - tab_s ( i , j ) enddo fe_f % vn (:, H_N ) = fe_f % vn (:, H2_N ) - fe_f % vn (:, H1_N ) return endsubroutine apply_roughness","loc":"proc/apply_roughness.html"},{"tags":"","title":"apply_roughness_MS – MUSST","text":"private subroutine apply_roughness_MS(ms_fe_f, tab_s) Note Subroutine to apply a roughness table to a surface for a multiscale problem Arguments Type Intent Optional Attributes Name type(MS_FE_FILM), intent(inout) :: ms_fe_f real(kind=R8), intent(in), dimension(:,:) :: tab_s Calls proc~~apply_roughness_ms~~CallsGraph proc~apply_roughness_ms apply_roughness_MS proc~apply_roughness apply_roughness proc~apply_roughness_ms->proc~apply_roughness Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~apply_roughness_ms~~CalledByGraph proc~apply_roughness_ms apply_roughness_MS proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~apply_roughness_ms proc~run_test run_test proc~run_test->proc~test_rough_ms program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_roughness_MS Source Code subroutine apply_roughness_MS ( ms_fe_f , tab_s ) implicit none type ( MS_FE_FILM ), intent ( inout ) :: ms_fe_f real ( kind = R8 ), intent ( in ), dimension (:,:) :: tab_s real ( kind = R8 ) :: xp , yp integer ( kind = I4 ) :: k , i , j , e do k = 1 , ms_fe_f % ts_fe_f % m % n xp = ms_fe_f % ts_fe_f % m % x ( k ) yp = ms_fe_f % ts_fe_f % m % y ( k ) i = int (( ms_fe_f % ts_fe_f % m % nx - 1 ) * xp / ms_fe_f % ts_fe_f % m % lx ) + 1 j = int (( ms_fe_f % ts_fe_f % m % ny - 1 ) * yp / ms_fe_f % ts_fe_f % m % ly ) + 1 ms_fe_f % ts_fe_f % vn ( k , H2_N ) = ms_fe_f % ts_fe_f % data_f % h_0 - tab_s ( i , j ) enddo ms_fe_f % ts_fe_f % vn (:, H_N ) = ms_fe_f % ts_fe_f % vn (:, H2_N ) - ms_fe_f % ts_fe_f % vn (:, H1_N ) do e = 1 , ms_fe_f % ts_fe_f % m % ne call apply_roughness ( ms_fe_f % bs_fe_f ( e ), tab_s ) enddo return endsubroutine apply_roughness_ms","loc":"proc/apply_roughness_ms.html"},{"tags":"","title":"test_slider_fe – MUSST","text":"private subroutine test_slider_fe() Note Subroutine to run the slider test Arguments None Calls proc~~test_slider_fe~~CallsGraph proc~test_slider_fe test_slider_fe proc~solve_fe_prob solve_fe_prob proc~test_slider_fe->proc~solve_fe_prob proc~init_fe_prob init_fe_prob proc~test_slider_fe->proc~init_fe_prob proc~modify_h_slider modify_h_slider proc~test_slider_fe->proc~modify_h_slider proc~solve_fe_film solve_FE_film proc~solve_fe_prob->proc~solve_fe_film proc~compute_corner_fluxes compute_corner_fluxes proc~solve_fe_prob->proc~compute_corner_fluxes proc~save_fe_field save_fe_field proc~solve_fe_prob->proc~save_fe_field proc~create_rect_fe_film create_rect_FE_film proc~init_fe_prob->proc~create_rect_fe_film omp_get_thread_num omp_get_thread_num proc~solve_fe_film->omp_get_thread_num proc~solve_syst solve_syst proc~solve_fe_film->proc~solve_syst proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~convert_matrice_format convert_matrice_format proc~solve_fe_film->proc~convert_matrice_format proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~init_scal init_scal proc~save_fe_field->proc~init_scal proc~empty empty proc~save_fe_field->proc~empty proc~write_surf write_surf proc~save_fe_field->proc~write_surf proc~create_rect_x_ymesh create_rect_x_ymesh proc~create_rect_fe_film->proc~create_rect_x_ymesh proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~init_scal->proc~empty proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~get_unit get_unit proc~write_surf->proc~get_unit proc~lower lower proc~write_surf->proc~lower proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string dmumps dmumps proc~init_solver->dmumps mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~c_f_string->proc~empty interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panproctest_slider_feCallsGraph = svgPanZoom('#proctest_slider_feCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~test_slider_fe~~CalledByGraph proc~test_slider_fe test_slider_fe proc~run_test run_test proc~run_test->proc~test_slider_fe program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code test_slider_fe Source Code subroutine test_slider_fe implicit none call init_fe_prob call modify_h_slider ( fe_f , lx ) call solve_fe_prob return endsubroutine test_slider_fe","loc":"proc/test_slider_fe.html"},{"tags":"","title":"test_bearing_x_fe – MUSST","text":"private subroutine test_bearing_x_fe() Note Subroutine to run the bearing test Arguments None Calls proc~~test_bearing_x_fe~~CallsGraph proc~test_bearing_x_fe test_bearing_x_fe proc~modify_h_bearing modify_h_bearing proc~test_bearing_x_fe->proc~modify_h_bearing proc~solve_fe_prob solve_fe_prob proc~test_bearing_x_fe->proc~solve_fe_prob proc~init_fe_prob init_fe_prob proc~test_bearing_x_fe->proc~init_fe_prob proc~solve_fe_film solve_FE_film proc~solve_fe_prob->proc~solve_fe_film proc~compute_corner_fluxes compute_corner_fluxes proc~solve_fe_prob->proc~compute_corner_fluxes proc~save_fe_field save_fe_field proc~solve_fe_prob->proc~save_fe_field proc~create_rect_fe_film create_rect_FE_film proc~init_fe_prob->proc~create_rect_fe_film omp_get_thread_num omp_get_thread_num proc~solve_fe_film->omp_get_thread_num proc~solve_syst solve_syst proc~solve_fe_film->proc~solve_syst proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~convert_matrice_format convert_matrice_format proc~solve_fe_film->proc~convert_matrice_format proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~init_scal init_scal proc~save_fe_field->proc~init_scal proc~empty empty proc~save_fe_field->proc~empty proc~write_surf write_surf proc~save_fe_field->proc~write_surf proc~create_rect_x_ymesh create_rect_x_ymesh proc~create_rect_fe_film->proc~create_rect_x_ymesh proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~init_scal->proc~empty proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~get_unit get_unit proc~write_surf->proc~get_unit proc~lower lower proc~write_surf->proc~lower proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string dmumps dmumps proc~init_solver->dmumps mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~c_f_string->proc~empty interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panproctest_bearing_x_feCallsGraph = svgPanZoom('#proctest_bearing_x_feCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~test_bearing_x_fe~~CalledByGraph proc~test_bearing_x_fe test_bearing_x_fe proc~run_test run_test proc~run_test->proc~test_bearing_x_fe program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code test_bearing_x_fe Source Code subroutine test_bearing_x_fe implicit none call init_fe_prob call modify_h_bearing ( fe_f , lx ) call solve_fe_prob return endsubroutine test_bearing_x_fe","loc":"proc/test_bearing_x_fe.html"},{"tags":"","title":"test_bearing_y_fe – MUSST","text":"private subroutine test_bearing_y_fe() Note Subroutine to run the bearing test Arguments None Calls proc~~test_bearing_y_fe~~CallsGraph proc~test_bearing_y_fe test_bearing_y_fe proc~init_fe_prob init_fe_prob proc~test_bearing_y_fe->proc~init_fe_prob proc~solve_fe_prob solve_fe_prob proc~test_bearing_y_fe->proc~solve_fe_prob proc~modify_h_bearing_y modify_h_bearing_y proc~test_bearing_y_fe->proc~modify_h_bearing_y proc~create_rect_fe_film create_rect_FE_film proc~init_fe_prob->proc~create_rect_fe_film proc~solve_fe_film solve_FE_film proc~solve_fe_prob->proc~solve_fe_film proc~compute_corner_fluxes compute_corner_fluxes proc~solve_fe_prob->proc~compute_corner_fluxes proc~save_fe_field save_fe_field proc~solve_fe_prob->proc~save_fe_field omp_get_thread_num omp_get_thread_num proc~solve_fe_film->omp_get_thread_num proc~solve_syst solve_syst proc~solve_fe_film->proc~solve_syst proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~convert_matrice_format convert_matrice_format proc~solve_fe_film->proc~convert_matrice_format proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~init_scal init_scal proc~save_fe_field->proc~init_scal proc~empty empty proc~save_fe_field->proc~empty proc~write_surf write_surf proc~save_fe_field->proc~write_surf proc~create_rect_x_ymesh create_rect_x_ymesh proc~create_rect_fe_film->proc~create_rect_x_ymesh proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~init_scal->proc~empty proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~get_unit get_unit proc~write_surf->proc~get_unit proc~lower lower proc~write_surf->proc~lower proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string dmumps dmumps proc~init_solver->dmumps mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~c_f_string->proc~empty interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panproctest_bearing_y_feCallsGraph = svgPanZoom('#proctest_bearing_y_feCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~test_bearing_y_fe~~CalledByGraph proc~test_bearing_y_fe test_bearing_y_fe proc~run_test run_test proc~run_test->proc~test_bearing_y_fe program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code test_bearing_y_fe Source Code subroutine test_bearing_y_fe implicit none call init_fe_prob call modify_h_bearing_y ( fe_f , ly ) call solve_fe_prob return endsubroutine test_bearing_y_fe","loc":"proc/test_bearing_y_fe.html"},{"tags":"","title":"test_rough_fe – MUSST","text":"private subroutine test_rough_fe() Note Subroutine to run the deterministic rough surface test Arguments None Calls proc~~test_rough_fe~~CallsGraph proc~test_rough_fe test_rough_fe proc~solve_fe_prob solve_fe_prob proc~test_rough_fe->proc~solve_fe_prob proc~apply_roughness apply_roughness proc~test_rough_fe->proc~apply_roughness proc~init_rough_prob init_rough_prob proc~test_rough_fe->proc~init_rough_prob proc~init_fe_prob init_fe_prob proc~test_rough_fe->proc~init_fe_prob proc~solve_fe_film solve_FE_film proc~solve_fe_prob->proc~solve_fe_film proc~compute_corner_fluxes compute_corner_fluxes proc~solve_fe_prob->proc~compute_corner_fluxes proc~save_fe_field save_fe_field proc~solve_fe_prob->proc~save_fe_field proc~create_rect_fe_film create_rect_FE_film proc~init_fe_prob->proc~create_rect_fe_film omp_get_thread_num omp_get_thread_num proc~solve_fe_film->omp_get_thread_num proc~solve_syst solve_syst proc~solve_fe_film->proc~solve_syst proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~convert_matrice_format convert_matrice_format proc~solve_fe_film->proc~convert_matrice_format proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~init_scal init_scal proc~save_fe_field->proc~init_scal proc~empty empty proc~save_fe_field->proc~empty proc~write_surf write_surf proc~save_fe_field->proc~write_surf proc~create_rect_x_ymesh create_rect_x_ymesh proc~create_rect_fe_film->proc~create_rect_x_ymesh proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~init_scal->proc~empty proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~get_unit get_unit proc~write_surf->proc~get_unit proc~lower lower proc~write_surf->proc~lower proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string dmumps dmumps proc~init_solver->dmumps mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~c_f_string->proc~empty interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panproctest_rough_feCallsGraph = svgPanZoom('#proctest_rough_feCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~test_rough_fe~~CalledByGraph proc~test_rough_fe test_rough_fe proc~run_test run_test proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code test_rough_fe Source Code subroutine test_rough_fe implicit none call init_rough_prob call init_fe_prob call apply_roughness ( fe_f , tab_s ) call solve_fe_prob return endsubroutine test_rough_fe","loc":"proc/test_rough_fe.html"},{"tags":"","title":"test_pocket_fe – MUSST","text":"private subroutine test_pocket_fe() Note Subroutine to run the pocket test Arguments None Calls proc~~test_pocket_fe~~CallsGraph proc~test_pocket_fe test_pocket_fe proc~solve_fe_prob solve_fe_prob proc~test_pocket_fe->proc~solve_fe_prob proc~modify_h_pocket modify_h_pocket proc~test_pocket_fe->proc~modify_h_pocket proc~init_fe_prob init_fe_prob proc~test_pocket_fe->proc~init_fe_prob proc~solve_fe_film solve_FE_film proc~solve_fe_prob->proc~solve_fe_film proc~compute_corner_fluxes compute_corner_fluxes proc~solve_fe_prob->proc~compute_corner_fluxes proc~save_fe_field save_fe_field proc~solve_fe_prob->proc~save_fe_field proc~create_rect_fe_film create_rect_FE_film proc~init_fe_prob->proc~create_rect_fe_film omp_get_thread_num omp_get_thread_num proc~solve_fe_film->omp_get_thread_num proc~solve_syst solve_syst proc~solve_fe_film->proc~solve_syst proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~convert_matrice_format convert_matrice_format proc~solve_fe_film->proc~convert_matrice_format proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~init_scal init_scal proc~save_fe_field->proc~init_scal proc~empty empty proc~save_fe_field->proc~empty proc~write_surf write_surf proc~save_fe_field->proc~write_surf proc~create_rect_x_ymesh create_rect_x_ymesh proc~create_rect_fe_film->proc~create_rect_x_ymesh proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~init_scal->proc~empty proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~get_unit get_unit proc~write_surf->proc~get_unit proc~lower lower proc~write_surf->proc~lower proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string dmumps dmumps proc~init_solver->dmumps mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~c_f_string->proc~empty interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panproctest_pocket_feCallsGraph = svgPanZoom('#proctest_pocket_feCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~test_pocket_fe~~CalledByGraph proc~test_pocket_fe test_pocket_fe proc~run_test run_test proc~run_test->proc~test_pocket_fe program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code test_pocket_fe Source Code subroutine test_pocket_fe implicit none call init_fe_prob call modify_h_pocket ( fe_f , lx ) call solve_fe_prob return endsubroutine test_pocket_fe","loc":"proc/test_pocket_fe.html"},{"tags":"","title":"test_slider_ms – MUSST","text":"private subroutine test_slider_ms() Note Subroutine to run the multiscale slider test Arguments None Calls proc~~test_slider_ms~~CallsGraph proc~test_slider_ms test_slider_ms proc~init_ms_prob init_ms_prob proc~test_slider_ms->proc~init_ms_prob proc~solve_ms_prob solve_ms_prob proc~test_slider_ms->proc~solve_ms_prob proc~modify_h_slider_ms modify_h_slider_MS proc~test_slider_ms->proc~modify_h_slider_ms proc~multi_scale_create_rect_fe_film multi_scale_create_rect_fe_film proc~init_ms_prob->proc~multi_scale_create_rect_fe_film proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~ms_fe_f_2_mat ms_fe_f_2_mat proc~solve_ms_prob->proc~ms_fe_f_2_mat proc~save_ms_field save_ms_field proc~solve_ms_prob->proc~save_ms_field proc~modify_h_slider modify_h_slider proc~modify_h_slider_ms->proc~modify_h_slider omp_get_thread_num omp_get_thread_num proc~multi_scale_solve_fe_film->omp_get_thread_num proc~solve_syst solve_syst proc~multi_scale_solve_fe_film->proc~solve_syst proc~solve_fe_film solve_FE_film proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~convert_matrice_format convert_matrice_format proc~multi_scale_solve_fe_film->proc~convert_matrice_format proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~multi_scale_solve_fe_film->proc~apply_bc_fe_film_simple proc~multi_scale_assembly_fe_film_reynolds multi_scale_assembly_fe_film_reynolds proc~multi_scale_solve_fe_film->proc~multi_scale_assembly_fe_film_reynolds proc~create_rect_fe_film create_rect_FE_film proc~multi_scale_create_rect_fe_film->proc~create_rect_fe_film proc~save_ms_field->proc~ms_fe_f_2_mat proc~init_scal init_scal proc~save_ms_field->proc~init_scal proc~empty empty proc~save_ms_field->proc~empty proc~write_surf write_surf proc~save_ms_field->proc~write_surf proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~init_scal->proc~empty proc~solve_fe_film->omp_get_thread_num proc~solve_fe_film->proc~solve_syst proc~solve_fe_film->proc~convert_matrice_format proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~get_unit get_unit proc~write_surf->proc~get_unit proc~lower lower proc~write_surf->proc~lower proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~multi_scale_assembly_fe_film_reynolds->omp_get_thread_num proc~create_rect_x_ymesh create_rect_x_ymesh proc~create_rect_fe_film->proc~create_rect_x_ymesh proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string dmumps dmumps proc~init_solver->dmumps mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~c_f_string->proc~empty interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d var panproctest_slider_msCallsGraph = svgPanZoom('#proctest_slider_msCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~test_slider_ms~~CalledByGraph proc~test_slider_ms test_slider_ms proc~run_test run_test proc~run_test->proc~test_slider_ms program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code test_slider_ms Source Code subroutine test_slider_ms implicit none call init_ms_prob call modify_h_slider_MS ( ms_fe_f , lx ) call solve_ms_prob return endsubroutine test_slider_ms","loc":"proc/test_slider_ms.html"},{"tags":"","title":"test_rough_ms – MUSST","text":"private subroutine test_rough_ms() Note Subroutine to run the rough surface multiscale problem Arguments None Calls proc~~test_rough_ms~~CallsGraph proc~test_rough_ms test_rough_ms proc~apply_roughness_ms apply_roughness_MS proc~test_rough_ms->proc~apply_roughness_ms proc~init_ms_prob init_ms_prob proc~test_rough_ms->proc~init_ms_prob proc~solve_ms_prob solve_ms_prob proc~test_rough_ms->proc~solve_ms_prob proc~init_rough_prob init_rough_prob proc~test_rough_ms->proc~init_rough_prob proc~apply_roughness apply_roughness proc~apply_roughness_ms->proc~apply_roughness proc~multi_scale_create_rect_fe_film multi_scale_create_rect_fe_film proc~init_ms_prob->proc~multi_scale_create_rect_fe_film proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~ms_fe_f_2_mat ms_fe_f_2_mat proc~solve_ms_prob->proc~ms_fe_f_2_mat proc~save_ms_field save_ms_field proc~solve_ms_prob->proc~save_ms_field omp_get_thread_num omp_get_thread_num proc~multi_scale_solve_fe_film->omp_get_thread_num proc~solve_syst solve_syst proc~multi_scale_solve_fe_film->proc~solve_syst proc~solve_fe_film solve_FE_film proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~convert_matrice_format convert_matrice_format proc~multi_scale_solve_fe_film->proc~convert_matrice_format proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~multi_scale_solve_fe_film->proc~apply_bc_fe_film_simple proc~multi_scale_assembly_fe_film_reynolds multi_scale_assembly_fe_film_reynolds proc~multi_scale_solve_fe_film->proc~multi_scale_assembly_fe_film_reynolds proc~create_rect_fe_film create_rect_FE_film proc~multi_scale_create_rect_fe_film->proc~create_rect_fe_film proc~save_ms_field->proc~ms_fe_f_2_mat proc~init_scal init_scal proc~save_ms_field->proc~init_scal proc~empty empty proc~save_ms_field->proc~empty proc~write_surf write_surf proc~save_ms_field->proc~write_surf proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~init_scal->proc~empty proc~solve_fe_film->omp_get_thread_num proc~solve_fe_film->proc~solve_syst proc~solve_fe_film->proc~convert_matrice_format proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~get_unit get_unit proc~write_surf->proc~get_unit proc~lower lower proc~write_surf->proc~lower proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~multi_scale_assembly_fe_film_reynolds->omp_get_thread_num proc~create_rect_x_ymesh create_rect_x_ymesh proc~create_rect_fe_film->proc~create_rect_x_ymesh proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string dmumps dmumps proc~init_solver->dmumps mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~c_f_string->proc~empty interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d var panproctest_rough_msCallsGraph = svgPanZoom('#proctest_rough_msCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~test_rough_ms~~CalledByGraph proc~test_rough_ms test_rough_ms proc~run_test run_test proc~run_test->proc~test_rough_ms program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code test_rough_ms Source Code subroutine test_rough_ms implicit none call init_rough_prob call init_ms_prob call apply_roughness_MS ( ms_fe_f , tab_s ) call solve_ms_prob return endsubroutine test_rough_ms","loc":"proc/test_rough_ms.html"},{"tags":"","title":"init_fe_prob – MUSST","text":"private subroutine init_fe_prob() Note Subroutine to initialize a deterministic 'smooth' problem Arguments None Calls proc~~init_fe_prob~~CallsGraph proc~init_fe_prob init_fe_prob proc~create_rect_fe_film create_rect_FE_film proc~init_fe_prob->proc~create_rect_fe_film proc~create_rect_x_ymesh create_rect_x_ymesh proc~create_rect_fe_film->proc~create_rect_x_ymesh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_fe_prob~~CalledByGraph proc~init_fe_prob init_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~init_fe_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~init_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~init_fe_prob proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~init_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~init_fe_prob proc~run_test run_test proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_fe_prob Source Code subroutine init_fe_prob implicit none if ( mod ( nx , 2 ) /= 1 ) then write ( OPU , * ) 'It is better to use an odd number of nodes in the x dir to have profile for comparison with analytical sol.' endif fe_f % m % nx = nx fe_f % m % ny = ny fe_f % m % lx = lx fe_f % m % ly = ly fe_f % m % zx = 0. fe_f % m % zy = 0. call create_rect_FE_film ( data_f = data_f , & num_p = num_pts , & fe_f = fe_f ) write ( OPU , * ) 'film created' return endsubroutine init_fe_prob","loc":"proc/init_fe_prob.html"},{"tags":"","title":"init_rough_prob – MUSST","text":"private subroutine init_rough_prob() Note Subroutine to initialize a deterministic 'rough' problem Arguments None Called by proc~~init_rough_prob~~CalledByGraph proc~init_rough_prob init_rough_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~init_rough_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~init_rough_prob proc~run_test run_test proc~run_test->proc~test_rough_ms proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_rough_prob Source Code subroutine init_rough_prob implicit none allocate ( tab_s ( nx , ny )) tab_s = 0._R8 call read_surf ( nom_fic = trim ( surface_file ), mu = 1._R8 , sq = sq , tab_s = tab_s , scal = scal_tmp ) return endsubroutine init_rough_prob","loc":"proc/init_rough_prob.html"},{"tags":"","title":"init_ms_prob – MUSST","text":"private subroutine init_ms_prob() Note Subroutine to initialize a multiscale 'smooth' problem Arguments None Calls proc~~init_ms_prob~~CallsGraph proc~init_ms_prob init_ms_prob proc~multi_scale_create_rect_fe_film multi_scale_create_rect_fe_film proc~init_ms_prob->proc~multi_scale_create_rect_fe_film proc~create_rect_fe_film create_rect_FE_film proc~multi_scale_create_rect_fe_film->proc~create_rect_fe_film proc~create_rect_x_ymesh create_rect_x_ymesh proc~create_rect_fe_film->proc~create_rect_x_ymesh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_ms_prob~~CalledByGraph proc~init_ms_prob init_ms_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~init_ms_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~init_ms_prob proc~run_test run_test proc~run_test->proc~test_slider_ms proc~run_test->proc~test_rough_ms program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_ms_prob Source Code subroutine init_ms_prob implicit none n_mic = ( nx - 1 ) / n_mac + 1 ms_fe_f % ts_fe_f % m % nx = n_mac + 1 ms_fe_f % ts_fe_f % m % ny = n_mac + 1 ms_fe_f % ts_fe_f % m % lx = lx ms_fe_f % ts_fe_f % m % ly = ly ms_fe_f % ts_fe_f % m % zx = 0. ms_fe_f % ts_fe_f % m % zy = 0. call multi_scale_create_rect_fe_film ( data_f = data_f , & bs_nx = n_mic , & bs_ny = n_mic , & num_pts = num_pts , & num_pbs = num_pbs , & ms_fe_f = ms_fe_f ) write ( OPU , * ) 'film created' return endsubroutine init_ms_prob","loc":"proc/init_ms_prob.html"},{"tags":"","title":"solve_fe_prob – MUSST","text":"private subroutine solve_fe_prob() Note Subroutine to solve a deterministic 'smooth' problem Arguments None Calls proc~~solve_fe_prob~~CallsGraph proc~solve_fe_prob solve_fe_prob proc~solve_fe_film solve_FE_film proc~solve_fe_prob->proc~solve_fe_film proc~compute_corner_fluxes compute_corner_fluxes proc~solve_fe_prob->proc~compute_corner_fluxes proc~save_fe_field save_fe_field proc~solve_fe_prob->proc~save_fe_field omp_get_thread_num omp_get_thread_num proc~solve_fe_film->omp_get_thread_num proc~solve_syst solve_syst proc~solve_fe_film->proc~solve_syst proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~convert_matrice_format convert_matrice_format proc~solve_fe_film->proc~convert_matrice_format proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~init_scal init_scal proc~save_fe_field->proc~init_scal proc~empty empty proc~save_fe_field->proc~empty proc~write_surf write_surf proc~save_fe_field->proc~write_surf proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~init_scal->proc~empty proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~get_unit get_unit proc~write_surf->proc~get_unit proc~lower lower proc~write_surf->proc~lower proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string dmumps dmumps proc~init_solver->dmumps mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~c_f_string->proc~empty interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panprocsolve_fe_probCallsGraph = svgPanZoom('#procsolve_fe_probCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solve_fe_prob~~CalledByGraph proc~solve_fe_prob solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code solve_fe_prob Source Code subroutine solve_fe_prob implicit none call system_clock ( count = cinit ) call cpu_time ( t1 ) call solve_FE_film ( fe_f , mat , bc ) call compute_corner_fluxes ( fe_f , mat , bf ) call cpu_time ( t2 ) call system_clock ( count = cend , count_rate = cr ) write ( OPU , * ) 'FE cpu time (s):' , char ( 9 ), t2 - t1 write ( unit_num_res , * ) 'FE_cpu_time_(s):' , char ( 9 ), t2 - t1 write ( OPU , * ) 'FE real comp time (s):' , char ( 9 ), real ( cend - cinit ) / real ( cr ) write ( unit_num_res , * ) 'FE_real_comp_time_(s):' , char ( 9 ), real ( cend - cinit ) / real ( cr ) save_PeK = . false . save_PeE = . false . if ( s_vtk /= NO_VTK ) call save_fe_f_vtk ( fe_f , trim ( ms_vtk )) select case ( test_num ) case ( 1 ) call save_profile_x_comp_slider ( fe_f , trim ( prof_ts ), lx , ly / 2 ) call execute_command_line ( \"python3 bin/pyt/filetoplot.py \" // trim ( prof_ts ) // \" '$x/L$' '$ph&#94;2/6 \\mu V L$' \" ) case ( 5 ) call save_profile_y_comp_air_pocket ( fe_f , trim ( prof_ts ), ly , lx / 2 , bc ) call execute_command_line ( \"python3 bin/pyt/filetoplot.py \" // trim ( prof_ts ) // \" '$x/L$' '$ph&#94;2/6 \\mu V L$' \" ) call save_profile_x_comp_air_pocket ( fe_f , trim ( prof_ts ) // '2' , lx , ly / 2 , bc ) call execute_command_line ( \"python3 bin/pyt/filetoplot.py \" // trim ( prof_ts ) // '2' // \" '$x/L$' '$ph&#94;2/6 \\mu V L$' \" ) case default call save_profile_x_fe ( fe_f , trim ( prof_ts ), lx , ly / 2 ) endselect call save_fe_field ( fe_f = fe_f , & ! file_name = \"out/\" // res_dir // \"/\" // \"pressure.sur\" , & ! code = P_N , & ! nodal = . true .) if ( save_PeK ) & ! call save_fe_field ( fe_f = fe_f , & ! file_name = \"out/\" // res_dir // \"/\" // \"PeK.sur\" , & ! code = PEK_C , & ! nodal = . false .) if ( save_PeE ) & ! call save_fe_field ( fe_f = fe_f , & ! file_name = \"out/\" // res_dir // \"/\" // \"PeE.sur\" , & ! code = PEE_C , & ! nodal = . false .) write ( OPU , * ) 'load FE (N):' , char ( 9 ), fe_f % fz () write ( unit_num_res , * ) 'load_FE_(N):' , char ( 9 ), fe_f % fz () write ( OPU , * ) 'fric/x FE (N)' , char ( 9 ), fe_f % fx () write ( unit_num_res , * ) 'fric/x_FE_(N)' , char ( 9 ), fe_f % fx () write ( OPU , * ) 'fric/y FE (N)' , char ( 9 ), fe_f % fy () write ( unit_num_res , * ) 'fric/y_FE_(N)' , char ( 9 ), fe_f % fy () return endsubroutine solve_fe_prob","loc":"proc/solve_fe_prob.html"},{"tags":"","title":"solve_ms_prob – MUSST","text":"private subroutine solve_ms_prob() Note Subroutine to solve a 'smooth' multiscale problem Arguments None Calls proc~~solve_ms_prob~~CallsGraph proc~solve_ms_prob solve_ms_prob proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~ms_fe_f_2_mat ms_fe_f_2_mat proc~solve_ms_prob->proc~ms_fe_f_2_mat proc~save_ms_field save_ms_field proc~solve_ms_prob->proc~save_ms_field omp_get_thread_num omp_get_thread_num proc~multi_scale_solve_fe_film->omp_get_thread_num proc~solve_syst solve_syst proc~multi_scale_solve_fe_film->proc~solve_syst proc~solve_fe_film solve_FE_film proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~convert_matrice_format convert_matrice_format proc~multi_scale_solve_fe_film->proc~convert_matrice_format proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~multi_scale_solve_fe_film->proc~apply_bc_fe_film_simple proc~multi_scale_assembly_fe_film_reynolds multi_scale_assembly_fe_film_reynolds proc~multi_scale_solve_fe_film->proc~multi_scale_assembly_fe_film_reynolds proc~save_ms_field->proc~ms_fe_f_2_mat proc~init_scal init_scal proc~save_ms_field->proc~init_scal proc~empty empty proc~save_ms_field->proc~empty proc~write_surf write_surf proc~save_ms_field->proc~write_surf proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~init_scal->proc~empty proc~solve_fe_film->omp_get_thread_num proc~solve_fe_film->proc~solve_syst proc~solve_fe_film->proc~convert_matrice_format proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~get_unit get_unit proc~write_surf->proc~get_unit proc~lower lower proc~write_surf->proc~lower proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~multi_scale_assembly_fe_film_reynolds->omp_get_thread_num proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string dmumps dmumps proc~init_solver->dmumps mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~c_f_string->proc~empty interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d var panprocsolve_ms_probCallsGraph = svgPanZoom('#procsolve_ms_probCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solve_ms_prob~~CalledByGraph proc~solve_ms_prob solve_ms_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~run_test run_test proc~run_test->proc~test_slider_ms proc~run_test->proc~test_rough_ms program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code solve_ms_prob Source Code subroutine solve_ms_prob implicit none real ( kind = R8 ), dimension (:, :), allocatable :: tab call system_clock ( count = cinit ) call cpu_time ( t1 ) call multi_scale_solve_fe_film ( ms_fe_f , ms_mat , bc ) call cpu_time ( t2 ) call system_clock ( count = cend , count_rate = cr ) write ( OPU , * ) 'MS cpu time (s):' , char ( 9 ), t2 - t1 write ( unit_num_res , * ) 'MS_cpu_time_(s):' , char ( 9 ), t2 - t1 write ( OPU , * ) 'MS real comp time (s):' , char ( 9 ), real ( cend - cinit ) / real ( cr ) write ( unit_num_res , * ) 'MS_real_comp_time_(s):' , char ( 9 ), real ( cend - cinit ) / real ( cr ) write ( OPU , * ) 'load MS_FE (N):' , char ( 9 ), ms_fe_f % ms_fz () write ( unit_num_res , * ) 'load_MS_FE_(N):' , char ( 9 ), ms_fe_f % ms_fz () write ( OPU , * ) 'fric/x MS FE (N):' , char ( 9 ), ms_fe_f % ms_fx () write ( unit_num_res , * ) 'fric/x_MS_FE_(N):' , char ( 9 ), ms_fe_f % ms_fx () write ( OPU , * ) 'fric/y MS FE (N):' , char ( 9 ), ms_fe_f % ms_fy () write ( unit_num_res , * ) 'fric/y_MS_FE_(N):' , char ( 9 ), ms_fe_f % ms_fy () call save_ms_fe_f_vtk ( ms_fe_f , trim ( ms_vtk )) call save_profile_x_fe ( ms_fe_f % ts_fe_f , trim ( prof_ts ), lx , ly / 2 ) call save_profile_x_ms ( ms_fe_f , trim ( prof_bs ), lx , ly / 2 ) call save_ms_field ( ms_fe_f = ms_fe_f , & ! file_name = \"out/\" // res_dir // \"/\" // \"ms_pressure.sur\" , & ! code = P_N , & ! nodal = . true . ) if ( compare_solution_file /= 0 ) then if ( allocated ( tab_sol ) ) deallocate ( tab_sol ) call read_surf ( nom_fic = trim ( pressure_solution_file ), & ! mu = - 1._R8 , & ! sq = - 1._R8 , & ! tab_s = tab_sol , & ! scal = scal_tmp ) if ( allocated ( tab_s ) ) deallocate ( tab_s ) call ms_fe_f_2_mat ( ms_fe_f = ms_fe_f , & ! code = P_N , & ! nodal = . true ., & ! mat = tab_s ) allocate ( tab ( 1 : nx , 1 : ny ) ) tab ( 1 : nx , 1 : ny ) = abs ( tab_s ( 1 : nx , 1 : ny ) - tab_sol ( 1 : nx , 1 : ny )) scal_tmp % zlength_unit = 'Pa' scal_tmp % dz_unit = 'Pa' call write_surf ( nom_fic = \"out/\" // res_dir // \"/\" // \"compare_pressure.sur\" , & ! tab_s = tab ( 1 : nx , 1 : ny ), & ! scal = scal_tmp ) where ( tab_s < data_f % fl % p_0 . and . tab_sol > data_f % fl % p_0 ) tab = - 1._R8 elsewhere ( tab_s > data_f % fl % p_0 . and . tab_sol < data_f % fl % p_0 ) tab = + 1._R8 elsewhere ( tab_s < data_f % fl % p_0 . and . tab_sol < data_f % fl % p_0 ) tab = 0._R8 elsewhere tab = - 2._R8 endwhere scal_tmp % zlength_unit = '  ' scal_tmp % dz_unit = '  ' call write_surf ( nom_fic = \"out/\" // res_dir // \"/\" // \"compare_cavitation.sur\" , & ! tab_s = tab ( 1 : nx , 1 : ny ), & ! scal = scal_tmp ) endif if ( allocated ( tab ) ) deallocate ( tab ) if ( allocated ( tab_s ) ) deallocate ( tab_s ) if ( allocated ( tab_sol ) ) deallocate ( tab_sol ) return endsubroutine solve_ms_prob","loc":"proc/solve_ms_prob.html"},{"tags":"","title":"GetUnit – MUSST","text":"private function GetUnit() result(Free_Unit) The GetUnit function is used for getting a free logic unit. The users of \\LIBVTKIO does not know which is\nthe logical unit: \\LIBVTKIO handels this information without boring the users. The logical unit used is safe-free: if the\nprogram calling \\LIBVTKIO has others logical units used \\LIBVTKIO will never use these units, but will choice one that is free. GetUnit function is private and cannot be called outside \\LIBVTKIO. If you are interested to use it change its scope to public. Arguments None Return Value integer(kind=I4P) Called by proc~~getunit~~CalledByGraph proc~getunit GetUnit proc~vtm_ini_xml VTM_INI_XML proc~vtm_ini_xml->proc~getunit proc~vtk_ini_xml VTK_INI_XML proc~vtk_ini_xml->proc~getunit proc~vtk_ini VTK_INI proc~vtk_ini->proc~getunit proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->proc~vtk_ini Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code GetUnit Source Code function GetUnit () result ( Free_Unit ) !--------------------------------------------------------------------------------------------------------------------------------- !!The GetUnit function is used for getting a free logic unit. The users of \\LIBVTKIO does not know which is !!the logical unit: \\LIBVTKIO handels this information without boring the users. The logical unit used is safe-free: if the !!program calling \\LIBVTKIO has others logical units used \\LIBVTKIO will never use these units, but will choice one that is free. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ) :: Free_Unit ! free logic unit integer ( I4P ) :: n1 ! counter integer ( I4P ) :: ios ! inquiring flag logical ( 4 ) :: lopen ! inquiring flag !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- !!The following is the code snippet of GetUnit function: the units 0, 5, 6, 9 and all non-free units are discarded. !! !(\\doc)codesnippet Free_Unit = - 1_I4P ! initializing free logic unit n1 = 1_I4P ! initializing counter do if (( n1 /= 5_I4P ). AND .( n1 /= 6_I4P ). AND .( n1 /= 9_I4P )) then inquire ( unit = n1 , opened = lopen , iostat = ios ) ! verify logic units if ( ios == 0_I4P ) then if (. NOT . lopen ) then Free_Unit = n1 ! assignment of free logic return endif endif endif n1 = n1 + 1_I4P ! updating counter enddo return !(doc/)codesnippet !!GetUnit function is private and cannot be called outside \\LIBVTKIO. If you are interested to use it change its scope to public. !--------------------------------------------------------------------------------------------------------------------------------- endfunction GetUnit","loc":"proc/getunit.html"},{"tags":"","title":"Upper_Case – MUSST","text":"private function Upper_Case(string) The Upper_Case function converts the lower case characters of a string to upper case one. \\LIBVTKIO uses this function in\norder to achieve case-insensitive: all character variables used within \\LIBVTKIO functions are pre-processed by\nUppper_Case function before these variables are used. So the users can call \\LIBVTKIO functions whitout pay attention of the\ncase of the kwywords passed to the functions: calling the function VTK_INI with the string \\code{E_IO = VTK_INI('Ascii',…)}\nor with the string  \\code{E_IO = VTK_INI('AscII',…)} is equivalent. Upper_Case function is private and cannot be called outside \\LIBVTKIO. If you are interested to use it change its scope\nto public. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len(string)) Called by proc~~upper_case~~CalledByGraph proc~upper_case Upper_Case proc~vtk_dat_xml VTK_DAT_XML proc~vtk_dat_xml->proc~upper_case proc~vtk_ini VTK_INI proc~vtk_ini->proc~upper_case proc~vtk_dat VTK_DAT proc~vtk_dat->proc~upper_case proc~vtk_var_vect_r4 VTK_VAR_VECT_R4 proc~vtk_var_vect_r4->proc~upper_case proc~vtk_var_vect_r8 VTK_VAR_VECT_R8 proc~vtk_var_vect_r8->proc~upper_case proc~vtk_ini_xml VTK_INI_XML proc~vtk_ini_xml->proc~upper_case proc~vtm_blk_xml VTM_BLK_XML proc~vtm_blk_xml->proc~upper_case interface~vtk_var VTK_VAR interface~vtk_var->proc~vtk_var_vect_r4 interface~vtk_var->proc~vtk_var_vect_r8 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->proc~vtk_ini proc~save_fe_f_vtk->proc~vtk_dat proc~save_fe_f_vtk->interface~vtk_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Upper_Case Source Code function Upper_Case ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !!The Upper\\_Case function converts the lower case characters of a string to upper case one. \\LIBVTKIO uses this function in !!order to achieve case-insensitive: all character variables used within \\LIBVTKIO functions are pre-processed by !!Uppper\\_Case function before these variables are used. So the users can call \\LIBVTKIO functions whitout pay attention of the !!case of the kwywords passed to the functions: calling the function VTK\\_INI with the string \\code{E_IO = VTK_INI('Ascii',...)} !!or with the string  \\code{E_IO = VTK_INI('AscII',...)} is equivalent. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len =* ), intent ( IN ) :: string ! string to be converted character ( len = len ( string )) :: Upper_Case ! converted string integer :: n1 ! characters counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- !!The following is the code snippet of Upper\\_Case function. !! !(\\doc)codesnippet Upper_Case = string do n1 = 1 , len ( string ) select case ( ichar ( string ( n1 : n1 ))) case ( 97 : 122 ) Upper_Case ( n1 : n1 ) = char ( ichar ( string ( n1 : n1 )) - 32 ) ! Upper case conversion endselect enddo return !(doc/)codesnippet !!Upper\\_Case function is private and cannot be called outside \\LIBVTKIO. If you are interested to use it change its scope !!to public. !--------------------------------------------------------------------------------------------------------------------------------- endfunction Upper_Case","loc":"proc/upper_case.html"},{"tags":"","title":"VTK_INI – MUSST","text":"public function VTK_INI(output_format, filename, title, mesh_topology) result(E_IO) The VTK_INI function is used for initializing file. This function must be the first to be called. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: output_format character(len=*), intent(in) :: filename character(len=*), intent(in) :: title character(len=*), intent(in) :: mesh_topology Return Value integer(kind=I4P) The VTK_INI variables have the following meaning: \\begin{description}\n \\item[{\\color{RoyalBlue}output\\_format}] indicates the \\virgo{format} of output file. It can assume the following values:\n \\begin{enumerateABlu}\n  \\item \\emph{ascii} (it is case insensitive) $\\rightarrow$ creating an ascii output file.\n  \\item \\emph{binary} (it is case insensitive) $\\rightarrow$ creating a binary (big\\_endian encoding) output file.\n \\end{enumerateABlu}\n \\item[{\\color{RoyalBlue}filename}] contains the name (with its path) of the output file.\n \\item[{\\color{RoyalBlue}title}] contains the title of the VTK dataset.\n \\item[{\\color{RoyalBlue}topology}] indicates the topology of the mesh and can assume the following values:\n \\begin{enumerateABlu}\n  \\item \\emph{STRUCTURED\\_POINTS}.\n  \\item \\emph{STRUCTURED\\_GRID}.\n  \\item \\emph{UNSTRUCTURED\\_GRID}.\n  \\item \\emph{RECTILINEAR\\_GRID}.\n \\end{enumerateABlu}\n \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling.\n\\end{description} The following is an example of VTK_INI calling: \\begin{boxred}{VTK\\_INI Calling}\n\\begin{verbatim}\n...\nE_IO = VTK_INI('Binary','example.vtk','VTK legacy file','UNSTRUCTURED_GRID')\n...\n\\end{verbatim}\n\\end{boxred} \\noindent Note that the \\virgo{.vtk} extension is necessary in the file name. Calls proc~~vtk_ini~~CallsGraph proc~vtk_ini VTK_INI proc~getunit GetUnit proc~vtk_ini->proc~getunit proc~upper_case Upper_Case proc~vtk_ini->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_ini~~CalledByGraph proc~vtk_ini VTK_INI proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->proc~vtk_ini Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_INI Source Code function VTK_INI ( output_format , filename , title , mesh_topology ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!The VTK\\_INI function is used for initializing file. This function must be the first to be called. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: output_format ! output format: ASCII or BINARY character ( * ), intent ( IN ) :: filename ! name of file character ( * ), intent ( IN ) :: title ! title character ( * ), intent ( IN ) :: mesh_topology ! mesh topology integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !!The VTK\\_INI variables have the following meaning: !! !!\\begin{description} !! \\item[{\\color{RoyalBlue}output\\_format}] indicates the \\virgo{format} of output file. It can assume the following values: !! \\begin{enumerateABlu} !!  \\item \\emph{ascii} (it is case insensitive) $\\rightarrow$ creating an ascii output file. !!  \\item \\emph{binary} (it is case insensitive) $\\rightarrow$ creating a binary (big\\_endian encoding) output file. !! \\end{enumerateABlu} !! \\item[{\\color{RoyalBlue}filename}] contains the name (with its path) of the output file. !! \\item[{\\color{RoyalBlue}title}] contains the title of the VTK dataset. !! \\item[{\\color{RoyalBlue}topology}] indicates the topology of the mesh and can assume the following values: !! \\begin{enumerateABlu} !!  \\item \\emph{STRUCTURED\\_POINTS}. !!  \\item \\emph{STRUCTURED\\_GRID}. !!  \\item \\emph{UNSTRUCTURED\\_GRID}. !!  \\item \\emph{RECTILINEAR\\_GRID}. !! \\end{enumerateABlu} !! \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling. !!\\end{description} !! !!The following is an example of VTK\\_INI calling: !! !!\\begin{boxred}{VTK\\_INI Calling} !!\\begin{verbatim} !!... !!E_IO = VTK_INI('Binary','example.vtk','VTK legacy file','UNSTRUCTURED_GRID') !!... !!\\end{verbatim} !!\\end{boxred} !!\\noindent Note that the \\virgo{.vtk} extension is necessary in the file name. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- topology = trim ( mesh_topology ) Unit_VTK = GetUnit () select case ( trim ( Upper_Case ( output_format ))) case ( 'ASCII' ) f_out = f_out_ascii open ( unit = Unit_VTK , & file = trim ( filename ), & form = 'FORMATTED' , & access = 'SEQUENTIAL' , & action = 'WRITE' , & iostat = E_IO ) ! writing header of file write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) '# vtk DataFile Version 3.0' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) trim ( title ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) trim ( Upper_Case ( output_format )) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'DATASET ' // trim ( topology ) case ( 'BINARY' ) f_out = f_out_binary open ( unit = Unit_VTK , & file = trim ( filename ), & form = 'UNFORMATTED' , & access = 'STREAM' , & action = 'WRITE' , & convert = 'BIG_ENDIAN' , & iostat = E_IO ) ! writing header of file write ( unit = Unit_VTK , iostat = E_IO ) '# vtk DataFile Version 3.0' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) trim ( title ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) trim ( Upper_Case ( output_format )) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) 'DATASET ' // trim ( topology ) // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_INI","loc":"proc/vtk_ini.html"},{"tags":"","title":"VTK_GEO_STRP_R8 – MUSST","text":"private function VTK_GEO_STRP_R8(Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz) result(E_IO) Function for saving mesh; topology = STRUCTURED_POINTS (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R8P), intent(in) :: X0 real(kind=R8P), intent(in) :: Y0 real(kind=R8P), intent(in) :: Z0 real(kind=R8P), intent(in) :: Dx real(kind=R8P), intent(in) :: Dy real(kind=R8P), intent(in) :: Dz Return Value integer(kind=I4P) Called by proc~~vtk_geo_strp_r8~~CalledByGraph proc~vtk_geo_strp_r8 VTK_GEO_STRP_R8 interface~vtk_geo VTK_GEO interface~vtk_geo->proc~vtk_geo_strp_r8 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_geo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_STRP_R8 Source Code function VTK_GEO_STRP_R8 ( Nx , Ny , Nz , X0 , Y0 , Z0 , Dx , Dy , Dz ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = STRUCTURED\\_POINTS (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx ! number of nodes in x direction integer ( I4P ), intent ( IN ) :: Ny ! number of nodes in y direction integer ( I4P ), intent ( IN ) :: Nz ! number of nodes in z direction real ( R8P ), intent ( IN ) :: X0 ! x coordinate of origin real ( R8P ), intent ( IN ) :: Y0 ! y coordinate of origin real ( R8P ), intent ( IN ) :: Z0 ! z coordinate of origin real ( R8P ), intent ( IN ) :: Dx ! space step in x direction real ( R8P ), intent ( IN ) :: Dy ! space step in y direction real ( R8P ), intent ( IN ) :: Dz ! space step in z direction integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , fmt = '(A,3' // FR8P // ')' , iostat = E_IO ) 'ORIGIN ' , X0 , Y0 , Z0 write ( unit = Unit_VTK , fmt = '(A,3' // FR8P // ')' , iostat = E_IO ) 'SPACING ' , Dx , Dy , Dz case ( f_out_binary ) write ( s_buffer , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,3' // FR8P // ')' , iostat = E_IO ) 'ORIGIN ' , X0 , Y0 , Z0 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,3' // FR8P // ')' , iostat = E_IO ) 'SPACING ' , Dx , Dy , Dz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRP_R8","loc":"proc/vtk_geo_strp_r8.html"},{"tags":"","title":"VTK_GEO_STRP_R4 – MUSST","text":"private function VTK_GEO_STRP_R4(Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz) result(E_IO) Function for saving mesh; topology = STRUCTURED_POINTS (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R4P), intent(in) :: X0 real(kind=R4P), intent(in) :: Y0 real(kind=R4P), intent(in) :: Z0 real(kind=R4P), intent(in) :: Dx real(kind=R4P), intent(in) :: Dy real(kind=R4P), intent(in) :: Dz Return Value integer(kind=I4P) Called by proc~~vtk_geo_strp_r4~~CalledByGraph proc~vtk_geo_strp_r4 VTK_GEO_STRP_R4 interface~vtk_geo VTK_GEO interface~vtk_geo->proc~vtk_geo_strp_r4 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_geo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_STRP_R4 Source Code function VTK_GEO_STRP_R4 ( Nx , Ny , Nz , X0 , Y0 , Z0 , Dx , Dy , Dz ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = STRUCTURED\\_POINTS (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx ! number of nodes in x direction integer ( I4P ), intent ( IN ) :: Ny ! number of nodes in y direction integer ( I4P ), intent ( IN ) :: Nz ! number of nodes in z direction real ( R4P ), intent ( IN ) :: X0 ! x coordinate of origin real ( R4P ), intent ( IN ) :: Y0 ! y coordinate of origin real ( R4P ), intent ( IN ) :: Z0 ! z coordinate of origin real ( R4P ), intent ( IN ) :: Dx ! space step in x direction real ( R4P ), intent ( IN ) :: Dy ! space step in y direction real ( R4P ), intent ( IN ) :: Dz ! space step in z direction integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , fmt = '(A,3' // FR4P // ')' , iostat = E_IO ) 'ORIGIN ' , X0 , Y0 , Z0 write ( unit = Unit_VTK , fmt = '(A,3' // FR4P // ')' , iostat = E_IO ) 'SPACING ' , Dx , Dy , Dz case ( f_out_binary ) write ( s_buffer , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,3' // FR4P // ')' , iostat = E_IO ) 'ORIGIN ' , X0 , Y0 , Z0 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,3' // FR4P // ')' , iostat = E_IO ) 'SPACING ' , Dx , Dy , Dz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRP_R4","loc":"proc/vtk_geo_strp_r4.html"},{"tags":"","title":"VTK_GEO_STRG_R8 – MUSST","text":"private function VTK_GEO_STRG_R8(Nx, Ny, Nz, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = STRUCTURED_GRID (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz integer(kind=I4P), intent(in) :: NN real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) Called by proc~~vtk_geo_strg_r8~~CalledByGraph proc~vtk_geo_strg_r8 VTK_GEO_STRG_R8 interface~vtk_geo VTK_GEO interface~vtk_geo->proc~vtk_geo_strg_r8 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_geo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_STRG_R8 Source Code function VTK_GEO_STRG_R8 ( Nx , Ny , Nz , NN , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = STRUCTURED\\_GRID (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx ! number of nodes in x direction integer ( I4P ), intent ( IN ) :: Ny ! number of nodes in y direction integer ( I4P ), intent ( IN ) :: Nz ! number of nodes in z direction integer ( I4P ), intent ( IN ) :: NN ! number of all nodes real ( R8P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates real ( R8P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates real ( R8P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' double' write ( unit = Unit_VTK , fmt = '(3' // FR8P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' double' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRG_R8","loc":"proc/vtk_geo_strg_r8.html"},{"tags":"","title":"VTK_GEO_STRG_R4 – MUSST","text":"private function VTK_GEO_STRG_R4(Nx, Ny, Nz, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = STRUCTURED_GRID (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz integer(kind=I4P), intent(in) :: NN real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) Called by proc~~vtk_geo_strg_r4~~CalledByGraph proc~vtk_geo_strg_r4 VTK_GEO_STRG_R4 interface~vtk_geo VTK_GEO interface~vtk_geo->proc~vtk_geo_strg_r4 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_geo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_STRG_R4 Source Code function VTK_GEO_STRG_R4 ( Nx , Ny , Nz , NN , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = STRUCTURED\\_GRID (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx ! number of nodes in x direction integer ( I4P ), intent ( IN ) :: Ny ! number of nodes in y direction integer ( I4P ), intent ( IN ) :: Nz ! number of nodes in z direction integer ( I4P ), intent ( IN ) :: NN ! number of all nodes real ( R4P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates real ( R4P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates real ( R4P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' float' write ( unit = Unit_VTK , fmt = '(3' // FR4P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' float' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_STRG_R4","loc":"proc/vtk_geo_strg_r4.html"},{"tags":"","title":"VTK_GEO_RECT_R8 – MUSST","text":"private function VTK_GEO_RECT_R8(Nx, Ny, Nz, X, Y, Z) result(E_IO) Function for saving mesh; topology = RECTILINEAR_GRID (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R8P), intent(in) :: X (1:Nx) real(kind=R8P), intent(in) :: Y (1:Ny) real(kind=R8P), intent(in) :: Z (1:Nz) Return Value integer(kind=I4P) Called by proc~~vtk_geo_rect_r8~~CalledByGraph proc~vtk_geo_rect_r8 VTK_GEO_RECT_R8 interface~vtk_geo VTK_GEO interface~vtk_geo->proc~vtk_geo_rect_r8 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_geo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_RECT_R8 Source Code function VTK_GEO_RECT_R8 ( Nx , Ny , Nz , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = RECTILINEAR\\_GRID (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx ! number of nodes in x direction integer ( I4P ), intent ( IN ) :: Ny ! number of nodes in y direction integer ( I4P ), intent ( IN ) :: Nz ! number of nodes in z direction real ( R8P ), intent ( IN ) :: X ( 1 : Nx ) ! x coordinates real ( R8P ), intent ( IN ) :: Y ( 1 : Ny ) ! y coordinates real ( R8P ), intent ( IN ) :: Z ( 1 : Nz ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'X_COORDINATES ' , Nx , ' double' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO )( X ( n1 ), n1 = 1 , Nx ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Y_COORDINATES ' , Ny , ' double' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO )( Y ( n1 ), n1 = 1 , Ny ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Z_COORDINATES ' , Nz , ' double' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO )( Z ( n1 ), n1 = 1 , Nz ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'X_COORDINATES ' , Nx , ' double' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( X ( n1 ), n1 = 1 , Nx ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Y_COORDINATES ' , Ny , ' double' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( Y ( n1 ), n1 = 1 , Ny ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Z_COORDINATES ' , Nz , ' double' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( Z ( n1 ), n1 = 1 , Nz ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_RECT_R8","loc":"proc/vtk_geo_rect_r8.html"},{"tags":"","title":"VTK_GEO_RECT_R4 – MUSST","text":"private function VTK_GEO_RECT_R4(Nx, Ny, Nz, X, Y, Z) result(E_IO) Function for saving mesh; topology = RECTILINEAR_GRID (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R4P), intent(in) :: X (1:Nx) real(kind=R4P), intent(in) :: Y (1:Ny) real(kind=R4P), intent(in) :: Z (1:Nz) Return Value integer(kind=I4P) Called by proc~~vtk_geo_rect_r4~~CalledByGraph proc~vtk_geo_rect_r4 VTK_GEO_RECT_R4 interface~vtk_geo VTK_GEO interface~vtk_geo->proc~vtk_geo_rect_r4 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_geo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_RECT_R4 Source Code function VTK_GEO_RECT_R4 ( Nx , Ny , Nz , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = RECTILINEAR\\_GRID (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: Nx ! number of nodes in x direction integer ( I4P ), intent ( IN ) :: Ny ! number of nodes in y direction integer ( I4P ), intent ( IN ) :: Nz ! number of nodes in z direction real ( R4P ), intent ( IN ) :: X ( 1 : Nx ) ! x coordinates real ( R4P ), intent ( IN ) :: Y ( 1 : Ny ) ! y coordinates real ( R4P ), intent ( IN ) :: Z ( 1 : Nz ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'X_COORDINATES ' , Nx , ' float' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO )( X ( n1 ), n1 = 1 , Nx ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Y_COORDINATES ' , Ny , ' float' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO )( Y ( n1 ), n1 = 1 , Ny ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Z_COORDINATES ' , Nz , ' float' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO )( Z ( n1 ), n1 = 1 , Nz ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,3' // FI4P // ')' , iostat = E_IO ) 'DIMENSIONS ' , Nx , Ny , Nz write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'X_COORDINATES ' , Nx , ' float' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( X ( n1 ), n1 = 1 , Nx ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Y_COORDINATES ' , Ny , ' float' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( Y ( n1 ), n1 = 1 , Ny ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'Z_COORDINATES ' , Nz , ' float' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( Z ( n1 ), n1 = 1 , Nz ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_RECT_R4","loc":"proc/vtk_geo_rect_r4.html"},{"tags":"","title":"VTK_GEO_UNST_R8 – MUSST","text":"private function VTK_GEO_UNST_R8(NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = UNSTRUCTURED_GRID (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) Called by proc~~vtk_geo_unst_r8~~CalledByGraph proc~vtk_geo_unst_r8 VTK_GEO_UNST_R8 interface~vtk_geo VTK_GEO interface~vtk_geo->proc~vtk_geo_unst_r8 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_geo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_UNST_R8 Source Code function VTK_GEO_UNST_R8 ( NN , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = UNSTRUCTURED\\_GRID (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NN ! number of nodes real ( R8P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates of all nodes real ( R8P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates of all nodes real ( R8P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates of all nodes integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' double' write ( unit = Unit_VTK , fmt = '(3' // FR8P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' double' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_UNST_R8","loc":"proc/vtk_geo_unst_r8.html"},{"tags":"","title":"VTK_GEO_UNST_R4 – MUSST","text":"private function VTK_GEO_UNST_R4(NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = UNSTRUCTURED_GRID (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) Called by proc~~vtk_geo_unst_r4~~CalledByGraph proc~vtk_geo_unst_r4 VTK_GEO_UNST_R4 interface~vtk_geo VTK_GEO interface~vtk_geo->proc~vtk_geo_unst_r4 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_geo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_UNST_R4 Source Code function VTK_GEO_UNST_R4 ( NN , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = UNSTRUCTURED\\_GRID (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NN ! number of nodes real ( R4P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates of all nodes real ( R4P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates of all nodes real ( R4P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates of all nodes integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' float' write ( unit = Unit_VTK , fmt = '(3' // FR4P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,' // FI4P // ',A)' , iostat = E_IO ) 'POINTS ' , NN , ' float' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_UNST_R4","loc":"proc/vtk_geo_unst_r4.html"},{"tags":"","title":"VTK_CON – MUSST","text":"public function VTK_CON(NC, connect, cell_type) result(E_IO) This function \\MaiuscolettoBS{must} be used when unstructured grid is used. It saves the connectivity of the unstructured\nmesh. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC integer(kind=I4P), intent(in) :: connect (:) integer(kind=I4P), intent(in) :: cell_type (1:NC) Return Value integer(kind=I4P) Called by proc~~vtk_con~~CalledByGraph proc~vtk_con VTK_CON proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->proc~vtk_con Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_CON Source Code function VTK_CON ( NC , connect , cell_type ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!This function \\MaiuscolettoBS{must} be used when unstructured grid is used. It saves the connectivity of the unstructured !!mesh. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC ! number of cells integer ( I4P ), intent ( IN ) :: connect (:) ! mesh connectivity integer ( I4P ), intent ( IN ) :: cell_type ( 1 : NC ) ! VTK cell type integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: ncon ! dimension of connectivity vector !!The VTK\\_CON variables have the following meaning: !! !!\\begin{description} !! \\item[{\\color{RoyalBlue}NC}] indicates the number of all cells. !! \\item[{\\color{RoyalBlue}connect}] contains the connectivity of the mesh. It is a vector. !! \\item[{\\color{RoyalBlue}cell\\_type}] contains the type of every cells. It is a vector of $[1:NC]$. !! \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling. !!\\end{description} !! !!The vector \\MaiuscolettoBS{connect} must follow the VTK legacy standard. It is passed as \\MaiuscolettoBS{assumed-shape} array !!because its dimensions is related to the mesh dimensions in a complex way. Its dimensions can be calculated by the following !!equation: !! !!\\begin{equation} !!dc = NC + \\sum\\limits_{i = 1}&#94;{NC} {nvertex_i } !!\\label{eq:connectivity dimensions} !!\\end{equation} !! !!\\noindent where $dc$ is connectivity vector dimension and $nvertex_i$ is the number of vertices of $i&#94;{th}$ cell. The VTK !!legacy standard for the mesh connectivity is quite obscure at least at first sight. It is more simple analizing an example. !!Suppose we have a mesh composed by 2 cells, one hexahedron (8 vertices) and one pyramid with square basis (5 vertices); suppose !!that the basis of pyramid is constitute by a face of the hexahedron and so the two cells share 4 vertices. The equation !!\\ref{eq:connectivity dimensions} gives $dc=2+8+5=15$; the connectivity vector for this mesh can be: !! !!\\begin{boxred}{Connectivity vector example for VTK legacy standard} !!\\begin{verbatim} !!! first cell !!connect(1)  = 8  => number of vertices of 1° cell !!connect(2)  = 0  => identification flag of 1° vertex of 1° cell !!connect(3)  = 1  => identification flag of 2° vertex of 1° cell !!connect(4)  = 2  => identification flag of 3° vertex of 1° cell !!connect(5)  = 3  => identification flag of 4° vertex of 1° cell !!connect(6)  = 4  => identification flag of 5° vertex of 1° cell !!connect(7)  = 5  => identification flag of 6° vertex of 1° cell !!connect(8)  = 6  => identification flag of 7° vertex of 1° cell !!connect(9)  = 7  => identification flag of 8° vertex of 1° cell !!! second cell !!connect(10) = 5  => number of vertices of 2° cell !!connect(11) = 0  => identification flag of 1° vertex of 2° cell !!connect(12) = 1  => identification flag of 2° vertex of 2° cell !!connect(13) = 2  => identification flag of 3° vertex of 2° cell !!connect(14) = 3  => identification flag of 4° vertex of 2° cell !!connect(15) = 8  => identification flag of 5° vertex of 2° cell !!\\end{verbatim} !!\\end{boxred} !! !!\\noindent Note that the first 4 identification flags of pyramid vertices as the same of the first 4 identification flags of !!the hexahedron because the two cells share this face. It is also important to note that the identification flags start !!form $0$ value: this is impose to the VTK standard. The function VTK\\_CON does not calculate the connectivity vector: it !!writes the connectivity vector conforming the VTK standard, but does not calculate it. In the future release of \\LIBVTKIO will !!be included a function to calculate the connectivity vector. !! !!The vector variable \\MaiuscolettoBS{tipo} must conform the VTK standard \\footnote{See the file VTK-Standard at the Kitware !!homepage.}. It contains the \\emph{type} of each cells. For the above example this vector is: !! !!\\begin{boxred}{Cell-Type vector example for VTK legacy standard} !!\\begin{verbatim} !!tipo(1) = 12  => VTK hexahedron type of 1° cell !!tipo(2) = 14  => VTK pyramid type of 2° cell !!\\end{verbatim} !!\\end{boxred} !! !!The following is an example of VTK\\_CON calling: !! !!\\begin{boxred}{VTK\\_CON Calling} !!\\begin{verbatim} !!... !!integer(4), parameter:: NC=2 !!integer(4), parameter:: Nvertex1=8 !!integer(4), parameter:: Nvertex2=5 !!integer(4), parameter:: dc=NC+Nvertex1+Nvertex2 !!integer(4)::            connect(1:dc) !!integer(4)::            cell_type(1:NC) !!... !!E_IO = VTK_CON(NC,connect,cell_type) !!... !!\\end{verbatim} !!\\end{boxred} !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ncon = size ( connect , 1 ) select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,2' // FI4P // ')' , iostat = E_IO ) 'CELLS ' , NC , ncon write ( unit = Unit_VTK , fmt = FI4P , iostat = E_IO ) connect write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'CELL_TYPES ' , NC write ( unit = Unit_VTK , fmt = FI4P , iostat = E_IO ) cell_type case ( f_out_binary ) write ( s_buffer , fmt = '(A,2' // FI4P // ')' , iostat = E_IO ) 'CELLS ' , NC , ncon write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) connect write ( unit = Unit_VTK , iostat = E_IO ) end_rec write ( s_buffer , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'CELL_TYPES ' , NC write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) cell_type write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_CON","loc":"proc/vtk_con.html"},{"tags":"","title":"VTK_DAT – MUSST","text":"public function VTK_DAT(NC_NN, var_location) result(E_IO) This function \\MaiuscolettoBS{must} be called before saving the data related to geometric mesh. This function initializes the\nsaving of data variables indicating the \\emph{type} of variables that will be saved. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: var_location Return Value integer(kind=I4P) Calls proc~~vtk_dat~~CallsGraph proc~vtk_dat VTK_DAT proc~upper_case Upper_Case proc~vtk_dat->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_dat~~CalledByGraph proc~vtk_dat VTK_DAT proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->proc~vtk_dat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_DAT Source Code function VTK_DAT ( NC_NN , var_location ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!This function \\MaiuscolettoBS{must} be called before saving the data related to geometric mesh. This function initializes the !!saving of data variables indicating the \\emph{type} of variables that will be saved. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes of field character ( * ), intent ( IN ) :: var_location ! location of saving variables: cell for cell-centered, node for node-centered integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string !!The VTK\\_DAT variables have the following meaning: !! !!\\begin{description} !! \\item[{\\color{RoyalBlue}NC\\_NN}] indicates the number of all cells or all nodes according to the value of !!                                  {\\color{RoyalBlue}tipo}. !! \\item[{\\color{RoyalBlue}var\\_location}] contains the location-type of variables that will be saved after VTK\\_DAT. It is !!                                         a scalar and cab assume the following values: !! \\begin{enumerateABlu} !!  \\item \\emph{cell} (it is case insensitive) $\\rightarrow$ variables will be cell-centered. !!  \\item \\emph{node} (it is case insensitive) $\\rightarrow$ variables will be node-centered. !! \\end{enumerateABlu} !! \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling. !!\\end{description} !! !!Of course a single file can contain both cell and node centered variables; in this case the VTK\\_DAT function must be !!called two times, before saving cell-centered variables and before saving node-centered variables. !! !!The following is an example of VTK\\_DAT calling: !! !!\\begin{boxred}{VTK\\_DAT Calling} !!\\begin{verbatim} !!... !!E_IO = VTK_DAT(50,'node') !!... !!\\end{verbatim} !!\\end{boxred} !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) select case ( trim ( Upper_Case ( var_location ))) case ( 'CELL' ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'CELL_DATA ' , NC_NN case ( 'NODE' ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'POINT_DATA ' , NC_NN endselect case ( f_out_binary ) select case ( trim ( Upper_Case ( var_location ))) case ( 'CELL' ) write ( s_buffer , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'CELL_DATA ' , NC_NN write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec case ( 'NODE' ) write ( s_buffer , fmt = '(A,' // FI4P // ')' , iostat = E_IO ) 'POINT_DATA ' , NC_NN write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_DAT","loc":"proc/vtk_dat.html"},{"tags":"","title":"VTK_VAR_SCAL_R8 – MUSST","text":"private function VTK_VAR_SCAL_R8(NC_NN, varname, var) result(E_IO) Function for saving field of scalar variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) Called by proc~~vtk_var_scal_r8~~CalledByGraph proc~vtk_var_scal_r8 VTK_VAR_SCAL_R8 interface~vtk_var VTK_VAR interface~vtk_var->proc~vtk_var_scal_r8 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_SCAL_R8 Source Code function VTK_VAR_SCAL_R8 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving field of scalar variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells character ( * ), intent ( IN ) :: varname ! variable name real ( R8P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' double 1' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'LOOKUP_TABLE default' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO ) var case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' double 1' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) 'LOOKUP_TABLE default' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) var write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_SCAL_R8","loc":"proc/vtk_var_scal_r8.html"},{"tags":"","title":"VTK_VAR_SCAL_R4 – MUSST","text":"private function VTK_VAR_SCAL_R4(NC_NN, varname, var) result(E_IO) Function for saving field of scalar variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) Called by proc~~vtk_var_scal_r4~~CalledByGraph proc~vtk_var_scal_r4 VTK_VAR_SCAL_R4 interface~vtk_var VTK_VAR interface~vtk_var->proc~vtk_var_scal_r4 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_SCAL_R4 Source Code function VTK_VAR_SCAL_R4 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving field of scalar variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells character ( * ), intent ( IN ) :: varname ! variable name real ( R4P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' float 1' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'LOOKUP_TABLE default' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO ) var case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' float 1' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) 'LOOKUP_TABLE default' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) var write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_SCAL_R4","loc":"proc/vtk_var_scal_r4.html"},{"tags":"","title":"VTK_VAR_SCAL_I4 – MUSST","text":"private function VTK_VAR_SCAL_I4(NC_NN, varname, var) result(E_IO) Function for saving field of scalar variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) Called by proc~~vtk_var_scal_i4~~CalledByGraph proc~vtk_var_scal_i4 VTK_VAR_SCAL_I4 interface~vtk_var VTK_VAR interface~vtk_var->proc~vtk_var_scal_i4 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_SCAL_I4 Source Code function VTK_VAR_SCAL_I4 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving field of scalar variable (I4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells character ( * ), intent ( IN ) :: varname ! variable name integer ( I4P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' int 1' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'LOOKUP_TABLE default' write ( unit = Unit_VTK , fmt = FI4P , iostat = E_IO ) var case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) 'SCALARS ' // trim ( varname ) // ' int 1' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) 'LOOKUP_TABLE default' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) var write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_SCAL_I4","loc":"proc/vtk_var_scal_i4.html"},{"tags":"","title":"VTK_VAR_VECT_R8 – MUSST","text":"private function VTK_VAR_VECT_R8(vec_type, NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving field of vectorial variable (R8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: varX (1:NC_NN) real(kind=R8P), intent(in) :: varY (1:NC_NN) real(kind=R8P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) Calls proc~~vtk_var_vect_r8~~CallsGraph proc~vtk_var_vect_r8 VTK_VAR_VECT_R8 proc~upper_case Upper_Case proc~vtk_var_vect_r8->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_vect_r8~~CalledByGraph proc~vtk_var_vect_r8 VTK_VAR_VECT_R8 interface~vtk_var VTK_VAR interface~vtk_var->proc~vtk_var_vect_r8 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_VECT_R8 Source Code function VTK_VAR_VECT_R8 ( vec_type , NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving field of vectorial variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: vec_type ! vector type: vect = generic vector , norm = normal vector integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells character ( * ), intent ( IN ) :: varname ! variable name real ( R8P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component of vector real ( R8P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component of vector real ( R8P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component of vector integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I8P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) select case ( Upper_Case ( trim ( vec_type ))) case ( 'VECT' ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' double' case ( 'NORM' ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'NORMALS ' // trim ( varname ) // ' double' endselect write ( unit = Unit_VTK , fmt = '(3' // FR8P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( f_out_binary ) select case ( Upper_Case ( trim ( vec_type ))) case ( 'VECT' ) write ( unit = Unit_VTK , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' double' // end_rec case ( 'NORM' ) write ( unit = Unit_VTK , iostat = E_IO ) 'NORMALS ' // trim ( varname ) // ' double' // end_rec endselect write ( unit = Unit_VTK , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_VECT_R8","loc":"proc/vtk_var_vect_r8.html"},{"tags":"","title":"VTK_VAR_VECT_R4 – MUSST","text":"private function VTK_VAR_VECT_R4(vec_type, NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving field of vectorial variable (R4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: varX (1:NC_NN) real(kind=R4P), intent(in) :: varY (1:NC_NN) real(kind=R4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) Calls proc~~vtk_var_vect_r4~~CallsGraph proc~vtk_var_vect_r4 VTK_VAR_VECT_R4 proc~upper_case Upper_Case proc~vtk_var_vect_r4->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_vect_r4~~CalledByGraph proc~vtk_var_vect_r4 VTK_VAR_VECT_R4 interface~vtk_var VTK_VAR interface~vtk_var->proc~vtk_var_vect_r4 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_VECT_R4 Source Code function VTK_VAR_VECT_R4 ( vec_type , NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving field of vectorial variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: vec_type ! vector type: vect = generic vector , norm = normal vector integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells character ( * ), intent ( IN ) :: varname ! variable name real ( R4P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component of vector real ( R4P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component of vector real ( R4P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component of vector integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I8P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) select case ( Upper_Case ( trim ( vec_type ))) case ( 'vect' ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' float' case ( 'norm' ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'NORMALS ' // trim ( varname ) // ' float' endselect write ( unit = Unit_VTK , fmt = '(3' // FR4P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( f_out_binary ) select case ( Upper_Case ( trim ( vec_type ))) case ( 'vect' ) write ( unit = Unit_VTK , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' float' // end_rec case ( 'norm' ) write ( unit = Unit_VTK , iostat = E_IO ) 'NORMALS ' // trim ( varname ) // ' float' // end_rec endselect write ( unit = Unit_VTK , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_VECT_R4","loc":"proc/vtk_var_vect_r4.html"},{"tags":"","title":"VTK_VAR_VECT_I4 – MUSST","text":"private function VTK_VAR_VECT_I4(NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving field of vectorial variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: varX (1:NC_NN) integer(kind=I4P), intent(in) :: varY (1:NC_NN) integer(kind=I4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) Called by proc~~vtk_var_vect_i4~~CalledByGraph proc~vtk_var_vect_i4 VTK_VAR_VECT_I4 interface~vtk_var VTK_VAR interface~vtk_var->proc~vtk_var_vect_i4 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_VECT_I4 Source Code function VTK_VAR_VECT_I4 ( NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving field of vectorial variable (I4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells character ( * ), intent ( IN ) :: varname ! variable name integer ( I4P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component of vector integer ( I4P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component of vector integer ( I4P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component of vector integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I8P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' int' write ( unit = Unit_VTK , fmt = '(3' // FI4P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) 'VECTORS ' // trim ( varname ) // ' int' // end_rec write ( unit = Unit_VTK , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_VECT_I4","loc":"proc/vtk_var_vect_i4.html"},{"tags":"","title":"VTK_VAR_TEXT_R8 – MUSST","text":"private function VTK_VAR_TEXT_R8(NC_NN, dimm, varname, textCoo) result(E_IO) Function for saving texture variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: dimm character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: textCoo (1:NC_NN,1:dimm) Return Value integer(kind=I4P) Called by proc~~vtk_var_text_r8~~CalledByGraph proc~vtk_var_text_r8 VTK_VAR_TEXT_R8 interface~vtk_var VTK_VAR interface~vtk_var->proc~vtk_var_text_r8 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_TEXT_R8 Source Code function VTK_VAR_TEXT_R8 ( NC_NN , dimm , varname , textCoo ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving texture variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells integer ( I4P ), intent ( IN ) :: dimm ! texture dimensions character ( * ), intent ( IN ) :: varname ! variable name real ( R8P ), intent ( IN ) :: textCoo ( 1 : NC_NN , 1 : dimm ) ! texture integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I8P ) :: n1 , n2 ! counters !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,1X,' // FI4P // ',1X,A)' , iostat = E_IO ) 'TEXTURE_COORDINATES ' // trim ( varname ), dimm , ' double' write ( s_buffer , fmt = '(I1)' , iostat = E_IO ) dimm s_buffer = '(' // trim ( s_buffer ) // FR4P // ')' write ( unit = Unit_VTK , fmt = trim ( s_buffer ), iostat = E_IO )(( textCoo ( n1 , n2 ), n2 = 1 , dimm ), n1 = 1 , NC_NN ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,1X,' // FI4P // ',1X,A)' , iostat = E_IO ) 'TEXTURE_COORDINATES ' // trim ( varname ), dimm , ' double' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )(( textCoo ( n1 , n2 ), n2 = 1 , dimm ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_TEXT_R8","loc":"proc/vtk_var_text_r8.html"},{"tags":"","title":"VTK_VAR_TEXT_R4 – MUSST","text":"private function VTK_VAR_TEXT_R4(NC_NN, dimm, varname, textCoo) result(E_IO) Function for saving texture variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: dimm character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: textCoo (1:NC_NN,1:dimm) Return Value integer(kind=I4P) Called by proc~~vtk_var_text_r4~~CalledByGraph proc~vtk_var_text_r4 VTK_VAR_TEXT_R4 interface~vtk_var VTK_VAR interface~vtk_var->proc~vtk_var_text_r4 proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_TEXT_R4 Source Code function VTK_VAR_TEXT_R4 ( NC_NN , dimm , varname , textCoo ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving texture variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of nodes or cells integer ( I4P ), intent ( IN ) :: dimm ! texture dimensions character ( * ), intent ( IN ) :: varname ! variable name real ( R4P ), intent ( IN ) :: textCoo ( 1 : NC_NN , 1 : dimm ) ! texture integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I8P ) :: n1 , n2 ! counters !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,1X,' // FI4P // ',1X,A)' , iostat = E_IO ) 'TEXTURE_COORDINATES ' // trim ( varname ), dimm , ' float' write ( s_buffer , fmt = '(I1)' , iostat = E_IO ) dimm s_buffer = '(' // trim ( s_buffer ) // FR4P // ')' write ( unit = Unit_VTK , fmt = trim ( s_buffer ), iostat = E_IO )(( textCoo ( n1 , n2 ), n2 = 1 , dimm ), n1 = 1 , NC_NN ) case ( f_out_binary ) write ( s_buffer , fmt = '(A,1X,' // FI4P // ',1X,A)' , iostat = E_IO ) 'TEXTURE_COORDINATES ' // trim ( varname ), dimm , ' float' write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO )(( textCoo ( n1 , n2 ), n2 = 1 , dimm ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_TEXT_R4","loc":"proc/vtk_var_text_r4.html"},{"tags":"","title":"VTK_END – MUSST","text":"public function VTK_END() result(E_IO) This function is used to finalize the file opened and it has not inputs. The \\LIBVTKIO manages the file unit without the\nuser's action. Arguments None Return Value integer(kind=I4P) The VTK_END variables have the following meaning: \\begin{description}\n \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling.\n\\end{description} The following is an example of VTK_END calling: \\begin{boxred}{VTK\\_END Calling}\n\\begin{verbatim}\n...\nE_IO = VTK_END()\n...\n\\end{verbatim}\n\\end{boxred} Called by proc~~vtk_end~~CalledByGraph proc~vtk_end VTK_END proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->proc~vtk_end Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_END Source Code function VTK_END () result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!This function is used to finalize the file opened and it has not inputs. The \\LIBVTKIO manages the file unit without the !!user's action. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !!The VTK\\_END variables have the following meaning: !! !!\\begin{description} !! \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling. !!\\end{description} !! !!The following is an example of VTK\\_END calling: !! !!\\begin{boxred}{VTK\\_END Calling} !!\\begin{verbatim} !!... !!E_IO = VTK_END() !!... !!\\end{verbatim} !!\\end{boxred} !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- close ( unit = Unit_VTK , iostat = E_IO ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_END","loc":"proc/vtk_end.html"},{"tags":"","title":"VTK_INI_XML – MUSST","text":"public function VTK_INI_XML(output_format, filename, mesh_topology, nx1, nx2, ny1, ny2, nz1, nz2) result(E_IO) The VTK_INI_XML function is used for initializing file. This function must be the first to be called. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: output_format character(len=*), intent(in) :: filename character(len=*), intent(in) :: mesh_topology integer(kind=I4P), intent(in), optional :: nx1 integer(kind=I4P), intent(in), optional :: nx2 integer(kind=I4P), intent(in), optional :: ny1 integer(kind=I4P), intent(in), optional :: ny2 integer(kind=I4P), intent(in), optional :: nz1 integer(kind=I4P), intent(in), optional :: nz2 Return Value integer(kind=I4P) Calls proc~~vtk_ini_xml~~CallsGraph proc~vtk_ini_xml VTK_INI_XML proc~getunit GetUnit proc~vtk_ini_xml->proc~getunit proc~upper_case Upper_Case proc~vtk_ini_xml->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_INI_XML Source Code function VTK_INI_XML ( output_format , filename , mesh_topology , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!The VTK\\_INI\\_XML function is used for initializing file. This function must be the first to be called. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: output_format ! output format: ASCII or BINARY character ( * ), intent ( IN ) :: filename ! file name character ( * ), intent ( IN ) :: mesh_topology ! mesh topology integer ( I4P ), intent ( IN ), optional :: nx1 , nx2 ! initial and final nodes of x axis integer ( I4P ), intent ( IN ), optional :: ny1 , ny2 ! initial and final nodes of y axis integer ( I4P ), intent ( IN ), optional :: nz1 , nz2 ! initial and final nodes of z axis integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string !!The VTK\\_INI\\_XML variables have the following meaning: !! !!\\begin{description} !!\\item[{\\color{RoyalBlue}output\\_format}] indicates the \\virgo{format} of output file. It can assume the following values: !! \\begin{enumerateABlu} !!  \\item \\emph{ascii} (it is case insensitive) $\\rightarrow$ creating an ascii output file. !!  \\item \\emph{binary} (it is case insensitive) $\\rightarrow$ creating a binary (big\\_endian encoding) output file. !! \\end{enumerateABlu} !! \\item[{\\color{RoyalBlue}filename}] contains the name (with its path) of the output file. !! \\item[{\\color{RoyalBlue}topology}] indicates the topology of the mesh and can assume the following values: !! \\begin{enumerateABlu} !!  \\item \\emph{StructuredGrid}. !!  \\item \\emph{RectilinearGrid}. !!  \\item \\emph{UnstructuredGrid}. !! \\end{enumerateABlu} !! \\item[{\\color{RoyalBlue}nx1,nx2}] contains the extent of X axis; $nx1$ is the initial node and $nx2$ is the final. !! \\item[{\\color{RoyalBlue}ny1,ny2}] contains the extent of Y axis; $ny1$ is the initial node and $ny2$ is the final. !! \\item[{\\color{RoyalBlue}nz1,nz2}] contains the extent of Z axis; $nz1$ is the initial node and $nz2$ is the final. !! \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling. !!\\end{description} !! !!This function is quite more complex than the rispective legacy function; it needs more inputs: the XML standard needs more !!informations to initialize the file. !! !!The following is an example of VTK\\_INI\\_XML calling: !! !!\\begin{boxred}{VTK\\_INI\\_XML Calling} !!\\begin{verbatim} !!... !!... !!E_IO = VTK_INI_XML('BINARY','XML_RECT_BINARY.vtr', & !!                   'RectilinearGrid',              & !!                   nx1=nx1,nx2=nx2,                & !!                   ny1=ny1,ny2=ny2,                & !!                   nz1=nz1,nz2=nz2) !!... !!\\end{verbatim} !!\\end{boxred} !! !!\\noindent Note that the file extension is necessary in the file name. The XML standard has different extensions for each !!different topologies (i.e. \\MaiuscolettoBS{.vtr} for rectilinear topology). See the VTK-standard file for more information. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- topology = trim ( mesh_topology ) Unit_VTK = GetUnit () select case ( trim ( Upper_Case ( output_format ))) case ( 'ASCII' ) f_out = f_out_ascii open ( unit = Unit_VTK , & file = trim ( filename ), & form = 'FORMATTED' , & access = 'SEQUENTIAL' , & action = 'WRITE' , & iostat = E_IO ) ! writing header of file write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) '<?xml version=\"1.0\"?>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) '<VTKFile type=\"' // trim ( topology ) // '\" version=\"0.1\" byte_order=\"BigEndian\">' indent = 2 select case ( trim ( topology )) case ( 'RectilinearGrid' , 'StructuredGrid' ) write ( unit = Unit_VTK , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<' // & trim ( topology ) // & ' WholeExtent=\"' , & nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , & '\">' case ( 'UnstructuredGrid' ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<' // trim ( topology ) // '>' endselect indent = indent + 2 case ( 'BINARY' ) f_out = f_out_binary open ( unit = Unit_VTK , & file = trim ( filename ), & form = 'UNFORMATTED' , & access = 'STREAM' , & action = 'WRITE' , & convert = 'BIG_ENDIAN' , & iostat = E_IO ) ! writing header of file write ( unit = Unit_VTK , iostat = E_IO ) '<?xml version=\"1.0\"?>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) '<VTKFile type=\"' // trim ( topology ) // '\" version=\"0.1\" byte_order=\"BigEndian\">' // end_rec indent = 2 select case ( trim ( topology )) case ( 'RectilinearGrid' , 'StructuredGrid' ) write ( s_buffer , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<' // & trim ( topology ) // & ' WholeExtent=\"' , & nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , & '\">' case ( 'UnstructuredGrid' ) write ( s_buffer , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<' // trim ( topology ) // '>' endselect write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec indent = indent + 2 Unit_VTK_Append = GetUnit () ! opening the SCRATCH file used for appending raw binary data open ( unit = Unit_VTK_Append , & form = 'UNFORMATTED' , & access = 'STREAM' , & action = 'READWRITE' , & convert = 'BIG_ENDIAN' , & status = 'SCRATCH' , & iostat = E_IO ) ioffset = 0 ! initializing offset puntator endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_INI_XML","loc":"proc/vtk_ini_xml.html"},{"tags":"","title":"VTK_GEO_XML_STRG_R8 – MUSST","text":"private function VTK_GEO_XML_STRG_R8(nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = StructuredGrid (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 integer(kind=I4P), intent(in) :: NN real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) Calls proc~~vtk_geo_xml_strg_r8~~CallsGraph proc~vtk_geo_xml_strg_r8 VTK_GEO_XML_STRG_R8 interface~str str proc~vtk_geo_xml_strg_r8->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_geo_xml_strg_r8~~CalledByGraph proc~vtk_geo_xml_strg_r8 VTK_GEO_XML_STRG_R8 interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_XML_STRG_R8 Source Code function VTK_GEO_XML_STRG_R8 ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = StructuredGrid (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: nx1 , nx2 ! initial and final nodes of x axis integer ( I4P ), intent ( IN ) :: ny1 , ny2 ! initial and final nodes of y axis integer ( I4P ), intent ( IN ) :: nz1 , nz2 ! initial and final nodes of z axis integer ( I4P ), intent ( IN ) :: NN ! number of all nodes real ( R8P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates real ( R8P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates real ( R8P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Point\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FR8P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' case ( f_out_binary ) write ( s_buffer , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' // end_rec indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Point\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NN * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , 3 * NN write ( unit = Unit_VTK_Append , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_STRG_R8","loc":"proc/vtk_geo_xml_strg_r8.html"},{"tags":"","title":"VTK_GEO_XML_STRG_R4 – MUSST","text":"private function VTK_GEO_XML_STRG_R4(nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = StructuredGrid (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 integer(kind=I4P), intent(in) :: NN real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) Calls proc~~vtk_geo_xml_strg_r4~~CallsGraph proc~vtk_geo_xml_strg_r4 VTK_GEO_XML_STRG_R4 interface~str str proc~vtk_geo_xml_strg_r4->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_geo_xml_strg_r4~~CalledByGraph proc~vtk_geo_xml_strg_r4 VTK_GEO_XML_STRG_R4 interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_XML_STRG_R4 Source Code function VTK_GEO_XML_STRG_R4 ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , NN , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = StructuredGrid (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: nx1 , nx2 ! initial and final nodes of x axis integer ( I4P ), intent ( IN ) :: ny1 , ny2 ! initial and final nodes of y axis integer ( I4P ), intent ( IN ) :: nz1 , nz2 ! initial and final nodes of z axis integer ( I4P ), intent ( IN ) :: NN ! number of all nodes real ( R4P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates real ( R4P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates real ( R4P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Point\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FR4P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' case ( f_out_binary ) write ( s_buffer , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' // end_rec indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Point\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NN * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , 3 * NN write ( unit = Unit_VTK_Append , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_STRG_R4","loc":"proc/vtk_geo_xml_strg_r4.html"},{"tags":"","title":"VTK_GEO_XML_RECT_R8 – MUSST","text":"private function VTK_GEO_XML_RECT_R8(nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z) result(E_IO) Function for saving mesh; topology = RectilinearGrid (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 real(kind=R8P), intent(in) :: X (nx1:nx2) real(kind=R8P), intent(in) :: Y (ny1:ny2) real(kind=R8P), intent(in) :: Z (nz1:nz2) Return Value integer(kind=I4P) Calls proc~~vtk_geo_xml_rect_r8~~CallsGraph proc~vtk_geo_xml_rect_r8 VTK_GEO_XML_RECT_R8 interface~str str proc~vtk_geo_xml_rect_r8->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_geo_xml_rect_r8~~CalledByGraph proc~vtk_geo_xml_rect_r8 VTK_GEO_XML_RECT_R8 interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_XML_RECT_R8 Source Code function VTK_GEO_XML_RECT_R8 ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = RectilinearGrid (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: nx1 , nx2 ! initial and final nodes of x axis integer ( I4P ), intent ( IN ) :: ny1 , ny2 ! initial and final nodes of y axis integer ( I4P ), intent ( IN ) :: nz1 , nz2 ! initial and final nodes of z axis real ( R8P ), intent ( IN ) :: X ( nx1 : nx2 ) ! x coordinates real ( R8P ), intent ( IN ) :: Y ( ny1 : ny2 ) ! y coordinates real ( R8P ), intent ( IN ) :: Z ( nz1 : nz2 ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Coordinates>' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Float64\" Name=\"X\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO )( X ( n1 ), n1 = nx1 , nx2 ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Float64\" Name=\"Y\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO )( Y ( n1 ), n1 = ny1 , ny2 ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Float64\" Name=\"Z\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO )( Z ( n1 ), n1 = nz1 , nz2 ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Coordinates>' case ( f_out_binary ) write ( s_buffer , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<Coordinates>' // end_rec indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"X\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = ( nx2 - nx1 + 1 ) * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , nx2 - nx1 + 1 write ( unit = Unit_VTK_Append , iostat = E_IO )( X ( n1 ), n1 = nx1 , nx2 ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"Y\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = ( ny2 - ny1 + 1 ) * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , ny2 - ny1 + 1 write ( unit = Unit_VTK_Append , iostat = E_IO )( Y ( n1 ), n1 = ny1 , ny2 ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"Z\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = ( nz2 - nz1 + 1 ) * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , nz2 - nz1 + 1 write ( unit = Unit_VTK_Append , iostat = E_IO )( Z ( n1 ), n1 = nz1 , nz2 ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Coordinates>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_RECT_R8","loc":"proc/vtk_geo_xml_rect_r8.html"},{"tags":"","title":"VTK_GEO_XML_RECT_R4 – MUSST","text":"private function VTK_GEO_XML_RECT_R4(nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z) result(E_IO) Function for saving mesh; topology = RectilinearGrid (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 real(kind=R4P), intent(in) :: X (nx1:nx2) real(kind=R4P), intent(in) :: Y (ny1:ny2) real(kind=R4P), intent(in) :: Z (nz1:nz2) Return Value integer(kind=I4P) Calls proc~~vtk_geo_xml_rect_r4~~CallsGraph proc~vtk_geo_xml_rect_r4 VTK_GEO_XML_RECT_R4 interface~str str proc~vtk_geo_xml_rect_r4->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_geo_xml_rect_r4~~CalledByGraph proc~vtk_geo_xml_rect_r4 VTK_GEO_XML_RECT_R4 interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_XML_RECT_R4 Source Code function VTK_GEO_XML_RECT_R4 ( nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = RectilinearGrid (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: nx1 , nx2 ! initial and final nodes of x axis integer ( I4P ), intent ( IN ) :: ny1 , ny2 ! initial and final nodes of y axis integer ( I4P ), intent ( IN ) :: nz1 , nz2 ! initial and final nodes of z axis real ( R4P ), intent ( IN ) :: X ( nx1 : nx2 ) ! x coordinates real ( R4P ), intent ( IN ) :: Y ( ny1 : ny2 ) ! y coordinates real ( R4P ), intent ( IN ) :: Z ( nz1 : nz2 ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Coordinates>' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Float32\" Name=\"X\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO )( X ( n1 ), n1 = nx1 , nx2 ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Float32\" Name=\"Y\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO )( Y ( n1 ), n1 = ny1 , ny2 ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Float32\" Name=\"Z\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO )( Z ( n1 ), n1 = nz1 , nz2 ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Coordinates>' case ( f_out_binary ) write ( s_buffer , fmt = '(A,6' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Piece Extent=\"' , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 , '\">' indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<Coordinates>' // end_rec indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"X\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = ( nx2 - nx1 + 1 ) * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , nx2 - nx1 + 1 write ( unit = Unit_VTK_Append , iostat = E_IO )( X ( n1 ), n1 = nx1 , nx2 ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"Y\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = ( ny2 - ny1 + 1 ) * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , ny2 - ny1 + 1 write ( unit = Unit_VTK_Append , iostat = E_IO )( Y ( n1 ), n1 = ny1 , ny2 ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"Z\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = ( nz2 - nz1 + 1 ) * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , nz2 - nz1 + 1 write ( unit = Unit_VTK_Append , iostat = E_IO )( Z ( n1 ), n1 = nz1 , nz2 ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Coordinates>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_RECT_R4","loc":"proc/vtk_geo_xml_rect_r4.html"},{"tags":"","title":"VTK_GEO_XML_UNST_R8 – MUSST","text":"private function VTK_GEO_XML_UNST_R8(NN, NC, X, Y, Z) result(E_IO) Function for saving mesh; topology = UnstructuredGrid (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN integer(kind=I4P), intent(in) :: NC real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) Calls proc~~vtk_geo_xml_unst_r8~~CallsGraph proc~vtk_geo_xml_unst_r8 VTK_GEO_XML_UNST_R8 interface~str str proc~vtk_geo_xml_unst_r8->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_geo_xml_unst_r8~~CalledByGraph proc~vtk_geo_xml_unst_r8 VTK_GEO_XML_UNST_R8 interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_XML_UNST_R8 Source Code function VTK_GEO_XML_UNST_R8 ( NN , NC , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = UnstructuredGrid (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NN ! number of nodes integer ( I4P ), intent ( IN ) :: NC ! number of cells real ( R8P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates real ( R8P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates real ( R8P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A,' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<Piece NumberOfPoints=\"' , & NN , & '\" NumberOfCells=\"' , & NC , & '\">' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Point\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FR8P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' case ( f_out_binary ) write ( s_buffer , fmt = '(A,' // FI4P // ',A,' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<Piece NumberOfPoints=\"' , & NN , & '\" NumberOfCells=\"' , & NC , & '\">' indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' // end_rec indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"Point\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NN * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , 3 * NN write ( unit = Unit_VTK_Append , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_UNST_R8","loc":"proc/vtk_geo_xml_unst_r8.html"},{"tags":"","title":"VTK_GEO_XML_UNST_R4 – MUSST","text":"private function VTK_GEO_XML_UNST_R4(NN, NC, X, Y, Z) result(E_IO) Function for saving mesh; topology = UnstructuredGrid (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN integer(kind=I4P), intent(in) :: NC real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) Calls proc~~vtk_geo_xml_unst_r4~~CallsGraph proc~vtk_geo_xml_unst_r4 VTK_GEO_XML_UNST_R4 interface~str str proc~vtk_geo_xml_unst_r4->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_geo_xml_unst_r4~~CalledByGraph proc~vtk_geo_xml_unst_r4 VTK_GEO_XML_UNST_R4 interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_XML_UNST_R4 Source Code function VTK_GEO_XML_UNST_R4 ( NN , NC , X , Y , Z ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving mesh; topology = UnstructuredGrid (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NN ! number of nodes integer ( I4P ), intent ( IN ) :: NC ! number of cells real ( R4P ), intent ( IN ) :: X ( 1 : NN ) ! x coordinates real ( R4P ), intent ( IN ) :: Y ( 1 : NN ) ! y coordinates real ( R4P ), intent ( IN ) :: Z ( 1 : NN ) ! z coordinates integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( len = maxlen ) :: s_buffer ! buffer string integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A,' // FI4P // ',A,' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<Piece NumberOfPoints=\"' , & NN , & '\" NumberOfCells=\"' , & NC , & '\">' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Point\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FR4P // ')' , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' case ( f_out_binary ) write ( s_buffer , fmt = '(A,' // FI4P // ',A,' // FI4P // ',A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<Piece NumberOfPoints=\"' , & NN , & '\" NumberOfCells=\"' , & NC , & '\">' indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) trim ( s_buffer ) // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<Points>' // end_rec indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" NumberOfComponents=\"3\" Name=\"Point\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NN * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , 3 * NN write ( unit = Unit_VTK_Append , iostat = E_IO )( X ( n1 ), Y ( n1 ), Z ( n1 ), n1 = 1 , NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Points>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_UNST_R4","loc":"proc/vtk_geo_xml_unst_r4.html"},{"tags":"","title":"VTK_GEO_XML_CLOSEP – MUSST","text":"private function VTK_GEO_XML_CLOSEP() result(E_IO) Function for closing mesh block data. Arguments None Return Value integer(kind=I4P) Called by proc~~vtk_geo_xml_closep~~CalledByGraph proc~vtk_geo_xml_closep VTK_GEO_XML_CLOSEP interface~vtk_geo_xml VTK_GEO_XML interface~vtk_geo_xml->proc~vtk_geo_xml_closep Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_GEO_XML_CLOSEP Source Code function VTK_GEO_XML_CLOSEP () result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for closing mesh block data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- indent = indent - 2 select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Piece>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Piece>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_GEO_XML_CLOSEP","loc":"proc/vtk_geo_xml_closep.html"},{"tags":"","title":"VTK_CON_XML – MUSST","text":"public function VTK_CON_XML(NC, connect, offset, cell_type) result(E_IO) This function \\MaiuscolettoBS{must} be used when unstructured grid is used. It saves the connectivity of the unstructured mesh. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC integer(kind=I4P), intent(in) :: connect (:) integer(kind=I4P), intent(in) :: offset (1:NC) integer(kind=I1P), intent(in) :: cell_type (1:NC) Return Value integer(kind=I4P) Calls proc~~vtk_con_xml~~CallsGraph proc~vtk_con_xml VTK_CON_XML interface~str str proc~vtk_con_xml->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_CON_XML Source Code function VTK_CON_XML ( NC , connect , offset , cell_type ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!This function \\MaiuscolettoBS{must} be used when unstructured grid is used. It saves the connectivity of the unstructured mesh. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC ! number of cells integer ( I4P ), intent ( IN ) :: connect (:) ! mesh connectivity integer ( I4P ), intent ( IN ) :: offset ( 1 : NC ) ! cell offset integer ( I1P ), intent ( IN ) :: cell_type ( 1 : NC ) ! VTK cell type integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !!The VTK\\_CON\\_XML variables have the following meaning: !! !!\\begin{description} !! \\item[{\\color{RoyalBlue}NCelle}] indicates the number of all cells. !! \\item[{\\color{RoyalBlue}connect}] contains the connectivity of the mesh. It is a vector. !! \\item[{\\color{RoyalBlue}offset}] contains the offset\\footnote{The summ of nodes of all previous cells included the !!                                  current cell.} of every cells. It is a vector of $[1:NCelle]$. !! \\item[{\\color{RoyalBlue}tipo}] contains the type of every cells. It is a vector of $[1:NCelle]$. !! \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling. !!\\end{description} !! !!The vector \\MaiuscolettoBS{connect} must follow the VTK XML standard. It is passed as \\MaiuscolettoBS{assumed-shape} !!array because its dimensions is related to the mesh dimensions in a complex way. Its dimensions can be calculated by !!the following equation: !! !!\\begin{equation} !!dc = \\sum\\limits_{i = 1}&#94;{NCelle} {nvertex_i } !!\\label{eq:xml connectivity dimensions} !!\\end{equation} !! !!\\noindent where $dc$ is connectivity vector dimension and $nvertex_i$ is the number of vertices of $i&#94;{th}$ cell. !!Note that this equation is different from the legacy one (eq. \\ref{eq:connectivity dimensions}). The XML connectivity !!convention is quite different from the legacy standard. As an example considering the same mesh of section \\ref{sec:VTKCON}: !!suppose we have a mesh composed by 2 cells, one hexahedron (8 vertices) and one pyramid with square basis (5 vertices); !!suppose that the basis of pyramid is constitute by a face of the hexahedron and so the two cells share 4 vertices. The !!equation \\ref{eq:xml connectivity dimensions} gives $dc=8+5=13$; the connectivity vector for this mesh can be: !! !!\\begin{boxred}{Connectivity vector example for VTK XML standard} !!\\begin{verbatim} !!! first cell !!connect(1)  = 0  => identification flag of 1° vertex of 1° cell !!connect(2)  = 1  => identification flag of 2° vertex of 1° cell !!connect(3)  = 2  => identification flag of 3° vertex of 1° cell !!connect(4)  = 3  => identification flag of 4° vertex of 1° cell !!connect(5)  = 4  => identification flag of 5° vertex of 1° cell !!connect(6)  = 5  => identification flag of 6° vertex of 1° cell !!connect(7)  = 6  => identification flag of 7° vertex of 1° cell !!connect(8)  = 7  => identification flag of 8° vertex of 1° cell !!! second cell !!connect(9)  = 0  => identification flag of 1° vertex of 2° cell !!connect(10) = 1  => identification flag of 2° vertex of 2° cell !!connect(11) = 2  => identification flag of 3° vertex of 2° cell !!connect(12) = 3  => identification flag of 4° vertex of 2° cell !!connect(13) = 8  => identification flag of 5° vertex of 2° cell !!\\end{verbatim} !!\\end{boxred} !! !!Therefore this connectivity vector convention is more simple than the legacy convention, now we must create also the !!\\MaiuscolettoBS{offset} vector that contains the data now missing in the \\MaiuscolettoBS{connect} vector. The offset !!vector for this mesh can be: !! !!\\begin{boxred}{Offset vector example for VTK XML standard} !!\\begin{verbatim} !!! first cell !!offset(1) = 8  => summ of nodes of 1° cell !!! second cell !!offset(2) = 13 => summ of nodes of 1° and 2° cells !!\\end{verbatim} !!\\end{boxred} !! !!\\noindent The value of every cell-offset can be calculated by the following equation: !! !!\\begin{equation} !!offset_c = \\sum\\limits_{i = 1}&#94;{c} {nvertex_i } !!\\label{eq:xml offset vlue} !!\\end{equation} !! !!\\noindent where $offset_c$ is the value of $c&#94;{th}$ cell and $nvertex_i$ is the number of vertices of $i&#94;{th}$ cell. !! !!The function VTK\\_CON\\_XML does not calculate the connectivity and offset vectors: it writes the connectivity and offset !!vectors conforming the VTK XML standard, but does not calculate them. In the future release of \\LIBVTKIO will be included !!a function to calculate the connectivity and offset vector. !! !!The vector variable \\MaiuscolettoBS{tipo} must conform the VTK XML standard \\footnote{See the file VTK-Standard at the !!Kitware homepage.} that is the same of the legacy standard presented previous (sec. \\ref{sec:VTKCON}). It contains the !!\\emph{type} of each cells. For the above example this vector is: !! !!\\begin{boxred}{Cell-Type vector example for VTK legacy standard} !!\\begin{verbatim} !!tipo(1) = 12  => VTK hexahedron type of 1° cell !!tipo(2) = 14  => VTK pyramid type of 2° cell !!\\end{verbatim} !!\\end{boxred} !! !!The following is an example of VTK\\_CON\\_XML calling: !! !!\\begin{boxred}{VTK\\_CON\\_XML Calling} !!\\begin{verbatim} !!... !!integer(4), parameter:: NCelle=2 !!integer(4), parameter:: Nvertex1=8 !!integer(4), parameter:: Nvertex2=5 !!integer(4), parameter:: dc=Nvertex1+Nvertex2 !!integer(4)::            connect(1:dc) !!integer(4)::            offset(1:NCelle) !!integer(4)::            tipo(1:NCelle) !!... !!E_IO = VTK_CON_XML(NCelle,connect,offset,tipo) !!... !!\\end{verbatim} !!\\end{boxred} !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<Cells>' indent = indent + 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FI4P , iostat = E_IO )( connect ( n1 ), n1 = 1 , size ( connect )) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FI4P , iostat = E_IO )( offset ( n1 ), n1 = 1 , NC ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<DataArray type=\"Int8\" Name=\"types\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FI1P , iostat = E_IO )( cell_type ( n1 ), n1 = 1 , NC ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</Cells>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<Cells>' // end_rec indent = indent + 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"connectivity\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = size ( connect ) * sizeof ( Tipo_I4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I4' , size ( connect ) write ( unit = Unit_VTK_Append , iostat = E_IO )( connect ( n1 ), n1 = 1 , size ( connect )) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"offsets\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC * sizeof ( Tipo_I4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I4' , NC write ( unit = Unit_VTK_Append , iostat = E_IO )( offset ( n1 ), n1 = 1 , NC ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int8\" Name=\"types\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC * sizeof ( Tipo_I1 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I1' , NC write ( unit = Unit_VTK_Append , iostat = E_IO )( cell_type ( n1 ), n1 = 1 , NC ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</Cells>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_CON_XML","loc":"proc/vtk_con_xml.html"},{"tags":"","title":"VTK_DAT_XML – MUSST","text":"public function VTK_DAT_XML(var_location, var_block_action) result(E_IO) This function \\MaiuscolettoBS{must} be called before saving the data related to geometric mesh. This function initializes\nthe saving of data variables indicating the \\emph{type} of variables that will be saved. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var_location character(len=*), intent(in) :: var_block_action Return Value integer(kind=I4P) The VTK_DAT_XML variables have the following meaning: \\begin{description}\n\\item[{\\color{RoyalBlue}var\\_location}] contains the location-type of variables that will be saved after VTK\\_DAT.\nIt is a scalar and cab assume the following values:\n \\begin{enumerateABlu}\n  \\item \\emph{cell} (it is case insensitive) $\\rightarrow$ variables will be cell-centered.\n  \\item \\emph{node} (it is case insensitive) $\\rightarrow$ variables will be node-centered.\n \\end{enumerateABlu}\n \\item[{\\color{RoyalBlue}var\\_block\\_action}] indicates if the block-data-variables is being opened or closed; it can\n                                              assume the following values:\n \\begin{enumerateABlu}\n  \\item \\emph{open}  (it is case insensitive) $\\rightarrow$ block-data is being opened.\n  \\item \\emph{close} (it is case insensitive) $\\rightarrow$ block-data is being closed.\n \\end{enumerateABlu}\n \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling.\n\\end{description} Of course a single file can contain both cell and node centered variables. The \\MaiuscolettoBS{VTK_DAT_XML} must be\ncalled two times, before saving a block-data-variables in order to open the block, and after the block-data-variables\nhas been saved in order to close the block. XML file can contains as many blocks as you want. The following is an example of VTK_DAT_XML calling: \\begin{boxred}{VTK\\_DAT\\_XML Calling}\n\\begin{verbatim}\n...\nE_IO = VTK_DAT_XML('node','OPEN')\n...\nSAVE YOUR DATA WITH VTK_VAR_XML\n...\nE_IO = VTK_DAT_XML('node','CLOSE')\n...\n\\end{verbatim}\n\\end{boxred} Calls proc~~vtk_dat_xml~~CallsGraph proc~vtk_dat_xml VTK_DAT_XML proc~upper_case Upper_Case proc~vtk_dat_xml->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_DAT_XML Source Code function VTK_DAT_XML ( var_location , var_block_action ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!This function \\MaiuscolettoBS{must} be called before saving the data related to geometric mesh. This function initializes !!the saving of data variables indicating the \\emph{type} of variables that will be saved. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: var_location ! location of saving variables: CELL for cell-centered, NODE for node-centered character ( * ), intent ( IN ) :: var_block_action ! variables block action: OPEN or CLOSE block integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !!The VTK\\_DAT\\_XML variables have the following meaning: !! !!\\begin{description} !!\\item[{\\color{RoyalBlue}var\\_location}] contains the location-type of variables that will be saved after VTK\\_DAT. !!It is a scalar and cab assume the following values: !! \\begin{enumerateABlu} !!  \\item \\emph{cell} (it is case insensitive) $\\rightarrow$ variables will be cell-centered. !!  \\item \\emph{node} (it is case insensitive) $\\rightarrow$ variables will be node-centered. !! \\end{enumerateABlu} !! \\item[{\\color{RoyalBlue}var\\_block\\_action}] indicates if the block-data-variables is being opened or closed; it can !!                                              assume the following values: !! \\begin{enumerateABlu} !!  \\item \\emph{open}  (it is case insensitive) $\\rightarrow$ block-data is being opened. !!  \\item \\emph{close} (it is case insensitive) $\\rightarrow$ block-data is being closed. !! \\end{enumerateABlu} !! \\item[{\\color{RoyalBlue}E\\_IO}] contains the inquiring integer flag for error handling. !!\\end{description} !! !!Of course a single file can contain both cell and node centered variables. The \\MaiuscolettoBS{VTK\\_DAT\\_XML} must be !!called two times, before saving a block-data-variables in order to open the block, and after the block-data-variables !!has been saved in order to close the block. XML file can contains as many blocks as you want. !! !!The following is an example of VTK\\_DAT\\_XML calling: !! !!\\begin{boxred}{VTK\\_DAT\\_XML Calling} !!\\begin{verbatim} !!... !!E_IO = VTK_DAT_XML('node','OPEN') !!... !!SAVE YOUR DATA WITH VTK_VAR_XML !!... !!E_IO = VTK_DAT_XML('node','CLOSE') !!... !!\\end{verbatim} !!\\end{boxred} !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) select case ( trim ( Upper_Case ( var_location ))) case ( 'CELL' ) select case ( trim ( Upper_Case ( var_block_action ))) case ( 'OPEN' ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<CellData>' indent = indent + 2 case ( 'CLOSE' ) indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</CellData>' endselect case ( 'NODE' ) select case ( trim ( Upper_Case ( var_block_action ))) case ( 'OPEN' ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '<PointData>' indent = indent + 2 case ( 'CLOSE' ) indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</PointData>' endselect endselect case ( f_out_binary ) select case ( trim ( Upper_Case ( var_location ))) case ( 'CELL' ) select case ( trim ( Upper_Case ( var_block_action ))) case ( 'OPEN' ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<CellData>' // end_rec indent = indent + 2 case ( 'CLOSE' ) indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</CellData>' // end_rec endselect case ( 'NODE' ) select case ( trim ( Upper_Case ( var_block_action ))) case ( 'OPEN' ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<PointData>' // end_rec indent = indent + 2 case ( 'CLOSE' ) indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</PointData>' // end_rec endselect endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_DAT_XML","loc":"proc/vtk_dat_xml.html"},{"tags":"","title":"VTK_VAR_XML_SCAL_R8 – MUSST","text":"private function VTK_VAR_XML_SCAL_R8(NC_NN, varname, var) result(E_IO) Function for saving scalar variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_scal_r8~~CallsGraph proc~vtk_var_xml_scal_r8 VTK_VAR_XML_SCAL_R8 interface~str str proc~vtk_var_xml_scal_r8->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_scal_r8~~CalledByGraph proc~vtk_var_xml_scal_r8 VTK_VAR_XML_SCAL_R8 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_scal_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_SCAL_R8 Source Code function VTK_VAR_XML_SCAL_R8 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving scalar variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name real ( R8P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR8P , iostat = E_IO )( var ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC_NN * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( var ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_R8","loc":"proc/vtk_var_xml_scal_r8.html"},{"tags":"","title":"VTK_VAR_XML_SCAL_R4 – MUSST","text":"private function VTK_VAR_XML_SCAL_R4(NC_NN, varname, var) result(E_IO) Function for saving scalar variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_scal_r4~~CallsGraph proc~vtk_var_xml_scal_r4 VTK_VAR_XML_SCAL_R4 interface~str str proc~vtk_var_xml_scal_r4->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_scal_r4~~CalledByGraph proc~vtk_var_xml_scal_r4 VTK_VAR_XML_SCAL_R4 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_scal_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_SCAL_R4 Source Code function VTK_VAR_XML_SCAL_R4 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving scalar variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name real ( R4P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FR4P , iostat = E_IO ) var write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC_NN * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( var ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_R4","loc":"proc/vtk_var_xml_scal_r4.html"},{"tags":"","title":"VTK_VAR_XML_SCAL_I8 – MUSST","text":"private function VTK_VAR_XML_SCAL_I8(NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I8P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_scal_i8~~CallsGraph proc~vtk_var_xml_scal_i8 VTK_VAR_XML_SCAL_I8 interface~str str proc~vtk_var_xml_scal_i8->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_scal_i8~~CalledByGraph proc~vtk_var_xml_scal_i8 VTK_VAR_XML_SCAL_I8 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_scal_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_SCAL_I8 Source Code function VTK_VAR_XML_SCAL_I8 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving scalar variable (I8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I8P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FI8P , iostat = E_IO ) var write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC_NN * sizeof ( Tipo_I8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I8' , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( var ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_I8","loc":"proc/vtk_var_xml_scal_i8.html"},{"tags":"","title":"VTK_VAR_XML_SCAL_I4 – MUSST","text":"private function VTK_VAR_XML_SCAL_I4(NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_scal_i4~~CallsGraph proc~vtk_var_xml_scal_i4 VTK_VAR_XML_SCAL_I4 interface~str str proc~vtk_var_xml_scal_i4->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_scal_i4~~CalledByGraph proc~vtk_var_xml_scal_i4 VTK_VAR_XML_SCAL_I4 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_scal_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_SCAL_I4 Source Code function VTK_VAR_XML_SCAL_I4 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving scalar variable (I4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I4P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FI4P , iostat = E_IO ) var write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC_NN * sizeof ( Tipo_I4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I4' , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( var ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_I4","loc":"proc/vtk_var_xml_scal_i4.html"},{"tags":"","title":"VTK_VAR_XML_SCAL_I2 – MUSST","text":"private function VTK_VAR_XML_SCAL_I2(NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I2P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_scal_i2~~CallsGraph proc~vtk_var_xml_scal_i2 VTK_VAR_XML_SCAL_I2 interface~str str proc~vtk_var_xml_scal_i2->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_scal_i2~~CalledByGraph proc~vtk_var_xml_scal_i2 VTK_VAR_XML_SCAL_I2 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_scal_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_SCAL_I2 Source Code function VTK_VAR_XML_SCAL_I2 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving scalar variable (I2P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I2P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int16\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FI2P , iostat = E_IO ) var write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int16\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC_NN * sizeof ( Tipo_I2 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I2' , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( var ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_I2","loc":"proc/vtk_var_xml_scal_i2.html"},{"tags":"","title":"VTK_VAR_XML_SCAL_I1 – MUSST","text":"private function VTK_VAR_XML_SCAL_I1(NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I1P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_scal_i1~~CallsGraph proc~vtk_var_xml_scal_i1 VTK_VAR_XML_SCAL_I1 interface~str str proc~vtk_var_xml_scal_i1->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_scal_i1~~CalledByGraph proc~vtk_var_xml_scal_i1 VTK_VAR_XML_SCAL_I1 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_scal_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_SCAL_I1 Source Code function VTK_VAR_XML_SCAL_I1 ( NC_NN , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving scalar variable (I1P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I1P ), intent ( IN ) :: var ( 1 : NC_NN ) ! variable to be saved integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int8\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = FI1P , iostat = E_IO ) var write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int8\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"1\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = NC_NN * sizeof ( Tipo_I1 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I1' , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( var ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_SCAL_I1","loc":"proc/vtk_var_xml_scal_i1.html"},{"tags":"","title":"VTK_VAR_XML_VECT_R8 – MUSST","text":"private function VTK_VAR_XML_VECT_R8(NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: varX (1:NC_NN) real(kind=R8P), intent(in) :: varY (1:NC_NN) real(kind=R8P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_vect_r8~~CallsGraph proc~vtk_var_xml_vect_r8 VTK_VAR_XML_VECT_R8 interface~str str proc~vtk_var_xml_vect_r8->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_vect_r8~~CalledByGraph proc~vtk_var_xml_vect_r8 VTK_VAR_XML_VECT_R8 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_vect_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_VECT_R8 Source Code function VTK_VAR_XML_VECT_R8 ( NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving vectorial variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name real ( R8P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component real ( R8P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component real ( R8P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FR8P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NC_NN * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , 3 * NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_R8","loc":"proc/vtk_var_xml_vect_r8.html"},{"tags":"","title":"VTK_VAR_XML_VECT_R4 – MUSST","text":"private function VTK_VAR_XML_VECT_R4(NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: varX (1:NC_NN) real(kind=R4P), intent(in) :: varY (1:NC_NN) real(kind=R4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_vect_r4~~CallsGraph proc~vtk_var_xml_vect_r4 VTK_VAR_XML_VECT_R4 interface~str str proc~vtk_var_xml_vect_r4->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_vect_r4~~CalledByGraph proc~vtk_var_xml_vect_r4 VTK_VAR_XML_VECT_R4 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_vect_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_VECT_R4 Source Code function VTK_VAR_XML_VECT_R4 ( NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving vectorial variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name real ( R4P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component real ( R4P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component real ( R4P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FR4P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NC_NN * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , 3 * NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_R4","loc":"proc/vtk_var_xml_vect_r4.html"},{"tags":"","title":"VTK_VAR_XML_VECT_I8 – MUSST","text":"private function VTK_VAR_XML_VECT_I8(NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I8P), intent(in) :: varX (1:NC_NN) integer(kind=I8P), intent(in) :: varY (1:NC_NN) integer(kind=I8P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_vect_i8~~CallsGraph proc~vtk_var_xml_vect_i8 VTK_VAR_XML_VECT_I8 interface~str str proc~vtk_var_xml_vect_i8->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_vect_i8~~CalledByGraph proc~vtk_var_xml_vect_i8 VTK_VAR_XML_VECT_I8 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_vect_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_VECT_I8 Source Code function VTK_VAR_XML_VECT_I8 ( NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving vectorial variable (I8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I8P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component integer ( I8P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component integer ( I8P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FI8P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NC_NN * sizeof ( Tipo_I8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I8' , 3 * NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_I8","loc":"proc/vtk_var_xml_vect_i8.html"},{"tags":"","title":"VTK_VAR_XML_VECT_I4 – MUSST","text":"private function VTK_VAR_XML_VECT_I4(NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: varX (1:NC_NN) integer(kind=I4P), intent(in) :: varY (1:NC_NN) integer(kind=I4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_vect_i4~~CallsGraph proc~vtk_var_xml_vect_i4 VTK_VAR_XML_VECT_I4 interface~str str proc~vtk_var_xml_vect_i4->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_vect_i4~~CalledByGraph proc~vtk_var_xml_vect_i4 VTK_VAR_XML_VECT_I4 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_vect_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_VECT_I4 Source Code function VTK_VAR_XML_VECT_I4 ( NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving vectorial variable (I4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I4P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component integer ( I4P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component integer ( I4P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FI4P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NC_NN * sizeof ( Tipo_I4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I4' , 3 * NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_I4","loc":"proc/vtk_var_xml_vect_i4.html"},{"tags":"","title":"VTK_VAR_XML_VECT_I2 – MUSST","text":"private function VTK_VAR_XML_VECT_I2(NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I2P), intent(in) :: varX (1:NC_NN) integer(kind=I2P), intent(in) :: varY (1:NC_NN) integer(kind=I2P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_vect_i2~~CallsGraph proc~vtk_var_xml_vect_i2 VTK_VAR_XML_VECT_I2 interface~str str proc~vtk_var_xml_vect_i2->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_vect_i2~~CalledByGraph proc~vtk_var_xml_vect_i2 VTK_VAR_XML_VECT_I2 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_vect_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_VECT_I2 Source Code function VTK_VAR_XML_VECT_I2 ( NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving vectorial variable (I2P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I2P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component integer ( I2P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component integer ( I2P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int16\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FI2P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int16\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NC_NN * sizeof ( Tipo_I2 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I2' , 3 * NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_I2","loc":"proc/vtk_var_xml_vect_i2.html"},{"tags":"","title":"VTK_VAR_XML_VECT_I1 – MUSST","text":"private function VTK_VAR_XML_VECT_I1(NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I1P), intent(in) :: varX (1:NC_NN) integer(kind=I1P), intent(in) :: varY (1:NC_NN) integer(kind=I1P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_vect_i1~~CallsGraph proc~vtk_var_xml_vect_i1 VTK_VAR_XML_VECT_I1 interface~str str proc~vtk_var_xml_vect_i1->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_vect_i1~~CalledByGraph proc~vtk_var_xml_vect_i1 VTK_VAR_XML_VECT_I1 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_vect_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_VECT_I1 Source Code function VTK_VAR_XML_VECT_I1 ( NC_NN , varname , varX , varY , varZ ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving vectorial variable (I1P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes character ( * ), intent ( IN ) :: varname ! variable name integer ( I1P ), intent ( IN ) :: varX ( 1 : NC_NN ) ! x component integer ( I1P ), intent ( IN ) :: varY ( 1 : NC_NN ) ! y component integer ( I1P ), intent ( IN ) :: varZ ( 1 : NC_NN ) ! z component integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int8\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"ascii\">' write ( unit = Unit_VTK , fmt = '(3' // FI1P // ')' , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int8\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"3\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // & end_rec N_Byte = 3 * NC_NN * sizeof ( Tipo_I1 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I1' , 3 * NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO )( varX ( n1 ), varY ( n1 ), varZ ( n1 ), n1 = 1 , NC_NN ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_VECT_I1","loc":"proc/vtk_var_xml_vect_i1.html"},{"tags":"","title":"VTK_VAR_XML_LIST_R8 – MUSST","text":"private function VTK_VAR_XML_LIST_R8(NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_list_r8~~CallsGraph proc~vtk_var_xml_list_r8 VTK_VAR_XML_LIST_R8 interface~str str proc~vtk_var_xml_list_r8->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_list_r8~~CalledByGraph proc~vtk_var_xml_list_r8 VTK_VAR_XML_LIST_R8 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_list_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_LIST_R8 Source Code function VTK_VAR_XML_LIST_R8 ( NC_NN , N_COL , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving list variable (R8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes integer ( I4P ), intent ( IN ) :: N_COL ! number of columns character ( * ), intent ( IN ) :: varname ! variable name real ( R8P ), intent ( IN ) :: var ( 1 : NC_NN , 1 : N_COL ) ! components integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 , n2 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"ascii\">' do n1 = 1 , NC_NN write ( unit = Unit_VTK , fmt = '(' // FR8P // ')' , iostat = E_IO ) ( var ( n1 , n2 ), n2 = 1 , N_COL ) enddo write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), '\">' // & end_rec N_Byte = N_COL * NC_NN * sizeof ( Tipo_R8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R8' , N_COL * NC_NN do n1 = 1 , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO ) var ( n1 ,:) enddo write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_R8","loc":"proc/vtk_var_xml_list_r8.html"},{"tags":"","title":"VTK_VAR_XML_LIST_R4 – MUSST","text":"private function VTK_VAR_XML_LIST_R4(NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_list_r4~~CallsGraph proc~vtk_var_xml_list_r4 VTK_VAR_XML_LIST_R4 interface~str str proc~vtk_var_xml_list_r4->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_list_r4~~CalledByGraph proc~vtk_var_xml_list_r4 VTK_VAR_XML_LIST_R4 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_list_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_LIST_R4 Source Code function VTK_VAR_XML_LIST_R4 ( NC_NN , N_COL , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving list variable (R4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes integer ( I4P ), intent ( IN ) :: N_COL ! number of columns character ( * ), intent ( IN ) :: varname ! variable name real ( R4P ), intent ( IN ) :: var ( 1 : NC_NN , 1 : N_COL ) ! components integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 , n2 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"ascii\">' do n1 = 1 , NC_NN write ( unit = Unit_VTK , fmt = '(' // FR4P // ')' , iostat = E_IO ) ( var ( n1 , n2 ), n2 = 1 , N_COL ) enddo write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Float32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), '\">' // & end_rec N_Byte = N_COL * NC_NN * sizeof ( Tipo_R4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'R4' , N_COL * NC_NN do n1 = 1 , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO ) var ( n1 ,:) enddo write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_R4","loc":"proc/vtk_var_xml_list_r4.html"},{"tags":"","title":"VTK_VAR_XML_LIST_I8 – MUSST","text":"private function VTK_VAR_XML_LIST_I8(NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I8P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_list_i8~~CallsGraph proc~vtk_var_xml_list_i8 VTK_VAR_XML_LIST_I8 interface~str str proc~vtk_var_xml_list_i8->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_list_i8~~CalledByGraph proc~vtk_var_xml_list_i8 VTK_VAR_XML_LIST_I8 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_list_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_LIST_I8 Source Code function VTK_VAR_XML_LIST_I8 ( NC_NN , N_COL , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving list variable (I8P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes integer ( I4P ), intent ( IN ) :: N_COL ! number of columns character ( * ), intent ( IN ) :: varname ! variable name integer ( I8P ), intent ( IN ) :: var ( 1 : NC_NN , 1 : N_COL ) ! components integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 , n2 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"ascii\">' do n1 = 1 , NC_NN write ( unit = Unit_VTK , fmt = '(' // FI8P // ')' , iostat = E_IO ) ( var ( n1 , n2 ), n2 = 1 , N_COL ) enddo write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int64\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // end_rec N_Byte = N_COL * NC_NN * sizeof ( Tipo_I8 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I8' , N_COL * NC_NN do n1 = 1 , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO ) var ( n1 ,:) enddo write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_I8","loc":"proc/vtk_var_xml_list_i8.html"},{"tags":"","title":"VTK_VAR_XML_LIST_I4 – MUSST","text":"private function VTK_VAR_XML_LIST_I4(NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_list_i4~~CallsGraph proc~vtk_var_xml_list_i4 VTK_VAR_XML_LIST_I4 interface~str str proc~vtk_var_xml_list_i4->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_list_i4~~CalledByGraph proc~vtk_var_xml_list_i4 VTK_VAR_XML_LIST_I4 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_list_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_LIST_I4 Source Code function VTK_VAR_XML_LIST_I4 ( NC_NN , N_COL , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving list variable (I4P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes integer ( I4P ), intent ( IN ) :: N_COL ! number of columns character ( * ), intent ( IN ) :: varname ! variable name integer ( I4P ), intent ( IN ) :: var ( 1 : NC_NN , 1 : N_COL ) ! components integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 , n2 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"ascii\">' do n1 = 1 , NC_NN write ( unit = Unit_VTK , fmt = '(' // FI4P // ')' , iostat = E_IO ) ( var ( n1 , n2 ), n2 = 1 , N_COL ) enddo write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int32\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // end_rec N_Byte = N_COL * NC_NN * sizeof ( Tipo_I4 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I4' , N_COL * NC_NN do n1 = 1 , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO ) var ( n1 ,:) enddo write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_I4","loc":"proc/vtk_var_xml_list_i4.html"},{"tags":"","title":"VTK_VAR_XML_LIST_I2 – MUSST","text":"private function VTK_VAR_XML_LIST_I2(NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I2P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_list_i2~~CallsGraph proc~vtk_var_xml_list_i2 VTK_VAR_XML_LIST_I2 interface~str str proc~vtk_var_xml_list_i2->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_list_i2~~CalledByGraph proc~vtk_var_xml_list_i2 VTK_VAR_XML_LIST_I2 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_list_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/vtk_var_xml_list_i2.html"},{"tags":"","title":"VTK_VAR_XML_LIST_I1 – MUSST","text":"private function VTK_VAR_XML_LIST_I1(NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I1P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) Calls proc~~vtk_var_xml_list_i1~~CallsGraph proc~vtk_var_xml_list_i1 VTK_VAR_XML_LIST_I1 interface~str str proc~vtk_var_xml_list_i1->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vtk_var_xml_list_i1~~CalledByGraph proc~vtk_var_xml_list_i1 VTK_VAR_XML_LIST_I1 interface~vtk_var_xml VTK_VAR_XML interface~vtk_var_xml->proc~vtk_var_xml_list_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTK_VAR_XML_LIST_I1 Source Code function VTK_VAR_XML_LIST_I1 ( NC_NN , N_COL , varname , var ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !! Function for saving list variable (I1P). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: NC_NN ! number of cells or nodes integer ( I4P ), intent ( IN ) :: N_COL ! number of columns character ( * ), intent ( IN ) :: varname ! variable name integer ( I1P ), intent ( IN ) :: var ( 1 : NC_NN , 1 : N_COL ) ! components integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done integer ( I4P ) :: n1 , n2 ! counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int8\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"ascii\">' do n1 = 1 , NC_NN write ( unit = Unit_VTK , fmt = '(' // FI1P // ')' , iostat = E_IO ) ( var ( n1 , n2 ), n2 = 1 , N_COL ) enddo write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' case ( f_out_binary ) write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // & '<DataArray type=\"Int8\" Name=\"' // & trim ( varname ) // & '\" NumberOfComponents=\"' // & trim ( str (. true ., N_COL )) // & '\" format=\"appended\" offset=\"' , & trim ( str (. true ., ioffset )), & '\">' // end_rec N_Byte = N_COL * NC_NN * sizeof ( Tipo_I1 ) ioffset = ioffset + sizeof ( Tipo_I4 ) + N_Byte write ( unit = Unit_VTK_Append , iostat = E_IO ) N_Byte , 'I1' , N_COL * NC_NN do n1 = 1 , NC_NN write ( unit = Unit_VTK_Append , iostat = E_IO ) var ( n1 ,:) enddo write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</DataArray>' // end_rec endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_VAR_XML_LIST_I1","loc":"proc/vtk_var_xml_list_i1.html"},{"tags":"","title":"VTK_END_XML – MUSST","text":"public function VTK_END_XML() result(E_IO) This function is used to finalize the file opened. The \\LIBVTKIO manages the file unit without the user's action. Arguments None Return Value integer(kind=I4P) Contents Source Code VTK_END_XML Source Code function VTK_END_XML () result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!This function is used to finalize the file opened. The \\LIBVTKIO manages the file unit without the user's action. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done character ( 2 ) :: var_type ! var\\_type = R8,R4,I8,I4,I2,I1 real ( R8P ), allocatable :: v_R8 (:) ! R8 vector for IO in AppendData real ( R4P ), allocatable :: v_R4 (:) ! R4 vector for IO in AppendData integer ( I8P ), allocatable :: v_I8 (:) ! I8 vector for IO in AppendData integer ( I4P ), allocatable :: v_I4 (:) ! I4 vector for IO in AppendData integer ( I2P ), allocatable :: v_I2 (:) ! I2 vector for IO in AppendData integer ( I1P ), allocatable :: v_I1 (:) ! I1 vector for IO in AppendData integer ( I4P ) :: N_v ! vector dimension integer ( I4P ) :: n1 ! counter !!The following is an example of VTK\\_END\\_XML calling: !! !!\\begin{boxred}{VTK\\_END\\_XML Calling} !!\\begin{verbatim} !!... !!E_IO = VTK_END_XML() !!... !!\\end{verbatim} !!\\end{boxred} !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( f_out ) case ( f_out_ascii ) indent = indent - 2 write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , indent ) // '</' // trim ( topology ) // '>' write ( unit = Unit_VTK , fmt = '(A)' , iostat = E_IO ) '</VTKFile>' case ( f_out_binary ) indent = indent - 2 write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</' // trim ( topology ) // '>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '<AppendedData encoding=\"raw\">' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) '_' endfile ( unit = Unit_VTK_Append , iostat = E_IO ) rewind ( unit = Unit_VTK_Append , iostat = E_IO ) do read ( unit = Unit_VTK_Append , iostat = E_IO , end = 100 ) N_Byte , var_type , N_v select case ( var_type ) case ( 'R8' ) allocate ( v_R8 ( 1 : N_v )) read ( unit = Unit_VTK_Append , iostat = E_IO )( v_R8 ( n1 ), n1 = 1 , N_v ) write ( unit = Unit_VTK , iostat = E_IO ) N_Byte ,( v_R8 ( n1 ), n1 = 1 , N_v ) deallocate ( v_R8 ) case ( 'R4' ) allocate ( v_R4 ( 1 : N_v )) read ( unit = Unit_VTK_Append , iostat = E_IO )( v_R4 ( n1 ), n1 = 1 , N_v ) write ( unit = Unit_VTK , iostat = E_IO ) N_Byte ,( v_R4 ( n1 ), n1 = 1 , N_v ) deallocate ( v_R4 ) case ( 'I8' ) allocate ( v_I8 ( 1 : N_v )) read ( unit = Unit_VTK_Append , iostat = E_IO )( v_I8 ( n1 ), n1 = 1 , N_v ) write ( unit = Unit_VTK , iostat = E_IO ) N_Byte ,( v_I8 ( n1 ), n1 = 1 , N_v ) deallocate ( v_I8 ) case ( 'I4' ) allocate ( v_I4 ( 1 : N_v )) read ( unit = Unit_VTK_Append , iostat = E_IO )( v_I4 ( n1 ), n1 = 1 , N_v ) write ( unit = Unit_VTK , iostat = E_IO ) N_Byte ,( v_I4 ( n1 ), n1 = 1 , N_v ) deallocate ( v_I4 ) case ( 'I2' ) allocate ( v_I2 ( 1 : N_v )) read ( unit = Unit_VTK_Append , iostat = E_IO )( v_I2 ( n1 ), n1 = 1 , N_v ) write ( unit = Unit_VTK , iostat = E_IO ) N_Byte ,( v_I2 ( n1 ), n1 = 1 , N_v ) deallocate ( v_I2 ) case ( 'I1' ) allocate ( v_I1 ( 1 : N_v )) read ( unit = Unit_VTK_Append , iostat = E_IO )( v_I1 ( n1 ), n1 = 1 , N_v ) write ( unit = Unit_VTK , iostat = E_IO ) N_Byte ,( v_I1 ( n1 ), n1 = 1 , N_v ) deallocate ( v_I1 ) case default E_IO = 1 write ( 6 , \"(' N_Byte =', I10, ' N_v =', I10)\" ) N_Byte , N_v write ( 6 , \"(' var1 =', I10, ' var2 =', I10)\" ) ichar ( var_type ( 1 : 1 )), ichar ( var_type ( 2 : 2 )) write ( 6 , '(A)' ) 'bad var_type' return endselect enddo 100 continue write ( unit = Unit_VTK , iostat = E_IO ) end_rec write ( unit = Unit_VTK , iostat = E_IO ) repeat ( ' ' , indent ) // '</AppendedData>' // end_rec write ( unit = Unit_VTK , iostat = E_IO ) '</VTKFile>' // end_rec ! closing AppendData file close ( unit = Unit_VTK_Append , iostat = E_IO ) endselect close ( unit = Unit_VTK , iostat = E_IO ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTK_END_XML","loc":"proc/vtk_end_xml.html"},{"tags":"","title":"VTM_INI_XML – MUSST","text":"public function VTM_INI_XML(filename) result(E_IO) The VTK_VTM_XML function is used for initializing a VTM (VTK Multiblocks) XML file that is a wrapper to a set of VTK XML files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer(kind=I4P) Calls proc~~vtm_ini_xml~~CallsGraph proc~vtm_ini_xml VTM_INI_XML proc~getunit GetUnit proc~vtm_ini_xml->proc~getunit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTM_INI_XML Source Code function VTM_INI_XML ( filename ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!The VTK_VTM_XML function is used for initializing a VTM (VTK Multiblocks) XML file that is a wrapper to a set of VTK XML files. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: filename ! file name integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Unit_VTM = GetUnit () open ( unit = Unit_VTM , & file = trim ( filename ), & form = 'FORMATTED' , & access = 'SEQUENTIAL' , & action = 'WRITE' , & iostat = E_IO ) write ( unit = Unit_VTM , fmt = '(A)' , iostat = E_IO ) '<?xml version=\"1.0\"?>' write ( unit = Unit_VTM , fmt = '(A)' , iostat = E_IO ) '<VTKFile type=\"vtkMultiBlockDataSet\" version=\"1.0\"' // & ' byte_order=\"BigEndian\" compressor=\"vtkZLibDataCompressor\">' vtm_indent = 2 write ( unit = Unit_VTM , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm_indent ) // '<vtkMultiBlockDataSet>' vtm_indent = vtm_indent + 2 blk = - 1 return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTM_INI_XML","loc":"proc/vtm_ini_xml.html"},{"tags":"","title":"VTM_BLK_XML – MUSST","text":"public function VTM_BLK_XML(block_action) result(E_IO) The VTM_BLK_XML function is used for opening or closing a block level of a VTM file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: block_action Return Value integer(kind=I4P) Calls proc~~vtm_blk_xml~~CallsGraph proc~vtm_blk_xml VTM_BLK_XML proc~upper_case Upper_Case proc~vtm_blk_xml->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VTM_BLK_XML Source Code function VTM_BLK_XML ( block_action ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!The VTM_BLK_XML function is used for opening or closing a block level of a VTM file. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: block_action ! block action: OPEN or CLOSE block integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( Upper_Case ( block_action ))) case ( 'OPEN' ) blk = blk + 1 write ( unit = Unit_VTM , fmt = '(A,I4.4,A)' , iostat = E_IO ) repeat ( ' ' , vtm_indent ) // '<Block index=\"' , blk , '\">' vtm_indent = vtm_indent + 2 case ( 'CLOSE' ) vtm_indent = vtm_indent - 2 write ( unit = Unit_VTM , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm_indent ) // '</Block>' endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTM_BLK_XML","loc":"proc/vtm_blk_xml.html"},{"tags":"","title":"VTM_WRF_XML – MUSST","text":"public function VTM_WRF_XML(wrf_dir, vtk_xml_file_list) result(E_IO) The VTM_WRF_XML function is used for saving the list of VTK XML wrapped files by the actual block of the mutliblock VTM file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: wrf_dir character(len=*), intent(in) :: vtk_xml_file_list (:) Return Value integer(kind=I4P) Contents Source Code VTM_WRF_XML Source Code function VTM_WRF_XML ( wrf_dir , vtk_xml_file_list ) result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!The VTM_WRF_XML function is used for saving the list of VTK XML wrapped files by the actual block of the mutliblock VTM file. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ), optional :: wrf_dir ! directory into which wrapped VTK XML are (optional) character ( * ), intent ( IN ) :: vtk_xml_file_list (:) ! list of VTK XML wrapped files integer ( I4P ) :: E_IO ! Input/Output inquiring flag: 0 if IO is done, > 0 if IO is not done integer ( I4P ) :: f ! file counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( wrf_dir )) then do f = 1 , size ( vtk_xml_file_list ) write ( unit = Unit_VTM , fmt = '(A,I3.3,A)' , iostat = E_IO ) repeat ( ' ' , vtm_indent ) // & '<DataSet index=\"' , f - 1 , '\" file=\"' // & adjustl ( trim ( wrf_dir )) // adjustl ( trim ( vtk_xml_file_list ( f ))) // & '\"></DataSet>' enddo else do f = 1 , size ( vtk_xml_file_list ) write ( unit = Unit_VTM , fmt = '(A,I3.3,A)' , iostat = E_IO ) repeat ( ' ' , vtm_indent ) // & '<DataSet index=\"' , f - 1 , '\" file=\"' // & adjustl ( trim ( vtk_xml_file_list ( f ))) // & '\"></DataSet>' enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTM_WRF_XML","loc":"proc/vtm_wrf_xml.html"},{"tags":"","title":"VTM_END_XML – MUSST","text":"public function VTM_END_XML() result(E_IO) This function is used to finalize the VTM file opened. The \\LIBVTKIO manages the file unit without the user's action. Arguments None Return Value integer(kind=I4P) Contents Source Code VTM_END_XML Source Code function VTM_END_XML () result ( E_IO ) !--------------------------------------------------------------------------------------------------------------------------------- !!This function is used to finalize the VTM file opened. The \\LIBVTKIO manages the file unit without the user's action. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ) :: E_IO ! Input/Output inquiring flag: $0$ if IO is done, $> 0$ if IO is not done !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- vtm_indent = vtm_indent - 2 write ( unit = Unit_VTM , fmt = '(A)' , iostat = E_IO ) repeat ( ' ' , vtm_indent ) // '</vtkMultiBlockDataSet>' write ( unit = Unit_VTM , fmt = '(A)' , iostat = E_IO ) '</VTKFile>' close ( unit = Unit_VTM ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction VTM_END_XML","loc":"proc/vtm_end_xml.html"},{"tags":"","title":"VTK_GEO – MUSST","text":"public interface VTK_GEO Calls interface~~vtk_geo~~CallsGraph interface~vtk_geo VTK_GEO proc~vtk_geo_unst_r8 VTK_GEO_UNST_R8 interface~vtk_geo->proc~vtk_geo_unst_r8 proc~vtk_geo_strg_r8 VTK_GEO_STRG_R8 interface~vtk_geo->proc~vtk_geo_strg_r8 proc~vtk_geo_strp_r8 VTK_GEO_STRP_R8 interface~vtk_geo->proc~vtk_geo_strp_r8 proc~vtk_geo_strg_r4 VTK_GEO_STRG_R4 interface~vtk_geo->proc~vtk_geo_strg_r4 proc~vtk_geo_strp_r4 VTK_GEO_STRP_R4 interface~vtk_geo->proc~vtk_geo_strp_r4 proc~vtk_geo_rect_r8 VTK_GEO_RECT_R8 interface~vtk_geo->proc~vtk_geo_rect_r8 proc~vtk_geo_unst_r4 VTK_GEO_UNST_R4 interface~vtk_geo->proc~vtk_geo_unst_r4 proc~vtk_geo_rect_r4 VTK_GEO_RECT_R4 interface~vtk_geo->proc~vtk_geo_rect_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~vtk_geo~~CalledByGraph interface~vtk_geo VTK_GEO proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_geo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures VTK_GEO_UNST_R8 VTK_GEO_UNST_R4 VTK_GEO_STRP_R8 VTK_GEO_STRP_R4 VTK_GEO_STRG_R8 VTK_GEO_STRG_R4 VTK_GEO_RECT_R8 VTK_GEO_RECT_R4 Module Procedures private function VTK_GEO_UNST_R8 (NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = UNSTRUCTURED_GRID (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_UNST_R4 (NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = UNSTRUCTURED_GRID (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_STRP_R8 (Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz) result(E_IO) Function for saving mesh; topology = STRUCTURED_POINTS (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R8P), intent(in) :: X0 real(kind=R8P), intent(in) :: Y0 real(kind=R8P), intent(in) :: Z0 real(kind=R8P), intent(in) :: Dx real(kind=R8P), intent(in) :: Dy real(kind=R8P), intent(in) :: Dz Return Value integer(kind=I4P) private function VTK_GEO_STRP_R4 (Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz) result(E_IO) Function for saving mesh; topology = STRUCTURED_POINTS (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R4P), intent(in) :: X0 real(kind=R4P), intent(in) :: Y0 real(kind=R4P), intent(in) :: Z0 real(kind=R4P), intent(in) :: Dx real(kind=R4P), intent(in) :: Dy real(kind=R4P), intent(in) :: Dz Return Value integer(kind=I4P) private function VTK_GEO_STRG_R8 (Nx, Ny, Nz, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = STRUCTURED_GRID (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz integer(kind=I4P), intent(in) :: NN real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_STRG_R4 (Nx, Ny, Nz, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = STRUCTURED_GRID (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz integer(kind=I4P), intent(in) :: NN real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_RECT_R8 (Nx, Ny, Nz, X, Y, Z) result(E_IO) Function for saving mesh; topology = RECTILINEAR_GRID (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R8P), intent(in) :: X (1:Nx) real(kind=R8P), intent(in) :: Y (1:Ny) real(kind=R8P), intent(in) :: Z (1:Nz) Return Value integer(kind=I4P) private function VTK_GEO_RECT_R4 (Nx, Ny, Nz, X, Y, Z) result(E_IO) Function for saving mesh; topology = RECTILINEAR_GRID (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R4P), intent(in) :: X (1:Nx) real(kind=R4P), intent(in) :: Y (1:Ny) real(kind=R4P), intent(in) :: Z (1:Nz) Return Value integer(kind=I4P)","loc":"interface/vtk_geo.html"},{"tags":"","title":"VTK_VAR – MUSST","text":"public interface VTK_VAR Calls interface~~vtk_var~~CallsGraph interface~vtk_var VTK_VAR proc~vtk_var_scal_r8 VTK_VAR_SCAL_R8 interface~vtk_var->proc~vtk_var_scal_r8 proc~vtk_var_scal_i4 VTK_VAR_SCAL_I4 interface~vtk_var->proc~vtk_var_scal_i4 proc~vtk_var_vect_i4 VTK_VAR_VECT_I4 interface~vtk_var->proc~vtk_var_vect_i4 proc~vtk_var_text_r8 VTK_VAR_TEXT_R8 interface~vtk_var->proc~vtk_var_text_r8 proc~vtk_var_vect_r4 VTK_VAR_VECT_R4 interface~vtk_var->proc~vtk_var_vect_r4 proc~vtk_var_vect_r8 VTK_VAR_VECT_R8 interface~vtk_var->proc~vtk_var_vect_r8 proc~vtk_var_text_r4 VTK_VAR_TEXT_R4 interface~vtk_var->proc~vtk_var_text_r4 proc~vtk_var_scal_r4 VTK_VAR_SCAL_R4 interface~vtk_var->proc~vtk_var_scal_r4 proc~upper_case Upper_Case proc~vtk_var_vect_r4->proc~upper_case proc~vtk_var_vect_r8->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~vtk_var~~CalledByGraph interface~vtk_var VTK_VAR proc~save_fe_f_vtk save_fe_f_vtk proc~save_fe_f_vtk->interface~vtk_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures VTK_VAR_SCAL_R8 VTK_VAR_SCAL_R4 VTK_VAR_SCAL_I4 VTK_VAR_VECT_R8 VTK_VAR_VECT_R4 VTK_VAR_VECT_I4 VTK_VAR_TEXT_R8 VTK_VAR_TEXT_R4 Module Procedures private function VTK_VAR_SCAL_R8 (NC_NN, varname, var) result(E_IO) Function for saving field of scalar variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_SCAL_R4 (NC_NN, varname, var) result(E_IO) Function for saving field of scalar variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_SCAL_I4 (NC_NN, varname, var) result(E_IO) Function for saving field of scalar variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_VECT_R8 (vec_type, NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving field of vectorial variable (R8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: varX (1:NC_NN) real(kind=R8P), intent(in) :: varY (1:NC_NN) real(kind=R8P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_VECT_R4 (vec_type, NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving field of vectorial variable (R4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: varX (1:NC_NN) real(kind=R4P), intent(in) :: varY (1:NC_NN) real(kind=R4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_VECT_I4 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving field of vectorial variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: varX (1:NC_NN) integer(kind=I4P), intent(in) :: varY (1:NC_NN) integer(kind=I4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_TEXT_R8 (NC_NN, dimm, varname, textCoo) result(E_IO) Function for saving texture variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: dimm character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: textCoo (1:NC_NN,1:dimm) Return Value integer(kind=I4P) private function VTK_VAR_TEXT_R4 (NC_NN, dimm, varname, textCoo) result(E_IO) Function for saving texture variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: dimm character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: textCoo (1:NC_NN,1:dimm) Return Value integer(kind=I4P)","loc":"interface/vtk_var.html"},{"tags":"","title":"VTK_GEO_XML – MUSST","text":"public interface VTK_GEO_XML Calls interface~~vtk_geo_xml~~CallsGraph interface~vtk_geo_xml VTK_GEO_XML proc~vtk_geo_xml_strg_r4 VTK_GEO_XML_STRG_R4 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r4 proc~vtk_geo_xml_strg_r8 VTK_GEO_XML_STRG_R8 interface~vtk_geo_xml->proc~vtk_geo_xml_strg_r8 proc~vtk_geo_xml_closep VTK_GEO_XML_CLOSEP interface~vtk_geo_xml->proc~vtk_geo_xml_closep proc~vtk_geo_xml_rect_r4 VTK_GEO_XML_RECT_R4 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r4 proc~vtk_geo_xml_unst_r8 VTK_GEO_XML_UNST_R8 interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r8 proc~vtk_geo_xml_rect_r8 VTK_GEO_XML_RECT_R8 interface~vtk_geo_xml->proc~vtk_geo_xml_rect_r8 proc~vtk_geo_xml_unst_r4 VTK_GEO_XML_UNST_R4 interface~vtk_geo_xml->proc~vtk_geo_xml_unst_r4 interface~str str proc~vtk_geo_xml_strg_r4->interface~str proc~vtk_geo_xml_strg_r8->interface~str proc~vtk_geo_xml_rect_r4->interface~str proc~vtk_geo_xml_unst_r8->interface~str proc~vtk_geo_xml_rect_r8->interface~str proc~vtk_geo_xml_unst_r4->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures VTK_GEO_XML_STRG_R4 VTK_GEO_XML_STRG_R8 VTK_GEO_XML_RECT_R8 VTK_GEO_XML_RECT_R4 VTK_GEO_XML_UNST_R8 VTK_GEO_XML_UNST_R4 VTK_GEO_XML_CLOSEP Module Procedures private function VTK_GEO_XML_STRG_R4 (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = StructuredGrid (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 integer(kind=I4P), intent(in) :: NN real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_XML_STRG_R8 (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = StructuredGrid (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 integer(kind=I4P), intent(in) :: NN real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_XML_RECT_R8 (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z) result(E_IO) Function for saving mesh; topology = RectilinearGrid (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 real(kind=R8P), intent(in) :: X (nx1:nx2) real(kind=R8P), intent(in) :: Y (ny1:ny2) real(kind=R8P), intent(in) :: Z (nz1:nz2) Return Value integer(kind=I4P) private function VTK_GEO_XML_RECT_R4 (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z) result(E_IO) Function for saving mesh; topology = RectilinearGrid (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 real(kind=R4P), intent(in) :: X (nx1:nx2) real(kind=R4P), intent(in) :: Y (ny1:ny2) real(kind=R4P), intent(in) :: Z (nz1:nz2) Return Value integer(kind=I4P) private function VTK_GEO_XML_UNST_R8 (NN, NC, X, Y, Z) result(E_IO) Function for saving mesh; topology = UnstructuredGrid (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN integer(kind=I4P), intent(in) :: NC real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_XML_UNST_R4 (NN, NC, X, Y, Z) result(E_IO) Function for saving mesh; topology = UnstructuredGrid (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN integer(kind=I4P), intent(in) :: NC real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_XML_CLOSEP () result(E_IO) Function for closing mesh block data. Arguments None Return Value integer(kind=I4P)","loc":"interface/vtk_geo_xml.html"},{"tags":"","title":"VTK_VAR_XML – MUSST","text":"public interface VTK_VAR_XML Calls interface~~vtk_var_xml~~CallsGraph interface~vtk_var_xml VTK_VAR_XML proc~vtk_var_xml_scal_r4 VTK_VAR_XML_SCAL_R4 interface~vtk_var_xml->proc~vtk_var_xml_scal_r4 proc~vtk_var_xml_vect_i8 VTK_VAR_XML_VECT_I8 interface~vtk_var_xml->proc~vtk_var_xml_vect_i8 proc~vtk_var_xml_vect_i1 VTK_VAR_XML_VECT_I1 interface~vtk_var_xml->proc~vtk_var_xml_vect_i1 proc~vtk_var_xml_list_i8 VTK_VAR_XML_LIST_I8 interface~vtk_var_xml->proc~vtk_var_xml_list_i8 proc~vtk_var_xml_scal_i8 VTK_VAR_XML_SCAL_I8 interface~vtk_var_xml->proc~vtk_var_xml_scal_i8 proc~vtk_var_xml_list_r8 VTK_VAR_XML_LIST_R8 interface~vtk_var_xml->proc~vtk_var_xml_list_r8 proc~vtk_var_xml_list_i4 VTK_VAR_XML_LIST_I4 interface~vtk_var_xml->proc~vtk_var_xml_list_i4 proc~vtk_var_xml_scal_i4 VTK_VAR_XML_SCAL_I4 interface~vtk_var_xml->proc~vtk_var_xml_scal_i4 proc~vtk_var_xml_vect_r4 VTK_VAR_XML_VECT_R4 interface~vtk_var_xml->proc~vtk_var_xml_vect_r4 proc~vtk_var_xml_list_r4 VTK_VAR_XML_LIST_R4 interface~vtk_var_xml->proc~vtk_var_xml_list_r4 proc~vtk_var_xml_scal_i2 VTK_VAR_XML_SCAL_I2 interface~vtk_var_xml->proc~vtk_var_xml_scal_i2 proc~vtk_var_xml_list_i2 VTK_VAR_XML_LIST_I2 interface~vtk_var_xml->proc~vtk_var_xml_list_i2 proc~vtk_var_xml_scal_r8 VTK_VAR_XML_SCAL_R8 interface~vtk_var_xml->proc~vtk_var_xml_scal_r8 proc~vtk_var_xml_list_i1 VTK_VAR_XML_LIST_I1 interface~vtk_var_xml->proc~vtk_var_xml_list_i1 proc~vtk_var_xml_vect_i4 VTK_VAR_XML_VECT_I4 interface~vtk_var_xml->proc~vtk_var_xml_vect_i4 proc~vtk_var_xml_scal_i1 VTK_VAR_XML_SCAL_I1 interface~vtk_var_xml->proc~vtk_var_xml_scal_i1 proc~vtk_var_xml_vect_r8 VTK_VAR_XML_VECT_R8 interface~vtk_var_xml->proc~vtk_var_xml_vect_r8 proc~vtk_var_xml_vect_i2 VTK_VAR_XML_VECT_I2 interface~vtk_var_xml->proc~vtk_var_xml_vect_i2 interface~str str proc~vtk_var_xml_scal_r4->interface~str proc~vtk_var_xml_vect_i8->interface~str proc~vtk_var_xml_vect_i1->interface~str proc~vtk_var_xml_list_i8->interface~str proc~vtk_var_xml_scal_i8->interface~str proc~vtk_var_xml_list_r8->interface~str proc~vtk_var_xml_list_i4->interface~str proc~vtk_var_xml_scal_i4->interface~str proc~vtk_var_xml_vect_r4->interface~str proc~vtk_var_xml_list_r4->interface~str proc~vtk_var_xml_scal_i2->interface~str proc~vtk_var_xml_list_i2->interface~str proc~vtk_var_xml_scal_r8->interface~str proc~vtk_var_xml_list_i1->interface~str proc~vtk_var_xml_vect_i4->interface~str proc~vtk_var_xml_scal_i1->interface~str proc~vtk_var_xml_vect_r8->interface~str proc~vtk_var_xml_vect_i2->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r16p str_R16P interface~str->proc~str_r16p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures VTK_VAR_XML_SCAL_R8 VTK_VAR_XML_SCAL_R4 VTK_VAR_XML_SCAL_I8 VTK_VAR_XML_SCAL_I4 VTK_VAR_XML_SCAL_I2 VTK_VAR_XML_SCAL_I1 VTK_VAR_XML_VECT_R8 VTK_VAR_XML_VECT_R4 VTK_VAR_XML_VECT_I8 VTK_VAR_XML_VECT_I4 VTK_VAR_XML_VECT_I2 VTK_VAR_XML_VECT_I1 VTK_VAR_XML_LIST_R8 VTK_VAR_XML_LIST_R4 VTK_VAR_XML_LIST_I8 VTK_VAR_XML_LIST_I4 VTK_VAR_XML_LIST_I2 VTK_VAR_XML_LIST_I1 Module Procedures private function VTK_VAR_XML_SCAL_R8 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_R4 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_I8 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I8P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_I4 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_I2 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I2P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_I1 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I1P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_R8 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: varX (1:NC_NN) real(kind=R8P), intent(in) :: varY (1:NC_NN) real(kind=R8P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_R4 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: varX (1:NC_NN) real(kind=R4P), intent(in) :: varY (1:NC_NN) real(kind=R4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_I8 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I8P), intent(in) :: varX (1:NC_NN) integer(kind=I8P), intent(in) :: varY (1:NC_NN) integer(kind=I8P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_I4 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: varX (1:NC_NN) integer(kind=I4P), intent(in) :: varY (1:NC_NN) integer(kind=I4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_I2 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I2P), intent(in) :: varX (1:NC_NN) integer(kind=I2P), intent(in) :: varY (1:NC_NN) integer(kind=I2P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_I1 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I1P), intent(in) :: varX (1:NC_NN) integer(kind=I1P), intent(in) :: varY (1:NC_NN) integer(kind=I1P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_R8 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_R4 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_I8 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I8P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_I4 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_I2 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I2P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_I1 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I1P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P)","loc":"interface/vtk_var_xml.html"},{"tags":"","title":"read_config – MUSST","text":"subroutine read_config() Arguments None Calls proc~~read_config~~CallsGraph proc~read_config read_config proc~get_unit get_unit proc~read_config->proc~get_unit proc~read_data read_data proc~read_config->proc~read_data num_par num_par proc~read_data->num_par Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_config~~CalledByGraph proc~read_config read_config program~main main program~main->proc~read_config Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_config Source Code subroutine read_config () implicit none integer ( kind = I4 ) :: jf , err_read character ( len = 032 ) :: word character ( len = 128 ) :: job_copy job_copy = \"out/\" // repos // job_file ( 4 : len_trim ( job_file )) VERBOSE = 20 SOLV_MESS = 0 OPU = 0 OUTPUT_FILE = \"no_file\" SOLVER_BS = 3 SOLVER_TS = 2 NB_THREADS_MAX = - 1 archive = 0 test_num = 0 call get_unit ( jf ) ; open ( jf , file = trim ( job_file ), status = 'old' ) do word = repeat ( ' ' , len ( word )) read ( jf , * , iostat = err_read ) word if ( index ( word , 'END_FILE' ) /= 0 ) exit if ( index ( word , 'VERBOSE' ) /= 0 ) then read ( jf , * ) VERBOSE endif if ( index ( word , 'SOLV_MESS' ) /= 0 ) then read ( jf , * ) SOLV_MESS endif if ( index ( word , 'OUTPUT_UNIT' ) /= 0 ) then read ( jf , * ) OPU if ( OPU == 0 ) then OPU = OUT_U else read ( jf , * ) OUTPUT_FILE call get_unit ( OPU ) open ( unit = OPU , & file = \"out/\" // repos // \"/\" // trim ( adjustl ( OUTPUT_FILE )), & status = 'unknown' ) endif endif if ( index ( word , 'SOLVER_BS' ) /= 0 ) then read ( jf , * ) SOLVER_BS if ( SOLVER_BS == 1 ) stop \"some remaining problems with SuLU, choose '3' instead\" if ( SOLVER_BS == 2 ) stop \"MUMPS is multithreaded, it is designed for TS, choose '3' instead\" endif if ( index ( word , 'SOLVER_TS' ) /= 0 ) then read ( jf , * ) SOLVER_TS endif if ( index ( word , 'PROBLEM_TYPE' ) /= 0 ) then read ( jf , * ) test_num endif if ( index ( word , 'PARAM_MUSST' ) /= 0 ) then call read_data ( jf , repos ) endif if ( index ( word , 'NB_THREADS_MAX' ) /= 0 ) then read ( jf , * ) NB_THREADS_MAX if ( NB_THREADS_MAX < 0 ) then !$ NB_THREADS_MAX = omp_get_num_procs() endif endif if ( index ( word , 'ARCHIVE' ) /= 0 ) then read ( jf , * ) archive if ( ARCHIVE == 1 ) then call execute_command_line ( \"sh bin/save/save.sh\" , wait = . true .) call execute_command_line ( \"mv *.7z out/\" // repos // \"/\" ) endif endif enddo close ( jf ) return endsubroutine read_config","loc":"proc/read_config.html"},{"tags":"","title":"ni4 – MUSST","text":"public function ni4(numn, ksi, eta) Note Standard QU4 element Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn local node number: 1->SW, 2-> SE, 3->NE, 4->NW real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta Return Value real(kind=R8) Called by proc~~ni4~~CalledByGraph proc~ni4 ni4 proc~init_prc_tab init_prc_tab proc~init_prc_tab->proc~ni4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/ni4.html"},{"tags":"","title":"ni4_up_1d – MUSST","text":"private function ni4_up_1d(numn, ksi, pe, se) Note Up-Downwind 1D element for perfect gaz cases Instead of the standard linear 1D element, a parameter pe is introduced to control the\n   slope. The higher pe the steepest curve => it can even lead to a quasi-discontinuous function.\n   If pe is zero, then the shape functions are the standard ones. se is linked to the flow direction: se=1 for upwind, se=-1 for downwind. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn local node number real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: pe parameter controlling the shape function slope real(kind=R8), intent(in) :: se +1 -> upwind, -1 -> downwind Return Value real(kind=R8) Called by proc~~ni4_up_1d~~CalledByGraph proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d ni4_up_2d proc~ni4_up_2d->proc~ni4_up_1d proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~fx fx proc~fx->proc~compute_prc_tables_reynolds_supg proc~fz fz proc~fz->proc~compute_prc_tables_reynolds_supg proc~fy fy proc~fy->proc~compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~compute_corner_fluxes compute_corner_fluxes proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~solve_fe_prob->proc~compute_corner_fluxes proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds->proc~compute_corner_fluxes proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_slider_ms->proc~solve_ms_prob program~main main program~main->proc~run_test var panprocni4_up_1dCalledByGraph = svgPanZoom('#procni4_up_1dCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/ni4_up_1d.html"},{"tags":"","title":"ni4_up_2d – MUSST","text":"public function ni4_up_2d(numn, ksi, eta, pe, se) Note Up-Downwind 2D element for perfect gaz cases Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn local node number real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta real(kind=R8), intent(in), dimension(2) :: pe parameter controling the shape function slope for each direction real(kind=R8), intent(in), dimension(2) :: se +1 -> upwind, -1 -> downwind, for each direction Return Value real(kind=R8) Calls proc~~ni4_up_2d~~CallsGraph proc~ni4_up_2d ni4_up_2d proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ni4_up_2d~~CalledByGraph proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~fx fx proc~fx->proc~compute_prc_tables_reynolds_supg proc~fz fz proc~fz->proc~compute_prc_tables_reynolds_supg proc~fy fy proc~fy->proc~compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~compute_corner_fluxes compute_corner_fluxes proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~solve_fe_prob->proc~compute_corner_fluxes proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds->proc~compute_corner_fluxes proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_slider_ms->proc~solve_ms_prob program~main main program~main->proc~run_test var panprocni4_up_2dCalledByGraph = svgPanZoom('#procni4_up_2dCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/ni4_up_2d.html"},{"tags":"","title":"ni_tanh_1d – MUSST","text":"private function ni_tanh_1d(numn, ksi, pe, se) Note Up-Downwind 1D element for perfect gaz cases, smooth functions Warning NOT USED Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: pe real(kind=R8), intent(in) :: se Return Value real(kind=R8) Called by proc~~ni_tanh_1d~~CalledByGraph proc~ni_tanh_1d ni_tanh_1d proc~ni_tanh_2d_ksi ni_tanh_2d_ksi proc~ni_tanh_2d_ksi->proc~ni_tanh_1d proc~ni_tanh_2d ni_tanh_2d proc~ni_tanh_2d->proc~ni_tanh_1d proc~ni_tanh_2d_eta ni_tanh_2d_eta proc~ni_tanh_2d_eta->proc~ni_tanh_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/ni_tanh_1d.html"},{"tags":"","title":"ni_tanh_1d_der – MUSST","text":"private function ni_tanh_1d_der(numn, ksi, pe, se) Note Up-Downwind 1D element for perfect gaz cases, smooth functions Warning NOT USED Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: pe real(kind=R8), intent(in) :: se Return Value real(kind=R8) Called by proc~~ni_tanh_1d_der~~CalledByGraph proc~ni_tanh_1d_der ni_tanh_1d_der proc~ni_tanh_2d_ksi ni_tanh_2d_ksi proc~ni_tanh_2d_ksi->proc~ni_tanh_1d_der proc~ni_tanh_2d_eta ni_tanh_2d_eta proc~ni_tanh_2d_eta->proc~ni_tanh_1d_der Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/ni_tanh_1d_der.html"},{"tags":"","title":"ni_tanh_2d – MUSST","text":"private function ni_tanh_2d(numn, ksi, eta, pe, se) Note Up-Downwind 2D element for perfect gaz cases, smooth functions Warning NOT USED Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta real(kind=R8), intent(in), dimension(2) :: pe real(kind=R8), intent(in), dimension(2) :: se Return Value real(kind=R8) Calls proc~~ni_tanh_2d~~CallsGraph proc~ni_tanh_2d ni_tanh_2d proc~ni_tanh_1d ni_tanh_1d proc~ni_tanh_2d->proc~ni_tanh_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/ni_tanh_2d.html"},{"tags":"","title":"ni_tanh_2d_ksi – MUSST","text":"private function ni_tanh_2d_ksi(numn, ksi, eta, pe, se) Note Up-Downwind 2D element for perfect gaz cases, smooth functions Warning NOT USED Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta real(kind=R8), intent(in), dimension(2) :: pe real(kind=R8), intent(in), dimension(2) :: se Return Value real(kind=R8) Calls proc~~ni_tanh_2d_ksi~~CallsGraph proc~ni_tanh_2d_ksi ni_tanh_2d_ksi proc~ni_tanh_1d_der ni_tanh_1d_der proc~ni_tanh_2d_ksi->proc~ni_tanh_1d_der proc~ni_tanh_1d ni_tanh_1d proc~ni_tanh_2d_ksi->proc~ni_tanh_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/ni_tanh_2d_ksi.html"},{"tags":"","title":"ni_tanh_2d_eta – MUSST","text":"private function ni_tanh_2d_eta(numn, ksi, eta, pe, se) Note Up-Downwind 2D element for perfect gaz cases, smooth functions Warning NOT USED Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta real(kind=R8), intent(in), dimension(2) :: pe real(kind=R8), intent(in), dimension(2) :: se Return Value real(kind=R8) Calls proc~~ni_tanh_2d_eta~~CallsGraph proc~ni_tanh_2d_eta ni_tanh_2d_eta proc~ni_tanh_1d_der ni_tanh_1d_der proc~ni_tanh_2d_eta->proc~ni_tanh_1d_der proc~ni_tanh_1d ni_tanh_1d proc~ni_tanh_2d_eta->proc~ni_tanh_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/ni_tanh_2d_eta.html"},{"tags":"","title":"ni4ksi – MUSST","text":"private function ni4ksi(numn, eta) Note Standard 2D element function derivatives (with respect to \\xi ) Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: eta Return Value real(kind=R8) Called by proc~~ni4ksi~~CalledByGraph proc~ni4ksi ni4ksi proc~j4 j4 proc~j4->proc~ni4ksi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/ni4ksi.html"},{"tags":"","title":"ni4eta – MUSST","text":"private function ni4eta(numn, ksi) Note Standard 2D element function derivatives (with respect to \\eta ) Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: ksi Return Value real(kind=R8) Called by proc~~ni4eta~~CalledByGraph proc~ni4eta ni4eta proc~j4 j4 proc~j4->proc~ni4eta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/ni4eta.html"},{"tags":"","title":"j4 – MUSST","text":"private function j4(numn, ksi, eta, x, y) Note Jacobian intermediate calculus Example if numn=1 j_4=\\sum_{i=1}&#94;{4} \\frac{\\partial N_i}{\\partial \\xi} x_i Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta real(kind=R8), intent(in), dimension(4) :: x real(kind=R8), intent(in), dimension(4) :: y Return Value real(kind=R8) Calls proc~~j4~~CallsGraph proc~j4 j4 proc~ni4eta ni4eta proc~j4->proc~ni4eta proc~ni4ksi ni4ksi proc~j4->proc~ni4ksi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/j4.html"},{"tags":"","title":"dj4 – MUSST","text":"public function dj4(ksi, eta, x, y) Note Jacobian calculated without calling any function, for computing speed reasons. Note Maxima , Wxmaxima script ni4_1(xi, eta):= (1. -xi)*(1. -eta)/4.$ ni4_2(xi, eta):= (1. +xi)*(1. -eta)/4.$ ni4_3(xi, eta):= (1. +xi)*(1. +eta)/4.$ ni4_4(xi, eta):= (1. -xi)*(1. +eta)/4.$ ni4xi_1(xi, eta):=diff(ni4_1(xi, eta),xi,1)$ ni4xi_2(xi, eta):=diff(ni4_2(xi, eta),xi,1)$ ni4xi_3(xi, eta):=diff(ni4_3(xi, eta),xi,1)$ ni4xi_4(xi, eta):=diff(ni4_4(xi, eta),xi,1)$ ni4eta_1(xi, eta):=diff(ni4_1(xi, eta),eta,1)$ ni4eta_2(xi, eta):=diff(ni4_2(xi, eta),eta,1)$ ni4eta_3(xi, eta):=diff(ni4_3(xi, eta),eta,1)$ ni4eta_4(xi, eta):=diff(ni4_4(xi, eta),eta,1)$ j4_1(xi, eta):=factorsum(ni4xi_1(xi, eta)*x1+ni4xi_2(xi, eta)*x2+ni4xi_3(xi, eta)*x3+ni4xi_4(xi, eta)*x4)$ j4_1(xi, eta); j4_2(xi, eta):=factorsum(ni4xi_1(xi, eta)*y1+ni4xi_2(xi, eta)*y2+ni4xi_3(xi, eta)*y3+ni4xi_4(xi, eta)*y4)$ j4_2(xi, eta); j4_3(xi, eta):=factorsum(ni4eta_1(xi, eta)*x1+ni4eta_2(xi, eta)*x2+ni4eta_3(xi, eta)*x3+ni4eta_4(xi, eta)*x4)$ j4_3(xi, eta); j4_4(xi, eta):=factorsum(ni4eta_1(xi, eta)*y1+ni4eta_2(xi, eta)*y2+ni4eta_3(xi, eta)*y3+ni4eta_4(xi, eta)*y4)$ j4_4(xi, eta); dj4(xi, eta):=factorout(j4_1(xi, eta)*j4_4(xi, eta)-j4_2(xi, eta)*j4_3(xi, eta),xi,eta)$ dj4(xi, eta); ni4x_1(xi,eta):=factorout(j4_4(xi, eta)*ni4xi_1(xi, eta),eta,xi) - factorout(j4_3(xi, eta)*ni4eta_1(xi, eta),xi,eta)$ ni4x_1(xi,eta); ni4x_2(xi,eta):=factorout(j4_4(xi, eta)*ni4xi_2(xi, eta),eta,xi) - factorout(j4_3(xi, eta)*ni4eta_2(xi, eta),eta,xi)$ ni4x_2(xi,eta); ni4x_3(xi,eta):=factorout(j4_4(xi, eta)*ni4xi_3(xi, eta),eta,xi) - factorout(j4_3(xi, eta)*ni4eta_3(xi, eta),xi,eta)$ ni4x_3(xi,eta); ni4x_4(xi,eta):=factorout(j4_4(xi, eta)*ni4xi_4(xi, eta),eta,xi) - factorout(j4_3(xi, eta)*ni4eta_4(xi, eta),eta,xi)$ ni4x_4(xi,eta); ni4y_1(xi,eta):=factorout(-j4_2(xi, eta)*ni4xi_1(xi, eta),eta,xi) + factorout(j4_1(xi, eta)*ni4eta_1(xi, eta),xi,eta)$ ni4y_1(xi,eta); ni4y_2(xi,eta):=factorout(-j4_2(xi, eta)*ni4xi_2(xi, eta),eta,xi) + factorout(j4_1(xi, eta)*ni4eta_2(xi, eta),eta,xi)$ ni4y_2(xi,eta); ni4y_3(xi,eta):=factorout(-j4_2(xi, eta)*ni4xi_3(xi, eta),eta,xi) + factorout(j4_1(xi, eta)*ni4eta_3(xi, eta),xi,eta)$ ni4y_3(xi,eta); ni4y_4(xi,eta):=factorout(-j4_2(xi, eta)*ni4xi_4(xi, eta),eta,xi) + factorout(j4_1(xi, eta)*ni4eta_4(xi, eta),eta,xi)$ ni4y_4(xi,eta); Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta real(kind=R8), intent(in), dimension(4) :: x real(kind=R8), intent(in), dimension(4) :: y Return Value real(kind=R8) Called by proc~~dj4~~CalledByGraph proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~compute_prc_tables_reynolds_supg->proc~dj4 proc~fx fx proc~fx->proc~compute_prc_tables_reynolds_supg proc~fz fz proc~fz->proc~compute_prc_tables_reynolds_supg proc~fy fy proc~fy->proc~compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~compute_corner_fluxes compute_corner_fluxes proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~solve_fe_prob->proc~compute_corner_fluxes proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds->proc~compute_corner_fluxes proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_slider_ms->proc~solve_ms_prob program~main main program~main->proc~run_test var panprocdj4CalledByGraph = svgPanZoom('#procdj4CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/dj4.html"},{"tags":"","title":"calc_ni4_xy_derivatives – MUSST","text":"public subroutine calc_ni4_xy_derivatives(ni4x, ni4y, ksi, eta, x, y, dj) Note QU4 derivatives with respect to x and y without any function call, for speed reasons Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(4) :: ni4x real(kind=R8), intent(out), dimension(4) :: ni4y real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta real(kind=R8), intent(in), dimension(4) :: x real(kind=R8), intent(in), dimension(4) :: y real(kind=R8), intent(in) :: dj Contents Source Code calc_ni4_xy_derivatives Source Code subroutine calc_ni4_xy_derivatives ( ni4x , ni4y , ksi , eta , x , y , dj ) implicit none real ( kind = R8 ), intent ( out ), dimension ( 4 ) :: ni4x real ( kind = R8 ), intent ( out ), dimension ( 4 ) :: ni4y real ( kind = R8 ), intent ( in ) :: ksi real ( kind = R8 ), intent ( in ) :: eta real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: x real ( kind = R8 ), intent ( in ), dimension ( 4 ) :: y real ( kind = R8 ), intent ( in ) :: dj !~       standard calculation !~       ni4x = ( j4(4, ksi, eta, x, y)*ni4ksi(numn, eta) -& !~                j4(3, ksi, eta, x, y)*ni4eta(numn, ksi) )/dj4(ksi, eta, x, y) !~       ni4y = ( -j4(2, ksi, eta, x, y)*ni4ksi(numn, eta) +& !~                 j4(1, ksi, eta, x, y)*ni4eta(numn, ksi) )/dj4(ksi, eta, x, y) real ( kind = R8 ) :: km1 , kp1 , em1 , ep1 , kme , kpe , & ! x1 , x2 , x3 , x4 , & ! y1 , y2 , y3 , y4 , & ! kx , ky , ex , ey km1 = ksi - 1._R8 kp1 = ksi + 1._R8 em1 = eta - 1._R8 ep1 = eta + 1._R8 kme = ksi - eta kpe = ksi + eta x1 = x ( 1 ) ; x2 = x ( 2 ) ; x3 = x ( 3 ) ; x4 = x ( 4 ) y1 = y ( 1 ) ; y2 = y ( 2 ) ; y3 = y ( 3 ) ; y4 = y ( 4 ) kx = - km1 * x1 + kp1 * x2 - kp1 * x3 + km1 * x4 ky = - km1 * y1 + kp1 * y2 - kp1 * y3 + km1 * y4 ex = - em1 * x1 + ep1 * x2 - ep1 * x3 + em1 * x4 ey = - em1 * y1 + ep1 * y2 - ep1 * y3 + em1 * y4 ni4x ( 1 ) = 0.0625_R8 * ( + km1 * kx - em1 * ky ) / dj ni4x ( 2 ) = 0.0625_R8 * ( - kp1 * kx + em1 * ky ) / dj ni4x ( 3 ) = 0.0625_R8 * ( + kp1 * kx - ep1 * ky ) / dj ni4x ( 4 ) = 0.0625_R8 * ( - km1 * kx + ep1 * ky ) / dj kx = - km1 * x1 + km1 * x2 - kp1 * x3 + kp1 * x4 ky = - km1 * y1 + km1 * y2 - kp1 * y3 + kp1 * y4 ex = - em1 * x1 + em1 * x2 - ep1 * x3 + ep1 * x4 ey = - em1 * y1 + em1 * y2 - ep1 * y3 + ep1 * y4 ni4y ( 1 ) = 0.0625_R8 * ( - km1 * ex + em1 * ey ) / dj ni4y ( 2 ) = 0.0625_R8 * ( + kp1 * ex - em1 * ey ) / dj ni4y ( 3 ) = 0.0625_R8 * ( - kp1 * ex + ep1 * ey ) / dj ni4y ( 4 ) = 0.0625_R8 * ( + km1 * ex - ep1 * ey ) / dj return endsubroutine calc_ni4_xy_derivatives","loc":"proc/calc_ni4_xy_derivatives.html"},{"tags":"","title":"lower – MUSST","text":"private function lower(s1) result(s2) Note Converts uppercase to lowercase, adapted from here Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 string to transform to lower case Return Value character(len=len(s1)) result: same string but each character is lower case Called by proc~~lower~~CalledByGraph proc~lower lower proc~write_surf write_surf proc~write_surf->proc~lower proc~read_surf read_surf proc~read_surf->proc~lower proc~save_fe_field save_fe_field proc~save_fe_field->proc~write_surf proc~save_ms_field save_ms_field proc~save_ms_field->proc~write_surf proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~save_fe_field proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~save_ms_field proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panproclowerCalledByGraph = svgPanZoom('#proclowerCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code lower Source Code function lower ( s1 ) result ( s2 ) character ( * ), intent ( in ) :: s1 !! *string to transform to lower case* character ( len ( s1 )) :: s2 !! *result: same string but each character is lower case* character ( len = 1 ) :: ch integer ( kind = I4 ), parameter :: duc = ichar ( 'A' ) - ichar ( 'a' ) integer ( kind = I4 ) :: i do i = 1 , len ( s1 ) ch = s1 ( i : i ) if ( ch >= 'A' . and . ch <= 'Z' ) ch = char ( ichar ( ch ) - duc ) s2 ( i : i ) = ch enddo return endfunction lower","loc":"proc/lower.html"},{"tags":"","title":"unit2IUc – MUSST","text":"public function unit2IUc(string) result(met) Arguments Type Intent Optional Attributes Name character(kind=C_CHAR), intent(in), dimension(:) :: string Return Value real(kind=R8) Calls proc~~unit2iuc~~CallsGraph proc~unit2iuc unit2IUc proc~unit2iuf unit2IUf proc~unit2iuc->proc~unit2iuf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~unit2iuc~~CalledByGraph proc~unit2iuc unit2IUc proc~trans_surf_tab trans_surf_tab proc~trans_surf_tab->proc~unit2iuc proc~build_surf build_surf proc~build_surf->proc~unit2iuc proc~read_surf read_surf proc~read_surf->proc~trans_surf_tab Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code unit2IUc Source Code function unit2IUc ( string ) result ( met ) implicit none real ( kind = R8 ) :: met character ( kind = C_CHAR ), dimension (:), intent ( in ) :: string character ( len = 2 ) :: chaine chaine = string ( 1 ) // string ( 2 ) met = unit2IUf ( chaine ) return endfunction unit2IUc","loc":"proc/unit2iuc.html"},{"tags":"","title":"unit2IUf – MUSST","text":"public function unit2IUf(string) result(met) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value real(kind=R8) Called by proc~~unit2iuf~~CalledByGraph proc~unit2iuf unit2IUf proc~unit2iuc unit2IUc proc~unit2iuc->proc~unit2iuf proc~trans_surf_tab trans_surf_tab proc~trans_surf_tab->proc~unit2iuc proc~build_surf build_surf proc~build_surf->proc~unit2iuc proc~read_surf read_surf proc~read_surf->proc~trans_surf_tab Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code unit2IUf Source Code function unit2IUf ( string ) result ( met ) implicit none real ( kind = R8 ) :: met character ( * ), intent ( in ) :: string select case ( string ) case ( 'm ' ) met = 1.e+00_R8 case ( 'cm' ) met = 1.e-02_R8 case ( 'mm' ) met = 1.e-03_R8 case ( 'µm' ) met = 1.e-06_R8 case ( 'nm' ) met = 1.e-09_R8 case ( 'pm' ) met = 1.e-12_R8 case ( 'Pa' ) met = 1.e+00_R8 case ( 'MP' ) met = 1.e+06_R8 case ( 'GP' ) met = 1.e+09_R8 case default met = 1.e+00_R8 endselect return endfunction unit2IUf","loc":"proc/unit2iuf.html"},{"tags":"","title":"scal2surf – MUSST","text":"public subroutine scal2surf(scal, surf) Arguments Type Intent Optional Attributes Name type( SCALE_SURF ), intent(in) :: scal object SCALE_SURF type( OBJ_SURF ), intent(out) :: surf object OBJ_SURF Called by proc~~scal2surf~~CalledByGraph proc~scal2surf scal2surf proc~write_surf write_surf proc~write_surf->proc~scal2surf proc~save_fe_field save_fe_field proc~save_fe_field->proc~write_surf proc~save_ms_field save_ms_field proc~save_ms_field->proc~write_surf proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~save_fe_field proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~save_ms_field proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocscal2surfCalledByGraph = svgPanZoom('#procscal2surfCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code scal2surf Source Code subroutine scal2surf ( scal , surf ) implicit none type ( SCALE_SURF ), intent ( in ) :: scal !! *object [[SCALE_SURF]]* type ( OBJ_SURF ), intent ( out ) :: surf !! *object [[OBJ_SURF]]* call f_c_string ( fs = trim ( scal % signature ), & cs = surf % signature ) call f_c_string ( fs = trim ( scal % xlength_unit ), & cs = surf % xlength_unit ) call f_c_string ( fs = trim ( scal % ylength_unit ), & cs = surf % ylength_unit ) call f_c_string ( fs = trim ( scal % zlength_unit ), & cs = surf % zlength_unit ) call f_c_string ( fs = trim ( scal % xaxis ), & cs = surf % xaxis ) call f_c_string ( fs = trim ( scal % yaxis ), & cs = surf % yaxis ) call f_c_string ( fs = trim ( scal % zaxis ), & cs = surf % zaxis ) call f_c_string ( fs = trim ( scal % dx_unit ), & cs = surf % dx_unit ) call f_c_string ( fs = trim ( scal % dy_unit ), & cs = surf % dy_unit ) call f_c_string ( fs = trim ( scal % dz_unit ), & cs = surf % dz_unit ) call f_c_string ( fs = trim ( scal % object_name ), & cs = surf % object_name ) call f_c_string ( fs = trim ( scal % operator_name ), & cs = surf % operator_name ) call f_c_string ( fs = trim ( scal % client_zone ), & cs = surf % client_zone ) call f_c_string ( fs = trim ( scal % reserved ), & cs = surf % reserved ) call f_c_string ( fs = trim ( scal % reservedzone ), & cs = surf % reservedzone ) call f_c_string ( fs = trim ( scal % obsolete ), & cs = surf % obsolete ) call f_c_string ( fs = trim ( scal % obsolete2 ), & cs = surf % obsolete2 ) surf % dx = scal % dx surf % dy = scal % dy surf % dz = scal % dz surf % xunit_ratio = scal % xunit_ratio surf % yunit_ratio = scal % yunit_ratio surf % zunit_ratio = scal % zunit_ratio surf % XOffset = scal % XOffset surf % YOffset = scal % YOffset surf % ZOffset = scal % ZOffset surf % measurement_duration = scal % measurement_duration surf % zmin = scal % zmin surf % zmax = scal % zmax surf % xres = scal % xres surf % yres = scal % yres surf % nofpoints = scal % nofpoints surf % format = scal % format surf % version = scal % version surf % material_code = scal % material_code surf % type = scal % type surf % range = scal % range surf % special_points = scal % special_points surf % absolute = scal % absolute surf % pointsize = scal % pointsize surf % imprint = scal % imprint surf % inversion = scal % inversion surf % leveling = scal % leveling surf % seconds = scal % seconds surf % minutes = scal % minutes surf % hours = scal % hours surf % day = scal % day surf % month = scal % month surf % year = scal % year surf % dayof = scal % dayof surf % comment_size = scal % comment_size surf % private_size = scal % private_size surf % nobjects = scal % nobjects surf % acquisition = scal % acquisition return endsubroutine scal2surf","loc":"proc/scal2surf.html"},{"tags":"","title":"surf2scal – MUSST","text":"public subroutine surf2scal(surf, scal) Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(in) :: surf object OBJ_SURF type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF Calls proc~~surf2scal~~CallsGraph proc~surf2scal surf2scal proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string proc~empty empty proc~c_f_string->proc~empty Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~surf2scal~~CalledByGraph proc~surf2scal surf2scal proc~write_surf write_surf proc~write_surf->proc~surf2scal proc~open_surffile open_surffile proc~open_surffile->proc~surf2scal proc~save_fe_field save_fe_field proc~save_fe_field->proc~write_surf proc~save_ms_field save_ms_field proc~save_ms_field->proc~write_surf proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~save_fe_field proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~save_ms_field proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocsurf2scalCalledByGraph = svgPanZoom('#procsurf2scalCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code surf2scal Source Code subroutine surf2scal ( surf , scal ) implicit none type ( OBJ_SURF ), intent ( in ) :: surf !! *object [[OBJ_SURF]]* type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* integer ( kind = I4 ) :: i call c_f_string ( cs = surf % signature , & fs = scal % signature , & borne_s = i ) call c_f_string ( cs = surf % xlength_unit , & fs = scal % xlength_unit , & borne_s = i ) call c_f_string ( cs = surf % ylength_unit , & fs = scal % ylength_unit , & borne_s = i ) call c_f_string ( cs = surf % zlength_unit , & fs = scal % zlength_unit , & borne_s = i ) call c_f_string ( cs = surf % xaxis , & fs = scal % xaxis , & borne_s = i ) call c_f_string ( cs = surf % yaxis , & fs = scal % yaxis , & borne_s = i ) call c_f_string ( cs = surf % zaxis , & fs = scal % zaxis , & borne_s = i ) call c_f_string ( cs = surf % dx_unit , & fs = scal % dx_unit , & borne_s = i ) call c_f_string ( cs = surf % dy_unit , & fs = scal % dy_unit , & borne_s = i ) call c_f_string ( cs = surf % dz_unit , & fs = scal % dz_unit , & borne_s = i ) call c_f_string ( cs = surf % object_name , & fs = scal % object_name , & borne_s = i ) call c_f_string ( cs = surf % operator_name , & fs = scal % operator_name , & borne_s = i ) call c_f_string ( cs = surf % client_zone , & fs = scal % client_zone , & borne_s = i ) call c_f_string ( cs = surf % reserved , & fs = scal % reserved , & borne_s = i ) call c_f_string ( cs = surf % reservedzone , & fs = scal % reservedzone , & borne_s = i ) call c_f_string ( cs = surf % obsolete , & fs = scal % obsolete , & borne_s = i ) call c_f_string ( cs = surf % obsolete2 , & fs = scal % obsolete2 , & borne_s = i ) scal % dx = surf % dx scal % dy = surf % dy scal % dz = surf % dz scal % xunit_ratio = surf % xunit_ratio scal % yunit_ratio = surf % yunit_ratio scal % zunit_ratio = surf % zunit_ratio scal % XOffset = surf % XOffset scal % YOffset = surf % YOffset scal % ZOffset = surf % ZOffset scal % measurement_duration = surf % measurement_duration scal % zmin = surf % zmin scal % zmax = surf % zmax scal % xres = surf % xres scal % yres = surf % yres scal % nofpoints = surf % nofpoints scal % format = surf % format scal % version = surf % version scal % material_code = surf % material_code scal % type = surf % type scal % range = surf % range scal % special_points = surf % special_points scal % absolute = surf % absolute scal % pointsize = surf % pointsize scal % imprint = surf % imprint scal % inversion = surf % inversion scal % leveling = surf % leveling scal % seconds = surf % seconds scal % minutes = surf % minutes scal % hours = surf % hours scal % day = surf % day scal % month = surf % month scal % year = surf % year scal % dayof = surf % dayof scal % comment_size = surf % comment_size scal % private_size = surf % private_size scal % nobjects = surf % nobjects scal % acquisition = surf % acquisition return endsubroutine surf2scal","loc":"proc/surf2scal.html"},{"tags":"","title":"empty – MUSST","text":"public subroutine empty(charinout) Note Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: charinout Called by proc~~empty~~CalledByGraph proc~empty empty proc~c_f_string c_f_string proc~c_f_string->proc~empty proc~save_fe_field save_fe_field proc~save_fe_field->proc~empty proc~init_scal init_scal proc~save_fe_field->proc~init_scal proc~write_surf write_surf proc~save_fe_field->proc~write_surf proc~save_ms_field save_ms_field proc~save_ms_field->proc~empty proc~save_ms_field->proc~init_scal proc~save_ms_field->proc~write_surf proc~trans_surf_txt trans_surf_txt proc~trans_surf_txt->proc~empty proc~trans_surf_txt->proc~c_f_string proc~init_scal->proc~empty proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~save_fe_field proc~surf2scal surf2scal proc~surf2scal->proc~c_f_string proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~save_ms_field proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~open_surffile open_surffile proc~open_surffile->proc~surf2scal proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~write_surf->proc~surf2scal proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocemptyCalledByGraph = svgPanZoom('#procemptyCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code empty Source Code subroutine empty ( charinout ) implicit none character ( len =* ), intent ( inout ) :: charinout charinout = repeat ( ' ' , len ( charinout )) return endsubroutine empty","loc":"proc/empty.html"},{"tags":"","title":"c_f_string – MUSST","text":"private subroutine c_f_string(cs, fs, borne_s) Note Converts a C string to a Fortran string A From a memory viewpoint, a C string is like a character vector ending with a C_NULL_CHAR , so as long as\n   it is not found, the characters are copied one by one in a fortran string Arguments Type Intent Optional Attributes Name character(kind=C_CHAR), intent(in), dimension(:) :: cs C string character(len=*), intent(out) :: fs Fortran string integer(kind=I4), intent(out) :: borne_s resulting Fortran string length Calls proc~~c_f_string~~CallsGraph proc~c_f_string c_f_string proc~empty empty proc~c_f_string->proc~empty Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~c_f_string~~CalledByGraph proc~c_f_string c_f_string proc~surf2scal surf2scal proc~surf2scal->proc~c_f_string proc~trans_surf_txt trans_surf_txt proc~trans_surf_txt->proc~c_f_string proc~write_surf write_surf proc~write_surf->proc~surf2scal proc~open_surffile open_surffile proc~open_surffile->proc~surf2scal proc~save_fe_field save_fe_field proc~save_fe_field->proc~write_surf proc~save_ms_field save_ms_field proc~save_ms_field->proc~write_surf proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~save_fe_field proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~save_ms_field proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocc_f_stringCalledByGraph = svgPanZoom('#procc_f_stringCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code c_f_string Source Code subroutine c_f_string ( cs , fs , borne_s ) implicit none character ( kind = C_CHAR ), dimension (:), intent ( in ) :: cs !! *C string* character ( len =* ), intent ( out ) :: fs !! *Fortran string* integer ( kind = I4 ), intent ( out ) :: borne_s !! *resulting Fortran string length* integer ( kind = I4 ) :: i , ucs ucs = size ( cs ) ! vector length borne_s = ucs ! resulting string default length i = 1 do if ( i > ucs ) exit if ( cs ( i ) == C_NULL_CHAR ) then ! fin de chaîne c rencontrée ; s'il n'y a pas de null_char borne_s = i - 1 ! c'est qu'on utilise tout le vecteur exit endif i = i + 1 enddo call empty ( fs ) do i = 1 , borne_s ! the C string is translated into fortran fs ( i : i ) = cs ( i ) enddo return endsubroutine c_f_string","loc":"proc/c_f_string.html"},{"tags":"","title":"f_c_string – MUSST","text":"private subroutine f_c_string(fs, cs) Note Converts a Fortran string to a C string A From a memory viewpoint, a C string is like a character vector ending with a C_NULL_CHAR ,\n   so the characters are copied one by one in a C_CHAR vector that ends with a C_NULL_CHAR Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fs fortran string character(kind=C_CHAR), intent(out), dimension(:) :: cs resulting C string Contents Source Code f_c_string Source Code subroutine f_c_string ( fs , cs ) implicit none character ( len =* ), intent ( in ) :: fs !! *fortran string* character ( kind = C_CHAR ), dimension (:), intent ( out ) :: cs !! *resulting C string* integer ( kind = I4 ) :: i , ufs ufs = len_trim ( fs ) ! longueur de la chaîne fortran sans les null, les blancs, ... if ( ufs == 0 ) then ! si la chaîne est vide cs ( 1 ) = C_NULL_CHAR else do i = 1 , ufs cs ( i ) = fs ( i : i ) enddo if ( ufs < size ( cs )) cs ( ufs + 1 ) = C_NULL_CHAR ! si la fin du vecteur n'est pas atteinte endif return endsubroutine f_c_string","loc":"proc/f_c_string.html"},{"tags":"","title":"init_scal – MUSST","text":"public subroutine init_scal(scal, nx, ny, lx, ly, unit_z) Note Arguments Type Intent Optional Attributes Name type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF integer(kind=I4), intent(in), optional :: nx integer(kind=I4), intent(in), optional :: ny real(kind=R8), intent(in), optional :: lx real(kind=R8), intent(in), optional :: ly character(len=*), intent(in), optional :: unit_z Calls proc~~init_scal~~CallsGraph proc~init_scal init_scal proc~empty empty proc~init_scal->proc~empty Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_scal~~CalledByGraph proc~init_scal init_scal proc~save_fe_field save_fe_field proc~save_fe_field->proc~init_scal proc~save_ms_field save_ms_field proc~save_ms_field->proc~init_scal proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~save_fe_field proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~save_ms_field proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_scal Source Code subroutine init_scal ( scal , nx , ny , lx , ly , unit_z ) implicit none type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* integer ( kind = I4 ), optional , intent ( in ) :: nx integer ( kind = I4 ), optional , intent ( in ) :: ny real ( kind = R8 ), optional , intent ( in ) :: lx real ( kind = R8 ), optional , intent ( in ) :: ly character ( * ), optional , intent ( in ) :: unit_z integer ( kind = I4 ), dimension ( 1 : 8 ) :: time_val character ( len = 256 ) :: string call date_and_time ( values = time_val ) scal % format = 0 scal % nobjects = 1 scal % version = 1 scal % type = 2 scal % material_code = 1 scal % acquisition = 0 scal % range = 0 scal % special_points = 0 scal % absolute = 1 scal % pointsize = 32 scal % zmin = 0 scal % zmax = 0 scal % xres = 0 scal % yres = 0 scal % nofpoints = 0 scal % xunit_ratio = 1. scal % yunit_ratio = 1. scal % zunit_ratio = 1. scal % imprint = 0 scal % inversion = 0 scal % leveling = 0 scal % seconds = time_val ( 7 ) scal % minutes = time_val ( 6 ) scal % hours = time_val ( 5 ) scal % day = time_val ( 3 ) scal % month = time_val ( 2 ) scal % year = time_val ( 1 ) scal % dayof = 0 scal % measurement_duration = 0.0 scal % comment_size = 0 scal % private_size = 0 scal % XOffset = 0. scal % YOffset = 0. scal % ZOffset = 0. call empty ( scal % reserved ) call empty ( scal % obsolete2 ) call empty ( scal % obsolete ) call empty ( scal % reservedzone ) call empty ( scal % client_zone ) call empty ( scal % object_name ) call empty ( scal % signature ) call empty ( scal % operator_name ) scal % object_name = 'HOME MADE' scal % signature = 'DIGITAL SURF' scal % operator_name = 'MOD_SURFILE' call empty ( scal % xaxis ) call empty ( scal % yaxis ) call empty ( scal % zaxis ) scal % xaxis = \"X\" scal % yaxis = \"Y\" scal % zaxis = \"Z\" call empty ( scal % xlength_unit ) call empty ( scal % ylength_unit ) call empty ( scal % zlength_unit ) call empty ( scal % dx_unit ) call empty ( scal % dy_unit ) call empty ( scal % dz_unit ) scal % xlength_unit = \"m\" ; scal % dx_unit = trim ( scal % xlength_unit ) ; scal % dx = 1.0 scal % ylength_unit = \"m\" ; scal % dy_unit = trim ( scal % ylength_unit ) ; scal % dy = 1.0 scal % zlength_unit = \"m\" ; scal % dz_unit = trim ( scal % zlength_unit ) ; scal % dz = 1.0 scal % mu = 0 scal % si = 0 if ( present ( nx )) scal % xres = nx if ( present ( ny )) scal % yres = ny if ( present ( nx ). and . present ( lx )) scal % dx = lx / nx if ( present ( ny ). and . present ( ly )) scal % dy = ly / ny if ( present ( unit_z )) then ; scal % zlength_unit = trim ( unit_z ) scal % dz_unit = trim ( unit_z ) ; endif return endsubroutine init_scal","loc":"proc/init_scal.html"},{"tags":"","title":"trans_surf_txt – MUSST","text":"public subroutine trans_surf_txt(surf, fichier, xyz) Note Writes an OBJ_SURF object in a text file The object components are first written in a fortran string, then it is written into\n   the file with a comment Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(in) :: surf object OBJ_SURF character(len=*), intent(in) :: fichier text file to write logical(kind=I4), intent(in) :: xyz whether to also write the heights (maybe huge) Calls proc~~trans_surf_txt~~CallsGraph proc~trans_surf_txt trans_surf_txt proc~c_f_string c_f_string proc~trans_surf_txt->proc~c_f_string proc~empty empty proc~trans_surf_txt->proc~empty proc~get_unit get_unit proc~trans_surf_txt->proc~get_unit proc~c_f_string->proc~empty Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code trans_surf_txt Source Code subroutine trans_surf_txt ( surf , fichier , xyz ) implicit none type ( OBJ_SURF ), intent ( in ) :: surf !! *object [[OBJ_SURF]]* character ( len =* ), intent ( in ) :: fichier !! *text file to write* logical ( kind = I4 ), intent ( in ) :: xyz !! *whether to also write the heights (maybe huge)* integer ( kind = I4 ) :: i , k , s character ( len = 512 ) :: string , cc call get_unit ( k ) open ( k , file = trim ( fichier )) call c_f_string ( cs = surf % signature , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"signature              \" ; call empty ( cc ) write ( cc , * ) surf % format ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"format                 \" ; call empty ( cc ) write ( cc , * ) surf % nobjects ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"nobjects               \" ; call empty ( cc ) write ( cc , * ) surf % version ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"version                \" ; call empty ( cc ) write ( cc , * ) surf % type ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"type                   \" ; call empty ( cc ) call c_f_string ( cs = surf % object_name , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"object_name            \" ; call empty ( cc ) call c_f_string ( cs = surf % operator_name , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"operator_name          \" ; call empty ( cc ) write ( cc , * ) surf % material_code ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"material_code          \" ; call empty ( cc ) write ( cc , * ) surf % acquisition ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"acquisition            \" ; call empty ( cc ) write ( cc , * ) surf % range ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"range                  \" ; call empty ( cc ) write ( cc , * ) surf % special_points ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"special_points         \" ; call empty ( cc ) write ( cc , * ) surf % absolute ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"absolute               \" ; call empty ( cc ) call c_f_string ( cs = surf % reserved , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"reserved               \" ; call empty ( cc ) write ( cc , * ) surf % pointsize ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"pointsize              \" ; call empty ( cc ) write ( cc , * ) surf % zmin ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zmin                   \" ; call empty ( cc ) write ( cc , * ) surf % zmax ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zmax                   \" ; call empty ( cc ) write ( cc , * ) surf % xres ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xres                   \" ; call empty ( cc ) write ( cc , * ) surf % yres ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"yres                   \" ; call empty ( cc ) write ( cc , * ) surf % nofpoints ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"nofpoints              \" ; call empty ( cc ) write ( cc , * ) surf % dx ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dx                     \" ; call empty ( cc ) write ( cc , * ) surf % dy ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dy                     \" ; call empty ( cc ) write ( cc , * ) surf % dz ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dz                     \" ; call empty ( cc ) call c_f_string ( cs = surf % xaxis , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xaxis                  \" ; call empty ( cc ) call c_f_string ( cs = surf % yaxis , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"yaxis                  \" ; call empty ( cc ) call c_f_string ( cs = surf % zaxis , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zaxis                  \" ; call empty ( cc ) call c_f_string ( cs = surf % dx_unit , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dx_unit                \" ; call empty ( cc ) call c_f_string ( cs = surf % dy_unit , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dy_unit                \" ; call empty ( cc ) call c_f_string ( cs = surf % dz_unit , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dz_unit                \" ; call empty ( cc ) call c_f_string ( cs = surf % xlength_unit , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xlength_unit           \" ; call empty ( cc ) call c_f_string ( cs = surf % ylength_unit , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"ylength_unit           \" ; call empty ( cc ) call c_f_string ( cs = surf % zlength_unit , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zlength_unit           \" ; call empty ( cc ) write ( cc , * ) surf % xunit_ratio ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xunit_ratio            \" ; call empty ( cc ) write ( cc , * ) surf % yunit_ratio ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"yunit_ratio            \" ; call empty ( cc ) write ( cc , * ) surf % zunit_ratio ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zunit_ratio            \" ; call empty ( cc ) write ( cc , * ) surf % imprint ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"imprint                \" ; call empty ( cc ) write ( cc , * ) surf % inversion ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"inversion              \" ; call empty ( cc ) write ( cc , * ) surf % leveling ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"leveling               \" ; call empty ( cc ) call c_f_string ( cs = surf % obsolete , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"obsolete               \" ; call empty ( cc ) write ( cc , * ) surf % seconds ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"seconds                \" ; call empty ( cc ) write ( cc , * ) surf % minutes ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"minutes                \" ; call empty ( cc ) write ( cc , * ) surf % hours ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"hours                  \" ; call empty ( cc ) write ( cc , * ) surf % day ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"day                    \" ; call empty ( cc ) write ( cc , * ) surf % month ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"month                  \" ; call empty ( cc ) write ( cc , * ) surf % year ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"year                   \" ; call empty ( cc ) write ( cc , * ) surf % dayof ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dayof                  \" ; call empty ( cc ) write ( cc , * ) surf % measurement_duration ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"measurement_duration   \" ; call empty ( cc ) call c_f_string ( cs = surf % obsolete2 , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"obsolete2              \" ; call empty ( cc ) write ( cc , * ) surf % comment_size ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"comment_size           \" ; call empty ( cc ) write ( cc , * ) surf % private_size ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"private_size           \" ; call empty ( cc ) call c_f_string ( cs = surf % client_zone , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"client_zone            \" ; call empty ( cc ) write ( cc , * ) surf % XOffset ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"XOffset                \" ; call empty ( cc ) write ( cc , * ) surf % YOffset ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"YOffset                \" ; call empty ( cc ) write ( cc , * ) surf % ZOffset ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"ZOffset                \" ; call empty ( cc ) call c_f_string ( cs = surf % reservedzone , fs = string , borne_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"reservedzone           \" ; call empty ( cc ) if ( xyz ) then do i = 0 , surf % nofpoints - 1 write ( k , * ) mod ( i , surf % xres ) * surf % dx , ( i / surf % xres ) * surf % dy , surf % val ( i + 1 ) * surf % dz enddo endif close ( k ) return endsubroutine trans_surf_txt","loc":"proc/trans_surf_txt.html"},{"tags":"","title":"open_surffile – MUSST","text":"private subroutine open_surffile(fichier, surf, scal, dump) Note Subroutine that opens a .sur file and transfers it contents into an object OBJ_SURF Warning By default here, the heights are not written with dump=.true. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fichier file to be read type( OBJ_SURF ), intent(out) :: surf object that will contain the file infos and heights type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF logical(kind=I4), intent(in), optional :: dump whether to transform the data in a text file Calls proc~~open_surffile~~CallsGraph proc~open_surffile open_surffile proc~surf2scal surf2scal proc~open_surffile->proc~surf2scal proc~get_unit get_unit proc~open_surffile->proc~get_unit proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string proc~empty empty proc~c_f_string->proc~empty Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code open_surffile Source Code subroutine open_surffile ( fichier , surf , scal , dump ) implicit none character ( len =* ), intent ( in ) :: fichier !! *file to be read* type ( OBJ_SURF ), intent ( out ) :: surf !! *object that will contain the file infos and heights* type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* logical ( kind = I4 ), optional , intent ( in ) :: dump !! *whether to transform the data in a text file* integer ( kind = I4 ) :: i , k real ( kind = R8 ) :: scal_x , scal_y , scal_z character ( kind = C_CHAR ) :: charact call get_unit ( k ) open ( k , file = trim ( fichier ), & ! form = 'unformatted' , & ! access = \"stream\" , & ! beware the \"frecord-marker\" in other modes action = \"read\" , & ! position = \"rewind\" , & ! convert = 'little_endian' ,& ! status = 'old' ) read ( k ) surf % signature , surf % format , surf % nobjects , surf % version , surf % type , surf % object_name , & surf % operator_name , surf % material_code , surf % acquisition , surf % range , surf % special_points , & surf % absolute , surf % reserved , surf % pointsize , surf % zmin , surf % zmax , surf % xres , surf % yres , & surf % nofpoints , surf % dx , surf % dy , surf % dz , surf % xaxis , surf % yaxis , surf % zaxis , surf % dx_unit , & surf % dy_unit , surf % dz_unit , surf % xlength_unit , surf % ylength_unit , surf % zlength_unit , & surf % xunit_ratio , surf % yunit_ratio , surf % zunit_ratio , surf % imprint , surf % inversion , surf % leveling , & surf % obsolete , surf % seconds , surf % minutes , surf % hours , surf % day , surf % month , surf % year , surf % dayof , & surf % measurement_duration , surf % obsolete2 , surf % comment_size , surf % private_size , surf % client_zone , & surf % XOffset , surf % YOffset , surf % ZOffset , surf % reservedzone do i = 1 , surf % comment_size read ( k ) charact enddo allocate ( surf % val ( 1 : surf % nofpoints ) ) do i = 1 , surf % nofpoints read ( k ) surf % val ( i ) enddo close ( k ) call surf2scal ( surf , scal ) if ( present ( dump ). and . dump ) call trans_surf_txt ( surf , trim ( fichier ) // '.txt' , xyz = . false .) return endsubroutine open_surffile","loc":"proc/open_surffile.html"},{"tags":"","title":"trans_surf_tab – MUSST","text":"private subroutine trans_surf_tab(surf, tab) Note Subroutine that writes the heights of an OBJ_SURF object into a 2D array Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(inout) :: surf object OBJ_SURF that contains the heights real(kind=R8), intent(out), dimension(:, :), allocatable :: tab height array Calls proc~~trans_surf_tab~~CallsGraph proc~trans_surf_tab trans_surf_tab proc~unit2iuc unit2IUc proc~trans_surf_tab->proc~unit2iuc proc~unit2iuf unit2IUf proc~unit2iuc->proc~unit2iuf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~trans_surf_tab~~CalledByGraph proc~trans_surf_tab trans_surf_tab proc~read_surf read_surf proc~read_surf->proc~trans_surf_tab Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code trans_surf_tab Source Code subroutine trans_surf_tab ( surf , tab ) implicit none type ( OBJ_SURF ), intent ( inout ) :: surf !! *object ```OBJ_SURF``` that contains the heights* real ( kind = R8 ), dimension (:, :), allocatable , intent ( out ) :: tab !! *height array* integer ( kind = I4 ) :: long , larg , i , j , k real ( kind = R8 ) :: unit_z long = surf % xres larg = surf % yres allocate ( tab ( 1 : long , 1 : larg ) ) unit_z = unit2IUc ( surf % dz_unit ) do j = 1 , larg do i = 1 , long k = ( j - 1 ) * long + i tab ( i , j ) = ( surf % val ( k ) * surf % dz + surf % Zoffset ) * unit_z enddo enddo deallocate ( surf % val ) return endsubroutine trans_surf_tab","loc":"proc/trans_surf_tab.html"},{"tags":"","title":"read_surf – MUSST","text":"public subroutine read_surf(nom_fic, mu, sq, tab_s, scal) Note Subroutine that opens a surface file .sur or .dat The heights are centred, scaled then put into a vector. Warning If the scale factor sq is negative, the heights are not scaled when reading .sur Warning By default, the .sur header is dumped Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nom_fic file name real(kind=R8), intent(in) :: mu if > 0, values are centered real(kind=R8), intent(in) :: sq desired height standard deviation real(kind=R8), intent(out), dimension(:,:), allocatable :: tab_s height array type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF Calls proc~~read_surf~~CallsGraph proc~read_surf read_surf proc~trans_surf_tab trans_surf_tab proc~read_surf->proc~trans_surf_tab proc~lower lower proc~read_surf->proc~lower proc~get_unit get_unit proc~read_surf->proc~get_unit proc~unit2iuc unit2IUc proc~trans_surf_tab->proc~unit2iuc proc~unit2iuf unit2IUf proc~unit2iuc->proc~unit2iuf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_surf Source Code subroutine read_surf ( nom_fic , mu , sq , tab_s , scal ) implicit none character ( len =* ), intent ( in ) :: nom_fic !! *file name* real ( kind = R8 ), intent ( in ) :: mu !! *if > 0, values are centered* real ( kind = R8 ), intent ( in ) :: sq !! *desired height standard deviation* type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* real ( kind = R8 ), dimension (:,:), allocatable , intent ( out ) :: tab_s !! *height array* integer ( kind = I4 ) :: style , i , ii , j , jj , k , nb , eof , tmp , nx , ny real ( kind = R8 ) :: sqs , mean , dz , lx , ly , lz type ( OBJ_SURF ) :: surf character ( len = 3 ) :: ext real ( kind = R8 ), dimension (:), allocatable :: x , y , z i = len_trim ( nom_fic ) ext = lower ( nom_fic ( i - 2 : i ) ) if ( ext == 'dat' ) style = SURF_DAT if ( ext == 'sur' ) style = SURF_SUR select case ( style ) case ( SURF_SUR ) call open_surffile ( fichier = trim ( nom_fic ), surf = surf , scal = scal , dump = . false .) call trans_surf_tab ( surf = surf , tab = tab_s ) case ( SURF_DAT ) call get_unit ( k ) open ( unit = k , file = trim ( nom_fic ), status = 'old' ) nb = 0 do read ( k , * , iostat = eof ) if ( eof /= 0 ) exit nb = nb + 1 enddo rewind ( k ) allocate ( x ( 1 : nb ) ) allocate ( y ( 1 : nb ) ) allocate ( z ( 1 : nb ) ) do i = 1 , nb read ( k , * ) x ( i ), y ( i ), z ( i ) enddo close ( k ) ! the triplet x, y, z is sorted according x !----------------------------------------------------------- call sort_real_2real ( g = 1 , d = nb , rtabref = x ( 1 : nb ), rtab1 = y ( 1 : nb ), rtab2 = z ( 1 : nb )) i = 1 do if ( abs ( x ( i ) - x ( 1 )) > 100 * EPS_R8 ) exit i = i + 1 enddo scal % dx = abs ( x ( i ) - x ( 1 )) j = 1 do if ( abs ( x ( j + 1 ) - x ( j )) > 1.0e-10 ) exit j = j + 1 enddo ny = j ! number of same abscissae for a given column if ( mod ( nb , ny ) /= 0 ) STOP 'READ_SURF, non rectangular mesh' nx = nb / ny scal % xres = nx scal % yres = ny do i = 1 , nx ii = ( i - 1 ) * ny + 1 jj = ii + ny - 1 call sort_real_1real ( g = 1 , d = ny , rtabref = y ( ii : jj ), rtab1 = z ( ii : jj )) enddo j = 1 do if ( abs ( y ( j ) - y ( 1 )) > 100 * EPS_R8 ) exit j = j + 1 enddo scal % dy = abs ( y ( j ) - y ( 1 )) allocate ( tab_s ( 1 : nx , 1 : ny ) ) k = 0 do i = 1 , nx do j = 1 , ny k = k + 1 tab_s ( i , j ) = z ( k ) enddo enddo lx = maxval ( x ) - minval ( x ) ly = maxval ( y ) - minval ( y ) lz = maxval ( tab_s ) - minval ( tab_s ) scal % dz = lz / ( nx * ny ) scal % xlength_unit = 'm ' ; scal % dx_unit = 'm ' scal % ylength_unit = 'm ' ; scal % dy_unit = 'm ' scal % zlength_unit = 'm ' ; scal % dz_unit = 'm ' !call sort_real(g=1, d=nx*ny, rtabref=z(1:nx*ny)) !scal%dz = 1.e+10 !do i = 2, nx*ny !   dz = z(i) -z(i-1) !   if (abs(dz) < 100*EPS_R8) cycle !   scal%dz = min(scal%dz, dz) !enddo !scal%dz = dz deallocate ( x , y , z ) endselect nx = scal % xres ny = scal % yres ! centering ? if ( mu > 0. ) then mean = sum ( tab_s ( 1 : nx , 1 : ny )) / ( nx * ny ) scal % mu = mean tab_s ( 1 : nx , 1 : ny ) = tab_s ( 1 : nx , 1 : ny ) - mean endif ! scaling ? if ( sq > 0. ) then sqs = ( sum ( tab_s ( 1 : nx , 1 : ny ) ** 2 ) / ( nx * ny )) ** ( 0.5_R8 ) scal % si = sqs tab_s ( 1 : nx , 1 : ny ) = tab_s ( 1 : nx , 1 : ny ) * sq / sqs endif return endsubroutine read_surf","loc":"proc/read_surf.html"},{"tags":"","title":"build_surf – MUSST","text":"private subroutine build_surf(surf, tab) Note Subroutine that creates an object OBJ_SURF Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(inout) :: surf resulting object OBJ_SURF real(kind=R8), intent(in), dimension(1:surf%xres, 1:surf%yres) :: tab Calls proc~~build_surf~~CallsGraph proc~build_surf build_surf proc~unit2iuc unit2IUc proc~build_surf->proc~unit2iuc proc~unit2iuf unit2IUf proc~unit2iuc->proc~unit2iuf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code build_surf Source Code subroutine build_surf ( surf , tab ) implicit none type ( OBJ_SURF ), intent ( inout ) :: surf !! *resulting object ```OBJ_SURF```* real ( kind = R8 ), dimension ( 1 : surf % xres , 1 : surf % yres ), intent ( in ) :: tab integer ( kind = I4 ) :: i , j , k , nx , ny real ( kind = R8 ) :: max_n , min_t , max_t , mil_t , amp_t , unit_x , unit_y , unit_z nx = surf % xres ny = surf % yres surf % nofpoints = nx * ny unit_x = unit2IUc ( surf % dx_unit ) unit_y = unit2IUc ( surf % dy_unit ) unit_z = unit2IUc ( surf % dz_unit ) if ( allocated ( surf % val )) deallocate ( surf % val ) allocate ( surf % val ( 1 : surf % nofpoints )) min_t = minval ( tab ( 1 : nx , 1 : ny ) ) / unit_z max_t = maxval ( tab ( 1 : nx , 1 : ny ) ) / unit_z mil_t = 0.5_R8 * ( min_t + max_t ) ! middle of the range amp_t = max_t - min_t ! range amplitude surf % ZOffset = mil_t max_n = 0.5 * huge ( 1 ) ! the heights are integers, allowed to span ! half the positive integer range. surf % dz = amp_t / max_n ! subsequent dz k = 0 do j = 1 , ny do i = 1 , nx k = k + 1 surf % val ( k ) = nint ( ( tab ( i , j ) / unit_z - surf % ZOffset ) / surf % dz ) ! enddo enddo surf % zmin = minval ( surf % val ) surf % zmax = maxval ( surf % val ) return endsubroutine build_surf","loc":"proc/build_surf.html"},{"tags":"","title":"write_surffile – MUSST","text":"private subroutine write_surffile(fichier, surf) Note Subroutine that writes an object OBJ_SURF in a file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fichier file to be written type( OBJ_SURF ), intent(inout) :: surf object OBJ_SURF to write Calls proc~~write_surffile~~CallsGraph proc~write_surffile write_surffile proc~get_unit get_unit proc~write_surffile->proc~get_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_surffile Source Code subroutine write_surffile ( fichier , surf ) implicit none character ( len =* ), intent ( in ) :: fichier !! *file to be written* type ( OBJ_SURF ), intent ( inout ) :: surf !! *object ```OBJ_SURF``` to write* integer ( kind = I4 ) :: i , k call get_unit ( k ) open ( k , file = trim ( fichier ), & ! form = 'unformatted' , & ! access = \"stream\" , & ! beware the \"frecord-marker\" in other modes action = \"write\" , & ! position = \"rewind\" , & ! status = \"replace\" , & ! convert = 'little_endian' ) write ( k ) surf % signature , surf % format , surf % nobjects , surf % version , surf % type , surf % object_name , & surf % operator_name , surf % material_code , surf % acquisition , surf % range , surf % special_points , & surf % absolute , surf % reserved , surf % pointsize , surf % zmin , surf % zmax , surf % xres , surf % yres , & surf % nofpoints , surf % dx , surf % dy , surf % dz , surf % xaxis , surf % yaxis , surf % zaxis , surf % dx_unit , & surf % dy_unit , surf % dz_unit , surf % xlength_unit , surf % ylength_unit , surf % zlength_unit , & surf % xunit_ratio , surf % yunit_ratio , surf % zunit_ratio , surf % imprint , surf % inversion , surf % leveling , & surf % obsolete , surf % seconds , surf % minutes , surf % hours , surf % day , surf % month , surf % year , surf % dayof , & surf % measurement_duration , surf % obsolete2 , surf % comment_size , surf % private_size , surf % client_zone , & surf % XOffset , surf % YOffset , surf % ZOffset , surf % reservedzone , & ( surf % val ( i ), i = 1 , surf % nofpoints ) close ( k ) return endsubroutine write_surffile","loc":"proc/write_surffile.html"},{"tags":"","title":"write_surf – MUSST","text":"public subroutine write_surf(nom_fic, tab_s, scal) Note Subroutine that writes a height array into a surface file .sur or .dat Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nom_fic file name real(kind=R8), intent(in), dimension(1:scal%xres, 1:scal%yres) :: tab_s type( SCALE_SURF ), intent(inout) :: scal object SCALE_SURF Calls proc~~write_surf~~CallsGraph proc~write_surf write_surf proc~get_unit get_unit proc~write_surf->proc~get_unit proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~lower lower proc~write_surf->proc~lower proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string proc~empty empty proc~c_f_string->proc~empty Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_surf~~CalledByGraph proc~write_surf write_surf proc~save_fe_field save_fe_field proc~save_fe_field->proc~write_surf proc~save_ms_field save_ms_field proc~save_ms_field->proc~write_surf proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~save_fe_field proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~save_ms_field proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_surf Source Code subroutine write_surf ( nom_fic , tab_s , scal ) implicit none character ( len =* ), intent ( in ) :: nom_fic !! *file name* type ( SCALE_SURF ), intent ( inout ) :: scal !! *object [[SCALE_SURF]]* real ( kind = R8 ), dimension ( 1 : scal % xres , 1 : scal % yres ), intent ( in ) :: tab_s character ( len = 3 ) :: ext integer ( kind = I4 ) :: style , i , j , k type ( OBJ_SURF ) :: surf_s real ( kind = R8 ) :: dx , dy i = len_trim ( nom_fic ) ext = lower ( nom_fic ( i - 2 : i ) ) if ( ext == 'dat' ) style = SURF_DAT if ( ext == 'sur' ) style = SURF_SUR select case ( style ) case ( SURF_SUR ) call scal2surf ( scal , surf_s ) call build_surf ( surf = surf_s , tab = tab_s ( 1 : scal % xres , 1 : scal % yres )) surf_s % comment_size = 0 ! to increase compatibility with mountains call write_surffile ( fichier = trim ( nom_fic ), surf = surf_s ) call surf2scal ( surf_s , scal ) case ( SURF_DAT ) dx = scal % dx dy = scal % dy call get_unit ( k ) open ( k , file = trim ( nom_fic )) do i = 1 , scal % xres do j = 1 , scal % yres write ( k , * ) ( i - 1 ) * dx , ( j - 1 ) * dy , tab_s ( i , j ) enddo enddo close ( k ) endselect return endsubroutine write_surf","loc":"proc/write_surf.html"},{"tags":"","title":"dbvalu – MUSST","text":"private function dbvalu(t, a, n, k, ideriv, x, inbv, work, iflag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: t knot vector of length n+k real(kind=wp), intent(in), dimension(n) :: a b-spline coefficient vector of length n integer, intent(in) :: n number of b-spline coefficients.\n (sum of knot multiplicities-k) integer, intent(in) :: k order of the b-spline, k >= 1 integer, intent(in) :: ideriv order of the derivative, 0 <= ideriv <= k-1.\n ideriv = 0 returns the b-spline value real(kind=wp), intent(in) :: x argument, t(k) <= x <= t(n+1) integer, intent(inout) :: inbv an initialization parameter which must be set\n to 1 the first time dbvalu is called.\n inbv contains information for efficient process-\n ing after the initial call and inbv must not\n be changed by the user.  distinct splines require\n distinct inbv parameters. real(kind=wp), dimension(:) :: work work vector of length 3*k integer, intent(out) :: iflag Return Value real(kind=wp) Calls proc~~dbvalu~~CallsGraph proc~dbvalu dbvalu proc~dintrv dintrv proc~dbvalu->proc~dintrv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~dbvalu~~CalledByGraph proc~dbvalu dbvalu proc~db2val db2val proc~db2val->proc~dbvalu proc~db1val db1val proc~db1val->proc~dbvalu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dbvalu Source Code real ( wp ) function dbvalu ( t , a , n , k , ideriv , x , inbv , work , iflag ) implicit none integer , intent ( in ) :: n !! number of b-spline coefficients. !! (sum of knot multiplicities-k) real ( wp ), dimension (:), intent ( in ) :: t !! knot vector of length n+k real ( wp ), dimension ( n ), intent ( in ) :: a !! b-spline coefficient vector of length n integer , intent ( in ) :: k !! order of the b-spline, k >= 1 integer , intent ( in ) :: ideriv !! order of the derivative, 0 <= ideriv <= k-1. !! ideriv = 0 returns the b-spline value real ( wp ), intent ( in ) :: x !! argument, t(k) <= x <= t(n+1) integer , intent ( inout ) :: inbv !! an initialization parameter which must be set !! to 1 the first time dbvalu is called. !! inbv contains information for efficient process- !! ing after the initial call and inbv must not !! be changed by the user.  distinct splines require !! distinct inbv parameters. real ( wp ), dimension (:) :: work !! work vector of length 3*k integer , intent ( out ) :: iflag !!   0: no errors !! 401: k does not satisfy k>=1 !! 402: n does not satisfy n>=k !! 403: ideriv does not satisfy 0<=ideriv<k !! 404: x is not greater than or equal to t(k) !! 405: x is not less than or equal to t(n+1) !! 406: a left limiting value cannot be obtained at t(k) integer :: i , iderp1 , ihi , ihmkmj , ilo , imk , imkpj , ipj ,& ip1 , ip1mj , j , jj , j1 , j2 , kmider , kmj , km1 , kpk , mflag real ( wp ) :: fkmj dbvalu = 0.0_wp if ( k < 1 ) then write ( error_unit , '(A)' ) 'dbvalu - k does not satisfy k>=1' iflag = 401 return endif if ( n < k ) then write ( error_unit , '(A)' ) 'dbvalu - n does not satisfy n>=k' iflag = 402 return endif if ( ideriv < 0 . or . ideriv >= k ) then write ( error_unit , '(A)' ) 'dbvalu - ideriv does not satisfy 0<=ideriv<k' iflag = 403 return endif kmider = k - ideriv ! find *i* in (k,n) such that t(i) <= x < t(i+1) ! (or, <= t(i+1) if t(i) < t(i+1) = t(n+1)). km1 = k - 1 call dintrv ( t , n + 1 , x , inbv , i , mflag ) if ( x < t ( k )) then write ( error_unit , '(A)' ) 'dbvalu - x is not greater than or equal to t(k)' iflag = 404 return endif if ( mflag /= 0 ) then if ( x > t ( i )) then write ( error_unit , '(A)' ) 'dbvalu - x is not less than or equal to t(n+1)' iflag = 405 return endif do if ( i == k ) then write ( error_unit , '(A)' ) 'dbvalu - a left limiting value cannot be obtained at t(k)' iflag = 406 return endif i = i - 1 if ( x /= t ( i )) exit enddo endif ! difference the coefficients *ideriv* times ! work(i) = aj(i), work(k+i) = dp(i), work(k+k+i) = dm(i), i=1.k imk = i - k do j = 1 , k imkpj = imk + j work ( j ) = a ( imkpj ) enddo if ( ideriv /= 0 ) then do j = 1 , ideriv kmj = k - j fkmj = real ( kmj , wp ) do jj = 1 , kmj ihi = i + jj ihmkmj = ihi - kmj work ( jj ) = ( work ( jj + 1 ) - work ( jj )) / ( t ( ihi ) - t ( ihmkmj )) * fkmj enddo enddo endif ! compute value at *x* in (t(i),(t(i+1)) of ideriv-th derivative, ! given its relevant b-spline coeff. in aj(1),...,aj(k-ideriv). if ( ideriv /= km1 ) then ip1 = i + 1 kpk = k + k j1 = k + 1 j2 = kpk + 1 do j = 1 , kmider ipj = i + j work ( j1 ) = t ( ipj ) - x ip1mj = ip1 - j work ( j2 ) = x - t ( ip1mj ) j1 = j1 + 1 j2 = j2 + 1 enddo iderp1 = ideriv + 1 do j = iderp1 , km1 kmj = k - j ilo = kmj do jj = 1 , kmj work ( jj ) = ( work ( jj + 1 ) * work ( kpk + ilo ) + work ( jj ) * & work ( k + jj )) / ( work ( kpk + ilo ) + work ( k + jj )) ilo = ilo - 1 enddo enddo endif iflag = 0 dbvalu = work ( 1 ) endfunction dbvalu","loc":"proc/dbvalu.html"},{"tags":"","title":"db1ink – MUSST","text":"public subroutine db1ink(x, nx, fcn, kx, tx, bcoef, iflag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(nx) :: x Array of x abcissae. Must be strictly increasing. integer, intent(in) :: nx Number of x abcissae real(kind=wp), intent(in), dimension(nx) :: fcn Array of function values to interpolate. fcn(i) should\n    contain the function value at the point x(i) integer, intent(in) :: kx The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) real(kind=wp), intent(inout), dimension(nx+kx) :: tx The knots in the x direction for the spline interpolant.\n    If iflag=0 these are chosen by db1ink .\n    If iflag=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(out), dimension(nx) :: bcoef Array of coefficients of the b-spline interpolant. integer, intent(inout) :: iflag on input: 0 = knot sequence chosen by db1ink .\n                1 = knot sequence chosen by user. on output: 1 = successful execution.\n                2 = iflag out of range.\n                3 = nx out of range.\n                4 = kx out of range.\n                5 = x not strictly increasing.\n                6 = tx not non-decreasing. Calls proc~~db1ink~~CallsGraph proc~db1ink db1ink proc~dbtpcf dbtpcf proc~db1ink->proc~dbtpcf proc~check_inputs check_inputs proc~db1ink->proc~check_inputs proc~dbknot dbknot proc~db1ink->proc~dbknot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code db1ink Source Code subroutine db1ink ( x , nx , fcn , kx , tx , bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! Number of x abcissae integer , intent ( in ) :: kx !! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) real ( wp ), dimension ( nx ), intent ( in ) :: x !! Array of x abcissae. Must be strictly increasing. real ( wp ), dimension ( nx ), intent ( in ) :: fcn !! Array of function values to interpolate. fcn(i) should !!    contain the function value at the point x(i) real ( wp ), dimension ( nx + kx ), intent ( inout ) :: tx !! The knots in the x direction for the spline interpolant. !!    If iflag=0 these are chosen by [[db1ink]]. !!    If iflag=1 these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension ( nx ), intent ( out ) :: bcoef !! Array of coefficients of the b-spline interpolant. integer , intent ( inout ) :: iflag !! **on input:**  0 = knot sequence chosen by [[db1ink]]. !!                1 = knot sequence chosen by user. !! **on output:** 1 = successful execution. !!                2 = iflag out of range. !!                3 = nx out of range. !!                4 = kx out of range. !!                5 = x not strictly increasing. !!                6 = tx not non-decreasing. real ( wp ), dimension ( 2 * kx * ( nx + 1 )) :: work logical :: status_ok !check validity of inputs call check_inputs ( 'db1ink' ,& iflag ,& nx = nx ,& kx = kx ,& x = x ,& tx = tx ,& status_ok = status_ok ) if ( status_ok ) then !choose knots if ( iflag == 0 ) then call dbknot ( x , nx , kx , tx ) endif !construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , 1 , tx , kx , bcoef , work , iflag ) if ( iflag == 0 ) iflag = 1 endif endsubroutine db1ink","loc":"proc/db1ink.html"},{"tags":"","title":"db1val – MUSST","text":"public subroutine db1val(xval, idx, tx, nx, kx, bcoef, f, iflag, inbvx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db1ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db1ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db1ink ) real(kind=wp), intent(in), dimension(nx) :: bcoef the b-spline coefficients computed by db1ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. Calls proc~~db1val~~CallsGraph proc~db1val db1val proc~dbvalu dbvalu proc~db1val->proc~dbvalu proc~dintrv dintrv proc~dbvalu->proc~dintrv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code db1val Source Code subroutine db1val ( xval , idx , tx , nx , kx , bcoef , f , iflag , inbvx ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db1ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db1ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db1ink]]) real ( wp ), dimension ( nx ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db1ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. real ( wp ), dimension ( 3 * kx ) :: work f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then write ( error_unit , '(A)' ) 'db1val - x value out of bounds' iflag = 1 return endif f = dbvalu ( tx , bcoef , nx , kx , idx , xval , inbvx , work , iflag ) endsubroutine db1val","loc":"proc/db1val.html"},{"tags":"","title":"db2ink – MUSST","text":"public subroutine db2ink(x, nx, y, ny, fcn, kx, ky, tx, ty, bcoef, iflag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(nx) :: x Array of x abcissae. Must be strictly increasing. integer, intent(in) :: nx Number of x abcissae real(kind=wp), intent(in), dimension(ny) :: y Array of y abcissae. Must be strictly increasing. integer, intent(in) :: ny Number of y abcissae real(kind=wp), intent(in), dimension(nx,ny) :: fcn Array of function values to interpolate. fcn(i,j) should\n    contain the function value at the point (x(i),y(j)) integer, intent(in) :: kx The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: ky The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) real(kind=wp), intent(inout), dimension(nx+kx) :: tx The knots in the x direction for the spline interpolant.\n    If iflag=0 these are chosen by db2ink .\n    If iflag=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(ny+ky) :: ty The knots in the y direction for the spline interpolant.\n    If iflag=0 these are chosen by db2ink .\n    If iflag=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(out), dimension(nx,ny) :: bcoef Array of coefficients of the b-spline interpolant. integer, intent(inout) :: iflag on input: 0 = knot sequence chosen by db2ink .\n                1 = knot sequence chosen by user. on output: 1 = successful execution.\n                2 = iflag out of range.\n                3 = nx out of range.\n                4 = kx out of range.\n                5 = x not strictly increasing.\n                6 = tx not non-decreasing.\n                7 = ny out of range.\n                8 = ky out of range.\n                9 = y not strictly increasing.\n               10 = ty not non-decreasing. Calls proc~~db2ink~~CallsGraph proc~db2ink db2ink proc~dbtpcf dbtpcf proc~db2ink->proc~dbtpcf proc~check_inputs check_inputs proc~db2ink->proc~check_inputs proc~dbknot dbknot proc~db2ink->proc~dbknot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code db2ink Source Code subroutine db2ink ( x , nx , y , ny , fcn , kx , ky , tx , ty , bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! Number of x abcissae integer , intent ( in ) :: ny !! Number of y abcissae integer , intent ( in ) :: kx !! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer , intent ( in ) :: ky !! The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) real ( wp ), dimension ( nx ), intent ( in ) :: x !! Array of x abcissae. Must be strictly increasing. real ( wp ), dimension ( ny ), intent ( in ) :: y !! Array of y abcissae. Must be strictly increasing. real ( wp ), dimension ( nx , ny ), intent ( in ) :: fcn !! Array of function values to interpolate. fcn(i,j) should !!    contain the function value at the point (x(i),y(j)) real ( wp ), dimension ( nx + kx ), intent ( inout ) :: tx !! The knots in the x direction for the spline interpolant. !!    If iflag=0 these are chosen by [[db2ink]]. !!    If iflag=1 these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension ( ny + ky ), intent ( inout ) :: ty !! The knots in the y direction for the spline interpolant. !!    If iflag=0 these are chosen by [[db2ink]]. !!    If iflag=1 these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension ( nx , ny ), intent ( out ) :: bcoef !! Array of coefficients of the b-spline interpolant. integer , intent ( inout ) :: iflag !! **on input:**  0 = knot sequence chosen by [[db2ink]]. !!                1 = knot sequence chosen by user. !! **on output:** 1 = successful execution. !!                2 = iflag out of range. !!                3 = nx out of range. !!                4 = kx out of range. !!                5 = x not strictly increasing. !!                6 = tx not non-decreasing. !!                7 = ny out of range. !!                8 = ky out of range. !!                9 = y not strictly increasing. !!               10 = ty not non-decreasing. real ( wp ), dimension ( nx * ny ) :: temp real ( wp ), dimension ( max ( 2 * kx * ( nx + 1 ), 2 * ky * ( ny + 1 ))) :: work logical :: status_ok !check validity of inputs call check_inputs ( 'db2ink' ,& iflag ,& nx = nx , ny = ny ,& kx = kx , ky = ky ,& x = x , y = y ,& tx = tx , ty = ty ,& status_ok = status_ok ) if ( status_ok ) then !choose knots if ( iflag == 0 ) then call dbknot ( x , nx , kx , tx ) call dbknot ( y , ny , ky , ty ) endif !construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , ny , tx , kx , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( y , ny , temp , ny , nx , ty , ky , bcoef , work , iflag ) if ( iflag == 0 ) iflag = 1 endif endsubroutine db2ink","loc":"proc/db2ink.html"},{"tags":"","title":"db2val – MUSST","text":"public subroutine db2val(xval, yval, idx, idy, tx, ty, nx, ny, kx, ky, bcoef, f, iflag, inbvx, inbvy, iloy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. real(kind=wp), intent(in) :: yval y coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. integer, intent(in) :: idy y derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db2ink ) real(kind=wp), intent(in), dimension(ny+ky) :: ty sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to db2ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db2ink ) integer, intent(in) :: ny the number of interpolation points in y. (same as in last call to db2ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db2ink ) integer, intent(in) :: ky order of polynomial pieces in y. (same as in last call to db2ink ) real(kind=wp), intent(in), dimension(nx,ny) :: bcoef the b-spline coefficients computed by db2ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. Calls proc~~db2val~~CallsGraph proc~db2val db2val proc~dintrv dintrv proc~db2val->proc~dintrv proc~dbvalu dbvalu proc~db2val->proc~dbvalu proc~dbvalu->proc~dintrv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code db2val Source Code subroutine db2val ( xval , yval , idx , idy , tx , ty , nx , ny , kx , ky , bcoef , f , iflag , inbvx , inbvy , iloy ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idy !! y derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db2ink]]) integer , intent ( in ) :: ny !! the number of interpolation points in y. (same as in last call to [[db2ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db2ink]]) integer , intent ( in ) :: ky !! order of polynomial pieces in y. (same as in last call to [[db2ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), intent ( in ) :: yval !! y coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db2ink]]) real ( wp ), dimension ( ny + ky ), intent ( in ) :: ty !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db2ink]]) real ( wp ), dimension ( nx , ny ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db2ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer :: k , lefty , mflag , kcol real ( wp ), dimension ( ky ) :: temp real ( wp ), dimension ( 3 * max ( kx , ky )) :: work f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then write ( error_unit , '(A)' ) 'db2val - x value out of bounds' iflag = 1 return endif if ( yval < ty ( 1 ) . or . yval > ty ( ny + ky )) then write ( error_unit , '(A)' ) 'db2val - y value out of bounds' iflag = 2 return endif iflag = - 1 call dintrv ( ty , ny + ky , yval , iloy , lefty , mflag ); if ( mflag /= 0 ) return kcol = lefty - ky do k = 1 , ky kcol = kcol + 1 temp ( k ) = dbvalu ( tx , bcoef (:, kcol ), nx , kx , idx , xval , inbvx , work , iflag ) if ( iflag /= 0 ) return !error enddo kcol = lefty - ky + 1 f = dbvalu ( ty ( kcol :), temp , ky , ky , idy , yval , inbvy , work , iflag ) endsubroutine db2val","loc":"proc/db2val.html"},{"tags":"","title":"check_inputs – MUSST","text":"private subroutine check_inputs(routine, iflag, nx, ny, nz, nq, nr, ns, kx, ky, kz, kq, kr, ks, x, y, z, q, r, s, tx, ty, tz, tq, tr, ts, status_ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: routine integer, intent(inout) :: iflag integer, intent(in), optional :: nx integer, intent(in), optional :: ny integer, intent(in), optional :: nz integer, intent(in), optional :: nq integer, intent(in), optional :: nr integer, intent(in), optional :: ns integer, intent(in), optional :: kx integer, intent(in), optional :: ky integer, intent(in), optional :: kz integer, intent(in), optional :: kq integer, intent(in), optional :: kr integer, intent(in), optional :: ks real(kind=wp), intent(in), optional dimension(:) :: x real(kind=wp), intent(in), optional dimension(:) :: y real(kind=wp), intent(in), optional dimension(:) :: z real(kind=wp), intent(in), optional dimension(:) :: q real(kind=wp), intent(in), optional dimension(:) :: r real(kind=wp), intent(in), optional dimension(:) :: s real(kind=wp), intent(in), optional dimension(:) :: tx real(kind=wp), intent(in), optional dimension(:) :: ty real(kind=wp), intent(in), optional dimension(:) :: tz real(kind=wp), intent(in), optional dimension(:) :: tq real(kind=wp), intent(in), optional dimension(:) :: tr real(kind=wp), intent(in), optional dimension(:) :: ts logical, intent(out) :: status_ok Called by proc~~check_inputs~~CalledByGraph proc~check_inputs check_inputs proc~db2ink db2ink proc~db2ink->proc~check_inputs proc~db1ink db1ink proc~db1ink->proc~check_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code check_inputs Source Code subroutine check_inputs ( routine ,& iflag ,& nx , ny , nz , nq , nr , ns ,& kx , ky , kz , kq , kr , ks ,& x , y , z , q , r , s ,& tx , ty , tz , tq , tr , ts ,& status_ok ) implicit none character ( len =* ), intent ( in ) :: routine integer , intent ( inout ) :: iflag integer , intent ( in ), optional :: nx , ny , nz , nq , nr , ns integer , intent ( in ), optional :: kx , ky , kz , kq , kr , ks real ( wp ), dimension (:), intent ( in ), optional :: x , y , z , q , r , s real ( wp ), dimension (:), intent ( in ), optional :: tx , ty , tz , tq , tr , ts logical , intent ( out ) :: status_ok logical :: error status_ok = . false . if (( iflag < 0 ) . or . ( iflag > 1 )) then write ( error_unit , '(A,1X,I5)' ) & trim ( routine ) // ' - iflag is out of range: ' , iflag iflag = 2 else call check ( 'x' , nx , kx , x , tx ,[ 3 , 4 , 5 , 6 ], error ); if ( error ) return call check ( 'y' , ny , ky , y , ty ,[ 7 , 8 , 9 , 10 ], error ); if ( error ) return call check ( 'z' , nz , kz , z , tz ,[ 11 , 12 , 13 , 14 ], error ); if ( error ) return call check ( 'q' , nq , kq , q , tq ,[ 15 , 16 , 17 , 18 ], error ); if ( error ) return call check ( 'r' , nr , kr , r , tr ,[ 19 , 20 , 21 , 22 ], error ); if ( error ) return call check ( 's' , ns , ks , s , ts ,[ 23 , 24 , 25 , 26 ], error ); if ( error ) return status_ok = . true . endif contains subroutine check ( s , n , k , x , t , ierrs , error ) !check t,x,n,k for validity implicit none character ( len = 1 ), intent ( in ), optional :: s !! coordinate string: 'x','y','z','q','r','s' integer , intent ( in ), optional :: n !! size of x integer , intent ( in ), optional :: k !! order real ( wp ), dimension (:), intent ( in ), optional :: x !! abcissae vector real ( wp ), dimension (:), intent ( in ), optional :: t !! knot vector size(n+k) integer , dimension (:), intent ( in ) :: ierrs !! int error codes for n,k,x,t checks logical , intent ( out ) :: error !! true if there was an error if ( present ( n )) then call check_n ( 'n' // s , n , ierrs ( 1 ), error ); if ( error ) return if ( present ( k )) then call check_k ( 'k' // s , k , n , ierrs ( 2 ), error ); if ( error ) return endif if ( present ( x )) then call check_x ( s , n , x , ierrs ( 3 ), error ); if ( error ) return endif if ( iflag /= 0 ) then if ( present ( k ) . and . present ( t )) then call check_t ( 't' // s , n , k , t , ierrs ( 4 ), error ); if ( error ) return endif endif endif endsubroutine check subroutine check_n ( s , n , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n integer , intent ( in ) :: ierr logical , intent ( out ) :: error if ( n < 3 ) then write ( error_unit , '(A,1X,I5)' ) & trim ( routine ) // ' - ' // trim ( s ) // ' is out of range: ' , n iflag = ierr error = . true . else error = . false . endif endsubroutine check_n subroutine check_k ( s , k , n , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: k integer , intent ( in ) :: n integer , intent ( in ) :: ierr logical , intent ( out ) :: error if (( k < 2 ) . or . ( k >= n )) then write ( error_unit , '(A,1X,I5)' ) & trim ( routine ) // ' - ' // trim ( s ) // ' is out of range: ' , k iflag = ierr error = . true . else error = . false . endif endsubroutine check_k subroutine check_x ( s , n , x , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n real ( wp ), dimension (:), intent ( in ) :: x integer , intent ( in ) :: ierr logical , intent ( out ) :: error integer :: i error = . true . do i = 2 , n if ( x ( i ) <= x ( i - 1 )) then iflag = ierr write ( error_unit , '(A)' ) trim ( routine ) // ' - ' // trim ( s ) // & ' array must be strictly increasing' return endif enddo error = . false . endsubroutine check_x subroutine check_t ( s , n , k , t , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n integer , intent ( in ) :: k real ( wp ), dimension (:), intent ( in ) :: t integer , intent ( in ) :: ierr logical , intent ( out ) :: error integer :: i error = . true . do i = 2 , n + k if ( t ( i ) < t ( i - 1 )) then iflag = ierr write ( error_unit , '(A)' ) trim ( routine ) // ' - ' // trim ( s ) // & ' array must be non-decreasing' return endif enddo error = . false . endsubroutine check_t endsubroutine check_inputs","loc":"proc/check_inputs.html"},{"tags":"","title":"dbknot – MUSST","text":"private subroutine dbknot(x, n, k, t) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(n) :: x integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(out), dimension(:) :: t Called by proc~~dbknot~~CalledByGraph proc~dbknot dbknot proc~db2ink db2ink proc~db2ink->proc~dbknot proc~db1ink db1ink proc~db1ink->proc~dbknot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dbknot Source Code subroutine dbknot ( x , n , k , t ) implicit none integer , intent ( in ) :: n integer , intent ( in ) :: k real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: t integer :: i , j , ipj , npj , ip1 , jstrt real ( wp ) :: rnot !put k knots at each endpoint !(shift right endpoints slightly -- see pg 350 of reference) rnot = x ( n ) + 0.1_wp * ( x ( n ) - x ( n - 1 ) ) do j = 1 , k t ( j ) = x ( 1 ) npj = n + j t ( npj ) = rnot enddo !distribute remaining knots if ( mod ( k , 2 ) == 1 ) then !case of odd k --  knots between data points i = ( k - 1 ) / 2 - k ip1 = i + 1 jstrt = k + 1 do j = jstrt , n ipj = i + j t ( j ) = 0.5_wp * ( x ( ipj ) + x ( ipj + 1 ) ) enddo else !case of even k --  knots at data points i = ( k / 2 ) - k jstrt = k + 1 do j = jstrt , n ipj = i + j t ( j ) = x ( ipj ) enddo endif endsubroutine dbknot","loc":"proc/dbknot.html"},{"tags":"","title":"dbtpcf – MUSST","text":"private subroutine dbtpcf(x, n, fcn, ldf, nf, t, k, bcoef, work, iflag) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) integer, intent(in) :: n real(kind=wp) :: fcn (ldf,nf) integer, intent(in) :: ldf integer, intent(in) :: nf real(kind=wp) :: t (*) integer, intent(in) :: k real(kind=wp) :: bcoef (nf,n) real(kind=wp) :: work (*) integer, intent(out) :: iflag Called by proc~~dbtpcf~~CalledByGraph proc~dbtpcf dbtpcf proc~db2ink db2ink proc~db2ink->proc~dbtpcf proc~db1ink db1ink proc~db1ink->proc~dbtpcf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dbtpcf Source Code subroutine dbtpcf ( x , n , fcn , ldf , nf , t , k , bcoef , work , iflag ) integer , intent ( in ) :: n integer , intent ( in ) :: nf integer , intent ( in ) :: ldf integer , intent ( in ) :: k real ( wp ) :: x ( n ) real ( wp ) :: fcn ( ldf , nf ) real ( wp ) :: t ( * ) real ( wp ) :: bcoef ( nf , n ) real ( wp ) :: work ( * ) integer , intent ( out ) :: iflag !!   0: no errors !! 301: n should be >0 integer :: i , j , m1 , m2 , iq , iw ! check for null input if ( nf > 0 ) then ! partition work array m1 = k - 1 m2 = m1 + k iq = 1 + n iw = iq + m2 * n + 1 ! compute b-spline coefficients ! first data set call dbintk ( x , fcn , t , n , k , work , work ( iq ), work ( iw ), iflag ) if ( iflag == 0 ) then do i = 1 , n bcoef ( 1 , i ) = work ( i ) enddo !  all remaining data sets by back-substitution if ( nf == 1 ) return do j = 2 , nf do i = 1 , n work ( i ) = fcn ( i , j ) enddo call dbnslv ( work ( iq ), m2 , n , m1 , m1 , work ) do i = 1 , n bcoef ( j , i ) = work ( i ) enddo enddo endif else write ( error_unit , '(A)' ) 'dbtpcf - n should be >0' iflag = 301 endif endsubroutine dbtpcf","loc":"proc/dbtpcf.html"},{"tags":"","title":"dbintk – MUSST","text":"private subroutine dbintk(x, y, t, n, k, bcoef, q, work, iflag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(n) :: x vector of length n containing data point abscissa\n in strictly increasing order. real(kind=wp), intent(in), dimension(n) :: y corresponding vector of length n containing data\n point ordinates. real(kind=wp), intent(in), dimension(*) :: t knot vector of length n+k\n since t(1),..,t(k) <= x(1) and t(n+1),..,t(n+k) = x(n), this leaves only n-k knots (not\n necessarily x(i) values) interior to (x(1),x(n)) integer, intent(in) :: n number of data points, n >= k integer, intent(in) :: k order of the spline, k >= 1 real(kind=wp), intent(out), dimension(n) :: bcoef a vector of length n containing the b-spline coefficients real(kind=wp), intent(out), dimension(*) :: q a work vector of length (2 k-1) n, containing\n the triangular factorization of the coefficient\n matrix of the linear system being solved.  the\n coefficients for the interpolant of an\n additional data set (x(i),yy(i)), i=1,…,n\n with the same abscissa can be obtained by loading\n yy into bcoef and then executing\n call dbnslv(q,2k-1,n,k-1,k-1,bcoef) real(kind=wp), intent(out), dimension(*) :: work work vector of length 2*k integer, intent(out) :: iflag corresponding basis function and the system is singular.\n 104: the system of solver detects a singular system.\n although the theoretical conditions for a solution were satisfied. Calls proc~~dbintk~~CallsGraph proc~dbintk dbintk proc~dbnslv dbnslv proc~dbintk->proc~dbnslv proc~dbnfac dbnfac proc~dbintk->proc~dbnfac Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dbintk Source Code subroutine dbintk ( x , y , t , n , k , bcoef , q , work , iflag ) implicit none integer , intent ( in ) :: n !! number of data points, n >= k real ( wp ), dimension ( n ), intent ( in ) :: x !! vector of length n containing data point abscissa !! in strictly increasing order. real ( wp ), dimension ( n ), intent ( in ) :: y !! corresponding vector of length n containing data !! point ordinates. real ( wp ), dimension ( * ), intent ( in ) :: t !! knot vector of length n+k !! since t(1),..,t(k) <= x(1) and t(n+1),..,t(n+k) !! >= x(n), this leaves only n-k knots (not !! necessarily x(i) values) interior to (x(1),x(n)) integer , intent ( in ) :: k !! order of the spline, k >= 1 real ( wp ), dimension ( n ), intent ( out ) :: bcoef !! a vector of length n containing the b-spline coefficients real ( wp ), dimension ( * ), intent ( out ) :: q !! a work vector of length (2*k-1)*n, containing !! the triangular factorization of the coefficient !! matrix of the linear system being solved.  the !! coefficients for the interpolant of an !! additional data set (x(i),yy(i)), i=1,...,n !! with the same abscissa can be obtained by loading !! yy into bcoef and then executing !! call dbnslv(q,2k-1,n,k-1,k-1,bcoef) real ( wp ), dimension ( * ), intent ( out ) :: work !! work vector of length 2*k integer , intent ( out ) :: iflag !!   0: no errors. !! 100: k does not satisfy k>=1. !! 101: n does not satisfy n>=k. !! 102: x(i) does not satisfy x(i)<x(i+1) for some i. !! 103: some abscissa was not in the support of the. !! corresponding basis function and the system is singular. !! 104: the system of solver detects a singular system. !! although the theoretical conditions for a solution were satisfied. integer :: iwork , i , ilp1mx , j , jj , km1 , kpkm2 , left , lenq , np1 real ( wp ) :: xi if ( k < 1 ) then write ( error_unit , '(A)' ) 'dbintk - k does not satisfy k>=1' iflag = 100 return endif if ( n < k ) then write ( error_unit , '(A)' ) 'dbintk - n does not satisfy n>=k' iflag = 101 return endif jj = n - 1 if ( jj /= 0 ) then do i = 1 , jj if ( x ( i ) >= x ( i + 1 )) then write ( error_unit , '(A)' ) 'dbintk - x(i) does not satisfy x(i)<x(i+1) for some i' iflag = 102 return endif enddo endif np1 = n + 1 km1 = k - 1 kpkm2 = 2 * km1 left = k ! zero out all entries of q lenq = n * ( k + km1 ) do i = 1 , lenq q ( i ) = 0.0_wp enddo ! loop over i to construct the n interpolation equations do i = 1 , n xi = x ( i ) ilp1mx = min ( i + k , np1 ) ! *** find  left  in the closed interval (i,i+k-1) such that !         t(left) <= x(i) < t(left+1) ! matrix is singular if this is not possible left = max ( left , i ) if ( xi < t ( left )) then write ( error_unit , '(A)' ) 'dbintk - some abscissa was not in the support of the' // & ' corresponding basis function and the system is singular' iflag = 103 return endif do if ( xi < t ( left + 1 )) go to 30 left = left + 1 if ( left >= ilp1mx ) exit enddo left = left - 1 if ( xi > t ( left + 1 )) then write ( error_unit , '(A)' ) 'dbintk - some abscissa was not in the support of the' // & ' corresponding basis function and the system is singular' iflag = 103 return endif ! *** the i-th equation enforces interpolation at xi, hence ! a(i,j) = b(j,k,t)(xi), all j. only the  k  entries with  j = ! left-k+1,...,left actually might be nonzero. these  k  numbers ! are returned, in  bcoef (used for temp.storage here), by the ! following 30 call dbspvn ( t , k , k , 1 , xi , left , bcoef , work , iwork , iflag ) if ( iflag /= 0 ) return ! we therefore want  bcoef(j) = b(left-k+j)(xi) to go into ! a(i,left-k+j), i.e., into  q(i-(left+j)+2*k,(left+j)-k) since ! a(i+j,j)  is to go into  q(i+k,j), all i,j,  if we consider  q ! as a two-dim. array , with  2*k-1  rows (see comments in ! dbnfac). in the present program, we treat  q  as an equivalent ! one-dimensional array (because of fortran restrictions on ! dimension statements) . we therefore want  bcoef(j) to go into ! entry !     i -(left+j) + 2*k + ((left+j) - k-1)*(2*k-1) !            = i-left+1 + (left -k)*(2*k-1) + (2*k-2)*j ! of q. jj = i - left + 1 + ( left - k ) * ( k + km1 ) do j = 1 , k jj = jj + kpkm2 q ( jj ) = bcoef ( j ) enddo enddo ! obtain factorization of a, stored again in q. call dbnfac ( q , k + km1 , n , km1 , km1 , iflag ) if ( iflag == 1 ) then !success ! *** solve  a*bcoef = y  by backsubstitution do i = 1 , n bcoef ( i ) = y ( i ) enddo call dbnslv ( q , k + km1 , n , km1 , km1 , bcoef ) iflag = 0 else !failure write ( error_unit , '(A)' ) 'dbintk - the system of solver detects a singular system' // & ' although the theoretical conditions for a solution were satisfied' iflag = 104 endif endsubroutine dbintk","loc":"proc/dbintk.html"},{"tags":"","title":"dbnfac – MUSST","text":"private subroutine dbnfac(w, nroww, nrow, nbandl, nbandu, iflag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(nroww,nrow) :: w work array. See header for details. integer, intent(in) :: nroww row dimension of the work array w. must be >= nbandl + 1 + nbandu. integer, intent(in) :: nrow matrix order integer, intent(in) :: nbandl number of bands of a below the main diagonal integer, intent(in) :: nbandu number of bands of a above the main diagonal integer, intent(out) :: iflag indicating success(=1) or failure (=2) Called by proc~~dbnfac~~CalledByGraph proc~dbnfac dbnfac proc~dbintk dbintk proc~dbintk->proc~dbnfac Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dbnfac Source Code subroutine dbnfac ( w , nroww , nrow , nbandl , nbandu , iflag ) integer , intent ( in ) :: nroww !! row dimension of the work array w. must be >= nbandl + 1 + nbandu. integer , intent ( in ) :: nrow !! matrix order integer , intent ( in ) :: nbandl !! number of bands of a below the main diagonal integer , intent ( in ) :: nbandu !! number of bands of a above the main diagonal integer , intent ( out ) :: iflag !! indicating success(=1) or failure (=2) real ( wp ), dimension ( nroww , nrow ), intent ( inout ) :: w !! work array. See header for details. integer :: i , ipk , j , jmax , k , kmax , middle , midmk , nrowm1 real ( wp ) :: factor , pivot iflag = 1 middle = nbandu + 1 ! w(middle,.) contains the main diagonal of a. nrowm1 = nrow - 1 if ( nrowm1 < 0 ) then iflag = 2 return elseif ( nrowm1 == 0 ) then if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 return endif if ( nbandl <= 0 ) then ! a is upper triangular. check that diagonal is nonzero . do i = 1 , nrowm1 if ( w ( middle , i ) == 0.0_wp ) then iflag = 2 return endif enddo if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 return endif if ( nbandu <= 0 ) then ! a is lower triangular. check that diagonal is nonzero and ! divide each column by its diagonal. do i = 1 , nrowm1 pivot = w ( middle , i ) if ( pivot == 0.0_wp ) then iflag = 2 return endif jmax = min ( nbandl , nrow - i ) do j = 1 , jmax w ( middle + j , i ) = w ( middle + j , i ) / pivot enddo enddo return endif ! a is not just a triangular matrix. construct lu factorization do i = 1 , nrowm1 ! w(middle,i)  is pivot for i-th step . pivot = w ( middle , i ) if ( pivot == 0.0_wp ) then iflag = 2 return endif ! jmax is the number of (nonzero) entries in column i ! below the diagonal. jmax = min ( nbandl , nrow - i ) ! divide each entry in column i below diagonal by pivot. do j = 1 , jmax w ( middle + j , i ) = w ( middle + j , i ) / pivot enddo ! kmax is the number of (nonzero) entries in row i to ! the right of the diagonal. kmax = min ( nbandu , nrow - i ) ! subtract a(i,i+k)*(i-th column) from (i+k)-th column ! (below row i). do k = 1 , kmax ipk = i + k midmk = middle - k factor = w ( midmk , ipk ) do j = 1 , jmax w ( midmk + j , ipk ) = w ( midmk + j , ipk ) - w ( middle + j , i ) * factor enddo enddo enddo ! check the last diagonal entry. if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 endsubroutine dbnfac","loc":"proc/dbnfac.html"},{"tags":"","title":"dbnslv – MUSST","text":"private subroutine dbnslv(w, nroww, nrow, nbandl, nbandu, b) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(nroww,nrow) :: w describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nroww describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nrow describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nbandl describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nbandu describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . real(kind=wp), intent(inout), dimension(nrow) :: b in : right side of the system to be solved out : the solution x, of order nrow Called by proc~~dbnslv~~CalledByGraph proc~dbnslv dbnslv proc~dbintk dbintk proc~dbintk->proc~dbnslv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dbnslv Source Code subroutine dbnslv ( w , nroww , nrow , nbandl , nbandu , b ) integer , intent ( in ) :: nroww !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nrow !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nbandl !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nbandu !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. real ( wp ), dimension ( nroww , nrow ), intent ( in ) :: w !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. real ( wp ), dimension ( nrow ), intent ( inout ) :: b !! **in**: right side of the system to be solved !! **out**: the solution x, of order nrow integer :: i , j , jmax , middle , nrowm1 middle = nbandu + 1 if ( nrow /= 1 ) then nrowm1 = nrow - 1 if ( nbandl /= 0 ) then ! forward pass ! for i=1,2,...,nrow-1, subtract right side(i)*(i-th column of l) !                       from right side (below i-th row). do i = 1 , nrowm1 jmax = min ( nbandl , nrow - i ) do j = 1 , jmax b ( i + j ) = b ( i + j ) - b ( i ) * w ( middle + j , i ) enddo enddo endif ! backward pass ! for i=nrow,nrow-1,...,1, divide right side(i) by i-th diagonal !                          entry of u, then subtract right side(i)*(i-th column !                          of u) from right side (above i-th row). if ( nbandu <= 0 ) then ! a is lower triangular. do i = 1 , nrow b ( i ) = b ( i ) / w ( 1 , i ) enddo return endif i = nrow do b ( i ) = b ( i ) / w ( middle , i ) jmax = min ( nbandu , i - 1 ) do j = 1 , jmax b ( i - j ) = b ( i - j ) - b ( i ) * w ( middle - j , i ) enddo i = i - 1 if ( i <= 1 ) exit enddo endif b ( 1 ) = b ( 1 ) / w ( middle , 1 ) endsubroutine dbnslv","loc":"proc/dbnslv.html"},{"tags":"","title":"dbspvn – MUSST","text":"private subroutine dbspvn(t, jhigh, k, index, x, ileft, vnikx, work, iwork, iflag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t (*) knot vector of length n+k, where\n n = number of b-spline basis functions\n n = sum of knot multiplicities-k\n dimension t(ileft+jhigh) integer, intent(in) :: jhigh order of b-spline, 1 <= jhigh <= k integer, intent(in) :: k highest possible order integer, intent(in) :: index index = 1 gives basis functions of order jhigh\n       = 2 denotes previous entry with work, iwork\n         values saved for subsequent calls to\n         dbspvn. real(kind=wp), intent(in) :: x argument of basis functions, t(k) <= x <= t(n+1) integer, intent(in) :: ileft largest integer such that t(ileft) <= x < t(ileft+1) real(kind=wp), intent(out) :: vnikx (k) vector of length k for spline values. real(kind=wp), intent(out) :: work (*) a work vector of length 2*k integer, intent(out) :: iwork a work parameter.  both work and iwork contain\n information necessary to continue for index = 2.\n when index = 1 exclusively, these are scratch\n variables and can be used for other purposes. integer, intent(out) :: iflag Contents Source Code dbspvn Source Code subroutine dbspvn ( t , jhigh , k , index , x , ileft , vnikx , work , iwork , iflag ) implicit none real ( wp ), intent ( in ) :: t ( * ) !! knot vector of length n+k, where !! n = number of b-spline basis functions !! n = sum of knot multiplicities-k !! dimension t(ileft+jhigh) integer , intent ( in ) :: jhigh !! order of b-spline, 1 <= jhigh <= k integer , intent ( in ) :: k !! highest possible order integer , intent ( in ) :: index !! index = 1 gives basis functions of order jhigh !!       = 2 denotes previous entry with work, iwork !!         values saved for subsequent calls to !!         dbspvn. real ( wp ), intent ( in ) :: x !! argument of basis functions, t(k) <= x <= t(n+1) integer , intent ( in ) :: ileft !! largest integer such that t(ileft) <= x < t(ileft+1) real ( wp ), intent ( out ) :: vnikx ( k ) !! vector of length k for spline values. real ( wp ), intent ( out ) :: work ( * ) !! a work vector of length 2*k integer , intent ( out ) :: iwork !! a work parameter.  both work and iwork contain !! information necessary to continue for index = 2. !! when index = 1 exclusively, these are scratch !! variables and can be used for other purposes. integer , intent ( out ) :: iflag !!   0: no errors !! 201: k does not satisfy k>=1 !! 202: jhigh does not satisfy 1<=jhigh<=k !! 203: index is not 1 or 2 !! 204: x does not satisfy t(ileft)<=x<=t(ileft+1) integer :: imjp1 , ipj , jp1 , jp1ml , l real ( wp ) :: vm , vmprev ! content of j, deltam, deltap is expected unchanged between calls. ! work(i) = deltap(i), ! work(k+i) = deltam(i), i = 1,k if ( k < 1 ) then write ( error_unit , '(A)' ) 'dbspvn - k does not satisfy k>=1' iflag = 201 return endif if ( jhigh > k . or . jhigh < 1 ) then write ( error_unit , '(A)' ) 'dbspvn - jhigh does not satisfy 1<=jhigh<=k' iflag = 202 return endif if ( index < 1 . or . index > 2 ) then write ( error_unit , '(A)' ) 'dbspvn - index is not 1 or 2' iflag = 203 return endif if ( x < t ( ileft ) . or . x > t ( ileft + 1 )) then write ( error_unit , '(A)' ) 'dbspvn - x does not satisfy t(ileft)<=x<=t(ileft+1)' iflag = 204 return endif iflag = 0 if ( index == 1 ) then iwork = 1 vnikx ( 1 ) = 1.0_wp if ( iwork >= jhigh ) return endif do ipj = ileft + iwork work ( iwork ) = t ( ipj ) - x imjp1 = ileft - iwork + 1 work ( k + iwork ) = x - t ( imjp1 ) vmprev = 0.0_wp jp1 = iwork + 1 do l = 1 , iwork jp1ml = jp1 - l vm = vnikx ( l ) / ( work ( l ) + work ( k + jp1ml )) vnikx ( l ) = vm * work ( l ) + vmprev vmprev = vm * work ( k + jp1ml ) enddo vnikx ( jp1 ) = vmprev iwork = jp1 if ( iwork >= jhigh ) exit enddo endsubroutine dbspvn","loc":"proc/dbspvn.html"},{"tags":"","title":"dintrv – MUSST","text":"private subroutine dintrv(XT, lxt, x, ilo, ileft, mflag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(lxt) :: XT a knot or break point vector of length lxt integer, intent(in) :: lxt length of the XT vector real(kind=wp), intent(in) :: x argument integer, intent(inout) :: ilo an initialization parameter which must be set\n to 1 the first time the spline array XT is\n processed by dintrv. ilo contains information for\n efficient processing after the initial call and ilo\n must not be changed by the user.  distinct splines\n require distinct ilo parameters. integer, intent(out) :: ileft largest integer satisfying XT(ileft) <= x integer, intent(out) :: mflag signals when x lies out of bounds Called by proc~~dintrv~~CalledByGraph proc~dintrv dintrv proc~db2val db2val proc~db2val->proc~dintrv proc~dbvalu dbvalu proc~db2val->proc~dbvalu proc~dbvalu->proc~dintrv proc~db1val db1val proc~db1val->proc~dbvalu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dintrv Source Code subroutine dintrv ( XT , lxt , x , ilo , ileft , mflag ) implicit none integer , intent ( in ) :: lxt !! length of the XT vector real ( wp ), dimension ( lxt ), intent ( in ) :: XT !! a knot or break point vector of length lxt real ( wp ), intent ( in ) :: x !! argument integer , intent ( inout ) :: ilo !! an initialization parameter which must be set !! to 1 the first time the spline array XT is !! processed by dintrv. ilo contains information for !! efficient processing after the initial call and ilo !! must not be changed by the user.  distinct splines !! require distinct ilo parameters. integer , intent ( out ) :: ileft !! largest integer satisfying XT(ileft) <= x integer , intent ( out ) :: mflag !! signals when x lies out of bounds integer :: ihi , istep , middle ihi = ilo + 1 if ( ihi < lxt ) go to 10 if ( x >= XT ( lxt )) go to 110 if ( lxt <= 1 ) go to 90 ilo = lxt - 1 ihi = lxt 10 if ( x >= XT ( ihi )) go to 40 if ( x >= XT ( ilo )) go to 100 ! *** now x < XT(ihi) . find lower bound istep = 1 20 ihi = ilo ilo = ihi - istep if ( ilo <= 1 ) go to 30 if ( x >= XT ( ilo )) go to 70 istep = istep * 2 go to 20 30 ilo = 1 if ( x < XT ( 1 )) go to 90 go to 70 ! *** now x >= XT(ilo) . find upper bound 40 istep = 1 50 ilo = ihi ihi = ilo + istep if ( ihi >= lxt ) go to 60 if ( x < XT ( ihi )) go to 70 istep = istep * 2 go to 50 60 if ( x >= XT ( lxt )) go to 110 ihi = lxt ! *** now XT(ilo) <= x < XT(ihi) . narrow the interval 70 middle = ( ilo + ihi ) / 2 if ( middle == ilo ) go to 100 !     note. it is assumed that middle = ilo in case ihi = ilo+1 if ( x < XT ( middle )) go to 80 ilo = middle go to 70 80 ihi = middle go to 70 ! *** set output and return 90 mflag = - 1 ileft = 1 return 100 mflag = 0 ileft = ilo return 110 mflag = 1 ileft = lxt endsubroutine dintrv","loc":"proc/dintrv.html"},{"tags":"","title":"init_order – MUSST","text":"public subroutine init_order(order) Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(out), dimension(:) :: order Contents Source Code init_order Source Code subroutine init_order ( order ) implicit none integer ( kind = I4 ), dimension (:), intent ( out ) :: order integer ( kind = I4 ) :: i , l l = ubound ( order , 1 ) do i = 1 , l order ( i ) = i enddo return endsubroutine init_order","loc":"proc/init_order.html"},{"tags":"","title":"sort_integer – MUSST","text":"public recursive subroutine sort_integer(g, d, itabref) Note Subroutine to sort a vector of integers Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d integer(kind=I4), intent(inout), dimension(:) :: itabref Contents Source Code sort_integer Source Code recursive subroutine sort_integer ( g , d , itabref ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d integer ( kind = I4 ), dimension (:), intent ( inout ) :: itabref integer ( kind = I4 ) :: i , j , mil integer ( kind = I4 ) :: tmp , cle i = g j = d mil = ( g + d ) / 2 cle = itabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( itabref ( i ) < cle ) i = i + 1 enddo do while ( itabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau tmp = itabref ( i ) itabref ( i ) = itabref ( j ) itabref ( j ) = tmp ! échange des éléments du vecteur position i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_integer ( g , j , itabref ) if ( d > i ) call sort_integer ( i , d , itabref ) return endsubroutine sort_integer","loc":"proc/sort_integer.html"},{"tags":"","title":"sort_real – MUSST","text":"public recursive subroutine sort_real(g, d, rtabref) Note Subroutine to sort a vector of reals Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d real(kind=R8), intent(inout), dimension(:) :: rtabref Contents Source Code sort_real Source Code recursive subroutine sort_real ( g , d , rtabref ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d real ( kind = R8 ), dimension (:), intent ( inout ) :: rtabref integer ( kind = I4 ) :: i , j , mil real ( kind = R8 ) :: tmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau tmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = tmp ! échange des éléments du vecteur position i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_real ( g , j , rtabref ) if ( d > i ) call sort_real ( i , d , rtabref ) return endsubroutine sort_real","loc":"proc/sort_real.html"},{"tags":"","title":"sort_real_1real – MUSST","text":"public recursive subroutine sort_real_1real(g, d, rtabref, rtab1) Note Subroutine to sort a vector of reals, according a vector of reals Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d real(kind=R8), intent(inout), dimension(:) :: rtabref real(kind=R8), intent(inout), dimension(:) :: rtab1 Contents Source Code sort_real_1real Source Code recursive subroutine sort_real_1real ( g , d , rtabref , rtab1 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d real ( kind = R8 ), dimension (:), intent ( inout ) :: rtabref real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab1 integer ( kind = I4 ) :: i , j , mil real ( kind = R8 ) :: rtmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau rtmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = rtmp ! échange des éléments du vecteur 2 rtmp = rtab1 ( i ) rtab1 ( i ) = rtab1 ( j ) rtab1 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_real_1real ( g , j , rtabref , rtab1 ) if ( d > i ) call sort_real_1real ( i , d , rtabref , rtab1 ) return endsubroutine sort_real_1real","loc":"proc/sort_real_1real.html"},{"tags":"","title":"sort_real_1int – MUSST","text":"public recursive subroutine sort_real_1int(g, d, rtabref, itab1) Note Subroutine to sort a vector of integers, according a vector of reals Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d real(kind=R8), intent(inout), dimension(:) :: rtabref integer(kind=I4), intent(inout), dimension(:) :: itab1 Contents Source Code sort_real_1int Source Code recursive subroutine sort_real_1int ( g , d , rtabref , itab1 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d real ( kind = R8 ), dimension (:), intent ( inout ) :: rtabref integer ( kind = I4 ), dimension (:), intent ( inout ) :: itab1 integer ( kind = I4 ) :: i , j , mil , itmp real ( kind = R8 ) :: rtmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau rtmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = rtmp ! échange des éléments du vecteur 2 itmp = itab1 ( i ) itab1 ( i ) = itab1 ( j ) itab1 ( j ) = itmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_real_1int ( g , j , rtabref , itab1 ) if ( d > i ) call sort_real_1int ( i , d , rtabref , itab1 ) return endsubroutine sort_real_1int","loc":"proc/sort_real_1int.html"},{"tags":"","title":"sort_real_2real – MUSST","text":"public recursive subroutine sort_real_2real(g, d, rtabref, rtab1, rtab2) Note Subroutine to sort 2 vectors of reals, according a vector of reals Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d real(kind=R8), intent(inout), dimension(:) :: rtabref real(kind=R8), intent(inout), dimension(:) :: rtab1 real(kind=R8), intent(inout), dimension(:) :: rtab2 Contents Source Code sort_real_2real Source Code recursive subroutine sort_real_2real ( g , d , rtabref , rtab1 , rtab2 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d real ( kind = R8 ), dimension (:), intent ( inout ) :: rtabref real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab1 real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab2 integer ( kind = I4 ) :: i , j , mil real ( kind = R8 ) :: rtmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau rtmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = rtmp ! échange des éléments du vecteur 2 rtmp = rtab1 ( i ) rtab1 ( i ) = rtab1 ( j ) rtab1 ( j ) = rtmp ! échange des éléments du vecteur 3 rtmp = rtab2 ( i ) rtab2 ( i ) = rtab2 ( j ) rtab2 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_real_2real ( g , j , rtabref , rtab1 , rtab2 ) if ( d > i ) call sort_real_2real ( i , d , rtabref , rtab1 , rtab2 ) return endsubroutine sort_real_2real","loc":"proc/sort_real_2real.html"},{"tags":"","title":"sort_int_1int_1real – MUSST","text":"public recursive subroutine sort_int_1int_1real(g, d, itabref, itab1, rtab2) Note Subroutine to sort a vector of reals and a vector of integers, according a vector of integers Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d integer(kind=I4), intent(inout), dimension(:) :: itabref integer(kind=I4), intent(inout), dimension(:) :: itab1 real(kind=R8), intent(inout), dimension(:) :: rtab2 Contents Source Code sort_int_1int_1real Source Code recursive subroutine sort_int_1int_1real ( g , d , itabref , itab1 , rtab2 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d integer ( kind = I4 ), dimension (:), intent ( inout ) :: itabref integer ( kind = I4 ), dimension (:), intent ( inout ) :: itab1 real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab2 integer ( kind = I4 ) :: i , j , mil , cle , itmp real ( kind = R8 ) :: rtmp i = g j = d mil = ( g + d ) / 2 cle = itabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( itabref ( i ) < cle ) i = i + 1 enddo do while ( itabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau itmp = itabref ( i ) itabref ( i ) = itabref ( j ) itabref ( j ) = itmp ! échange des éléments du vecteur 2 itmp = itab1 ( i ) itab1 ( i ) = itab1 ( j ) itab1 ( j ) = itmp ! échange des éléments du vecteur 3 rtmp = rtab2 ( i ) rtab2 ( i ) = rtab2 ( j ) rtab2 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_int_1int_1real ( g , j , itabref , itab1 , rtab2 ) if ( d > i ) call sort_int_1int_1real ( i , d , itabref , itab1 , rtab2 ) return endsubroutine sort_int_1int_1real","loc":"proc/sort_int_1int_1real.html"},{"tags":"","title":"sort_int_1real – MUSST","text":"public recursive subroutine sort_int_1real(g, d, itabref, rtab1) Note Subroutine to sort a vector of reals, according a vector of integers Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d integer(kind=I4), intent(inout), dimension(:) :: itabref real(kind=R8), intent(inout), dimension(:) :: rtab1 Contents Source Code sort_int_1real Source Code recursive subroutine sort_int_1real ( g , d , itabref , rtab1 ) implicit none integer ( kind = I4 ), intent ( in ) :: g , d integer ( kind = I4 ), dimension (:), intent ( inout ) :: itabref real ( kind = R8 ), dimension (:), intent ( inout ) :: rtab1 integer ( kind = I4 ) :: i , j , mil , cle , itmp real ( kind = R8 ) :: rtmp i = g j = d mil = ( g + d ) / 2 cle = itabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( itabref ( i ) < cle ) i = i + 1 enddo do while ( itabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau itmp = itabref ( i ) itabref ( i ) = itabref ( j ) itabref ( j ) = itmp ! échange des éléments du vecteur 3 rtmp = rtab1 ( i ) rtab1 ( i ) = rtab1 ( j ) rtab1 ( j ) = rtmp i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_int_1real ( g , j , itabref , rtab1 ) if ( d > i ) call sort_int_1real ( i , d , itabref , rtab1 ) return endsubroutine sort_int_1real","loc":"proc/sort_int_1real.html"},{"tags":"","title":"get_unit – MUSST","text":"public subroutine get_unit(iunit) Note from John Burkardt website Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(out) :: iunit Called by proc~~get_unit~~CalledByGraph proc~get_unit get_unit proc~read_surf read_surf proc~read_surf->proc~get_unit proc~trans_surf_txt trans_surf_txt proc~trans_surf_txt->proc~get_unit proc~run_test run_test proc~run_test->proc~get_unit proc~test_slider_fe test_slider_fe proc~run_test->proc~test_slider_fe proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_bearing_x_fe test_bearing_x_fe proc~run_test->proc~test_bearing_x_fe proc~test_bearing_y_fe test_bearing_y_fe proc~run_test->proc~test_bearing_y_fe proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_pocket_fe test_pocket_fe proc~run_test->proc~test_pocket_fe proc~test_rough_fe test_rough_fe proc~run_test->proc~test_rough_fe proc~open_surffile open_surffile proc~open_surffile->proc~get_unit proc~read_config read_config proc~read_config->proc~get_unit proc~write_surf write_surf proc~write_surf->proc~get_unit proc~save_profile_x_comp_slider save_profile_x_comp_slider proc~save_profile_x_comp_slider->proc~get_unit proc~save_profile_x_comp_air_pocket save_profile_x_comp_air_pocket proc~save_profile_x_comp_air_pocket->proc~get_unit proc~save_profile_y_comp_air_pocket save_profile_y_comp_air_pocket proc~save_profile_y_comp_air_pocket->proc~get_unit proc~write_surffile write_surffile proc~write_surffile->proc~get_unit proc~save_profile_x_ms save_profile_x_ms proc~save_profile_x_ms->proc~get_unit proc~save_profile_x_fe save_profile_x_fe proc~save_profile_x_fe->proc~get_unit proc~save_fe_field save_fe_field proc~save_fe_field->proc~write_surf proc~save_ms_field save_ms_field proc~save_ms_field->proc~write_surf program~main main program~main->proc~run_test program~main->proc~read_config proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~save_fe_field proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~save_ms_field proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe->proc~solve_fe_prob var panprocget_unitCalledByGraph = svgPanZoom('#procget_unitCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_unit Source Code subroutine get_unit ( iunit ) implicit none integer ( kind = I4 ), intent ( out ) :: iunit integer ( kind = I4 ) :: i integer ( kind = I4 ) :: ios logical ( kind = I4 ) :: lopen iunit = 0 do i = 10 , 99 if ( i /= OPU . and . i /= IPU . and . i /= ERU ) then inquire ( unit = i , opened = lopen , iostat = ios ) if ( ios == 0 ) then if ( . not . lopen ) then iunit = i return endif endif endif enddo return endsubroutine get_unit","loc":"proc/get_unit.html"},{"tags":"","title":"solve_syst – MUSST","text":"public subroutine solve_syst(mat, step) Note General hat subroutine that handles the resolution steps: * ini solver initialization * ana solver analyzis when it's proposed by the solver * fac solver factorization * sol solver solution * fre solver memory release when it's proposed by the solver * end solver end Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type character(len=*), intent(in) :: step 'ini'=initialize, 'ana'=analyze, 'fac'=factorize, 'sol'=solve, 'fre'=free memory, 'end'=close solver Calls proc~~solve_syst~~CallsGraph proc~solve_syst solve_syst proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize dmumps dmumps proc~init_solver->dmumps mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~init_superlu init_superlu proc~init_solver->proc~init_superlu proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~factorize_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~analyse_solver->dmumps proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu proc~close_solver->mpi_finalize ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~close_solver->dmumps proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panprocsolve_systCallsGraph = svgPanZoom('#procsolve_systCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solve_syst~~CalledByGraph proc~solve_syst solve_syst proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocsolve_systCalledByGraph = svgPanZoom('#procsolve_systCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code solve_syst Source Code subroutine solve_syst ( mat , step ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* character ( len =* ), intent ( in ) :: step !! *'ini'=initialize, 'ana'=analyze, 'fac'=factorize, 'sol'=solve, 'fre'=free memory, 'end'=close solver* if ( index ( step , 'ini' ) /= 0 ) then ; call init_solver ( mat ) ; return ; endif if ( index ( step , 'ana' ) /= 0 ) then ; call analyse_solver ( mat ) ; return ; endif if ( index ( step , 'fac' ) /= 0 ) then ; call factorize_solver ( mat ) ; return ; endif if ( index ( step , 'sol' ) /= 0 ) then ; call solution_solver ( mat ) ; return ; endif if ( index ( step , 'fre' ) /= 0 ) then ; call freefact_solver ( mat ) ; return ; endif if ( index ( step , 'end' ) /= 0 ) then ; call close_solver ( mat ) ; return ; endif stop 'Bad step chosen in SOLVE_SYST' return endsubroutine solve_syst","loc":"proc/solve_syst.html"},{"tags":"","title":"init_solver – MUSST","text":"private subroutine init_solver(mat) Note Subroutine to initialize the matrices of the solver Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type Calls proc~~init_solver~~CallsGraph proc~init_solver init_solver mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize dmumps dmumps proc~init_solver->dmumps mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~init_superlu init_superlu proc~init_solver->proc~init_superlu proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_solver~~CalledByGraph proc~init_solver init_solver proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocinit_solverCalledByGraph = svgPanZoom('#procinit_solverCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_solver Source Code subroutine init_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr ! allocation of the system vectors: rhs and unknown allocate ( mat % b ( mat % nn ), mat % x ( mat % nn ) ) mat % b = HIG_R8 mat % x = HIG_R8 ! check solver type select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 call ma48_initialize ( factors = mat % matma48 % fact , & control = mat % matma48 % ctrl ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matma48 % ctrl % wp = - 1 mat % matma48 % ctrl % mp = - 1 mat % matma48 % ctrl % ldiag = - 1 case ( PRINT_MESS :) mat % matma48 % ctrl % ldiag = + 2 endselect #else stop 'MA48_LIB not defined' #endif case ( MUMP ) call mpi_init ( ierr ) mat % matmump % comm = MPI_COMM_WORLD mat % matmump % job = - 1 ! initialisation mat % matmump % sym = 0 ! no symetry mat % matmump % par = 1 ! MPI, host working call dmumps ( mat % matmump ) mat % matmump % icntl ( 1 ) = output_unit ! output stream for error messages mat % matmump % icntl ( 2 ) = error_unit ! output stream for diagnostic printing, statistics, and warning messages. mat % matmump % icntl ( 3 ) = error_unit ! output stream for global information, collected on the host. mat % matmump % icntl ( 4 ) = 1 ! level of printing for error, warning, and diagnostic messages. 1 : only errors mat % matmump % icntl ( 5 ) = 1 ! Specify element entry : elemental matrices if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'MUMP error, INIT_SOLVER' endif select case ( SOLV_MESS ) case ( NO_MESS ) mat % matmump % icntl ( 4 ) = 1 ! error output only case ( PRINT_MESS :) mat % matmump % icntl ( 4 ) = 3 ! all error output endselect case ( SULU ) call init_superlu ( sulu = mat % matsulu ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matsulu % options % PrintStat = 0 case ( PRINT_MESS :) mat % matsulu % options % PrintStat = 1 endselect case ( UMFP ) mat % matumfp % c_numeric = C_NULL_PTR call umfpack_di_defaults ( mat % matumfp % c_control ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matumfp % c_control ( UMFPACK_PRL ) = 1 case ( PRINT_MESS :) mat % matumfp % c_control ( UMFPACK_PRL ) = 2 endselect call umfpack_di_report_control ( mat % matumfp % c_control ) case default stop 'Unknown solver type, INIT_SOLVER' endselect return endsubroutine init_solver","loc":"proc/init_solver.html"},{"tags":"","title":"analyse_solver – MUSST","text":"private subroutine analyse_solver(mat) Note Subroutine to analyse, factorize (symbolic) the matrix of the system Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type Calls proc~~analyse_solver~~CallsGraph proc~analyse_solver analyse_solver proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic dmumps dmumps proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~analyse_solver~~CalledByGraph proc~analyse_solver analyse_solver proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocanalyse_solverCalledByGraph = svgPanZoom('#procanalyse_solverCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code analyse_solver Source Code subroutine analyse_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 mat % matma48 % zmat % row => mat % irow mat % matma48 % zmat % col => mat % jcol mat % matma48 % zmat % val => mat % a_elt mat % matma48 % zmat % n = mat % nn mat % matma48 % zmat % m = mat % nn mat % matma48 % zmat % ne = mat % nz call ma48_analyse ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & ainfo = mat % matma48 % ainf , & finfo = mat % matma48 % finf ) if ( mat % matma48 % ainf % flag < 0 ) then write ( OPU , * ) 'Failure of ma48_analyse with ainfop%flag = ' , mat % matma48 % ainf % flag stop endif #else stop 'MA48_LIB not defined' #endif case ( MUMP ) mat % matmump % eltptr => mat % eltptr mat % matmump % eltvar => mat % eltvar mat % matmump % a_elt => mat % a_elt mat % matmump % rhs => mat % b mat % matmump % n = mat % nn mat % matmump % nelt = mat % ne mat % matmump % job = 1 ! performs the analysis call dmumps ( mat % matmump ) case ( SULU ) mat % matsulu % irow => mat % irow mat % matsulu % jptr => mat % jptr mat % matsulu % a_elt => mat % a_elt mat % matsulu % b => mat % b mat % matsulu % n = mat % nn mat % matsulu % nz = mat % nz mat % matsulu % nrhs = 1 mat % matsulu % first = . true . call prep_superlu ( sulu = mat % matsulu ) case ( UMFP ) call s_umfpack_di_symbolic ( n_row = mat % nn , & n_col = mat % nn , & Ap = mat % jptr , & Ai = mat % irow , & Ax = mat % a_elt , & Symbolic = mat % matumfp % c_symbolic , & Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) case default stop 'ANALYSE_SOLVER : unknown solver type' endselect return endsubroutine analyse_solver","loc":"proc/analyse_solver.html"},{"tags":"","title":"factorize_solver – MUSST","text":"private subroutine factorize_solver(mat) Note Subroutine to factorize the matrix of the system Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type Calls proc~~factorize_solver~~CallsGraph proc~factorize_solver factorize_solver ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric dmumps dmumps proc~factorize_solver->dmumps proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~factorize_solver~~CalledByGraph proc~factorize_solver factorize_solver proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocfactorize_solverCalledByGraph = svgPanZoom('#procfactorize_solverCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code factorize_solver Source Code subroutine factorize_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 call ma48_factorize ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & finfo = mat % matma48 % finf , & fast = mat % matma48 % fast ) if ( mat % matma48 % finf % flag < 0 ) then write ( OPU , * ) 'Failure of ma48_factorize with finfo%flag = ' , mat % matma48 % finf % flag stop endif #else stop 'MA48_LIB not defined' #endif case ( MUMP ) mat % matmump % job = 2 call dmumps ( mat % matmump ) case ( SULU ) ! Just factorize once, in the case that the matrix doesn't change much if ( mat % matsulu % first ) call fact_superlu ( sulu = mat % matsulu , & verbose = ( mat % matsulu % options % PrintStat == 1 )) case ( UMFP ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! first release memory call s_umfpack_di_numeric ( Ap = mat % jptr , & Ai = mat % irow , & Ax = mat % a_elt , & Symbolic = mat % matumfp % c_symbolic , & Numeric = mat % matumfp % c_numeric , & Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) case default stop 'Unknown solver type, FACTORIZE_SOLVER' endselect return endsubroutine factorize_solver","loc":"proc/factorize_solver.html"},{"tags":"","title":"solution_solver – MUSST","text":"private subroutine solution_solver(mat) Note Subroutine to solve the system [A]\\{x\\} = \\{b\\} (sparse A) Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type Calls proc~~solution_solver~~CallsGraph proc~solution_solver solution_solver proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu mpi_finalize mpi_finalize proc~solution_solver->mpi_finalize dmumps dmumps proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx proc~prep_superlu prep_superlu proc~solv_superlu->proc~prep_superlu interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solution_solver~~CalledByGraph proc~solution_solver solution_solver proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocsolution_solverCalledByGraph = svgPanZoom('#procsolution_solverCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code solution_solver Source Code subroutine solution_solver ( mat ) implicit none type ( MAT_SOLV ), target , intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 call ma48_solve ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & rhs = mat % b , & x = mat % x , & control = mat % matma48 % ctrl , & sinfo = mat % matma48 % sinf , & resid = mat % matma48 % resid , & error = mat % error ) #else stop 'MA48_LIB not defined' #endif case ( MUMP ) mat % matmump % job = 3 call dmumps ( mat % matmump ) if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'Error in SOLUTION_SOLVER' endif ! solution has been assembled on the host if ( mat % matmump % myid == 0 ) then mat % x ( 1 : mat % nn ) = mat % matmump % rhs ( 1 : mat % nn ) endif case ( SULU ) call solv_superlu ( sol_x = mat % x , & sulu = mat % matsulu , & verbose = ( mat % matsulu % options % PrintStat == 1 )) mat % matsulu % first = . false . case ( UMFP ) ! Numeric factors must exist if (. not . C_ASSOCIATED ( mat % matumfp % c_numeric )) call solve_syst ( mat , 'fac' ) mat % matumfp % c_control ( UMFPACK_IRSTEP ) = 0 ! solve ax=b, without iterative refinement ! If you want to evaluate the required RAM (Go) ! write(*,*) mat%matumfp%c_info(UMFPACK_PEAK_MEMORY_ESTIMATE)/mat%matumfp%c_info(UMFPACK_SIZE_OF_UNIT)/1e9 ! write(*,*) sizeof(mat%a_elt)/1e9 call s_umfpack_di_solve ( sys = UMFPACK_A , & x = mat % x , & b = mat % b , & numeric = mat % matumfp % c_numeric , & control = mat % matumfp % c_control , & info = mat % matumfp % c_info ) if ( mat % matumfp % c_info ( UMFPACK_STATUS ) < 0 ) then write ( OPU , * ) 'error occurred in umfpack_di_solve: ' , mat % matumfp % c_info ( UMFPACK_STATUS ) stop 'Error in SOLUTION_SOLVER' endif case default stop 'Unknown solver type, SOLUTION_SOLVER' endselect return endsubroutine solution_solver","loc":"proc/solution_solver.html"},{"tags":"","title":"freefact_solver – MUSST","text":"private subroutine freefact_solver(mat) Note Subroutine to free the factors if applicable Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type Calls proc~~freefact_solver~~CallsGraph proc~freefact_solver freefact_solver proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~freefact_solver->proc~umfpack_di_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~freefact_solver~~CalledByGraph proc~freefact_solver freefact_solver proc~solve_syst solve_syst proc~solve_syst->proc~freefact_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocfreefact_solverCalledByGraph = svgPanZoom('#procfreefact_solverCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code freefact_solver Source Code subroutine freefact_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 continue #else stop 'MA48_LIB not defined' #endif case ( MUMP ) continue case ( SULU ) call free_superlu () case ( UMFP ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! free the numeric factorization case default stop 'unknown solver type, FREEFACT_SOLVER' endselect return endsubroutine freefact_solver","loc":"proc/freefact_solver.html"},{"tags":"","title":"close_solver – MUSST","text":"private subroutine close_solver(mat) Note Subroutine to close the solver Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type Calls proc~~close_solver~~CallsGraph proc~close_solver close_solver mpi_finalize mpi_finalize proc~close_solver->mpi_finalize ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu dmumps dmumps proc~close_solver->dmumps proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~close_solver~~CalledByGraph proc~close_solver close_solver proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocclose_solverCalledByGraph = svgPanZoom('#procclose_solverCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code close_solver Source Code subroutine close_solver ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr deallocate ( mat % eltptr ) deallocate ( mat % eltvar ) select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 nullify ( mat % matma48 % zmat % row ) nullify ( mat % matma48 % zmat % col ) nullify ( mat % matma48 % zmat % val ) call ma48_finalize ( factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & info = ierr ) deallocate ( mat % b , mat % x ) #else stop 'MA48_LIB not defined' #endif case ( MUMP ) if ( mat % matmump % myid == 0 ) then nullify ( mat % matmump % rhs ) nullify ( mat % matmump % eltptr ) nullify ( mat % matmump % eltvar ) nullify ( mat % matmump % a_elt ) endif ! destroy the instance (deallocate internal data structures) mat % matmump % job = - 2 call dmumps ( mat % matmump ) if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'Error MUMP in close_solver' endif call mpi_finalize ( ierr ) deallocate ( mat % b , mat % x ) case ( SULU ) call close_superlu ( sulu = mat % matsulu ) nullify ( mat % matsulu % b ) nullify ( mat % matsulu % irow ) nullify ( mat % matsulu % jptr ) nullify ( mat % matsulu % a_elt ) case ( UMFP ) deallocate ( mat % jptr , mat % irow ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! free the numeric factorization ! no lu factors (numeric) are in memory at this point. call umfpack_di_free_symbolic ( Symbolic = mat % matumfp % c_symbolic ) ! free the symbolic analysis call umfpack_di_report_info ( Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) ! print final statistics deallocate ( mat % b , mat % x ) case default stop 'Unknown solver type, close_solver' endselect return endsubroutine close_solver","loc":"proc/close_solver.html"},{"tags":"","title":"convert_matrice_format – MUSST","text":"public subroutine convert_matrice_format(mat) Note Subroutine to transform the Rutherford Boeing format into Harwell Boeing and triplet Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type Calls proc~~convert_matrice_format~~CallsGraph proc~convert_matrice_format convert_matrice_format proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~convert_matrice_format~~CalledByGraph proc~convert_matrice_format convert_matrice_format proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~convert_matrice_format proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~convert_matrice_format proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocconvert_matrice_formatCalledByGraph = svgPanZoom('#procconvert_matrice_formatCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code convert_matrice_format Source Code subroutine convert_matrice_format ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* integer ( kind = I4 ) :: i ! ======================================================================================================================= ! Compressed Column Storage (CCS) is also called the Harwell-Boeing sparse matrix format. ! ************************************************ ! Elemental entries (example provided by MUMP): ! A1 = 1|-1  2  3| A2 = 3|2 -1  3| !      2| 2  1  1|      4|1  2 -1| !      3| 1  1  1|      5|3  2  1| => a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 1, 2, 1, 3, -1, 2, 2, 3, -1, 1) ! ! A  = 1|-1  2  3  0  0| !      2| 2  1  1  0  0| !      3| 1  1  3 -1  3| !      4| 0  0  1  2 -1| !      5| 0  0  3  2  1| => eltvar = (1, 2, 3, 3, 4, 5), it locates the elemental matrix line in the assembled matrix !                        => eltptr = (1, 4, 7), it gives the elemental matrix first entry position in eltvar (last !                                               position being size(eltvar)+1) ! ! ************************************************ ! Assembled matrix : ! A being the same, a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 3, 1, 3, -1, 2, 2, 3, -1, 1) !                    irow = ( 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5,  3, 4, 5, 3,  4, 5) !                    jptr = (1, 4, 7, 12, 15, 18) ! ! ======================================================================================================================= ! Triplet form ! ************************************************ ! For each non zero a_elt entry, returns its row and column number ! A being the same, a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 3, 1, 3, -1, 2, 2, 3, -1, 1) !                    irow = ( 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5,  3, 4, 5, 3,  4, 5) !                    jcol = ( 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3,  4, 4, 4, 5,  5, 5) call from_elemental_to_assembled ( mat = mat ) select case ( mat % slv_t ) case ( MA48 ) ! Triplet form: irow, jcol, a_elt #if WITH_MA48 continue #else stop 'MA48_LIB not defined' #endif case ( MUMP ) ! Compressed row, elemental entries chosen: eltptr, eltvar, a_elt continue case ( UMFP , SULU ) ! Compressed row, assembled form: irow, jptr, a_elt deallocate ( mat % jcol ) ! no more needed ! UMFP and SULU allocations begin at 0 (C convention) do i = 1 , mat % nn + 1 mat % jptr ( i ) = mat % jptr ( i ) - 1 enddo if ( mat % slv_t == SULU ) mat % matsulu % jptr => mat % jptr ! otherwise, matsulu%jptr will be associated to ! a deallocated part of memory do i = 1 , mat % nz mat % irow ( i ) = mat % irow ( i ) - 1 enddo case default stop 'Unknown solver type, CONVERT_MATRICE_FORMAT' endselect return endsubroutine convert_matrice_format","loc":"proc/convert_matrice_format.html"},{"tags":"","title":"from_elemental_to_assembled – MUSST","text":"private subroutine from_elemental_to_assembled(mat) Note Subroutine to transform the elemental entries into assembled CC vectors Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type Called by proc~~from_elemental_to_assembled~~CalledByGraph proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format convert_matrice_format proc~convert_matrice_format->proc~from_elemental_to_assembled proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~convert_matrice_format proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~convert_matrice_format proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocfrom_elemental_to_assembledCalledByGraph = svgPanZoom('#procfrom_elemental_to_assembledCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code from_elemental_to_assembled Source Code subroutine from_elemental_to_assembled ( mat ) implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* integer ( kind = I4 ), pointer :: solver , nb_elt , n , ntot , nz integer ( kind = I4 ), dimension (:), pointer :: eltptr integer ( kind = I4 ), dimension (:), pointer :: eltvar real ( kind = R8 ), dimension (:), pointer :: a_elt integer ( kind = I4 ), dimension (:), pointer :: irow , jcol integer ( kind = I4 ), dimension (:), pointer :: jptr integer ( kind = I4 ) :: inelt , imatorder , i , j , ii , jj , i1 , i2 , ir1 , ir2 , jr1 , jr2 , itmp , innz , state solver => mat % slv_t nb_elt => mat % ne n => mat % nn ntot => mat % nt nz => mat % nz if ( solver == MUMP ) return ! conversion from elemental form to triplet form, perhaps with null a_elts !-------------------------------------------------------------------------- state = 0 if (. not . allocated ( mat % irow )) allocate ( mat % irow ( ntot ), stat = state ) if ( state /= 0 ) stop 'Memory allocation problem, FROM_ELEMENTAL_TO_ASSEMBLED' if (. not . allocated ( mat % jcol )) allocate ( mat % jcol ( ntot ), stat = state ) if ( state /= 0 ) stop 'Memory allocation problem, FROM_ELEMENTAL_TO_ASSEMBLED' eltptr => mat % eltptr eltvar => mat % eltvar a_elt => mat % a_elt irow => mat % irow jcol => mat % jcol jptr => mat % jptr irow ( 1 : ntot ) = - 1 jcol ( 1 : ntot ) = - 1 ii = 1 do inelt = 1 , nb_elt imatorder = eltptr ( inelt + 1 ) - eltptr ( inelt ) do i = 1 , imatorder irow ( ii :( ii + imatorder - 1 )) = eltvar ( eltptr ( inelt ): eltptr ( inelt + 1 ) - 1 ) jcol ( ii :( ii + imatorder - 1 )) = eltvar ( eltptr ( inelt ) + i - 1 ) ii = ii + imatorder enddo enddo ! where a_elt brings no contribution, rows and columns are zeroed !----------------------------------------------------------------- where ( abs ( a_elt ) < EPS_R8 ) irow = 0 jcol = 0 endwhere ! the triplet irow, jcol and a_elt is sorted according jcol !----------------------------------------------------------- call sort_int_1int_1real ( g = 1 , d = ntot , itabref = jcol ( 1 : ntot ), itab1 = irow ( 1 : ntot ), rtab2 = a_elt ( 1 : ntot )) ! column pointer determination for each new value !---------------------------------------------- if ( allocated ( mat % jptr )) deallocate ( mat % jptr ) ; allocate ( mat % jptr ( n + 1 ) ) ; jptr => mat % jptr ii = 1 do if ( jcol ( ii ) > 0 ) exit ! zeroed terms are ignored ii = ii + 1 enddo jptr ( 1 ) = ii do i = 1 , n - 1 itmp = jcol ( ii ) do ii = ii + 1 if ( jcol ( ii ) /= itmp ) exit enddo jptr ( i + 1 ) = ii enddo jptr ( n + 1 ) = ntot + 1 ! columns are already sorted; rows are now sorted for each row value !-------------------------------------------------------------------- do i = 1 , n i1 = jptr ( i ) i2 = jptr ( i + 1 ) - 1 call sort_int_1real ( g = 1 , d = i2 - i1 + 1 , itabref = irow ( i1 : i2 ), rtab1 = a_elt ( i1 : i2 )) enddo ! assembly starting from the jcol, irow and a_elt top ! for identical matrix locations, a_elts are added !----------------------------------------------------- innz = 1 jj = jptr ( 1 ) ! first non-zero element jr1 = jcol ( jj ) ir1 = irow ( jj ) jcol ( innz ) = jr1 irow ( innz ) = ir1 a_elt ( innz ) = a_elt ( jj ) do j = jj + 1 , ntot jr2 = jcol ( j ) ir2 = irow ( j ) if ( ( jr2 /= jr1 ). or .( ir2 /= ir1 ) ) then ! if row or column index has changed innz = innz + 1 ! a non-zero term is added jcol ( innz ) = jr2 irow ( innz ) = ir2 a_elt ( innz ) = a_elt ( j ) else a_elt ( innz ) = a_elt ( innz ) + a_elt ( j ) ! row and column indexes are the same, stiffness terms are added endif jr1 = jr2 ! stores (i-1) and (j-1) for further comparison ir1 = ir2 enddo nz = innz jcol ( nz + 1 : ntot ) = - 1 irow ( nz + 1 : ntot ) = - 1 a_elt ( nz + 1 : ntot ) = huge ( 1._R8 ) ! col pointer update !---------------------------------------------- jj = 1 jptr ( 1 ) = 1 do j = 1 , n - 1 itmp = jcol ( jj ) do jj = jj + 1 if ( jcol ( jj ) /= itmp ) exit enddo jptr ( j + 1 ) = jj enddo jptr ( n + 1 ) = nz + 1 nullify ( eltptr , eltvar , a_elt , irow , jcol , jptr ) return endsubroutine from_elemental_to_assembled","loc":"proc/from_elemental_to_assembled.html"},{"tags":"","title":"init_superlu – MUSST","text":"public subroutine init_superlu(sulu) Note Subroutine to set the default LU behaviour sulu%options%Fact               = DOFACT sulu%options%Equil              = YES sulu%options%ColPerm            = COLAMD sulu%options%DiagPivotThresh    = 1.0 sulu%options%Trans              = NOTRANS sulu%options%IterRefine         = NOREFINE sulu%options%SymmetricMode      = NO sulu%options%PivotGrowth        = NO sulu%options%ConditionNumber    = NO sulu%options%PrintStat          = YES Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu Calls proc~~init_superlu~~CallsGraph proc~init_superlu init_superlu interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_superlu~~CalledByGraph proc~init_superlu init_superlu proc~init_solver init_solver proc~init_solver->proc~init_superlu proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocinit_superluCalledByGraph = svgPanZoom('#procinit_superluCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_superlu Source Code subroutine init_superlu ( sulu ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu call set_default_options ( sulu % options ) return endsubroutine init_superlu","loc":"proc/init_superlu.html"},{"tags":"","title":"prep_superlu – MUSST","text":"public subroutine prep_superlu(sulu) Note Subroutine to prepare the SULU_ENV components Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu Calls proc~~prep_superlu~~CallsGraph proc~prep_superlu prep_superlu interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~prep_superlu~~CalledByGraph proc~prep_superlu prep_superlu proc~solv_superlu solv_superlu proc~solv_superlu->proc~prep_superlu proc~analyse_solver analyse_solver proc~analyse_solver->proc~prep_superlu proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~solve_syst->proc~solution_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocprep_superluCalledByGraph = svgPanZoom('#procprep_superluCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code prep_superlu Source Code subroutine prep_superlu ( sulu ) implicit none type ( sulu_env ), intent ( inout ) :: sulu integer ( kind = I4 ) :: nn , nz , nb nn = sulu % n nz = sulu % nz nb = sulu % nrhs if (. not . allocated ( sulu % perm_c )) then allocate ( sulu % perm_c ( 1 : nn ) ) allocate ( sulu % perm_r ( 1 : nn ) ) allocate ( sulu % etree ( 1 : nn ) ) allocate ( sulu % RR ( 1 : nn ) ) allocate ( sulu % CC ( 1 : nn ) ) allocate ( sulu % ferr ( 1 : nb ) ) allocate ( sulu % berr ( 1 : nb ) ) allocate ( sulu % rpg ( 1 : nb ) ) allocate ( sulu % rcond ( 1 : nb ) ) allocate ( sulu % x ( 1 : nn ) ) endif sulu % x ( 1 : nn ) = 0 call dCreate_CompCol_Matrix ( A = sulu % SMA , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % n , & ! in int nnz = sulu % nz , & ! in int nzval = sulu % a_elt , & ! in double dimension() rowind = sulu % irow , & ! in int dimension() colptr = sulu % jptr , & ! in int dimension() stype = SLU_NC , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) call dCreate_Dense_Matrix ( BX = sulu % smb , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % nrhs , & ! in int x = sulu % b , & ! in double dimension() ldx = sulu % n , & ! in int stype = SLU_DN , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) call dCreate_Dense_Matrix ( BX = sulu % smx , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % nrhs , & ! in int x = sulu % x , & ! in double dimension() ldx = sulu % n , & ! in int stype = SLU_DN , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) return endsubroutine prep_superlu","loc":"proc/prep_superlu.html"},{"tags":"","title":"fact_superlu – MUSST","text":"public subroutine fact_superlu(sulu, verbose) Note Subroutine to factorize the system note the directives: sulu%options%Fact = DOFACT sulu%SMB%ncol     = 0 Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu logical(kind=I4), intent(in) :: verbose Calls proc~~fact_superlu~~CallsGraph proc~fact_superlu fact_superlu interface~statfree StatFree proc~fact_superlu->interface~statfree interface~statinit StatInit proc~fact_superlu->interface~statinit interface~dgssvx dgssvx proc~fact_superlu->interface~dgssvx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fact_superlu Source Code subroutine fact_superlu ( sulu , verbose ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu logical ( kind = I4 ), intent ( in ) :: verbose sulu % lwork = 0 call StatInit ( sulu % stat ) sulu % options % Fact = DOFACT sulu % SMB % ncol = 0 call dgssvx ( options = sulu % options , & ! superlu_options_t   *options A = sulu % SMA , & ! SuperMatrix         *A perm_c = sulu % perm_c , & ! int                 *perm_c perm_r = sulu % perm_r , & ! int                 *perm_r etree = sulu % etree , & ! int                 *etree equed = sulu % equed , & ! char                *equed R = sulu % RR , & ! double              *R C = sulu % CC , & ! double              *C L = sulu % SML , & ! SuperMatrix         *L U = sulu % SMU , & ! SuperMatrix         *U work = sulu % work , & ! void                *work lwork = sulu % lwork , & ! int                  lwork B = sulu % SMB , & ! SuperMatrix         *B X = sulu % SMX , & ! SuperMatrix         *X recip_pivot_growth = sulu % rpg , & ! double              *recip_pivot_growth rcond = sulu % rcond , & ! double              *rcond ferr = sulu % ferr , & ! double              *ferr berr = sulu % berr , & ! double              *berr Glu = sulu % Glu , & ! GlobalLU_t          *Glu mem_usage = sulu % mem_usage , & ! mem_usage_t         *mem_usage stat = sulu % stat , & ! SuperLUStat_t       *stat info = sulu % info & ! int                 *info ) if ( verbose ) call StatPrint ( sulu % stat ) call StatFree ( sulu % stat ) return endsubroutine fact_superlu","loc":"proc/fact_superlu.html"},{"tags":"","title":"solv_superlu – MUSST","text":"public subroutine solv_superlu(sol_x, sulu, verbose) Note Subroutine to solve the system If no resolution has yet occured, sulu%first= true sulu%options%Fact = FACTORED sulu%SMB%ncol     = sulu%nrhs (usually 1 ) otherwise sulu%options%Fact = SAMEPATTERN sma, smb and smx are recreated but do not forget that we still have: mat%matsulu%irow   => mat%irow mat%matsulu%jptr   => mat%jptr mat%matsulu%a_elt  => mat%a_elt mat%matsulu%b      => mat%b Note The solution is retrieved with the pointer store of type NCFORMAT which\n gives access to nzval Warning At the end, the memory is released with the dstruction of sml and smu Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(:) :: sol_x type( SULU_ENV ), intent(inout) :: sulu logical(kind=I4), intent(in) :: verbose Calls proc~~solv_superlu~~CallsGraph proc~solv_superlu solv_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx proc~prep_superlu prep_superlu proc~solv_superlu->proc~prep_superlu interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solv_superlu~~CalledByGraph proc~solv_superlu solv_superlu proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocsolv_superluCalledByGraph = svgPanZoom('#procsolv_superluCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code solv_superlu Source Code subroutine solv_superlu ( sol_x , sulu , verbose ) implicit none real ( kind = R8 ), dimension (:), intent ( inout ) :: sol_x type ( SULU_ENV ), intent ( inout ) :: sulu logical ( kind = I4 ), intent ( in ) :: verbose type ( NCFORMAT ), pointer :: Xstore real ( kind = R8 ), pointer :: tabX (:) integer ( kind = I4 ) :: i call StatInit ( sulu % stat ) if ( sulu % first ) then sulu % options % Fact = FACTORED sulu % SMB % ncol = sulu % nrhs else sulu % options % Fact = SAMEPATTERN call prep_superlu ( sulu ) endif call dgssvx ( options = sulu % options , & ! superlu_options_t   *options A = sulu % SMA , & ! SuperMatrix         *A perm_c = sulu % perm_c , & ! int                 *perm_c perm_r = sulu % perm_r , & ! int                 *perm_r etree = sulu % etree , & ! int                 *etree equed = sulu % equed , & ! char                *equed R = sulu % RR , & ! double              *R C = sulu % CC , & ! double              *C L = sulu % SML , & ! SuperMatrix         *L U = sulu % SMU , & ! SuperMatrix         *U work = sulu % work , & ! void                *work lwork = sulu % lwork , & ! int                  lwork B = sulu % SMB , & ! SuperMatrix         *B X = sulu % SMX , & ! SuperMatrix         *X recip_pivot_growth = sulu % rpg , & ! double              *recip_pivot_growth rcond = sulu % rcond , & ! double              *rcond ferr = sulu % ferr , & ! double              *ferr berr = sulu % berr , & ! double              *berr Glu = sulu % Glu , & ! GlobalLU_t          *Glu mem_usage = sulu % mem_usage , & ! mem_usage_t         *mem_usage stat = sulu % stat , & ! SuperLUStat_t       *stat info = sulu % info & ! int                 *info ) call c_f_pointer ( sulu % SMX % Store , XStore ) call c_f_pointer ( XStore % nzval , tabX , [ XStore % nnz ]) do i = 1 , sulu % n sol_x ( i ) = tabX ( i ) enddo nullify ( Xstore , tabX ) if ( verbose ) call StatPrint ( sulu % stat ) call StatFree ( sulu % stat ) call Destroy_SuperNode_Matrix ( sulu % SML ) call Destroy_CompCol_Matrix ( sulu % SMU ) return endsubroutine solv_superlu","loc":"proc/solv_superlu.html"},{"tags":"","title":"free_superlu – MUSST","text":"public subroutine free_superlu() Note Subroutine that actually does nothing yet. Maybe, there will be extra memory that\n could be released here? Arguments None Called by proc~~free_superlu~~CalledByGraph proc~free_superlu free_superlu proc~freefact_solver freefact_solver proc~freefact_solver->proc~free_superlu proc~solve_syst solve_syst proc~solve_syst->proc~freefact_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocfree_superluCalledByGraph = svgPanZoom('#procfree_superluCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code free_superlu Source Code subroutine free_superlu () implicit none !type(SULU_ENV), intent(inout) :: sulu return endsubroutine free_superlu","loc":"proc/free_superlu.html"},{"tags":"","title":"close_superlu – MUSST","text":"public subroutine close_superlu(sulu) Note Subroutine to close the SuperLU process, with memory release Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu Calls proc~~close_superlu~~CallsGraph proc~close_superlu close_superlu interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~close_superlu~~CalledByGraph proc~close_superlu close_superlu proc~close_solver close_solver proc~close_solver->proc~close_superlu proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocclose_superluCalledByGraph = svgPanZoom('#procclose_superluCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code close_superlu Source Code subroutine close_superlu ( sulu ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu call Destroy_CompCol_Matrix ( sulu % SMA ) call Destroy_Dense_Matrix ( sulu % smb ) call Destroy_Dense_Matrix ( sulu % smx ) deallocate ( sulu % perm_c ) deallocate ( sulu % perm_r ) deallocate ( sulu % etree ) deallocate ( sulu % RR ) deallocate ( sulu % CC ) deallocate ( sulu % ferr ) deallocate ( sulu % berr ) deallocate ( sulu % rpg ) deallocate ( sulu % rcond ) return endsubroutine close_superlu","loc":"proc/close_superlu.html"},{"tags":"","title":"Destroy_SuperNode_Matrix – MUSST","text":"interface Called by interface~~destroy_supernode_matrix~~CalledByGraph interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu solv_superlu proc~solv_superlu->interface~destroy_supernode_matrix proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacedestroy_supernode_matrixCalledByGraph = svgPanZoom('#interfacedestroy_supernode_matrixCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine Destroy_SuperNode_Matrix(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A","loc":"interface/destroy_supernode_matrix.html"},{"tags":"","title":"Destroy_SuperMatrix_Store – MUSST","text":"interface private subroutine Destroy_SuperMatrix_Store(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A","loc":"interface/destroy_supermatrix_store.html"},{"tags":"","title":"Destroy_CompCol_Matrix – MUSST","text":"interface Called by interface~~destroy_compcol_matrix~~CalledByGraph interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~close_superlu close_superlu proc~close_superlu->interface~destroy_compcol_matrix proc~solv_superlu solv_superlu proc~solv_superlu->interface~destroy_compcol_matrix proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~close_solver close_solver proc~close_solver->proc~close_superlu proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver proc~solve_syst->proc~close_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacedestroy_compcol_matrixCalledByGraph = svgPanZoom('#interfacedestroy_compcol_matrixCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine Destroy_CompCol_Matrix(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A","loc":"interface/destroy_compcol_matrix.html"},{"tags":"","title":"Destroy_Dense_Matrix – MUSST","text":"interface Called by interface~~destroy_dense_matrix~~CalledByGraph interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu close_superlu proc~close_superlu->interface~destroy_dense_matrix proc~close_solver close_solver proc~close_solver->proc~close_superlu proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacedestroy_dense_matrixCalledByGraph = svgPanZoom('#interfacedestroy_dense_matrixCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private subroutine Destroy_Dense_Matrix(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A","loc":"interface/destroy_dense_matrix.html"},{"tags":"","title":"StatInit – MUSST","text":"interface Called by interface~~statinit~~CalledByGraph interface~statinit StatInit proc~fact_superlu fact_superlu proc~fact_superlu->interface~statinit proc~solv_superlu solv_superlu proc~solv_superlu->interface~statinit proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacestatinitCalledByGraph = svgPanZoom('#interfacestatinitCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private subroutine StatInit(stat) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(out) :: stat","loc":"interface/statinit.html"},{"tags":"","title":"StatFree – MUSST","text":"interface Called by interface~~statfree~~CalledByGraph interface~statfree StatFree proc~fact_superlu fact_superlu proc~fact_superlu->interface~statfree proc~solv_superlu solv_superlu proc~solv_superlu->interface~statfree proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacestatfreeCalledByGraph = svgPanZoom('#interfacestatfreeCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private subroutine StatFree(stat) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(in) :: stat","loc":"interface/statfree.html"},{"tags":"","title":"dCreate_CompCol_Matrix – MUSST","text":"interface Called by interface~~dcreate_compcol_matrix~~CalledByGraph interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu prep_superlu proc~prep_superlu->interface~dcreate_compcol_matrix proc~solv_superlu solv_superlu proc~solv_superlu->proc~prep_superlu proc~analyse_solver analyse_solver proc~analyse_solver->proc~prep_superlu proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~solve_syst->proc~solution_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacedcreate_compcol_matrixCalledByGraph = svgPanZoom('#interfacedcreate_compcol_matrixCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private subroutine dCreate_CompCol_Matrix(A, m, n, nnz, nzval, rowind, colptr, stype, dtype, mtype) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(out) :: A integer(kind=C_INT), intent(in), value :: m integer(kind=C_INT), intent(in), value :: n integer(kind=C_INT), intent(in), value :: nnz real(kind=C_DOUBLE), intent(in) :: nzval (*) integer(kind=C_INT), intent(in) :: rowind (*) integer(kind=C_INT), intent(in) :: colptr (*) integer(kind=C_INT), intent(in), value :: stype integer(kind=C_INT), intent(in), value :: dtype integer(kind=C_INT), intent(in), value :: mtype","loc":"interface/dcreate_compcol_matrix.html"},{"tags":"","title":"dCreate_Dense_Matrix – MUSST","text":"interface Called by interface~~dcreate_dense_matrix~~CalledByGraph interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu prep_superlu proc~prep_superlu->interface~dcreate_dense_matrix proc~solv_superlu solv_superlu proc~solv_superlu->proc~prep_superlu proc~analyse_solver analyse_solver proc~analyse_solver->proc~prep_superlu proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~solve_syst->proc~solution_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacedcreate_dense_matrixCalledByGraph = svgPanZoom('#interfacedcreate_dense_matrixCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private subroutine dCreate_Dense_Matrix(BX, m, n, x, ldx, stype, dtype, mtype) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(out) :: BX integer(kind=C_INT), intent(in), value :: m integer(kind=C_INT), intent(in), value :: n real(kind=C_DOUBLE), intent(in) :: x (*) integer(kind=C_INT), intent(in), value :: ldx integer(kind=C_INT), intent(in), value :: stype integer(kind=C_INT), intent(in), value :: dtype integer(kind=C_INT), intent(in), value :: mtype","loc":"interface/dcreate_dense_matrix.html"},{"tags":"","title":"set_default_options – MUSST","text":"interface Called by interface~~set_default_options~~CalledByGraph interface~set_default_options set_default_options proc~init_superlu init_superlu proc~init_superlu->interface~set_default_options proc~init_solver init_solver proc~init_solver->proc~init_superlu proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfaceset_default_optionsCalledByGraph = svgPanZoom('#interfaceset_default_optionsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private subroutine set_default_options(options) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLU_OPTIONS_T ), intent(inout) :: options","loc":"interface/set_default_options.html"},{"tags":"","title":"dgssvx – MUSST","text":"interface Called by interface~~dgssvx~~CalledByGraph interface~dgssvx dgssvx proc~fact_superlu fact_superlu proc~fact_superlu->interface~dgssvx proc~solv_superlu solv_superlu proc~solv_superlu->interface~dgssvx proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacedgssvxCalledByGraph = svgPanZoom('#interfacedgssvxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private subroutine dgssvx(options, A, perm_c, perm_r, etree, equed, R, C, L, U, work, lwork, B, X, recip_pivot_growth, rcond, ferr, berr, Glu, mem_usage, stat, info) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLU_OPTIONS_T ), intent(in) :: options type( SUPERMATRIX ), intent(inout) :: A integer(kind=C_INT), intent(inout) :: perm_c (*) integer(kind=C_INT), intent(inout) :: perm_r (*) integer(kind=C_INT), intent(inout) :: etree (*) character(kind=C_CHAR), intent(inout) :: equed (*) real(kind=C_DOUBLE), intent(inout) :: R (*) real(kind=C_DOUBLE), intent(inout) :: C (*) type( SUPERMATRIX ), intent(inout) :: L type( SUPERMATRIX ), intent(inout) :: U type(C_PTR), intent(out) :: work integer(kind=C_INT), intent(in), value :: lwork type( SUPERMATRIX ), intent(inout) :: B type( SUPERMATRIX ), intent(out) :: X real(kind=C_DOUBLE), intent(out) :: recip_pivot_growth (*) real(kind=C_DOUBLE), intent(out) :: rcond (*) real(kind=C_DOUBLE), intent(out) :: ferr (*) real(kind=C_DOUBLE), intent(out) :: berr (*) type( GLOBALLU_T ), intent(inout) :: Glu type( MEM_USAGE_T ), intent(out) :: mem_usage type( SUPERLUSTAT_T ), intent(out) :: stat integer(kind=C_INT), intent(out) :: info","loc":"interface/dgssvx.html"},{"tags":"","title":"StatPrint – MUSST","text":"interface private subroutine StatPrint(stat) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(in) :: stat","loc":"interface/statprint.html"},{"tags":"","title":"umfpack_di_symbolic – MUSST","text":"public function umfpack_di_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_di_symbolic~~CallsGraph proc~umfpack_di_symbolic umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_symbolic~~CalledByGraph proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~analyse_solver analyse_solver proc~analyse_solver->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4csym_ip interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->interface~umf4zsym proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocumfpack_di_symbolicCalledByGraph = svgPanZoom('#procumfpack_di_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_symbolic.html"},{"tags":"","title":"umfpack_zi_symbolic – MUSST","text":"public function umfpack_zi_symbolic(n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), intent(in), target :: Az (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_zi_symbolic~~CallsGraph proc~umfpack_zi_symbolic umfpack_zi_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_zi_symbolic->interface~c_umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_symbolic.html"},{"tags":"","title":"umfpack_ci_symbolic – MUSST","text":"public function umfpack_ci_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_ci_symbolic~~CallsGraph proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_symbolic~~CalledByGraph proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->proc~umfpack_ci_symbolic interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4csym_ip interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->interface~umf4zsym var panprocumfpack_ci_symbolicCalledByGraph = svgPanZoom('#procumfpack_ci_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_ci_symbolic.html"},{"tags":"","title":"umfpack_di_numeric – MUSST","text":"public function umfpack_di_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_di_numeric~~CallsGraph proc~umfpack_di_numeric umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_numeric~~CalledByGraph proc~umfpack_di_numeric umfpack_di_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->proc~umfpack_di_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~s_umfpack_di_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocumfpack_di_numericCalledByGraph = svgPanZoom('#procumfpack_di_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_numeric.html"},{"tags":"","title":"umfpack_zi_numeric – MUSST","text":"public function umfpack_zi_numeric(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) real(kind=r8), intent(in), target :: Az (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_zi_numeric~~CallsGraph proc~umfpack_zi_numeric umfpack_zi_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_zi_numeric->interface~c_umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_numeric.html"},{"tags":"","title":"umfpack_ci_numeric – MUSST","text":"public function umfpack_ci_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_ci_numeric~~CallsGraph proc~umfpack_ci_numeric umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_numeric~~CalledByGraph proc~umfpack_ci_numeric umfpack_ci_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num var panprocumfpack_ci_numericCalledByGraph = svgPanZoom('#procumfpack_ci_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_ci_numeric.html"},{"tags":"","title":"umfpack_di_solve – MUSST","text":"public function umfpack_di_solve(sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_di_solve~~CallsGraph proc~umfpack_di_solve umfpack_di_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_solve~~CalledByGraph proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve s_umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->proc~umfpack_di_solve proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~solution_solver solution_solver proc~solution_solver->proc~s_umfpack_di_solve proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve interface~umf4solr umf4solr interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->interface~umf4solr proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocumfpack_di_solveCalledByGraph = svgPanZoom('#procumfpack_di_solveCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_solve.html"},{"tags":"","title":"umfpack_zi_solve – MUSST","text":"public function umfpack_zi_solve(sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), intent(in), optional target :: Az (*) real(kind=r8), target :: Xx (*) real(kind=r8), target :: Xz (*) real(kind=r8), intent(in), target :: Bx (*) real(kind=r8), intent(in), target :: Bz (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_zi_solve~~CallsGraph proc~umfpack_zi_solve umfpack_zi_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_zi_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_solve.html"},{"tags":"","title":"umfpack_ci_solve – MUSST","text":"public function umfpack_ci_solve(sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) complex(kind=r8), intent(in), optional target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_ci_solve~~CallsGraph proc~umfpack_ci_solve umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_solve~~CalledByGraph proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->proc~umfpack_ci_solve interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~umf4csol_ip umf4csol_ip proc~umf4csol_ip->proc~s_umfpack_ci_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve interface~umf4csol umf4csol interface~umf4csol->proc~umf4csol_ip interface~umf4csol->interface~umf4csol proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~umf4zsol umf4zsol interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->interface~umf4zsol proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve interface~umf4sol umf4sol interface~umf4sol->proc~umf4csol_ip interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4solr umf4solr interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr var panprocumfpack_ci_solveCalledByGraph = svgPanZoom('#procumfpack_ci_solveCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_ci_solve.html"},{"tags":"","title":"umfpack_di_scale – MUSST","text":"public function umfpack_di_scale(X, B, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer Calls proc~~umfpack_di_scale~~CallsGraph proc~umfpack_di_scale umfpack_di_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_scale~~CalledByGraph proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->proc~umfpack_di_scale proc~s_umfpack_di_scale s_umfpack_di_scale proc~s_umfpack_di_scale->proc~umfpack_di_scale proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_di_scale proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_scale.html"},{"tags":"","title":"umfpack_zi_scale – MUSST","text":"public function umfpack_zi_scale(Xx, Xz, Bx, Bz, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: Xx (*) real(kind=r8), target :: Xz (*) real(kind=r8), intent(in), target :: Bx (*) real(kind=r8), intent(in), target :: Bz (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer Calls proc~~umfpack_zi_scale~~CallsGraph proc~umfpack_zi_scale umfpack_zi_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_zi_scale->interface~c_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_scale.html"},{"tags":"","title":"umfpack_ci_scale – MUSST","text":"public function umfpack_ci_scale(Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer Calls proc~~umfpack_ci_scale~~CallsGraph proc~umfpack_ci_scale umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_scale~~CalledByGraph proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale proc~s_umfpack_ci_scale s_umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_ci_scale proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_ci_scale.html"},{"tags":"","title":"umfpack_di_save_numeric – MUSST","text":"public function umfpack_di_save_numeric(Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_di_save_numeric~~CallsGraph proc~umfpack_di_save_numeric umfpack_di_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_save_numeric~~CalledByGraph proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~s_umfpack_di_save_numeric s_umfpack_di_save_numeric proc~s_umfpack_di_save_numeric->proc~umfpack_di_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_save_numeric.html"},{"tags":"","title":"umfpack_zi_save_numeric – MUSST","text":"public function umfpack_zi_save_numeric(Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_zi_save_numeric~~CallsGraph proc~umfpack_zi_save_numeric umfpack_zi_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_save_numeric~~CalledByGraph proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric s_umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric->proc~umfpack_zi_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_save_numeric.html"},{"tags":"","title":"umfpack_save_numeric – MUSST","text":"public function umfpack_save_numeric(Numeric, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer Calls proc~~umfpack_save_numeric~~CallsGraph proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_save_numeric~~CalledByGraph proc~umfpack_save_numeric umfpack_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_save_numeric.html"},{"tags":"","title":"umfpack_di_save_symbolic – MUSST","text":"public function umfpack_di_save_symbolic(Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_di_save_symbolic~~CallsGraph proc~umfpack_di_save_symbolic umfpack_di_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_save_symbolic~~CalledByGraph proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic s_umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic->proc~umfpack_di_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_save_symbolic.html"},{"tags":"","title":"umfpack_zi_save_symbolic – MUSST","text":"public function umfpack_zi_save_symbolic(Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_zi_save_symbolic~~CallsGraph proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_save_symbolic~~CalledByGraph proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic s_umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_save_symbolic.html"},{"tags":"","title":"umfpack_save_symbolic – MUSST","text":"public function umfpack_save_symbolic(Symbolic, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer Calls proc~~umfpack_save_symbolic~~CallsGraph proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_save_symbolic~~CalledByGraph proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_save_symbolic.html"},{"tags":"","title":"umfpack_di_load_numeric – MUSST","text":"public function umfpack_di_load_numeric(Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_di_load_numeric~~CallsGraph proc~umfpack_di_load_numeric umfpack_di_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_load_numeric~~CalledByGraph proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~s_umfpack_di_load_numeric s_umfpack_di_load_numeric proc~s_umfpack_di_load_numeric->proc~umfpack_di_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_load_numeric.html"},{"tags":"","title":"umfpack_zi_load_numeric – MUSST","text":"public function umfpack_zi_load_numeric(Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_zi_load_numeric~~CallsGraph proc~umfpack_zi_load_numeric umfpack_zi_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_load_numeric~~CalledByGraph proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric s_umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric->proc~umfpack_zi_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_load_numeric.html"},{"tags":"","title":"umfpack_load_numeric – MUSST","text":"public function umfpack_load_numeric(Numeric, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer Calls proc~~umfpack_load_numeric~~CallsGraph proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_load_numeric~~CalledByGraph proc~umfpack_load_numeric umfpack_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_load_numeric.html"},{"tags":"","title":"umfpack_di_load_symbolic – MUSST","text":"public function umfpack_di_load_symbolic(Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_di_load_symbolic~~CallsGraph proc~umfpack_di_load_symbolic umfpack_di_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_load_symbolic~~CalledByGraph proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic s_umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_load_symbolic.html"},{"tags":"","title":"umfpack_zi_load_symbolic – MUSST","text":"public function umfpack_zi_load_symbolic(Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_zi_load_symbolic~~CallsGraph proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_load_symbolic~~CalledByGraph proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic s_umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_load_symbolic.html"},{"tags":"","title":"umfpack_load_symbolic – MUSST","text":"public function umfpack_load_symbolic(Symbolic, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer Calls proc~~umfpack_load_symbolic~~CallsGraph proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_load_symbolic~~CalledByGraph proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_load_symbolic.html"},{"tags":"","title":"umfpack_di_operator_CSC – MUSST","text":"public function umfpack_di_operator_CSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_di_operator_csc~~CallsGraph proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_csc->proc~umfpack_di_free_symbolic proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_csc->proc~umfpack_di_free_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic var panprocumfpack_di_operator_cscCallsGraph = svgPanZoom('#procumfpack_di_operator_cscCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_operator_csc~~CalledByGraph proc~umfpack_di_operator_csc umfpack_di_operator_CSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_operator_csc.html"},{"tags":"","title":"umfpack_zi_operator_CSC – MUSST","text":"public function umfpack_zi_operator_CSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) Calls proc~~umfpack_zi_operator_csc~~CallsGraph proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumfpack_zi_operator_cscCallsGraph = svgPanZoom('#procumfpack_zi_operator_cscCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_operator_csc~~CalledByGraph proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_operator_csc.html"},{"tags":"","title":"umfpack_ci_operator_CSC – MUSST","text":"public function umfpack_ci_operator_CSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_ci_operator_csc~~CallsGraph proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_symbolic proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumfpack_ci_operator_cscCallsGraph = svgPanZoom('#procumfpack_ci_operator_cscCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_operator_csc~~CalledByGraph proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_ci_operator_csc.html"},{"tags":"","title":"umfpack_di_operator_CSR – MUSST","text":"public function umfpack_di_operator_CSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_di_operator_csr~~CallsGraph proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_csr->proc~umfpack_di_free_symbolic proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_csr->proc~umfpack_di_free_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic var panprocumfpack_di_operator_csrCallsGraph = svgPanZoom('#procumfpack_di_operator_csrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_operator_csr~~CalledByGraph proc~umfpack_di_operator_csr umfpack_di_operator_CSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_operator_csr.html"},{"tags":"","title":"umfpack_zi_operator_CSR – MUSST","text":"public function umfpack_zi_operator_CSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) Calls proc~~umfpack_zi_operator_csr~~CallsGraph proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumfpack_zi_operator_csrCallsGraph = svgPanZoom('#procumfpack_zi_operator_csrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_operator_csr~~CalledByGraph proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_operator_csr.html"},{"tags":"","title":"umfpack_ci_operator_CSR – MUSST","text":"public function umfpack_ci_operator_CSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_ci_operator_csr~~CallsGraph proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_symbolic proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumfpack_ci_operator_csrCallsGraph = svgPanZoom('#procumfpack_ci_operator_csrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_operator_csr~~CalledByGraph proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_ci_operator_csr.html"},{"tags":"","title":"umfpack_di_operator_pCSC – MUSST","text":"public function umfpack_di_operator_pCSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_di_operator_pcsc~~CallsGraph proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_symbolic proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic var panprocumfpack_di_operator_pcscCallsGraph = svgPanZoom('#procumfpack_di_operator_pcscCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_operator_pcsc~~CalledByGraph proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_operator_pcsc.html"},{"tags":"","title":"umfpack_zi_operator_pCSC – MUSST","text":"public function umfpack_zi_operator_pCSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) Calls proc~~umfpack_zi_operator_pcsc~~CallsGraph proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumfpack_zi_operator_pcscCallsGraph = svgPanZoom('#procumfpack_zi_operator_pcscCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_operator_pcsc~~CalledByGraph proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_operator_pcsc.html"},{"tags":"","title":"umfpack_ci_operator_pCSC – MUSST","text":"public function umfpack_ci_operator_pCSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_ci_operator_pcsc~~CallsGraph proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_symbolic proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumfpack_ci_operator_pcscCallsGraph = svgPanZoom('#procumfpack_ci_operator_pcscCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_operator_pcsc~~CalledByGraph proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_ci_operator_pcsc.html"},{"tags":"","title":"umfpack_di_operator_pCSR – MUSST","text":"public function umfpack_di_operator_pCSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_di_operator_pcsr~~CallsGraph proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_symbolic proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic var panprocumfpack_di_operator_pcsrCallsGraph = svgPanZoom('#procumfpack_di_operator_pcsrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_operator_pcsr~~CalledByGraph proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_operator_pcsr.html"},{"tags":"","title":"umfpack_zi_operator_pCSR – MUSST","text":"public function umfpack_zi_operator_pCSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) Calls proc~~umfpack_zi_operator_pcsr~~CallsGraph proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumfpack_zi_operator_pcsrCallsGraph = svgPanZoom('#procumfpack_zi_operator_pcsrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_operator_pcsr~~CalledByGraph proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_operator_pcsr.html"},{"tags":"","title":"umfpack_ci_operator_pCSR – MUSST","text":"public function umfpack_ci_operator_pCSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) Calls proc~~umfpack_ci_operator_pcsr~~CallsGraph proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_symbolic proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumfpack_ci_operator_pcsrCallsGraph = svgPanZoom('#procumfpack_ci_operator_pcsrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_ci_operator_pcsr~~CalledByGraph proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_ci_operator_pcsr.html"},{"tags":"","title":"make_CSC_di – MUSST","text":"public function make_CSC_di(Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_di ) Called by proc~~make_csc_di~~CalledByGraph proc~make_csc_di make_CSC_di interface~pcsc pCSC interface~pcsc->proc~make_csc_di Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/make_csc_di.html"},{"tags":"","title":"make_CSC_zi – MUSST","text":"public function make_CSC_zi(Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSC_zi ) Called by proc~~make_csc_zi~~CalledByGraph proc~make_csc_zi make_CSC_zi interface~pcsc pCSC interface~pcsc->proc~make_csc_zi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/make_csc_zi.html"},{"tags":"","title":"make_CSC_ci – MUSST","text":"public function make_CSC_ci(Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_ci ) Called by proc~~make_csc_ci~~CalledByGraph proc~make_csc_ci make_CSC_ci interface~pcsc pCSC interface~pcsc->proc~make_csc_ci Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/make_csc_ci.html"},{"tags":"","title":"make_CSR_di – MUSST","text":"public function make_CSR_di(Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_di ) Called by proc~~make_csr_di~~CalledByGraph proc~make_csr_di make_CSR_di interface~pcsr pCSR interface~pcsr->proc~make_csr_di Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/make_csr_di.html"},{"tags":"","title":"make_CSR_zi – MUSST","text":"public function make_CSR_zi(Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSR_zi ) Called by proc~~make_csr_zi~~CalledByGraph proc~make_csr_zi make_CSR_zi interface~pcsr pCSR interface~pcsr->proc~make_csr_zi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/make_csr_zi.html"},{"tags":"","title":"make_CSR_ci – MUSST","text":"public function make_CSR_ci(Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_ci ) Called by proc~~make_csr_ci~~CalledByGraph proc~make_csr_ci make_CSR_ci interface~pcsr pCSR interface~pcsr->proc~make_csr_ci Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/make_csr_ci.html"},{"tags":"","title":"make_Vec_zi – MUSST","text":"public function make_Vec_zi(bx, bz) result(result) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), target :: bx (:) real(kind=r8), intent(in), target :: bz (:) Return Value type( pVec_zi ) Called by proc~~make_vec_zi~~CalledByGraph proc~make_vec_zi make_Vec_zi interface~pvec pVec interface~pvec->proc~make_vec_zi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/make_vec_zi.html"},{"tags":"","title":"s_umfpack_di_symbolic – MUSST","text":"public subroutine s_umfpack_di_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_di_symbolic~~CallsGraph proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_di_symbolic~~CalledByGraph proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~analyse_solver analyse_solver proc~analyse_solver->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4csym_ip interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->interface~umf4zsym proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocs_umfpack_di_symbolicCalledByGraph = svgPanZoom('#procs_umfpack_di_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_di_symbolic.html"},{"tags":"","title":"s_umfpack_zi_symbolic – MUSST","text":"public subroutine s_umfpack_zi_symbolic(n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_zi_symbolic~~CallsGraph proc~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~umfpack_zi_symbolic umfpack_zi_symbolic proc~s_umfpack_zi_symbolic->interface~umfpack_zi_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_zi_symbolic.html"},{"tags":"","title":"s_umfpack_ci_symbolic – MUSST","text":"public subroutine s_umfpack_ci_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_ci_symbolic~~CallsGraph proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_ci_symbolic~~CalledByGraph proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4csym_ip interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->interface~umf4zsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_ci_symbolic.html"},{"tags":"","title":"s_umfpack_di_numeric – MUSST","text":"public subroutine s_umfpack_di_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_di_numeric~~CallsGraph proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_di_numeric~~CalledByGraph proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~s_umfpack_di_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocs_umfpack_di_numericCalledByGraph = svgPanZoom('#procs_umfpack_di_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_di_numeric.html"},{"tags":"","title":"s_umfpack_zi_numeric – MUSST","text":"public subroutine s_umfpack_zi_numeric(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_zi_numeric~~CallsGraph proc~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~umfpack_zi_numeric umfpack_zi_numeric proc~s_umfpack_zi_numeric->interface~umfpack_zi_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric proc~umfpack_ci_numeric umfpack_ci_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_zi_numeric.html"},{"tags":"","title":"s_umfpack_ci_numeric – MUSST","text":"public subroutine s_umfpack_ci_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_ci_numeric~~CallsGraph proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_ci_numeric~~CalledByGraph proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_ci_numeric.html"},{"tags":"","title":"s_umfpack_di_solve – MUSST","text":"public subroutine s_umfpack_di_solve(sys, Ap, Ai, Ax, X, B, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_di_solve~~CallsGraph proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_di_solve~~CalledByGraph proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~solution_solver solution_solver proc~solution_solver->proc~s_umfpack_di_solve proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve interface~umf4solr umf4solr interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->interface~umf4solr proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocs_umfpack_di_solveCalledByGraph = svgPanZoom('#procs_umfpack_di_solveCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_di_solve.html"},{"tags":"","title":"s_umfpack_zi_solve – MUSST","text":"public subroutine s_umfpack_zi_solve(sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(in), optional :: Az (*) real(kind=r8), intent(out) :: Xx (*) real(kind=r8), intent(out) :: Xz (*) real(kind=r8), intent(in) :: Bx (*) real(kind=r8), intent(in) :: Bz (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_zi_solve~~CallsGraph proc~s_umfpack_zi_solve s_umfpack_zi_solve interface~umfpack_zi_solve umfpack_zi_solve proc~s_umfpack_zi_solve->interface~umfpack_zi_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve proc~umfpack_ci_solve umfpack_ci_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_zi_solve.html"},{"tags":"","title":"s_umfpack_ci_solve – MUSST","text":"public subroutine s_umfpack_ci_solve(sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_ci_solve~~CallsGraph proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_ci_solve~~CalledByGraph proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~umf4csol_ip umf4csol_ip proc~umf4csol_ip->proc~s_umfpack_ci_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve interface~umf4csol umf4csol interface~umf4csol->proc~umf4csol_ip interface~umf4csol->interface~umf4csol proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~umf4zsol umf4zsol interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->interface~umf4zsol proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve interface~umf4sol umf4sol interface~umf4sol->proc~umf4csol_ip interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4solr umf4solr interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_ci_solve.html"},{"tags":"","title":"umfpack_di_free_symbolic – MUSST","text":"public subroutine umfpack_di_free_symbolic(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic Calls proc~~umfpack_di_free_symbolic~~CallsGraph proc~umfpack_di_free_symbolic umfpack_di_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_free_symbolic~~CalledByGraph proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic s_umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_symbolic proc~close_solver close_solver proc~close_solver->proc~umfpack_di_free_symbolic interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocumfpack_di_free_symbolicCalledByGraph = svgPanZoom('#procumfpack_di_free_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_free_symbolic.html"},{"tags":"","title":"umfpack_zi_free_symbolic – MUSST","text":"public subroutine umfpack_zi_free_symbolic(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic Calls proc~~umfpack_zi_free_symbolic~~CallsGraph proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_free_symbolic~~CalledByGraph proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic s_umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_symbolic interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_free_symbolic.html"},{"tags":"","title":"umfpack_free_symbolic – MUSST","text":"public subroutine umfpack_free_symbolic(Symbolic, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic character(len=*), optional :: version Calls proc~~umfpack_free_symbolic~~CallsGraph proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_free_symbolic~~CalledByGraph proc~umfpack_free_symbolic umfpack_free_symbolic interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_free_symbolic.html"},{"tags":"","title":"umfpack_di_free_numeric – MUSST","text":"public subroutine umfpack_di_free_numeric(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric Calls proc~~umfpack_di_free_numeric~~CallsGraph proc~umfpack_di_free_numeric umfpack_di_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_free_numeric~~CalledByGraph proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~umfpack_di_free_numeric proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~s_umfpack_di_free_numeric s_umfpack_di_free_numeric interface~s_umfpack_di_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~umfpack_di_free_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~umfpack_di_free_numeric proc~freefact_solver freefact_solver proc~freefact_solver->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_numeric proc~close_solver close_solver proc~close_solver->proc~umfpack_di_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~solve_syst->proc~freefact_solver proc~solve_syst->proc~close_solver interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocumfpack_di_free_numericCalledByGraph = svgPanZoom('#procumfpack_di_free_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_free_numeric.html"},{"tags":"","title":"umfpack_zi_free_numeric – MUSST","text":"public subroutine umfpack_zi_free_numeric(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric Calls proc~~umfpack_zi_free_numeric~~CallsGraph proc~umfpack_zi_free_numeric umfpack_zi_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_free_numeric~~CalledByGraph proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric s_umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_free_numeric.html"},{"tags":"","title":"umfpack_free_numeric – MUSST","text":"public subroutine umfpack_free_numeric(Numeric, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric character(len=*), optional :: version Calls proc~~umfpack_free_numeric~~CallsGraph proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_free_numeric~~CalledByGraph proc~umfpack_free_numeric umfpack_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_free_numeric.html"},{"tags":"","title":"s_umfpack_di_scale – MUSST","text":"public subroutine s_umfpack_di_scale(X, B, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status Calls proc~~s_umfpack_di_scale~~CallsGraph proc~s_umfpack_di_scale s_umfpack_di_scale proc~umfpack_di_scale umfpack_di_scale proc~s_umfpack_di_scale->proc~umfpack_di_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_di_scale~~CalledByGraph proc~s_umfpack_di_scale s_umfpack_di_scale interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_di_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_di_scale.html"},{"tags":"","title":"s_umfpack_zi_scale – MUSST","text":"public subroutine s_umfpack_zi_scale(Xx, Xz, Bx, Bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: Xx (*) real(kind=r8), intent(out) :: Xz (*) real(kind=r8), intent(in) :: Bx (*) real(kind=r8), intent(in) :: Bz (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status Calls proc~~s_umfpack_zi_scale~~CallsGraph proc~s_umfpack_zi_scale s_umfpack_zi_scale interface~umfpack_zi_scale umfpack_zi_scale proc~s_umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_zi_scale.html"},{"tags":"","title":"s_umfpack_ci_scale – MUSST","text":"public subroutine s_umfpack_ci_scale(Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status Calls proc~~s_umfpack_ci_scale~~CallsGraph proc~s_umfpack_ci_scale s_umfpack_ci_scale proc~umfpack_ci_scale umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~s_umfpack_ci_scale~~CalledByGraph proc~s_umfpack_ci_scale s_umfpack_ci_scale interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_ci_scale interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_ci_scale.html"},{"tags":"","title":"umfpack_di_defaults – MUSST","text":"public subroutine umfpack_di_defaults(Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umfpack_di_defaults~~CallsGraph proc~umfpack_di_defaults umfpack_di_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_defaults~~CalledByGraph proc~umfpack_di_defaults umfpack_di_defaults interface~s_umfpack_di_defaults s_umfpack_di_defaults interface~s_umfpack_di_defaults->proc~umfpack_di_defaults proc~umfpack_defaults umfpack_defaults proc~umfpack_defaults->proc~umfpack_di_defaults proc~init_solver init_solver proc~init_solver->proc~umfpack_di_defaults proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocumfpack_di_defaultsCalledByGraph = svgPanZoom('#procumfpack_di_defaultsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_defaults.html"},{"tags":"","title":"umfpack_zi_defaults – MUSST","text":"public subroutine umfpack_zi_defaults(Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umfpack_zi_defaults~~CallsGraph proc~umfpack_zi_defaults umfpack_zi_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_defaults~~CalledByGraph proc~umfpack_zi_defaults umfpack_zi_defaults interface~s_umfpack_zi_defaults s_umfpack_zi_defaults interface~s_umfpack_zi_defaults->proc~umfpack_zi_defaults proc~umfpack_defaults umfpack_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_defaults.html"},{"tags":"","title":"umfpack_defaults – MUSST","text":"public subroutine umfpack_defaults(Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version Calls proc~~umfpack_defaults~~CallsGraph proc~umfpack_defaults umfpack_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_defaults~~CalledByGraph proc~umfpack_defaults umfpack_defaults proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_defaults.html"},{"tags":"","title":"umfpack_di_report_control – MUSST","text":"public subroutine umfpack_di_report_control(Control) Uses iso_fortran_env proc~~umfpack_di_report_control~~UsesGraph proc~umfpack_di_report_control umfpack_di_report_control iso_fortran_env iso_fortran_env proc~umfpack_di_report_control->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umfpack_di_report_control~~CallsGraph proc~umfpack_di_report_control umfpack_di_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_report_control~~CalledByGraph proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control umfpack_report_control proc~umfpack_report_control->proc~umfpack_di_report_control interface~s_umfpack_di_report_control s_umfpack_di_report_control interface~s_umfpack_di_report_control->proc~umfpack_di_report_control proc~init_solver init_solver proc~init_solver->proc~umfpack_di_report_control proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocumfpack_di_report_controlCalledByGraph = svgPanZoom('#procumfpack_di_report_controlCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_report_control.html"},{"tags":"","title":"umfpack_zi_report_control – MUSST","text":"public subroutine umfpack_zi_report_control(Control) Uses iso_fortran_env proc~~umfpack_zi_report_control~~UsesGraph proc~umfpack_zi_report_control umfpack_zi_report_control iso_fortran_env iso_fortran_env proc~umfpack_zi_report_control->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umfpack_zi_report_control~~CallsGraph proc~umfpack_zi_report_control umfpack_zi_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_report_control~~CalledByGraph proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control umfpack_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control interface~s_umfpack_zi_report_control s_umfpack_zi_report_control interface~s_umfpack_zi_report_control->proc~umfpack_zi_report_control proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_report_control.html"},{"tags":"","title":"umfpack_report_control – MUSST","text":"public subroutine umfpack_report_control(Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version Calls proc~~umfpack_report_control~~CallsGraph proc~umfpack_report_control umfpack_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_report_control~~CalledByGraph proc~umfpack_report_control umfpack_report_control proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_report_control.html"},{"tags":"","title":"umfpack_di_report_info – MUSST","text":"public subroutine umfpack_di_report_info(Control, Info) Uses iso_fortran_env proc~~umfpack_di_report_info~~UsesGraph proc~umfpack_di_report_info umfpack_di_report_info iso_fortran_env iso_fortran_env proc~umfpack_di_report_info->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) Calls proc~~umfpack_di_report_info~~CallsGraph proc~umfpack_di_report_info umfpack_di_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_di_report_info~~CalledByGraph proc~umfpack_di_report_info umfpack_di_report_info interface~s_umfpack_di_report_info s_umfpack_di_report_info interface~s_umfpack_di_report_info->proc~umfpack_di_report_info proc~umfpack_report_info umfpack_report_info proc~umfpack_report_info->proc~umfpack_di_report_info proc~close_solver close_solver proc~close_solver->proc~umfpack_di_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var panprocumfpack_di_report_infoCalledByGraph = svgPanZoom('#procumfpack_di_report_infoCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_di_report_info.html"},{"tags":"","title":"umfpack_zi_report_info – MUSST","text":"public subroutine umfpack_zi_report_info(Control, Info) Uses iso_fortran_env proc~~umfpack_zi_report_info~~UsesGraph proc~umfpack_zi_report_info umfpack_zi_report_info iso_fortran_env iso_fortran_env proc~umfpack_zi_report_info->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) Calls proc~~umfpack_zi_report_info~~CallsGraph proc~umfpack_zi_report_info umfpack_zi_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_zi_report_info~~CalledByGraph proc~umfpack_zi_report_info umfpack_zi_report_info interface~s_umfpack_zi_report_info s_umfpack_zi_report_info interface~s_umfpack_zi_report_info->proc~umfpack_zi_report_info proc~umfpack_report_info umfpack_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_zi_report_info.html"},{"tags":"","title":"umfpack_report_info – MUSST","text":"public subroutine umfpack_report_info(Control, Info, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) character(len=*), optional :: version Calls proc~~umfpack_report_info~~CallsGraph proc~umfpack_report_info umfpack_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umfpack_report_info~~CalledByGraph proc~umfpack_report_info umfpack_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umfpack_report_info.html"},{"tags":"","title":"s_umfpack_di_save_numeric – MUSST","text":"public subroutine s_umfpack_di_save_numeric(Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_di_save_numeric~~CallsGraph proc~s_umfpack_di_save_numeric s_umfpack_di_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~s_umfpack_di_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_di_save_numeric.html"},{"tags":"","title":"s_umfpack_zi_save_numeric – MUSST","text":"public subroutine s_umfpack_zi_save_numeric(Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_zi_save_numeric~~CallsGraph proc~s_umfpack_zi_save_numeric s_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric->proc~umfpack_zi_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_zi_save_numeric.html"},{"tags":"","title":"s_umfpack_save_numeric – MUSST","text":"public subroutine s_umfpack_save_numeric(Numeric, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version Calls proc~~s_umfpack_save_numeric~~CallsGraph proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric var panprocs_umfpack_save_numericCallsGraph = svgPanZoom('#procs_umfpack_save_numericCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_save_numeric.html"},{"tags":"","title":"s_umfpack_di_save_symbolic – MUSST","text":"public subroutine s_umfpack_di_save_symbolic(Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_di_save_symbolic~~CallsGraph proc~s_umfpack_di_save_symbolic s_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic->proc~umfpack_di_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_di_save_symbolic.html"},{"tags":"","title":"s_umfpack_zi_save_symbolic – MUSST","text":"public subroutine s_umfpack_zi_save_symbolic(Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_zi_save_symbolic~~CallsGraph proc~s_umfpack_zi_save_symbolic s_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_zi_save_symbolic.html"},{"tags":"","title":"s_umfpack_save_symbolic – MUSST","text":"public subroutine s_umfpack_save_symbolic(Symbolic, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version Calls proc~~s_umfpack_save_symbolic~~CallsGraph proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic var panprocs_umfpack_save_symbolicCallsGraph = svgPanZoom('#procs_umfpack_save_symbolicCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_save_symbolic.html"},{"tags":"","title":"s_umfpack_di_load_numeric – MUSST","text":"public subroutine s_umfpack_di_load_numeric(Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_di_load_numeric~~CallsGraph proc~s_umfpack_di_load_numeric s_umfpack_di_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~s_umfpack_di_load_numeric->proc~umfpack_di_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_di_load_numeric.html"},{"tags":"","title":"s_umfpack_zi_load_numeric – MUSST","text":"public subroutine s_umfpack_zi_load_numeric(Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_zi_load_numeric~~CallsGraph proc~s_umfpack_zi_load_numeric s_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_zi_load_numeric.html"},{"tags":"","title":"s_umfpack_load_numeric – MUSST","text":"public subroutine s_umfpack_load_numeric(Numeric, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version Calls proc~~s_umfpack_load_numeric~~CallsGraph proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric var panprocs_umfpack_load_numericCallsGraph = svgPanZoom('#procs_umfpack_load_numericCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_load_numeric.html"},{"tags":"","title":"s_umfpack_di_load_symbolic – MUSST","text":"public subroutine s_umfpack_di_load_symbolic(Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_di_load_symbolic~~CallsGraph proc~s_umfpack_di_load_symbolic s_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic->proc~umfpack_di_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_di_load_symbolic.html"},{"tags":"","title":"s_umfpack_zi_load_symbolic – MUSST","text":"public subroutine s_umfpack_zi_load_symbolic(Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_zi_load_symbolic~~CallsGraph proc~s_umfpack_zi_load_symbolic s_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_zi_load_symbolic.html"},{"tags":"","title":"s_umfpack_load_symbolic – MUSST","text":"public subroutine s_umfpack_load_symbolic(Symbolic, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version Calls proc~~s_umfpack_load_symbolic~~CallsGraph proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic var panprocs_umfpack_load_symbolicCallsGraph = svgPanZoom('#procs_umfpack_load_symbolicCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/s_umfpack_load_symbolic.html"},{"tags":"","title":"umf4def – MUSST","text":"public subroutine umf4def(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4def~~CallsGraph proc~umf4def umf4def proc~umfpack_defaults umfpack_defaults proc~umf4def->proc~umfpack_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4def.html"},{"tags":"","title":"umf4zdef – MUSST","text":"public subroutine umf4zdef(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4zdef~~CallsGraph proc~umf4zdef umf4zdef proc~umfpack_defaults umfpack_defaults proc~umf4zdef->proc~umfpack_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zdef.html"},{"tags":"","title":"umf4cdef – MUSST","text":"public subroutine umf4cdef(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4cdef~~CallsGraph proc~umf4cdef umf4cdef proc~umfpack_defaults umfpack_defaults proc~umf4cdef->proc~umfpack_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4cdef.html"},{"tags":"","title":"umf4pcon – MUSST","text":"public subroutine umf4pcon(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4pcon~~CallsGraph proc~umf4pcon umf4pcon proc~umfpack_report_control umfpack_report_control proc~umf4pcon->proc~umfpack_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4pcon.html"},{"tags":"","title":"umf4zpcon – MUSST","text":"public subroutine umf4zpcon(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4zpcon~~CallsGraph proc~umf4zpcon umf4zpcon proc~umfpack_report_control umfpack_report_control proc~umf4zpcon->proc~umfpack_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zpcon.html"},{"tags":"","title":"umf4cpcon – MUSST","text":"public subroutine umf4cpcon(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4cpcon~~CallsGraph proc~umf4cpcon umf4cpcon proc~umfpack_report_control umfpack_report_control proc~umf4cpcon->proc~umfpack_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4cpcon.html"},{"tags":"","title":"umf4sym – MUSST","text":"public subroutine umf4sym(m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4sym~~CallsGraph proc~umf4sym umf4sym interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4sym->interface~s_umfpack_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic var panprocumf4symCallsGraph = svgPanZoom('#procumf4symCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4sym.html"},{"tags":"","title":"umf4zsym – MUSST","text":"public subroutine umf4zsym(m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsym~~CallsGraph proc~umf4zsym umf4zsym interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4zsym->interface~s_umfpack_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic var panprocumf4zsymCallsGraph = svgPanZoom('#procumf4zsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zsym.html"},{"tags":"","title":"umf4csym – MUSST","text":"public subroutine umf4csym(m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csym~~CallsGraph proc~umf4csym umf4csym interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4csym->interface~s_umfpack_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic var panprocumf4csymCallsGraph = svgPanZoom('#procumf4csymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4csym.html"},{"tags":"","title":"umf4sym_ip – MUSST","text":"public subroutine umf4sym_ip(m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4sym_ip~~CallsGraph proc~umf4sym_ip umf4sym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4sym_ip->interface~s_umfpack_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic var panprocumf4sym_ipCallsGraph = svgPanZoom('#procumf4sym_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4sym_ip~~CalledByGraph proc~umf4sym_ip umf4sym_ip interface~umf4sym umf4sym interface~umf4sym->proc~umf4sym_ip interface~umf4sym->interface~umf4sym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4sym_ip.html"},{"tags":"","title":"umf4zsym_ip – MUSST","text":"public subroutine umf4zsym_ip(m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsym_ip~~CallsGraph proc~umf4zsym_ip umf4zsym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic var panprocumf4zsym_ipCallsGraph = svgPanZoom('#procumf4zsym_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zsym_ip~~CalledByGraph proc~umf4zsym_ip umf4zsym_ip interface~umf4sym umf4sym interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4zsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zsym_ip.html"},{"tags":"","title":"umf4csym_ip – MUSST","text":"public subroutine umf4csym_ip(m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csym_ip~~CallsGraph proc~umf4csym_ip umf4csym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4csym_ip->interface~s_umfpack_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic var panprocumf4csym_ipCallsGraph = svgPanZoom('#procumf4csym_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4csym_ip~~CalledByGraph proc~umf4csym_ip umf4csym_ip interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->interface~umf4zsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4csym_ip.html"},{"tags":"","title":"umf4num – MUSST","text":"public subroutine umf4num(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4num~~CallsGraph proc~umf4num umf4num interface~s_umfpack_numeric s_umfpack_numeric proc~umf4num->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumf4numCallsGraph = svgPanZoom('#procumf4numCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4num.html"},{"tags":"","title":"umf4znum – MUSST","text":"public subroutine umf4znum(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4znum~~CallsGraph proc~umf4znum umf4znum interface~s_umfpack_numeric s_umfpack_numeric proc~umf4znum->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumf4znumCallsGraph = svgPanZoom('#procumf4znumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4znum.html"},{"tags":"","title":"umf4cnum – MUSST","text":"public subroutine umf4cnum(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4cnum~~CallsGraph proc~umf4cnum umf4cnum interface~s_umfpack_numeric s_umfpack_numeric proc~umf4cnum->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumf4cnumCallsGraph = svgPanZoom('#procumf4cnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4cnum.html"},{"tags":"","title":"umf4num_ip – MUSST","text":"public subroutine umf4num_ip(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4num_ip~~CallsGraph proc~umf4num_ip umf4num_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4num_ip->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumf4num_ipCallsGraph = svgPanZoom('#procumf4num_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4num_ip~~CalledByGraph proc~umf4num_ip umf4num_ip interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->interface~umf4num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4num_ip.html"},{"tags":"","title":"umf4znum_ip – MUSST","text":"public subroutine umf4znum_ip(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4znum_ip~~CallsGraph proc~umf4znum_ip umf4znum_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4znum_ip->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumf4znum_ipCallsGraph = svgPanZoom('#procumf4znum_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4znum_ip~~CalledByGraph proc~umf4znum_ip umf4znum_ip interface~umf4znum umf4znum interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum interface~umf4num umf4num interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4znum_ip.html"},{"tags":"","title":"umf4cnum_ip – MUSST","text":"public subroutine umf4cnum_ip(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4cnum_ip~~CallsGraph proc~umf4cnum_ip umf4cnum_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4cnum_ip->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var panprocumf4cnum_ipCallsGraph = svgPanZoom('#procumf4cnum_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4cnum_ip~~CalledByGraph proc~umf4cnum_ip umf4cnum_ip interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->interface~umf4znum interface~umf4num umf4num interface~umf4num->proc~umf4cnum_ip interface~umf4num->interface~umf4num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4cnum_ip.html"},{"tags":"","title":"umf4solr – MUSST","text":"public subroutine umf4solr(sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4solr~~CallsGraph proc~umf4solr umf4solr interface~s_umfpack_solve s_umfpack_solve proc~umf4solr->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4solrCallsGraph = svgPanZoom('#procumf4solrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4solr.html"},{"tags":"","title":"umf4zsolr – MUSST","text":"public subroutine umf4zsolr(sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsolr~~CallsGraph proc~umf4zsolr umf4zsolr interface~s_umfpack_solve s_umfpack_solve proc~umf4zsolr->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4zsolrCallsGraph = svgPanZoom('#procumf4zsolrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zsolr.html"},{"tags":"","title":"umf4csolr – MUSST","text":"public subroutine umf4csolr(sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csolr~~CallsGraph proc~umf4csolr umf4csolr interface~s_umfpack_solve s_umfpack_solve proc~umf4csolr->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4csolrCallsGraph = svgPanZoom('#procumf4csolrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4csolr.html"},{"tags":"","title":"umf4solr_ip – MUSST","text":"public subroutine umf4solr_ip(sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4solr_ip~~CallsGraph proc~umf4solr_ip umf4solr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4solr_ip->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4solr_ipCallsGraph = svgPanZoom('#procumf4solr_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4solr_ip~~CalledByGraph proc~umf4solr_ip umf4solr_ip interface~umf4solr umf4solr interface~umf4solr->proc~umf4solr_ip interface~umf4solr->interface~umf4solr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4solr_ip.html"},{"tags":"","title":"umf4zsolr_ip – MUSST","text":"public subroutine umf4zsolr_ip(sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsolr_ip~~CallsGraph proc~umf4zsolr_ip umf4zsolr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4zsolr_ip->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4zsolr_ipCallsGraph = svgPanZoom('#procumf4zsolr_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zsolr_ip~~CalledByGraph proc~umf4zsolr_ip umf4zsolr_ip interface~umf4solr umf4solr interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->interface~umf4zsolr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zsolr_ip.html"},{"tags":"","title":"umf4csolr_ip – MUSST","text":"public subroutine umf4csolr_ip(sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csolr_ip~~CallsGraph proc~umf4csolr_ip umf4csolr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4csolr_ip->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4csolr_ipCallsGraph = svgPanZoom('#procumf4csolr_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4csolr_ip~~CalledByGraph proc~umf4csolr_ip umf4csolr_ip interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4solr umf4solr interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4csolr_ip.html"},{"tags":"","title":"umf4sol – MUSST","text":"public subroutine umf4sol(sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4sol~~CallsGraph proc~umf4sol umf4sol interface~s_umfpack_solve s_umfpack_solve proc~umf4sol->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4solCallsGraph = svgPanZoom('#procumf4solCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4sol.html"},{"tags":"","title":"umf4zsol – MUSST","text":"public subroutine umf4zsol(sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsol~~CallsGraph proc~umf4zsol umf4zsol interface~s_umfpack_solve s_umfpack_solve proc~umf4zsol->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4zsolCallsGraph = svgPanZoom('#procumf4zsolCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zsol.html"},{"tags":"","title":"umf4csol – MUSST","text":"public subroutine umf4csol(sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csol~~CallsGraph proc~umf4csol umf4csol interface~s_umfpack_solve s_umfpack_solve proc~umf4csol->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4csolCallsGraph = svgPanZoom('#procumf4csolCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4csol.html"},{"tags":"","title":"umf4sol_ip – MUSST","text":"public subroutine umf4sol_ip(sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4sol_ip~~CallsGraph proc~umf4sol_ip umf4sol_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4sol_ip->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4sol_ipCallsGraph = svgPanZoom('#procumf4sol_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4sol_ip~~CalledByGraph proc~umf4sol_ip umf4sol_ip interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4sol_ip.html"},{"tags":"","title":"umf4zsol_ip – MUSST","text":"public subroutine umf4zsol_ip(sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsol_ip~~CallsGraph proc~umf4zsol_ip umf4zsol_ip interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umf4zsol_ip->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var panprocumf4zsol_ipCallsGraph = svgPanZoom('#procumf4zsol_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zsol_ip~~CalledByGraph proc~umf4zsol_ip umf4zsol_ip interface~umf4zsol umf4zsol interface~umf4zsol->proc~umf4zsol_ip interface~umf4zsol->interface~umf4zsol interface~umf4sol umf4sol interface~umf4sol->proc~umf4zsol_ip interface~umf4sol->interface~umf4sol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zsol_ip.html"},{"tags":"","title":"umf4csol_ip – MUSST","text":"public subroutine umf4csol_ip(sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csol_ip~~CallsGraph proc~umf4csol_ip umf4csol_ip proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umf4csol_ip->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4csol_ip~~CalledByGraph proc~umf4csol_ip umf4csol_ip interface~umf4csol umf4csol interface~umf4csol->proc~umf4csol_ip interface~umf4csol->interface~umf4csol interface~umf4zsol umf4zsol interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->interface~umf4zsol interface~umf4sol umf4sol interface~umf4sol->proc~umf4csol_ip interface~umf4sol->interface~umf4sol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4csol_ip.html"},{"tags":"","title":"umf4scal – MUSST","text":"public subroutine umf4scal(x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric integer, intent(out) :: status Calls proc~~umf4scal~~CallsGraph proc~umf4scal umf4scal interface~umfpack_scale_function umfpack_scale_function proc~umf4scal->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale var panprocumf4scalCallsGraph = svgPanZoom('#procumf4scalCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4scal.html"},{"tags":"","title":"umf4zscal – MUSST","text":"public subroutine umf4zscal(x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric integer, intent(out) :: status Calls proc~~umf4zscal~~CallsGraph proc~umf4zscal umf4zscal interface~umfpack_scale_function umfpack_scale_function proc~umf4zscal->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale var panprocumf4zscalCallsGraph = svgPanZoom('#procumf4zscalCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zscal.html"},{"tags":"","title":"umf4cscal – MUSST","text":"public subroutine umf4cscal(x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric integer, intent(out) :: status Calls proc~~umf4cscal~~CallsGraph proc~umf4cscal umf4cscal interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale var panprocumf4cscalCallsGraph = svgPanZoom('#procumf4cscalCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4cscal.html"},{"tags":"","title":"umf4scal_ip – MUSST","text":"public subroutine umf4scal_ip(x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status Calls proc~~umf4scal_ip~~CallsGraph proc~umf4scal_ip umf4scal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4scal_ip->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale var panprocumf4scal_ipCallsGraph = svgPanZoom('#procumf4scal_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4scal_ip~~CalledByGraph proc~umf4scal_ip umf4scal_ip interface~umf4scal umf4scal interface~umf4scal->proc~umf4scal_ip interface~umf4scal->interface~umf4scal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4scal_ip.html"},{"tags":"","title":"umf4zscal_ip – MUSST","text":"public subroutine umf4zscal_ip(x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status Calls proc~~umf4zscal_ip~~CallsGraph proc~umf4zscal_ip umf4zscal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4zscal_ip->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale var panprocumf4zscal_ipCallsGraph = svgPanZoom('#procumf4zscal_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zscal_ip~~CalledByGraph proc~umf4zscal_ip umf4zscal_ip interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->interface~umf4scal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zscal_ip.html"},{"tags":"","title":"umf4cscal_ip – MUSST","text":"public subroutine umf4cscal_ip(x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status Calls proc~~umf4cscal_ip~~CallsGraph proc~umf4cscal_ip umf4cscal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal_ip->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale var panprocumf4cscal_ipCallsGraph = svgPanZoom('#procumf4cscal_ipCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4cscal_ip~~CalledByGraph proc~umf4cscal_ip umf4cscal_ip interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4cscal_ip.html"},{"tags":"","title":"umf4pinf – MUSST","text":"public subroutine umf4pinf(Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4pinf~~CallsGraph proc~umf4pinf umf4pinf proc~umfpack_report_info umfpack_report_info proc~umf4pinf->proc~umfpack_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4pinf.html"},{"tags":"","title":"umf4zpinf – MUSST","text":"public subroutine umf4zpinf(Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zpinf~~CallsGraph proc~umf4zpinf umf4zpinf proc~umfpack_report_info umfpack_report_info proc~umf4zpinf->proc~umfpack_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zpinf.html"},{"tags":"","title":"umf4cpinf – MUSST","text":"public subroutine umf4cpinf(Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4cpinf~~CallsGraph proc~umf4cpinf umf4cpinf proc~umfpack_report_info umfpack_report_info proc~umf4cpinf->proc~umfpack_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4cpinf.html"},{"tags":"","title":"umf4fnum – MUSST","text":"public subroutine umf4fnum(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric Calls proc~~umf4fnum~~CallsGraph proc~umf4fnum umf4fnum proc~umfpack_free_numeric umfpack_free_numeric proc~umf4fnum->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4fnum.html"},{"tags":"","title":"umf4zfnum – MUSST","text":"public subroutine umf4zfnum(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric Calls proc~~umf4zfnum~~CallsGraph proc~umf4zfnum umf4zfnum proc~umfpack_free_numeric umfpack_free_numeric proc~umf4zfnum->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zfnum.html"},{"tags":"","title":"umf4cfnum – MUSST","text":"public subroutine umf4cfnum(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric Calls proc~~umf4cfnum~~CallsGraph proc~umf4cfnum umf4cfnum proc~umfpack_free_numeric umfpack_free_numeric proc~umf4cfnum->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4cfnum.html"},{"tags":"","title":"umf4fnum_ip – MUSST","text":"public subroutine umf4fnum_ip(Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric Calls proc~~umf4fnum_ip~~CallsGraph proc~umf4fnum_ip umf4fnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4fnum_ip~~CalledByGraph proc~umf4fnum_ip umf4fnum_ip interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4fnum_ip.html"},{"tags":"","title":"umf4zfnum_ip – MUSST","text":"public subroutine umf4zfnum_ip(Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric Calls proc~~umf4zfnum_ip~~CallsGraph proc~umf4zfnum_ip umf4zfnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4zfnum_ip->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zfnum_ip~~CalledByGraph proc~umf4zfnum_ip umf4zfnum_ip interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zfnum_ip.html"},{"tags":"","title":"umf4cfnum_ip – MUSST","text":"public subroutine umf4cfnum_ip(Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric Calls proc~~umf4cfnum_ip~~CallsGraph proc~umf4cfnum_ip umf4cfnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4cfnum_ip~~CalledByGraph proc~umf4cfnum_ip umf4cfnum_ip interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4cfnum_ip.html"},{"tags":"","title":"umf4fsym – MUSST","text":"public subroutine umf4fsym(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic Calls proc~~umf4fsym~~CallsGraph proc~umf4fsym umf4fsym proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4fsym->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4fsym.html"},{"tags":"","title":"umf4zfsym – MUSST","text":"public subroutine umf4zfsym(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic Calls proc~~umf4zfsym~~CallsGraph proc~umf4zfsym umf4zfsym proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4zfsym->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zfsym.html"},{"tags":"","title":"umf4cfsym – MUSST","text":"public subroutine umf4cfsym(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic Calls proc~~umf4cfsym~~CallsGraph proc~umf4cfsym umf4cfsym proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4cfsym->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4cfsym.html"},{"tags":"","title":"umf4fsym_ip – MUSST","text":"public subroutine umf4fsym_ip(Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic Calls proc~~umf4fsym_ip~~CallsGraph proc~umf4fsym_ip umf4fsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4fsym_ip->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4fsym_ip~~CalledByGraph proc~umf4fsym_ip umf4fsym_ip interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4fsym_ip.html"},{"tags":"","title":"umf4zfsym_ip – MUSST","text":"public subroutine umf4zfsym_ip(Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic Calls proc~~umf4zfsym_ip~~CallsGraph proc~umf4zfsym_ip umf4zfsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4zfsym_ip->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zfsym_ip~~CalledByGraph proc~umf4zfsym_ip umf4zfsym_ip interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zfsym_ip.html"},{"tags":"","title":"umf4cfsym_ip – MUSST","text":"public subroutine umf4cfsym_ip(Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic Calls proc~~umf4cfsym_ip~~CallsGraph proc~umf4cfsym_ip umf4cfsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4cfsym_ip~~CalledByGraph proc~umf4cfsym_ip umf4cfsym_ip interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4cfsym_ip.html"},{"tags":"","title":"umf4snum – MUSST","text":"public subroutine umf4snum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4snum~~CallsGraph proc~umf4snum umf4snum proc~umfpack_save_numeric umfpack_save_numeric proc~umf4snum->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4snum.html"},{"tags":"","title":"umf4zsnum – MUSST","text":"public subroutine umf4zsnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zsnum~~CallsGraph proc~umf4zsnum umf4zsnum proc~umfpack_save_numeric umfpack_save_numeric proc~umf4zsnum->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zsnum.html"},{"tags":"","title":"umf4csnum – MUSST","text":"public subroutine umf4csnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4csnum~~CallsGraph proc~umf4csnum umf4csnum proc~umfpack_save_numeric umfpack_save_numeric proc~umf4csnum->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4csnum.html"},{"tags":"","title":"umf4snum_ip – MUSST","text":"public subroutine umf4snum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4snum_ip~~CallsGraph proc~umf4snum_ip umf4snum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4snum_ip->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4snum_ip~~CalledByGraph proc~umf4snum_ip umf4snum_ip interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4snum_ip.html"},{"tags":"","title":"umf4zsnum_ip – MUSST","text":"public subroutine umf4zsnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zsnum_ip~~CallsGraph proc~umf4zsnum_ip umf4zsnum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zsnum_ip~~CalledByGraph proc~umf4zsnum_ip umf4zsnum_ip interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zsnum_ip.html"},{"tags":"","title":"umf4csnum_ip – MUSST","text":"public subroutine umf4csnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4csnum_ip~~CallsGraph proc~umf4csnum_ip umf4csnum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4csnum_ip~~CalledByGraph proc~umf4csnum_ip umf4csnum_ip interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4csnum_ip.html"},{"tags":"","title":"umf4ssym – MUSST","text":"public subroutine umf4ssym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4ssym~~CallsGraph proc~umf4ssym umf4ssym proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4ssym->proc~umfpack_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4ssym.html"},{"tags":"","title":"umf4zssym – MUSST","text":"public subroutine umf4zssym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zssym~~CallsGraph proc~umf4zssym umf4zssym proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4zssym->proc~umfpack_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zssym.html"},{"tags":"","title":"umf4cssym – MUSST","text":"public subroutine umf4cssym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4cssym~~CallsGraph proc~umf4cssym umf4cssym proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4cssym->proc~umfpack_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4cssym.html"},{"tags":"","title":"umf4ssym_ip – MUSST","text":"public subroutine umf4ssym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4ssym_ip~~CallsGraph proc~umf4ssym_ip umf4ssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4ssym_ip->proc~umfpack_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4ssym_ip~~CalledByGraph proc~umf4ssym_ip umf4ssym_ip interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4ssym_ip.html"},{"tags":"","title":"umf4zssym_ip – MUSST","text":"public subroutine umf4zssym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zssym_ip~~CallsGraph proc~umf4zssym_ip umf4zssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zssym_ip~~CalledByGraph proc~umf4zssym_ip umf4zssym_ip interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zssym_ip.html"},{"tags":"","title":"umf4cssym_ip – MUSST","text":"public subroutine umf4cssym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4cssym_ip~~CallsGraph proc~umf4cssym_ip umf4cssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4cssym_ip~~CalledByGraph proc~umf4cssym_ip umf4cssym_ip interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4cssym_ip.html"},{"tags":"","title":"umf4lnum – MUSST","text":"public subroutine umf4lnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4lnum~~CallsGraph proc~umf4lnum umf4lnum proc~umfpack_load_numeric umfpack_load_numeric proc~umf4lnum->proc~umfpack_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4lnum.html"},{"tags":"","title":"umf4zlnum – MUSST","text":"public subroutine umf4zlnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zlnum~~CallsGraph proc~umf4zlnum umf4zlnum proc~umfpack_load_numeric umfpack_load_numeric proc~umf4zlnum->proc~umfpack_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zlnum.html"},{"tags":"","title":"umf4clnum – MUSST","text":"public subroutine umf4clnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4clnum~~CallsGraph proc~umf4clnum umf4clnum proc~umfpack_load_numeric umfpack_load_numeric proc~umf4clnum->proc~umfpack_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4clnum.html"},{"tags":"","title":"umf4lnum_ip – MUSST","text":"public subroutine umf4lnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4lnum_ip~~CallsGraph proc~umf4lnum_ip umf4lnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4lnum_ip~~CalledByGraph proc~umf4lnum_ip umf4lnum_ip interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4lnum_ip.html"},{"tags":"","title":"umf4zlnum_ip – MUSST","text":"public subroutine umf4zlnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zlnum_ip~~CallsGraph proc~umf4zlnum_ip umf4zlnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zlnum_ip~~CalledByGraph proc~umf4zlnum_ip umf4zlnum_ip interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zlnum_ip.html"},{"tags":"","title":"umf4clnum_ip – MUSST","text":"public subroutine umf4clnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4clnum_ip~~CallsGraph proc~umf4clnum_ip umf4clnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4clnum_ip~~CalledByGraph proc~umf4clnum_ip umf4clnum_ip interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4clnum_ip.html"},{"tags":"","title":"umf4lsym – MUSST","text":"public subroutine umf4lsym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4lsym~~CallsGraph proc~umf4lsym umf4lsym proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4lsym->proc~umfpack_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4lsym.html"},{"tags":"","title":"umf4zlsym – MUSST","text":"public subroutine umf4zlsym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zlsym~~CallsGraph proc~umf4zlsym umf4zlsym proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4zlsym->proc~umfpack_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zlsym.html"},{"tags":"","title":"umf4clsym – MUSST","text":"public subroutine umf4clsym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4clsym~~CallsGraph proc~umf4clsym umf4clsym proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4clsym->proc~umfpack_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4clsym.html"},{"tags":"","title":"umf4lsym_ip – MUSST","text":"public subroutine umf4lsym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4lsym_ip~~CallsGraph proc~umf4lsym_ip umf4lsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4lsym_ip~~CalledByGraph proc~umf4lsym_ip umf4lsym_ip interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4lsym_ip.html"},{"tags":"","title":"umf4zlsym_ip – MUSST","text":"public subroutine umf4zlsym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zlsym_ip~~CallsGraph proc~umf4zlsym_ip umf4zlsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4zlsym_ip~~CalledByGraph proc~umf4zlsym_ip umf4zlsym_ip interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4zlsym_ip.html"},{"tags":"","title":"umf4clsym_ip – MUSST","text":"public subroutine umf4clsym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4clsym_ip~~CallsGraph proc~umf4clsym_ip umf4clsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4clsym_ip->proc~umfpack_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~umf4clsym_ip~~CalledByGraph proc~umf4clsym_ip umf4clsym_ip interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","loc":"proc/umf4clsym_ip.html"},{"tags":"","title":"c_umfpack_di_symbolic – MUSST","text":"interface Called by interface~~c_umfpack_di_symbolic~~CalledByGraph interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~analyse_solver analyse_solver proc~analyse_solver->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4csym_ip interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->interface~umf4zsym proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacec_umfpack_di_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_di_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) bind(c,name='umfpack_di_symbolic') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n_row integer(kind=c_int), value :: n_col type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr) :: Symbolic type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","loc":"interface/c_umfpack_di_symbolic.html"},{"tags":"","title":"c_umfpack_zi_symbolic – MUSST","text":"interface Called by interface~~c_umfpack_zi_symbolic~~CalledByGraph interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_zi_symbolic umfpack_zi_symbolic proc~umfpack_zi_symbolic->interface~c_umfpack_zi_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->proc~umfpack_ci_symbolic interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4csym_ip interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->interface~umf4zsym var paninterfacec_umfpack_zi_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_symbolic(n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info) bind(c,name='umfpack_zi_symbolic') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n_row integer(kind=c_int), value :: n_col type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr) :: Symbolic type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","loc":"interface/c_umfpack_zi_symbolic.html"},{"tags":"","title":"c_umfpack_di_numeric – MUSST","text":"interface Called by interface~~c_umfpack_di_numeric~~CalledByGraph interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->proc~umfpack_di_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~s_umfpack_di_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacec_umfpack_di_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_di_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) bind(c,name='umfpack_di_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Symbolic type(c_ptr) :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","loc":"interface/c_umfpack_di_numeric.html"},{"tags":"","title":"c_umfpack_zi_numeric – MUSST","text":"interface Called by interface~~c_umfpack_zi_numeric~~CalledByGraph interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric proc~umfpack_zi_numeric umfpack_zi_numeric proc~umfpack_zi_numeric->interface~c_umfpack_zi_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num var paninterfacec_umfpack_zi_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_numeric(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) bind(c,name='umfpack_zi_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr), intent(in), value :: Symbolic type(c_ptr) :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","loc":"interface/c_umfpack_zi_numeric.html"},{"tags":"","title":"c_umfpack_di_solve – MUSST","text":"interface Called by interface~~c_umfpack_di_solve~~CalledByGraph interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve proc~s_umfpack_di_solve s_umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->proc~umfpack_di_solve proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~solution_solver solution_solver proc~solution_solver->proc~s_umfpack_di_solve proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~solve_syst solve_syst proc~solve_syst->proc~solution_solver proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve interface~umf4solr umf4solr interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->interface~umf4solr proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacec_umfpack_di_solveCalledByGraph = svgPanZoom('#interfacec_umfpack_di_solveCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_solve(sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) bind(c,name='umfpack_di_solve') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: sys type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), value :: X type(c_ptr), intent(in), value :: B type(c_ptr), intent(in), value :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","loc":"interface/c_umfpack_di_solve.html"},{"tags":"","title":"c_umfpack_zi_solve – MUSST","text":"interface Called by interface~~c_umfpack_zi_solve~~CalledByGraph interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_zi_solve umfpack_zi_solve proc~umfpack_zi_solve->interface~c_umfpack_zi_solve proc~umfpack_ci_solve umfpack_ci_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->proc~umfpack_ci_solve interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~umf4csol_ip umf4csol_ip proc~umf4csol_ip->proc~s_umfpack_ci_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve interface~umf4csol umf4csol interface~umf4csol->proc~umf4csol_ip interface~umf4csol->interface~umf4csol proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~umf4zsol umf4zsol interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->interface~umf4zsol proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve interface~umf4sol umf4sol interface~umf4sol->proc~umf4csol_ip interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4solr umf4solr interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr var paninterfacec_umfpack_zi_solveCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_solveCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_solve(sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info) bind(c,name='umfpack_zi_solve') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: sys type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr), value :: Xx type(c_ptr), value :: Xz type(c_ptr), intent(in), value :: Bx type(c_ptr), intent(in), value :: Bz type(c_ptr), intent(in), value :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","loc":"interface/c_umfpack_zi_solve.html"},{"tags":"","title":"c_umfpack_di_scale – MUSST","text":"interface Called by interface~~c_umfpack_di_scale~~CalledByGraph interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->proc~umfpack_di_scale proc~s_umfpack_di_scale s_umfpack_di_scale proc~s_umfpack_di_scale->proc~umfpack_di_scale proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_di_scale proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal var paninterfacec_umfpack_di_scaleCalledByGraph = svgPanZoom('#interfacec_umfpack_di_scaleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_scale(X, B, Numeric) bind(c,name='umfpack_di_scale') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: X type(c_ptr), intent(in), value :: B type(c_ptr), intent(in), value :: Numeric Return Value integer(kind=c_int)","loc":"interface/c_umfpack_di_scale.html"},{"tags":"","title":"c_umfpack_zi_scale – MUSST","text":"interface Called by interface~~c_umfpack_zi_scale~~CalledByGraph interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_zi_scale umfpack_zi_scale proc~umfpack_zi_scale->interface~c_umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale proc~s_umfpack_ci_scale s_umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_ci_scale proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal var paninterfacec_umfpack_zi_scaleCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_scaleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_scale(Xx, Xz, Bx, Bz, Numeric) bind(c,name='umfpack_zi_scale') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Xx type(c_ptr), value :: Xz type(c_ptr), intent(in), value :: Bx type(c_ptr), intent(in), value :: Bz type(c_ptr), intent(in), value :: Numeric Return Value integer(kind=c_int)","loc":"interface/c_umfpack_zi_scale.html"},{"tags":"","title":"c_umfpack_di_save_numeric – MUSST","text":"interface Called by interface~~c_umfpack_di_save_numeric~~CalledByGraph interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~s_umfpack_di_save_numeric s_umfpack_di_save_numeric proc~s_umfpack_di_save_numeric->proc~umfpack_di_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum var paninterfacec_umfpack_di_save_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_di_save_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_save_numeric(Numeric, filename) bind(c,name='umfpack_di_save_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","loc":"interface/c_umfpack_di_save_numeric.html"},{"tags":"","title":"c_umfpack_zi_save_numeric – MUSST","text":"interface Called by interface~~c_umfpack_zi_save_numeric~~CalledByGraph interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric s_umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric->proc~umfpack_zi_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum var paninterfacec_umfpack_zi_save_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_save_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_save_numeric(Numeric, filename) bind(c,name='umfpack_zi_save_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","loc":"interface/c_umfpack_zi_save_numeric.html"},{"tags":"","title":"c_umfpack_di_save_symbolic – MUSST","text":"interface Called by interface~~c_umfpack_di_save_symbolic~~CalledByGraph interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic s_umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic->proc~umfpack_di_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym var paninterfacec_umfpack_di_save_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_di_save_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_save_symbolic(Symbolic, filename) bind(c,name='umfpack_di_save_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","loc":"interface/c_umfpack_di_save_symbolic.html"},{"tags":"","title":"c_umfpack_zi_save_symbolic – MUSST","text":"interface Called by interface~~c_umfpack_zi_save_symbolic~~CalledByGraph interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic s_umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym var paninterfacec_umfpack_zi_save_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_save_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_save_symbolic(Symbolic, filename) bind(c,name='umfpack_zi_save_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","loc":"interface/c_umfpack_zi_save_symbolic.html"},{"tags":"","title":"c_umfpack_di_load_numeric – MUSST","text":"interface Called by interface~~c_umfpack_di_load_numeric~~CalledByGraph interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~s_umfpack_di_load_numeric s_umfpack_di_load_numeric proc~s_umfpack_di_load_numeric->proc~umfpack_di_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum var paninterfacec_umfpack_di_load_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_di_load_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_load_numeric(Numeric, filename) bind(c,name='umfpack_di_load_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","loc":"interface/c_umfpack_di_load_numeric.html"},{"tags":"","title":"c_umfpack_zi_load_numeric – MUSST","text":"interface Called by interface~~c_umfpack_zi_load_numeric~~CalledByGraph interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric s_umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric->proc~umfpack_zi_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum var paninterfacec_umfpack_zi_load_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_load_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_load_numeric(Numeric, filename) bind(c,name='umfpack_zi_load_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","loc":"interface/c_umfpack_zi_load_numeric.html"},{"tags":"","title":"c_umfpack_di_load_symbolic – MUSST","text":"interface Called by interface~~c_umfpack_di_load_symbolic~~CalledByGraph interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic s_umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym var paninterfacec_umfpack_di_load_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_di_load_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_di_load_symbolic(Symbolic, filename) bind(c,name='umfpack_di_load_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","loc":"interface/c_umfpack_di_load_symbolic.html"},{"tags":"","title":"c_umfpack_zi_load_symbolic – MUSST","text":"interface Called by interface~~c_umfpack_zi_load_symbolic~~CalledByGraph interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic s_umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym var paninterfacec_umfpack_zi_load_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_load_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function c_umfpack_zi_load_symbolic(Symbolic, filename) bind(c,name='umfpack_zi_load_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int)","loc":"interface/c_umfpack_zi_load_symbolic.html"},{"tags":"","title":"c_umfpack_di_report_numeric – MUSST","text":"interface public function c_umfpack_di_report_numeric(Numeric, Control) bind(c,name='umfpack_di_report_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric type(c_ptr), value :: Control Return Value integer(kind=c_int)","loc":"interface/c_umfpack_di_report_numeric.html"},{"tags":"","title":"c_umfpack_zi_report_numeric – MUSST","text":"interface public function c_umfpack_zi_report_numeric(Numeric, Control) bind(c,name='umfpack_zi_report_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric type(c_ptr), value :: Control Return Value integer(kind=c_int)","loc":"interface/c_umfpack_zi_report_numeric.html"},{"tags":"","title":"c_umfpack_di_report_symbolic – MUSST","text":"interface public function c_umfpack_di_report_symbolic(Symbolic, Control) bind(c,name='umfpack_di_report_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic type(c_ptr), value :: Control Return Value integer(kind=c_int)","loc":"interface/c_umfpack_di_report_symbolic.html"},{"tags":"","title":"c_umfpack_zi_report_symbolic – MUSST","text":"interface public function c_umfpack_zi_report_symbolic(Symbolic, Control) bind(c,name='umfpack_zi_report_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic type(c_ptr), value :: Control Return Value integer(kind=c_int)","loc":"interface/c_umfpack_zi_report_symbolic.html"},{"tags":"","title":"c_umfpack_di_free_symbolic – MUSST","text":"interface Called by interface~~c_umfpack_di_free_symbolic~~CalledByGraph interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic s_umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_symbolic proc~close_solver close_solver proc~close_solver->proc~umfpack_di_free_symbolic interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacec_umfpack_di_free_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_di_free_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_di_free_symbolic(Symbolic) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic","loc":"interface/c_umfpack_di_free_symbolic.html"},{"tags":"","title":"c_umfpack_zi_free_symbolic – MUSST","text":"interface Called by interface~~c_umfpack_zi_free_symbolic~~CalledByGraph interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic s_umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_symbolic interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym var paninterfacec_umfpack_zi_free_symbolicCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_free_symbolicCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_zi_free_symbolic(Symbolic) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic","loc":"interface/c_umfpack_zi_free_symbolic.html"},{"tags":"","title":"c_umfpack_di_free_numeric – MUSST","text":"interface Called by interface~~c_umfpack_di_free_numeric~~CalledByGraph interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~umfpack_di_free_numeric proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~s_umfpack_di_free_numeric s_umfpack_di_free_numeric interface~s_umfpack_di_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~umfpack_di_free_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~umfpack_di_free_numeric proc~freefact_solver freefact_solver proc~freefact_solver->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_numeric proc~close_solver close_solver proc~close_solver->proc~umfpack_di_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~solve_syst->proc~freefact_solver proc~solve_syst->proc~close_solver interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacec_umfpack_di_free_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_di_free_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_di_free_numeric(Numeric) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric","loc":"interface/c_umfpack_di_free_numeric.html"},{"tags":"","title":"c_umfpack_zi_free_numeric – MUSST","text":"interface Called by interface~~c_umfpack_zi_free_numeric~~CalledByGraph interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric s_umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum var paninterfacec_umfpack_zi_free_numericCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_free_numericCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_zi_free_numeric(Numeric) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric","loc":"interface/c_umfpack_zi_free_numeric.html"},{"tags":"","title":"c_umfpack_di_defaults – MUSST","text":"interface Called by interface~~c_umfpack_di_defaults~~CalledByGraph interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~s_umfpack_di_defaults s_umfpack_di_defaults interface~s_umfpack_di_defaults->proc~umfpack_di_defaults proc~umfpack_defaults umfpack_defaults proc~umfpack_defaults->proc~umfpack_di_defaults proc~init_solver init_solver proc~init_solver->proc~umfpack_di_defaults proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacec_umfpack_di_defaultsCalledByGraph = svgPanZoom('#interfacec_umfpack_di_defaultsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_di_defaults(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control","loc":"interface/c_umfpack_di_defaults.html"},{"tags":"","title":"c_umfpack_zi_defaults – MUSST","text":"interface Called by interface~~c_umfpack_zi_defaults~~CalledByGraph interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults interface~s_umfpack_zi_defaults s_umfpack_zi_defaults interface~s_umfpack_zi_defaults->proc~umfpack_zi_defaults proc~umfpack_defaults umfpack_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_zi_defaults(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control","loc":"interface/c_umfpack_zi_defaults.html"},{"tags":"","title":"c_umfpack_di_report_status – MUSST","text":"interface public subroutine c_umfpack_di_report_status(Control, status) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control integer(kind=c_int), value :: status","loc":"interface/c_umfpack_di_report_status.html"},{"tags":"","title":"c_umfpack_zi_report_status – MUSST","text":"interface public subroutine c_umfpack_zi_report_status(Control, status) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control integer(kind=c_int), value :: status","loc":"interface/c_umfpack_zi_report_status.html"},{"tags":"","title":"c_umfpack_di_report_control – MUSST","text":"interface Called by interface~~c_umfpack_di_report_control~~CalledByGraph interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control proc~umfpack_report_control umfpack_report_control proc~umfpack_report_control->proc~umfpack_di_report_control interface~s_umfpack_di_report_control s_umfpack_di_report_control interface~s_umfpack_di_report_control->proc~umfpack_di_report_control proc~init_solver init_solver proc~init_solver->proc~umfpack_di_report_control proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacec_umfpack_di_report_controlCalledByGraph = svgPanZoom('#interfacec_umfpack_di_report_controlCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_di_report_control(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control","loc":"interface/c_umfpack_di_report_control.html"},{"tags":"","title":"c_umfpack_zi_report_control – MUSST","text":"interface Called by interface~~c_umfpack_zi_report_control~~CalledByGraph interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control proc~umfpack_report_control umfpack_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control interface~s_umfpack_zi_report_control s_umfpack_zi_report_control interface~s_umfpack_zi_report_control->proc~umfpack_zi_report_control proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control var paninterfacec_umfpack_zi_report_controlCalledByGraph = svgPanZoom('#interfacec_umfpack_zi_report_controlCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_zi_report_control(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control","loc":"interface/c_umfpack_zi_report_control.html"},{"tags":"","title":"c_umfpack_di_report_info – MUSST","text":"interface Called by interface~~c_umfpack_di_report_info~~CalledByGraph interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~s_umfpack_di_report_info s_umfpack_di_report_info interface~s_umfpack_di_report_info->proc~umfpack_di_report_info proc~umfpack_report_info umfpack_report_info proc~umfpack_report_info->proc~umfpack_di_report_info proc~close_solver close_solver proc~close_solver->proc~umfpack_di_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info proc~solve_fe_film solve_FE_film proc~solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~solve_fe_prob solve_fe_prob proc~solve_fe_prob->proc~solve_fe_film proc~elementary_full_domain_fe_film_reynolds elementary_full_domain_FE_film_reynolds proc~elementary_full_domain_fe_film_reynolds->proc~solve_fe_film proc~solve_ms_prob solve_ms_prob proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~test_slider_fe test_slider_fe proc~test_slider_fe->proc~solve_fe_prob proc~test_rough_ms test_rough_ms proc~test_rough_ms->proc~solve_ms_prob proc~test_bearing_x_fe test_bearing_x_fe proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_y_fe test_bearing_y_fe proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_slider_ms test_slider_ms proc~test_slider_ms->proc~solve_ms_prob proc~test_pocket_fe test_pocket_fe proc~test_pocket_fe->proc~solve_fe_prob proc~test_rough_fe test_rough_fe proc~test_rough_fe->proc~solve_fe_prob proc~run_test run_test proc~run_test->proc~test_slider_fe proc~run_test->proc~test_rough_ms proc~run_test->proc~test_bearing_x_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~test_slider_ms proc~run_test->proc~test_pocket_fe proc~run_test->proc~test_rough_fe program~main main program~main->proc~run_test var paninterfacec_umfpack_di_report_infoCalledByGraph = svgPanZoom('#interfacec_umfpack_di_report_infoCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_di_report_info(Control, Info) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control type(c_ptr), value :: Info","loc":"interface/c_umfpack_di_report_info.html"},{"tags":"","title":"c_umfpack_zi_report_info – MUSST","text":"interface Called by interface~~c_umfpack_zi_report_info~~CalledByGraph interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info interface~s_umfpack_zi_report_info s_umfpack_zi_report_info interface~s_umfpack_zi_report_info->proc~umfpack_zi_report_info proc~umfpack_report_info umfpack_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine c_umfpack_zi_report_info(Control, Info) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control type(c_ptr), value :: Info","loc":"interface/c_umfpack_zi_report_info.html"},{"tags":"","title":"umfpack_zi_symbolic – MUSST","text":"public interface umfpack_zi_symbolic Calls interface~~umfpack_zi_symbolic~~CallsGraph interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umfpack_zi_symbolic~~CalledByGraph interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->interface~umfpack_zi_symbolic proc~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~s_umfpack_zi_symbolic->interface~umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_symbolic umfpack_ci_symbolic Module Procedures public interface umfpack_zi_symbolic () Arguments None public function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer","loc":"interface/umfpack_zi_symbolic.html"},{"tags":"","title":"s_umfpack_zi_symbolic – MUSST","text":"public interface s_umfpack_zi_symbolic Calls interface~~s_umfpack_zi_symbolic~~CallsGraph interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~s_umfpack_zi_symbolic~~CalledByGraph interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_symbolic proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4csym_ip interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->interface~umf4zsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_zi_symbolic s_umfpack_ci_symbolic Module Procedures public interface s_umfpack_zi_symbolic () Arguments None public subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","loc":"interface/s_umfpack_zi_symbolic.html"},{"tags":"","title":"umfpack_symbolic – MUSST","text":"public interface umfpack_symbolic Calls interface~~umfpack_symbolic~~CallsGraph interface~umfpack_symbolic umfpack_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~umfpack_symbolic->proc~umfpack_ci_symbolic interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_symbolic->interface~umfpack_zi_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic interface~umfpack_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_symbolic umfpack_zi_symbolic umfpack_ci_symbolic Module Procedures public function umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface umfpack_zi_symbolic () Arguments None public function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer","loc":"interface/umfpack_symbolic.html"},{"tags":"","title":"s_umfpack_symbolic – MUSST","text":"public interface s_umfpack_symbolic Calls interface~~s_umfpack_symbolic~~CallsGraph interface~s_umfpack_symbolic s_umfpack_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic var paninterfaces_umfpack_symbolicCallsGraph = svgPanZoom('#interfaces_umfpack_symbolicCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~s_umfpack_symbolic~~CalledByGraph interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->proc~umf4csym_ip interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->interface~umf4zsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_di_symbolic s_umfpack_zi_symbolic s_umfpack_ci_symbolic Module Procedures public subroutine s_umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface s_umfpack_zi_symbolic () Arguments None public subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","loc":"interface/s_umfpack_symbolic.html"},{"tags":"","title":"umfpack_zi_numeric – MUSST","text":"public interface umfpack_zi_numeric Calls interface~~umfpack_zi_numeric~~CallsGraph interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric proc~umfpack_ci_numeric umfpack_ci_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umfpack_zi_numeric~~CalledByGraph interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric proc~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~s_umfpack_zi_numeric->interface~umfpack_zi_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->interface~umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_numeric umfpack_ci_numeric Module Procedures public interface umfpack_zi_numeric () Arguments None public function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer","loc":"interface/umfpack_zi_numeric.html"},{"tags":"","title":"s_umfpack_zi_numeric – MUSST","text":"public interface s_umfpack_zi_numeric Calls interface~~s_umfpack_zi_numeric~~CallsGraph interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~s_umfpack_zi_numeric~~CalledByGraph interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_zi_numeric s_umfpack_ci_numeric Module Procedures public interface s_umfpack_zi_numeric () Arguments None public subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","loc":"interface/s_umfpack_zi_numeric.html"},{"tags":"","title":"umfpack_numeric – MUSST","text":"public interface umfpack_numeric Calls interface~~umfpack_numeric~~CallsGraph interface~umfpack_numeric umfpack_numeric proc~umfpack_di_numeric umfpack_di_numeric interface~umfpack_numeric->proc~umfpack_di_numeric proc~umfpack_ci_numeric umfpack_ci_numeric interface~umfpack_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_numeric->interface~umfpack_zi_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_numeric umfpack_zi_numeric umfpack_ci_numeric Module Procedures public function umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface umfpack_zi_numeric () Arguments None public function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer","loc":"interface/umfpack_numeric.html"},{"tags":"","title":"s_umfpack_numeric – MUSST","text":"public interface s_umfpack_numeric Calls interface~~s_umfpack_numeric~~CallsGraph interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var paninterfaces_umfpack_numericCallsGraph = svgPanZoom('#interfaces_umfpack_numericCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~s_umfpack_numeric~~CalledByGraph interface~s_umfpack_numeric s_umfpack_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4znum umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_di_numeric s_umfpack_zi_numeric s_umfpack_ci_numeric Module Procedures public subroutine s_umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface s_umfpack_zi_numeric () Arguments None public subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","loc":"interface/s_umfpack_numeric.html"},{"tags":"","title":"umfpack_zi_solve – MUSST","text":"public interface umfpack_zi_solve Calls interface~~umfpack_zi_solve~~CallsGraph interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve proc~umfpack_ci_solve umfpack_ci_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umfpack_zi_solve~~CalledByGraph interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->interface~umfpack_zi_solve proc~s_umfpack_zi_solve s_umfpack_zi_solve proc~s_umfpack_zi_solve->interface~umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_solve umfpack_ci_solve Module Procedures public interface umfpack_zi_solve () Arguments None public function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) complex(kind=r8), intent(in), optional target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer","loc":"interface/umfpack_zi_solve.html"},{"tags":"","title":"s_umfpack_zi_solve – MUSST","text":"public interface s_umfpack_zi_solve Calls interface~~s_umfpack_zi_solve~~CallsGraph interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~s_umfpack_zi_solve~~CalledByGraph interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_solve proc~umf4zsol_ip umf4zsol_ip proc~umf4zsol_ip->interface~s_umfpack_zi_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~umf4zsol umf4zsol interface~umf4zsol->proc~umf4zsol_ip interface~umf4zsol->interface~umf4zsol proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve interface~umf4sol umf4sol interface~umf4sol->proc~umf4zsol_ip interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4solr umf4solr interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_zi_solve s_umfpack_ci_solve Module Procedures public interface s_umfpack_zi_solve () Arguments None public subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","loc":"interface/s_umfpack_zi_solve.html"},{"tags":"","title":"umfpack_solve – MUSST","text":"public interface umfpack_solve Calls interface~~umfpack_solve~~CallsGraph interface~umfpack_solve umfpack_solve interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_solve->interface~umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve interface~umfpack_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve interface~umfpack_solve->proc~umfpack_ci_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_solve umfpack_zi_solve umfpack_ci_solve Module Procedures public function umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface umfpack_zi_solve () Arguments None public function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) complex(kind=r8), intent(in), optional target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer","loc":"interface/umfpack_solve.html"},{"tags":"","title":"s_umfpack_solve – MUSST","text":"public interface s_umfpack_solve Calls interface~~s_umfpack_solve~~CallsGraph interface~s_umfpack_solve s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var paninterfaces_umfpack_solveCallsGraph = svgPanZoom('#interfaces_umfpack_solveCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~s_umfpack_solve~~CalledByGraph interface~s_umfpack_solve s_umfpack_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve interface~umf4zsolr umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4zsolr interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4solr umf4solr interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->interface~umf4solr interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_di_solve s_umfpack_zi_solve s_umfpack_ci_solve Module Procedures public subroutine s_umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface s_umfpack_zi_solve () Arguments None public subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","loc":"interface/s_umfpack_solve.html"},{"tags":"","title":"s_umfpack_free_symbolic – MUSST","text":"public interface s_umfpack_free_symbolic Calls interface~~s_umfpack_free_symbolic~~CallsGraph interface~s_umfpack_free_symbolic s_umfpack_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic var paninterfaces_umfpack_free_symbolicCallsGraph = svgPanZoom('#interfaces_umfpack_free_symbolicCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_free_symbolic Module Procedures public subroutine umfpack_free_symbolic (Symbolic, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic character(len=*), optional :: version","loc":"interface/s_umfpack_free_symbolic.html"},{"tags":"","title":"s_umfpack_di_free_symbolic – MUSST","text":"public interface s_umfpack_di_free_symbolic Calls interface~~s_umfpack_di_free_symbolic~~CallsGraph interface~s_umfpack_di_free_symbolic s_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_free_symbolic Module Procedures public subroutine umfpack_di_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic","loc":"interface/s_umfpack_di_free_symbolic.html"},{"tags":"","title":"s_umfpack_zi_free_symbolic – MUSST","text":"public interface s_umfpack_zi_free_symbolic Calls interface~~s_umfpack_zi_free_symbolic~~CallsGraph interface~s_umfpack_zi_free_symbolic s_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic->proc~umfpack_zi_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_free_symbolic Module Procedures public subroutine umfpack_zi_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic","loc":"interface/s_umfpack_zi_free_symbolic.html"},{"tags":"","title":"s_umfpack_free_numeric – MUSST","text":"public interface s_umfpack_free_numeric Calls interface~~s_umfpack_free_numeric~~CallsGraph interface~s_umfpack_free_numeric s_umfpack_free_numeric proc~umfpack_free_numeric umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric var paninterfaces_umfpack_free_numericCallsGraph = svgPanZoom('#interfaces_umfpack_free_numericCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_free_numeric Module Procedures public subroutine umfpack_free_numeric (Numeric, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric character(len=*), optional :: version","loc":"interface/s_umfpack_free_numeric.html"},{"tags":"","title":"s_umfpack_di_free_numeric – MUSST","text":"public interface s_umfpack_di_free_numeric Calls interface~~s_umfpack_di_free_numeric~~CallsGraph interface~s_umfpack_di_free_numeric s_umfpack_di_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric interface~s_umfpack_di_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_free_numeric Module Procedures public subroutine umfpack_di_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric","loc":"interface/s_umfpack_di_free_numeric.html"},{"tags":"","title":"s_umfpack_zi_free_numeric – MUSST","text":"public interface s_umfpack_zi_free_numeric Calls interface~~s_umfpack_zi_free_numeric~~CallsGraph interface~s_umfpack_zi_free_numeric s_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric->proc~umfpack_zi_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_free_numeric Module Procedures public subroutine umfpack_zi_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric","loc":"interface/s_umfpack_zi_free_numeric.html"},{"tags":"","title":"s_umfpack_defaults – MUSST","text":"public interface s_umfpack_defaults Calls interface~~s_umfpack_defaults~~CallsGraph interface~s_umfpack_defaults s_umfpack_defaults proc~umfpack_defaults umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_defaults Module Procedures public subroutine umfpack_defaults (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version","loc":"interface/s_umfpack_defaults.html"},{"tags":"","title":"s_umfpack_di_defaults – MUSST","text":"public interface s_umfpack_di_defaults Calls interface~~s_umfpack_di_defaults~~CallsGraph interface~s_umfpack_di_defaults s_umfpack_di_defaults proc~umfpack_di_defaults umfpack_di_defaults interface~s_umfpack_di_defaults->proc~umfpack_di_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_defaults Module Procedures public subroutine umfpack_di_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1)","loc":"interface/s_umfpack_di_defaults.html"},{"tags":"","title":"s_umfpack_zi_defaults – MUSST","text":"public interface s_umfpack_zi_defaults Calls interface~~s_umfpack_zi_defaults~~CallsGraph interface~s_umfpack_zi_defaults s_umfpack_zi_defaults proc~umfpack_zi_defaults umfpack_zi_defaults interface~s_umfpack_zi_defaults->proc~umfpack_zi_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_defaults Module Procedures public subroutine umfpack_zi_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1)","loc":"interface/s_umfpack_zi_defaults.html"},{"tags":"","title":"umfpack_zi_scale – MUSST","text":"public interface umfpack_zi_scale Calls interface~~umfpack_zi_scale~~CallsGraph interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umfpack_zi_scale~~CalledByGraph interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->interface~umfpack_zi_scale proc~s_umfpack_zi_scale s_umfpack_zi_scale proc~s_umfpack_zi_scale->interface~umfpack_zi_scale proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_scale umfpack_ci_scale Module Procedures public interface umfpack_zi_scale () Arguments None public function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer","loc":"interface/umfpack_zi_scale.html"},{"tags":"","title":"umfpack_scale_function – MUSST","text":"public interface umfpack_scale_function Calls interface~~umfpack_scale_function~~CallsGraph interface~umfpack_scale_function umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umfpack_scale_function~~CalledByGraph interface~umfpack_scale_function umfpack_scale_function proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function interface~umf4zscal umf4zscal interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_scale umfpack_zi_scale umfpack_ci_scale Module Procedures public function umfpack_di_scale (X, B, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public interface umfpack_zi_scale () Arguments None public function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer","loc":"interface/umfpack_scale_function.html"},{"tags":"","title":"s_umfpack_zi_scale – MUSST","text":"public interface s_umfpack_zi_scale Calls interface~~s_umfpack_zi_scale~~CallsGraph interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale proc~s_umfpack_ci_scale s_umfpack_ci_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale proc~umfpack_ci_scale umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~s_umfpack_zi_scale~~CalledByGraph interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->interface~s_umfpack_zi_scale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_zi_scale s_umfpack_ci_scale Module Procedures public interface s_umfpack_zi_scale () Arguments None public subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status","loc":"interface/s_umfpack_zi_scale.html"},{"tags":"","title":"s_umfpack_scale – MUSST","text":"public interface s_umfpack_scale Calls interface~~s_umfpack_scale~~CallsGraph interface~s_umfpack_scale s_umfpack_scale proc~s_umfpack_di_scale s_umfpack_di_scale interface~s_umfpack_scale->proc~s_umfpack_di_scale interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_scale->interface~s_umfpack_zi_scale proc~s_umfpack_ci_scale s_umfpack_ci_scale interface~s_umfpack_scale->proc~s_umfpack_ci_scale proc~umfpack_di_scale umfpack_di_scale proc~s_umfpack_di_scale->proc~umfpack_di_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale proc~umfpack_ci_scale umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale var paninterfaces_umfpack_scaleCallsGraph = svgPanZoom('#interfaces_umfpack_scaleCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures s_umfpack_di_scale s_umfpack_zi_scale s_umfpack_ci_scale Module Procedures public subroutine s_umfpack_di_scale (X, B, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public interface s_umfpack_zi_scale () Arguments None public subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status","loc":"interface/s_umfpack_scale.html"},{"tags":"","title":"s_umfpack_report_control – MUSST","text":"public interface s_umfpack_report_control Calls interface~~s_umfpack_report_control~~CallsGraph interface~s_umfpack_report_control s_umfpack_report_control proc~umfpack_report_control umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control var paninterfaces_umfpack_report_controlCallsGraph = svgPanZoom('#interfaces_umfpack_report_controlCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_report_control Module Procedures public subroutine umfpack_report_control (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version","loc":"interface/s_umfpack_report_control.html"},{"tags":"","title":"s_umfpack_di_report_control – MUSST","text":"public interface s_umfpack_di_report_control Calls interface~~s_umfpack_di_report_control~~CallsGraph interface~s_umfpack_di_report_control s_umfpack_di_report_control proc~umfpack_di_report_control umfpack_di_report_control interface~s_umfpack_di_report_control->proc~umfpack_di_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_report_control Module Procedures public subroutine umfpack_di_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1)","loc":"interface/s_umfpack_di_report_control.html"},{"tags":"","title":"s_umfpack_zi_report_control – MUSST","text":"public interface s_umfpack_zi_report_control Calls interface~~s_umfpack_zi_report_control~~CallsGraph interface~s_umfpack_zi_report_control s_umfpack_zi_report_control proc~umfpack_zi_report_control umfpack_zi_report_control interface~s_umfpack_zi_report_control->proc~umfpack_zi_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_report_control Module Procedures public subroutine umfpack_zi_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1)","loc":"interface/s_umfpack_zi_report_control.html"},{"tags":"","title":"s_umfpack_report_info – MUSST","text":"public interface s_umfpack_report_info Calls interface~~s_umfpack_report_info~~CallsGraph interface~s_umfpack_report_info s_umfpack_report_info proc~umfpack_report_info umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_report_info Module Procedures public subroutine umfpack_report_info (Control, Info, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) character(len=*), optional :: version","loc":"interface/s_umfpack_report_info.html"},{"tags":"","title":"s_umfpack_di_report_info – MUSST","text":"public interface s_umfpack_di_report_info Calls interface~~s_umfpack_di_report_info~~CallsGraph interface~s_umfpack_di_report_info s_umfpack_di_report_info proc~umfpack_di_report_info umfpack_di_report_info interface~s_umfpack_di_report_info->proc~umfpack_di_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_report_info Module Procedures public subroutine umfpack_di_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1)","loc":"interface/s_umfpack_di_report_info.html"},{"tags":"","title":"s_umfpack_zi_report_info – MUSST","text":"public interface s_umfpack_zi_report_info Calls interface~~s_umfpack_zi_report_info~~CallsGraph interface~s_umfpack_zi_report_info s_umfpack_zi_report_info proc~umfpack_zi_report_info umfpack_zi_report_info interface~s_umfpack_zi_report_info->proc~umfpack_zi_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_zi_report_info Module Procedures public subroutine umfpack_zi_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1)","loc":"interface/s_umfpack_zi_report_info.html"},{"tags":"","title":"umf4csym – MUSST","text":"public interface umf4csym Calls interface~~umf4csym~~CallsGraph interface~umf4csym umf4csym interface~umf4csym->interface~umf4csym proc~umf4csym_ip umf4csym_ip interface~umf4csym->proc~umf4csym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4csym_ip->interface~s_umfpack_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic var paninterfaceumf4csymCallsGraph = svgPanZoom('#interfaceumf4csymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4csym~~CalledByGraph interface~umf4csym umf4csym interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->interface~umf4csym interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4zsym->interface~umf4csym interface~umf4zsym->interface~umf4zsym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4csym umf4csym_ip Module Procedures public interface umf4csym () Arguments None public subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","loc":"interface/umf4csym.html"},{"tags":"","title":"umf4zsym – MUSST","text":"public interface umf4zsym Calls interface~~umf4zsym~~CallsGraph interface~umf4zsym umf4zsym interface~umf4zsym->interface~umf4zsym proc~umf4zsym_ip umf4zsym_ip interface~umf4zsym->proc~umf4zsym_ip proc~umf4csym_ip umf4csym_ip interface~umf4zsym->proc~umf4csym_ip interface~umf4csym umf4csym interface~umf4zsym->interface~umf4csym interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~umf4csym_ip->interface~s_umfpack_symbolic interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic var paninterfaceumf4zsymCallsGraph = svgPanZoom('#interfaceumf4zsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4zsym~~CalledByGraph interface~umf4zsym umf4zsym interface~umf4zsym->interface~umf4zsym interface~umf4sym umf4sym interface~umf4sym->interface~umf4zsym interface~umf4sym->interface~umf4sym Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zsym umf4zsym_ip umf4csym umf4csym_ip Module Procedures public interface umf4zsym () Arguments None public subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csym () Arguments None public subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","loc":"interface/umf4zsym.html"},{"tags":"","title":"umf4sym – MUSST","text":"public interface umf4sym Calls interface~~umf4sym~~CallsGraph interface~umf4sym umf4sym interface~umf4sym->interface~umf4sym proc~umf4sym_ip umf4sym_ip interface~umf4sym->proc~umf4sym_ip proc~umf4zsym_ip umf4zsym_ip interface~umf4sym->proc~umf4zsym_ip proc~umf4csym_ip umf4csym_ip interface~umf4sym->proc~umf4csym_ip interface~umf4csym umf4csym interface~umf4sym->interface~umf4csym interface~umf4zsym umf4zsym interface~umf4sym->interface~umf4zsym interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~umf4csym_ip->interface~s_umfpack_symbolic interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->interface~umf4csym interface~umf4zsym->interface~umf4zsym proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic var paninterfaceumf4symCallsGraph = svgPanZoom('#interfaceumf4symCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4sym umf4sym_ip umf4zsym umf4zsym_ip umf4csym umf4csym_ip Module Procedures public interface umf4sym () Arguments None public subroutine umf4sym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsym () Arguments None public subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csym () Arguments None public subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","loc":"interface/umf4sym.html"},{"tags":"","title":"umf4cnum – MUSST","text":"public interface umf4cnum Calls interface~~umf4cnum~~CallsGraph interface~umf4cnum umf4cnum interface~umf4cnum->interface~umf4cnum proc~umf4cnum_ip umf4cnum_ip interface~umf4cnum->proc~umf4cnum_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4cnum_ip->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var paninterfaceumf4cnumCallsGraph = svgPanZoom('#interfaceumf4cnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4cnum~~CalledByGraph interface~umf4cnum umf4cnum interface~umf4cnum->interface~umf4cnum interface~umf4znum umf4znum interface~umf4znum->interface~umf4cnum interface~umf4znum->interface~umf4znum interface~umf4num umf4num interface~umf4num->interface~umf4cnum interface~umf4num->interface~umf4num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4cnum umf4cnum_ip Module Procedures public interface umf4cnum () Arguments None public subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","loc":"interface/umf4cnum.html"},{"tags":"","title":"umf4znum – MUSST","text":"public interface umf4znum Calls interface~~umf4znum~~CallsGraph interface~umf4znum umf4znum interface~umf4znum->interface~umf4znum proc~umf4cnum_ip umf4cnum_ip interface~umf4znum->proc~umf4cnum_ip proc~umf4znum_ip umf4znum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4cnum umf4cnum interface~umf4znum->interface~umf4cnum interface~s_umfpack_numeric s_umfpack_numeric proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4znum_ip->interface~s_umfpack_numeric interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var paninterfaceumf4znumCallsGraph = svgPanZoom('#interfaceumf4znumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4znum~~CalledByGraph interface~umf4znum umf4znum interface~umf4znum->interface~umf4znum interface~umf4num umf4num interface~umf4num->interface~umf4znum interface~umf4num->interface~umf4num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4znum umf4znum_ip umf4cnum umf4cnum_ip Module Procedures public interface umf4znum () Arguments None public subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4cnum () Arguments None public subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","loc":"interface/umf4znum.html"},{"tags":"","title":"umf4num – MUSST","text":"public interface umf4num Calls interface~~umf4num~~CallsGraph interface~umf4num umf4num interface~umf4num->interface~umf4num proc~umf4cnum_ip umf4cnum_ip interface~umf4num->proc~umf4cnum_ip proc~umf4znum_ip umf4znum_ip interface~umf4num->proc~umf4znum_ip interface~umf4znum umf4znum interface~umf4num->interface~umf4znum interface~umf4cnum umf4cnum interface~umf4num->interface~umf4cnum proc~umf4num_ip umf4num_ip interface~umf4num->proc~umf4num_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4znum_ip->interface~s_umfpack_numeric interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum interface~umf4znum->interface~umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum proc~umf4num_ip->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric var paninterfaceumf4numCallsGraph = svgPanZoom('#interfaceumf4numCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4num umf4num_ip umf4znum umf4znum_ip umf4cnum umf4cnum_ip Module Procedures public interface umf4num () Arguments None public subroutine umf4num_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4znum () Arguments None public subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4cnum () Arguments None public subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","loc":"interface/umf4num.html"},{"tags":"","title":"umf4csolr – MUSST","text":"public interface umf4csolr Calls interface~~umf4csolr~~CallsGraph interface~umf4csolr umf4csolr interface~umf4csolr->interface~umf4csolr proc~umf4csolr_ip umf4csolr_ip interface~umf4csolr->proc~umf4csolr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4csolr_ip->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var paninterfaceumf4csolrCallsGraph = svgPanZoom('#interfaceumf4csolrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4csolr~~CalledByGraph interface~umf4csolr umf4csolr interface~umf4csolr->interface~umf4csolr interface~umf4solr umf4solr interface~umf4solr->interface~umf4csolr interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4csolr umf4csolr_ip Module Procedures public interface umf4csolr () Arguments None public subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","loc":"interface/umf4csolr.html"},{"tags":"","title":"umf4zsolr – MUSST","text":"public interface umf4zsolr Calls interface~~umf4zsolr~~CallsGraph interface~umf4zsolr umf4zsolr interface~umf4zsolr->interface~umf4zsolr proc~umf4zsolr_ip umf4zsolr_ip interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4csolr umf4csolr interface~umf4zsolr->interface~umf4csolr proc~umf4csolr_ip umf4csolr_ip interface~umf4zsolr->proc~umf4csolr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4zsolr_ip->interface~s_umfpack_solve interface~umf4csolr->interface~umf4csolr interface~umf4csolr->proc~umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var paninterfaceumf4zsolrCallsGraph = svgPanZoom('#interfaceumf4zsolrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4zsolr~~CalledByGraph interface~umf4zsolr umf4zsolr interface~umf4zsolr->interface~umf4zsolr interface~umf4solr umf4solr interface~umf4solr->interface~umf4zsolr interface~umf4solr->interface~umf4solr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zsolr umf4zsolr_ip umf4csolr umf4csolr_ip Module Procedures public interface umf4zsolr () Arguments None public subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csolr () Arguments None public subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","loc":"interface/umf4zsolr.html"},{"tags":"","title":"umf4solr – MUSST","text":"public interface umf4solr Calls interface~~umf4solr~~CallsGraph interface~umf4solr umf4solr interface~umf4solr->interface~umf4solr proc~umf4zsolr_ip umf4zsolr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4csolr umf4csolr interface~umf4solr->interface~umf4csolr interface~umf4zsolr umf4zsolr interface~umf4solr->interface~umf4zsolr proc~umf4csolr_ip umf4csolr_ip interface~umf4solr->proc~umf4csolr_ip proc~umf4solr_ip umf4solr_ip interface~umf4solr->proc~umf4solr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4zsolr_ip->interface~s_umfpack_solve interface~umf4csolr->interface~umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr interface~umf4zsolr->proc~umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4solr_ip->interface~s_umfpack_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var paninterfaceumf4solrCallsGraph = svgPanZoom('#interfaceumf4solrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4solr umf4solr_ip umf4zsolr umf4zsolr_ip umf4csolr umf4csolr_ip Module Procedures public interface umf4solr () Arguments None public subroutine umf4solr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsolr () Arguments None public subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csolr () Arguments None public subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","loc":"interface/umf4solr.html"},{"tags":"","title":"umf4csol – MUSST","text":"public interface umf4csol Calls interface~~umf4csol~~CallsGraph interface~umf4csol umf4csol interface~umf4csol->interface~umf4csol proc~umf4csol_ip umf4csol_ip interface~umf4csol->proc~umf4csol_ip proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umf4csol_ip->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4csol~~CalledByGraph interface~umf4csol umf4csol interface~umf4csol->interface~umf4csol interface~umf4zsol umf4zsol interface~umf4zsol->interface~umf4csol interface~umf4zsol->interface~umf4zsol interface~umf4sol umf4sol interface~umf4sol->interface~umf4csol interface~umf4sol->interface~umf4sol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4csol umf4csol_ip Module Procedures public interface umf4csol () Arguments None public subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","loc":"interface/umf4csol.html"},{"tags":"","title":"umf4zsol – MUSST","text":"public interface umf4zsol Calls interface~~umf4zsol~~CallsGraph interface~umf4zsol umf4zsol interface~umf4zsol->interface~umf4zsol proc~umf4csol_ip umf4csol_ip interface~umf4zsol->proc~umf4csol_ip interface~umf4csol umf4csol interface~umf4zsol->interface~umf4csol proc~umf4zsol_ip umf4zsol_ip interface~umf4zsol->proc~umf4zsol_ip proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umf4csol_ip->proc~s_umfpack_ci_solve interface~umf4csol->proc~umf4csol_ip interface~umf4csol->interface~umf4csol interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umf4zsol_ip->interface~s_umfpack_zi_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var paninterfaceumf4zsolCallsGraph = svgPanZoom('#interfaceumf4zsolCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4zsol~~CalledByGraph interface~umf4zsol umf4zsol interface~umf4zsol->interface~umf4zsol interface~umf4sol umf4sol interface~umf4sol->interface~umf4zsol interface~umf4sol->interface~umf4sol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zsol umf4zsol_ip umf4csol umf4csol_ip Module Procedures public interface umf4zsol () Arguments None public subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csol () Arguments None public subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","loc":"interface/umf4zsol.html"},{"tags":"","title":"umf4sol – MUSST","text":"public interface umf4sol Calls interface~~umf4sol~~CallsGraph interface~umf4sol umf4sol interface~umf4sol->interface~umf4sol proc~umf4sol_ip umf4sol_ip interface~umf4sol->proc~umf4sol_ip proc~umf4csol_ip umf4csol_ip interface~umf4sol->proc~umf4csol_ip interface~umf4csol umf4csol interface~umf4sol->interface~umf4csol proc~umf4zsol_ip umf4zsol_ip interface~umf4sol->proc~umf4zsol_ip interface~umf4zsol umf4zsol interface~umf4sol->interface~umf4zsol interface~s_umfpack_solve s_umfpack_solve proc~umf4sol_ip->interface~s_umfpack_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umf4csol_ip->proc~s_umfpack_ci_solve interface~umf4csol->proc~umf4csol_ip interface~umf4csol->interface~umf4csol interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umf4zsol_ip->interface~s_umfpack_zi_solve interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->interface~umf4csol interface~umf4zsol->proc~umf4zsol_ip interface~umf4zsol->interface~umf4zsol interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var paninterfaceumf4solCallsGraph = svgPanZoom('#interfaceumf4solCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4sol umf4sol_ip umf4zsol umf4zsol_ip umf4csol umf4csol_ip Module Procedures public interface umf4sol () Arguments None public subroutine umf4sol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsol () Arguments None public subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csol () Arguments None public subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","loc":"interface/umf4sol.html"},{"tags":"","title":"umf4cscal – MUSST","text":"public interface umf4cscal Calls interface~~umf4cscal~~CallsGraph interface~umf4cscal umf4cscal interface~umf4cscal->interface~umf4cscal proc~umf4cscal_ip umf4cscal_ip interface~umf4cscal->proc~umf4cscal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal_ip->interface~umfpack_scale_function proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale var paninterfaceumf4cscalCallsGraph = svgPanZoom('#interfaceumf4cscalCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4cscal~~CalledByGraph interface~umf4cscal umf4cscal interface~umf4cscal->interface~umf4cscal interface~umf4zscal umf4zscal interface~umf4zscal->interface~umf4cscal interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->interface~umf4cscal interface~umf4scal->interface~umf4scal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4cscal umf4cscal_ip Module Procedures public interface umf4cscal () Arguments None public subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status","loc":"interface/umf4cscal.html"},{"tags":"","title":"umf4zscal – MUSST","text":"public interface umf4zscal Calls interface~~umf4zscal~~CallsGraph interface~umf4zscal umf4zscal interface~umf4zscal->interface~umf4zscal proc~umf4zscal_ip umf4zscal_ip interface~umf4zscal->proc~umf4zscal_ip proc~umf4cscal_ip umf4cscal_ip interface~umf4zscal->proc~umf4cscal_ip interface~umf4cscal umf4cscal interface~umf4zscal->interface~umf4cscal interface~umfpack_scale_function umfpack_scale_function proc~umf4zscal_ip->interface~umfpack_scale_function proc~umf4cscal_ip->interface~umfpack_scale_function interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale var paninterfaceumf4zscalCallsGraph = svgPanZoom('#interfaceumf4zscalCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~umf4zscal~~CalledByGraph interface~umf4zscal umf4zscal interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->interface~umf4zscal interface~umf4scal->interface~umf4scal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zscal umf4zscal_ip umf4cscal umf4cscal_ip Module Procedures public interface umf4zscal () Arguments None public subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4cscal () Arguments None public subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status","loc":"interface/umf4zscal.html"},{"tags":"","title":"umf4scal – MUSST","text":"public interface umf4scal Calls interface~~umf4scal~~CallsGraph interface~umf4scal umf4scal interface~umf4scal->interface~umf4scal proc~umf4cscal_ip umf4cscal_ip interface~umf4scal->proc~umf4cscal_ip interface~umf4zscal umf4zscal interface~umf4scal->interface~umf4zscal proc~umf4zscal_ip umf4zscal_ip interface~umf4scal->proc~umf4zscal_ip proc~umf4scal_ip umf4scal_ip interface~umf4scal->proc~umf4scal_ip interface~umf4cscal umf4cscal interface~umf4scal->interface~umf4cscal interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal_ip->interface~umfpack_scale_function interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->interface~umf4zscal interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->interface~umf4cscal proc~umf4zscal_ip->interface~umfpack_scale_function proc~umf4scal_ip->interface~umfpack_scale_function interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale var paninterfaceumf4scalCallsGraph = svgPanZoom('#interfaceumf4scalCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4scal umf4scal_ip umf4zscal umf4zscal_ip umf4cscal umf4cscal_ip Module Procedures public interface umf4scal () Arguments None public subroutine umf4scal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4zscal () Arguments None public subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4cscal () Arguments None public subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status","loc":"interface/umf4scal.html"},{"tags":"","title":"umf4cfnum – MUSST","text":"public interface umf4cfnum Calls interface~~umf4cfnum~~CallsGraph interface~umf4cfnum umf4cfnum interface~umf4cfnum->interface~umf4cfnum proc~umf4cfnum_ip umf4cfnum_ip interface~umf4cfnum->proc~umf4cfnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric var paninterfaceumf4cfnumCallsGraph = svgPanZoom('#interfaceumf4cfnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4cfnum umf4cfnum_ip Module Procedures public interface umf4cfnum () Arguments None public subroutine umf4cfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric","loc":"interface/umf4cfnum.html"},{"tags":"","title":"umf4zfnum – MUSST","text":"public interface umf4zfnum Calls interface~~umf4zfnum~~CallsGraph interface~umf4zfnum umf4zfnum interface~umf4zfnum->interface~umf4zfnum proc~umf4zfnum_ip umf4zfnum_ip interface~umf4zfnum->proc~umf4zfnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4zfnum_ip->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric var paninterfaceumf4zfnumCallsGraph = svgPanZoom('#interfaceumf4zfnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zfnum umf4zfnum_ip Module Procedures public interface umf4zfnum () Arguments None public subroutine umf4zfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric","loc":"interface/umf4zfnum.html"},{"tags":"","title":"umf4fnum – MUSST","text":"public interface umf4fnum Calls interface~~umf4fnum~~CallsGraph interface~umf4fnum umf4fnum interface~umf4fnum->interface~umf4fnum proc~umf4fnum_ip umf4fnum_ip interface~umf4fnum->proc~umf4fnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric var paninterfaceumf4fnumCallsGraph = svgPanZoom('#interfaceumf4fnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4fnum umf4fnum_ip Module Procedures public interface umf4fnum () Arguments None public subroutine umf4fnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric","loc":"interface/umf4fnum.html"},{"tags":"","title":"umf4cfsym – MUSST","text":"public interface umf4cfsym Calls interface~~umf4cfsym~~CallsGraph interface~umf4cfsym umf4cfsym interface~umf4cfsym->interface~umf4cfsym proc~umf4cfsym_ip umf4cfsym_ip interface~umf4cfsym->proc~umf4cfsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic var paninterfaceumf4cfsymCallsGraph = svgPanZoom('#interfaceumf4cfsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4cfsym umf4cfsym_ip Module Procedures public interface umf4cfsym () Arguments None public subroutine umf4cfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic","loc":"interface/umf4cfsym.html"},{"tags":"","title":"umf4zfsym – MUSST","text":"public interface umf4zfsym Calls interface~~umf4zfsym~~CallsGraph interface~umf4zfsym umf4zfsym interface~umf4zfsym->interface~umf4zfsym proc~umf4zfsym_ip umf4zfsym_ip interface~umf4zfsym->proc~umf4zfsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4zfsym_ip->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic var paninterfaceumf4zfsymCallsGraph = svgPanZoom('#interfaceumf4zfsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zfsym umf4zfsym_ip Module Procedures public interface umf4zfsym () Arguments None public subroutine umf4zfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic","loc":"interface/umf4zfsym.html"},{"tags":"","title":"umf4fsym – MUSST","text":"public interface umf4fsym Calls interface~~umf4fsym~~CallsGraph interface~umf4fsym umf4fsym interface~umf4fsym->interface~umf4fsym proc~umf4fsym_ip umf4fsym_ip interface~umf4fsym->proc~umf4fsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4fsym_ip->proc~umfpack_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic var paninterfaceumf4fsymCallsGraph = svgPanZoom('#interfaceumf4fsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4fsym umf4fsym_ip Module Procedures public interface umf4fsym () Arguments None public subroutine umf4fsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic","loc":"interface/umf4fsym.html"},{"tags":"","title":"umf4csnum – MUSST","text":"public interface umf4csnum Calls interface~~umf4csnum~~CallsGraph interface~umf4csnum umf4csnum interface~umf4csnum->interface~umf4csnum proc~umf4csnum_ip umf4csnum_ip interface~umf4csnum->proc~umf4csnum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric var paninterfaceumf4csnumCallsGraph = svgPanZoom('#interfaceumf4csnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4csnum umf4csnum_ip Module Procedures public interface umf4csnum () Arguments None public subroutine umf4csnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","loc":"interface/umf4csnum.html"},{"tags":"","title":"umf4zsnum – MUSST","text":"public interface umf4zsnum Calls interface~~umf4zsnum~~CallsGraph interface~umf4zsnum umf4zsnum interface~umf4zsnum->interface~umf4zsnum proc~umf4zsnum_ip umf4zsnum_ip interface~umf4zsnum->proc~umf4zsnum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric var paninterfaceumf4zsnumCallsGraph = svgPanZoom('#interfaceumf4zsnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zsnum umf4zsnum_ip Module Procedures public interface umf4zsnum () Arguments None public subroutine umf4zsnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","loc":"interface/umf4zsnum.html"},{"tags":"","title":"umf4snum – MUSST","text":"public interface umf4snum Calls interface~~umf4snum~~CallsGraph interface~umf4snum umf4snum interface~umf4snum->interface~umf4snum proc~umf4snum_ip umf4snum_ip interface~umf4snum->proc~umf4snum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4snum_ip->proc~umfpack_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric var paninterfaceumf4snumCallsGraph = svgPanZoom('#interfaceumf4snumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4snum umf4snum_ip Module Procedures public interface umf4snum () Arguments None public subroutine umf4snum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","loc":"interface/umf4snum.html"},{"tags":"","title":"umf4cssym – MUSST","text":"public interface umf4cssym Calls interface~~umf4cssym~~CallsGraph interface~umf4cssym umf4cssym interface~umf4cssym->interface~umf4cssym proc~umf4cssym_ip umf4cssym_ip interface~umf4cssym->proc~umf4cssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic var paninterfaceumf4cssymCallsGraph = svgPanZoom('#interfaceumf4cssymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4cssym umf4cssym_ip Module Procedures public interface umf4cssym () Arguments None public subroutine umf4cssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","loc":"interface/umf4cssym.html"},{"tags":"","title":"umf4zssym – MUSST","text":"public interface umf4zssym Calls interface~~umf4zssym~~CallsGraph interface~umf4zssym umf4zssym interface~umf4zssym->interface~umf4zssym proc~umf4zssym_ip umf4zssym_ip interface~umf4zssym->proc~umf4zssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic var paninterfaceumf4zssymCallsGraph = svgPanZoom('#interfaceumf4zssymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zssym umf4zssym_ip Module Procedures public interface umf4zssym () Arguments None public subroutine umf4zssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","loc":"interface/umf4zssym.html"},{"tags":"","title":"umf4ssym – MUSST","text":"public interface umf4ssym Calls interface~~umf4ssym~~CallsGraph interface~umf4ssym umf4ssym interface~umf4ssym->interface~umf4ssym proc~umf4ssym_ip umf4ssym_ip interface~umf4ssym->proc~umf4ssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4ssym_ip->proc~umfpack_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic var paninterfaceumf4ssymCallsGraph = svgPanZoom('#interfaceumf4ssymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4ssym umf4ssym_ip Module Procedures public interface umf4ssym () Arguments None public subroutine umf4ssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","loc":"interface/umf4ssym.html"},{"tags":"","title":"umf4clnum – MUSST","text":"public interface umf4clnum Calls interface~~umf4clnum~~CallsGraph interface~umf4clnum umf4clnum interface~umf4clnum->interface~umf4clnum proc~umf4clnum_ip umf4clnum_ip interface~umf4clnum->proc~umf4clnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric var paninterfaceumf4clnumCallsGraph = svgPanZoom('#interfaceumf4clnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4clnum umf4clnum_ip Module Procedures public interface umf4clnum () Arguments None public subroutine umf4clnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","loc":"interface/umf4clnum.html"},{"tags":"","title":"umf4zlnum – MUSST","text":"public interface umf4zlnum Calls interface~~umf4zlnum~~CallsGraph interface~umf4zlnum umf4zlnum interface~umf4zlnum->interface~umf4zlnum proc~umf4zlnum_ip umf4zlnum_ip interface~umf4zlnum->proc~umf4zlnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric var paninterfaceumf4zlnumCallsGraph = svgPanZoom('#interfaceumf4zlnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zlnum umf4zlnum_ip Module Procedures public interface umf4zlnum () Arguments None public subroutine umf4zlnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","loc":"interface/umf4zlnum.html"},{"tags":"","title":"umf4lnum – MUSST","text":"public interface umf4lnum Calls interface~~umf4lnum~~CallsGraph interface~umf4lnum umf4lnum interface~umf4lnum->interface~umf4lnum proc~umf4lnum_ip umf4lnum_ip interface~umf4lnum->proc~umf4lnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric var paninterfaceumf4lnumCallsGraph = svgPanZoom('#interfaceumf4lnumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4lnum umf4lnum_ip Module Procedures public interface umf4lnum () Arguments None public subroutine umf4lnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","loc":"interface/umf4lnum.html"},{"tags":"","title":"umf4clsym – MUSST","text":"public interface umf4clsym Calls interface~~umf4clsym~~CallsGraph interface~umf4clsym umf4clsym interface~umf4clsym->interface~umf4clsym proc~umf4clsym_ip umf4clsym_ip interface~umf4clsym->proc~umf4clsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4clsym_ip->proc~umfpack_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic var paninterfaceumf4clsymCallsGraph = svgPanZoom('#interfaceumf4clsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4clsym umf4clsym_ip Module Procedures public interface umf4clsym () Arguments None public subroutine umf4clsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","loc":"interface/umf4clsym.html"},{"tags":"","title":"umf4zlsym – MUSST","text":"public interface umf4zlsym Calls interface~~umf4zlsym~~CallsGraph interface~umf4zlsym umf4zlsym interface~umf4zlsym->interface~umf4zlsym proc~umf4zlsym_ip umf4zlsym_ip interface~umf4zlsym->proc~umf4zlsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic var paninterfaceumf4zlsymCallsGraph = svgPanZoom('#interfaceumf4zlsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4zlsym umf4zlsym_ip Module Procedures public interface umf4zlsym () Arguments None public subroutine umf4zlsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","loc":"interface/umf4zlsym.html"},{"tags":"","title":"umf4lsym – MUSST","text":"public interface umf4lsym Calls interface~~umf4lsym~~CallsGraph interface~umf4lsym umf4lsym interface~umf4lsym->interface~umf4lsym proc~umf4lsym_ip umf4lsym_ip interface~umf4lsym->proc~umf4lsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic var paninterfaceumf4lsymCallsGraph = svgPanZoom('#interfaceumf4lsymCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umf4lsym umf4lsym_ip Module Procedures public interface umf4lsym () Arguments None public subroutine umf4lsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","loc":"interface/umf4lsym.html"},{"tags":"","title":"pCSC – MUSST","text":"public interface pCSC Calls interface~~pcsc~~CallsGraph interface~pcsc pCSC proc~make_csc_zi make_CSC_zi interface~pcsc->proc~make_csc_zi proc~make_csc_di make_CSC_di interface~pcsc->proc~make_csc_di proc~make_csc_ci make_CSC_ci interface~pcsc->proc~make_csc_ci Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures make_CSC_di make_CSC_zi make_CSC_ci Module Procedures public function make_CSC_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_di ) public function make_CSC_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSC_zi ) public function make_CSC_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_ci )","loc":"interface/pcsc.html"},{"tags":"","title":"pCSR – MUSST","text":"public interface pCSR Calls interface~~pcsr~~CallsGraph interface~pcsr pCSR proc~make_csr_zi make_CSR_zi interface~pcsr->proc~make_csr_zi proc~make_csr_ci make_CSR_ci interface~pcsr->proc~make_csr_ci proc~make_csr_di make_CSR_di interface~pcsr->proc~make_csr_di Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures make_CSR_di make_CSR_zi make_CSR_ci Module Procedures public function make_CSR_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_di ) public function make_CSR_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSR_zi ) public function make_CSR_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_ci )","loc":"interface/pcsr.html"},{"tags":"","title":"pVec – MUSST","text":"public interface pVec Calls interface~~pvec~~CallsGraph interface~pvec pVec proc~make_vec_zi make_Vec_zi interface~pvec->proc~make_vec_zi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures make_Vec_zi Module Procedures public function make_Vec_zi (bx, bz) result(result) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), target :: bx (:) real(kind=r8), intent(in), target :: bz (:) Return Value type( pVec_zi )","loc":"interface/pvec.html"},{"tags":"","title":"operator(.umfpack.) – MUSST","text":"public interface operator(.umfpack.) Calls interface~~operator(.umfpack.)~~CallsGraph interface~operator(.umfpack.) operator(.umfpack.) proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr proc~umfpack_di_operator_csc umfpack_di_operator_CSC interface~operator(.umfpack.)->proc~umfpack_di_operator_csc proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umfpack_di_operator_csr umfpack_di_operator_CSR interface~operator(.umfpack.)->proc~umfpack_di_operator_csr proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_numeric proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_symbolic proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_symbolic proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csc->proc~umfpack_di_free_numeric proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csc->proc~umfpack_di_free_symbolic proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_symbolic proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csr->proc~umfpack_di_free_numeric proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csr->proc~umfpack_di_free_symbolic proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_symbolic proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve var paninterfaceoperatorumfpackCallsGraph = svgPanZoom('#interfaceoperatorumfpackCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures umfpack_di_operator_CSC umfpack_zi_operator_CSC umfpack_ci_operator_CSC umfpack_di_operator_CSR umfpack_zi_operator_CSR umfpack_ci_operator_CSR umfpack_di_operator_pCSC umfpack_zi_operator_pCSC umfpack_ci_operator_pCSC umfpack_di_operator_pCSR umfpack_zi_operator_pCSR umfpack_ci_operator_pCSR Module Procedures public function umfpack_di_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1)","loc":"interface/operator(.umfpack.).html"},{"tags":"","title":"data_film_hd – MUSST","text":"Definition of the data for a film solution problem Uses data_arch fluid_law module~~data_film_hd~~UsesGraph module~data_film_hd data_film_hd module~fluid_law fluid_law module~data_film_hd->module~fluid_law module~data_arch data_arch module~data_film_hd->module~data_arch module~fluid_law->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~data_film_hd~~UsedByGraph module~data_film_hd data_film_hd module~test_musst test_musst module~test_musst->module~data_film_hd module~film film module~test_musst->module~film module~ms_film ms_film module~test_musst->module~ms_film module~inout_files inout_files module~test_musst->module~inout_files module~film->module~data_film_hd module~ms_film->module~data_film_hd module~ms_film->module~film module~inout_files->module~film module~inout_files->module~ms_film program~main main program~main->module~test_musst Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables HD Derived Types DATA_FILM Variables Type Visibility Attributes Name Initial integer(kind=I4), public, parameter :: HD = 0 code for problem type, 0 : hydrodynamic problem Derived Types type, public :: DATA_FILM Components Type Visibility Attributes Name Initial real(kind=R8), public :: h_0 h_0 : ambient pressure real(kind=R8), public :: h_g h_g : cavitation pressure real(kind=R8), public :: V_x V_x : surface velocity along x real(kind=R8), public :: V_y V_y : surface velocity along y type(FLUID), public :: fl fluid rheological properties integer(kind=I4), public :: pb_type problem type, e.g. HD (hydrodynamic)","loc":"module/data_film_hd.html"},{"tags":"","title":"film – MUSST","text":"FE solution of the Reynolds equation Description of the film module This is the main module for the finite element solution of the Reynolds equation. Definition of FE_film FE_FILM is a data structure containing a FE_MESH and some data describing a lubrication problem Solution procedure This module can be used to create a FE_FILM, assemble the FE_FIM and solve it. Some post-treatements like fluxes, forces are available. Uses data_arch data_film_hd fluid_law num_param mesh solver elements omp_lib surfile module~~film~~UsesGraph module~film film module~mesh mesh module~film->module~mesh module~fluid_law fluid_law module~film->module~fluid_law module~surfile surfile module~film->module~surfile module~elements elements module~film->module~elements omp_lib omp_lib module~film->omp_lib module~solver solver module~film->module~solver module~data_film_hd data_film_hd module~film->module~data_film_hd module~num_param num_param module~film->module~num_param module~data_arch data_arch module~film->module~data_arch module~mesh->module~data_arch module~fluid_law->module~data_arch module~surfile->module~data_arch iso_c_binding iso_c_binding module~surfile->iso_c_binding module~sort_arrays sort_arrays module~surfile->module~sort_arrays module~elements->module~data_arch module~solver->module~data_arch module~sulu_wrapper sulu_wrapper module~solver->module~sulu_wrapper module~gen_param gen_param module~solver->module~gen_param module~mumfpack mumfpack module~solver->module~mumfpack module~solver->iso_c_binding iso_fortran_env iso_fortran_env module~solver->iso_fortran_env module~mumps_wrapper mumps_wrapper module~solver->module~mumps_wrapper module~solver->module~sort_arrays hsl_ma48_double hsl_ma48_double module~solver->hsl_ma48_double module~data_film_hd->module~fluid_law module~data_film_hd->module~data_arch module~num_param->module~data_arch module~num_param->iso_fortran_env module~data_arch->iso_fortran_env module~sulu_wrapper->iso_c_binding module~gen_param->module~data_arch module~mumfpack->iso_c_binding module~sort_arrays->module~data_arch Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~film~~UsedByGraph module~film film module~test_musst test_musst module~test_musst->module~film module~inout_files inout_files module~test_musst->module~inout_files module~ms_film ms_film module~test_musst->module~ms_film module~inout_files->module~film module~inout_files->module~ms_film module~ms_film->module~film program~main main program~main->module~test_musst Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables H1_N H2_N H_N P_N RHO_N T_N DRHODP_N MU_N VX_N VY_N HG_C PEK_C PEE_C REY ASS NO_ASS NO_BC scal_tmp BC_SPLINE Derived Types PRC_TAB FE_FILM Functions fz fx fy Subroutines create_rect_FE_film solve_FE_film apply_bc_FE_film apply_bc_FE_film_simple assembly_FE_film_reynolds assemble_in_mat_sol elementary_assembly_FE_film_reynolds elementary_full_domain_FE_film_reynolds init_prc_tab compute_prc_tables_reynolds_supg length_width_elem compute_corner_fluxes save_fe_field Variables Type Visibility Attributes Name Initial integer(kind=I4), public, parameter :: H1_N = 1 code for bottom surface height h_1 integer(kind=I4), public, parameter :: H2_N = 2 code for top surface height h_2 integer(kind=I4), public, parameter :: H_N = 3 code for film thickness h integer(kind=I4), public, parameter :: P_N = 4 code for film absolute pressure p integer(kind=I4), public, parameter :: RHO_N = 5 code for fluid density \\rho integer(kind=I4), public, parameter :: T_N = 6 code for film absolute temperature T integer(kind=I4), public, parameter :: DRHODP_N = 7 code for film compressibility \\frac{\\partial \\rho}{\\partial p} integer(kind=I4), public, parameter :: MU_N = 8 code for fluid viscosity \\mu integer(kind=I4), public, parameter :: VX_N = 9 code for surface velocity along x V_x . Should be modified (surfaces 1 and 2) integer(kind=I4), public, parameter :: VY_N = 10 code for surface velocity along y V_y . Should be modified (surfaces 1 and 2) integer(kind=I4), public, parameter :: HG_C = 1 code for groove depth on the stationnary surface h_g , cell variable integer(kind=I4), public, parameter :: PEK_C = 2 code for Peclet number along \\xi integer(kind=I4), public, parameter :: PEE_C = 3 code for Peclet number along \\eta integer(kind=I4), public, parameter :: REY = 1 code for imposed pressure at the boundary integer(kind=I4), public, parameter :: ASS = 1 code for assembly of the system integer(kind=I4), public, parameter :: NO_ASS = 0 code for no assemble, computation of the residual only integer(kind=I4), public, parameter :: NO_BC = -1 code for computation of the residual everywhere, even at the boundaries (fluxes computations) type(SCALE_SURF), private :: scal_tmp object SCALE_SURF logical(kind=I4), public, parameter :: BC_SPLINE = .false. instead of linearly interpolating the boundary pressures, it can be done in a smoother way. NOT TO BE USED YET. Derived Types type, public :: PRC_TAB PRC_TAB stores some precomputed coefficients for the finite element matrices Components Type Visibility Attributes Name Initial integer(kind=I4), public :: ng Gauss point number along a direction real(kind=R8), public, dimension(:), allocatable :: pg point coordinates in a direction real(kind=R8), public, dimension(:), allocatable :: wg point weight real(kind=R8), public, dimension(:,:,:), allocatable :: vni4 for each node, shape function at Gauss points real(kind=R8), public, dimension(:,:,:), allocatable :: vni4x for each node, shape function derivative at Gauss points real(kind=R8), public, dimension(:,:,:), allocatable :: vni4y for each node, shape function derivative at Gauss points real(kind=R8), public, dimension(:,:,:), allocatable :: vni4d for each node, upwind shape function at Gauss points real(kind=R8), public, dimension(:,:,:), allocatable :: vcal 14 values calculated at the Gauss points type, public :: FE_FILM FE_FILM stores the whole stuff related to a film: the nodal variables, the mesh, etc. Components Type Visibility Attributes Name Initial integer(kind=I4), public :: n_vn number of nodal variables integer(kind=I4), public :: n_vc number of variables on cells type(FE_MESH), public :: m mesh of the film type(DATA_FILM), public :: data_f data of the problem type( PRC_TAB ), public :: prc precomputation type(NUM_PAR), public :: num_p numerical param for iterative solution real(kind=R8), public, dimension(:,:), allocatable :: vn nodal variables table real(kind=R8), public, dimension(:,:), allocatable :: vc cell variables table integer(kind=I4), public, dimension(:,:), allocatable :: bc boundary nodes code character(len=20), public, dimension(:), allocatable :: vn_name nodal variable names character(len=20), public, dimension(:), allocatable :: vc_name cell variable names Type-Bound Procedures procedure, public :: fx force computation along x procedure, public :: fy force computation along y procedure, public :: fz force computation along z Functions private function fz (fe_f) Read more… Arguments Type Intent Optional Attributes Name class( FE_FILM ), intent(inout) :: fe_f fluid type Return Value real(kind=R8) private function fx (fe_f) Read more… Arguments Type Intent Optional Attributes Name class( FE_FILM ), intent(inout) :: fe_f FE film Return Value real(kind=R8) private function fy (fe_f) Read more… Arguments Type Intent Optional Attributes Name class( FE_FILM ), intent(inout) :: fe_f FE film Return Value real(kind=R8) Subroutines public subroutine create_rect_FE_film (data_f, num_p, fe_f) Read more… Arguments Type Intent Optional Attributes Name type(DATA_FILM), intent(inout) :: data_f data of the film type(NUM_PAR), intent(in) :: num_p numerical param for iterative solution type( FE_FILM ), intent(inout) :: fe_f FE film data type public subroutine solve_FE_film (fe_f, mat, bc, flag_ass) Read more… Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE film data type type(MAT_SOLV), intent(inout) :: mat matrices for solving real(kind=R8), intent(in), dimension(MAX_NNC) :: bc boundary conditions at the corners logical(kind=I4), intent(in), optional :: flag_ass optional flag for assembly public subroutine apply_bc_FE_film (fe_f, bc) Read more… Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE film data type real(kind=R8), intent(in), dimension(MAX_NNC) :: bc boundary conditions at the corners public subroutine apply_bc_FE_film_simple (fe_f, bc) Read more… Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE film data type real(kind=R8), intent(in), dimension(MAX_NNC) :: bc boundary conditions at the corners public subroutine assembly_FE_film_reynolds (fe_f, mat, ass_c) Read more… Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE_film data type type(MAT_SOLV), intent(inout) :: mat matrices for solving integer(kind=I4), intent(in) :: ass_c assembly type public subroutine assemble_in_mat_sol (mat, num, nelt, nline, tind, m_elt, compt) Read more… Arguments Type Intent Optional Attributes Name type(MAT_SOLV), intent(inout) :: mat mat_solv type integer(kind=I4), intent(in) :: num element number integer(kind=I4), intent(in) :: nelt size of elemental matrix integer(kind=I4), intent(in) :: nline number of lines integer(kind=I4), intent(in), dimension(nelt) :: tind index table of elemental matrix real(kind=R8), intent(in), dimension(nelt, nelt) :: m_elt elemental matrix integer(kind=I4), intent(inout), dimension(2) :: compt number to index the position in the solver matrix private subroutine elementary_assembly_FE_film_reynolds (fe_f, ke_ij, be_i, ind_e, e, ass_c) Read more… Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE film real(kind=R8), intent(out), dimension(MAX_NNE, MAX_NNE) :: ke_ij elementary matrix real(kind=R8), intent(out), dimension(MAX_NNE) :: be_i elementary rhs member integer(kind=I4), intent(out), dimension(MAX_NNE) :: ind_e elementary index member integer(kind=I4), intent(in) :: e element number integer(kind=I4), intent(in) :: ass_c assembly type public subroutine elementary_full_domain_FE_film_reynolds (fe_f, mat, ke_ij, be_i, ind_e) Read more… Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE film type(MAT_SOLV), intent(inout) :: mat solver type matrices real(kind=R8), intent(out), dimension(MAX_NNC, MAX_NNC) :: ke_ij elementary matrix real(kind=R8), intent(inout), dimension(MAX_NNC         ) :: be_i elementary rhs member integer(kind=I4), intent(out), dimension(MAX_NNC         ) :: ind_e elementary index member public subroutine init_prc_tab (fe_f) Read more… Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f private subroutine compute_prc_tables_reynolds_supg (fe_f, e) Read more… Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE film integer(kind=I4), intent(in) :: e element number private subroutine length_width_elem (spdx, spdy, x, y, length, width) Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: spdx fluid velocity along x axis real(kind=R8), intent(in) :: spdy fluid velocity along y axis real(kind=R8), intent(in), dimension(4) :: x corner abscissae real(kind=R8), intent(in), dimension(4) :: y corner ordinates real(kind=R8), intent(out) :: length fluid element length real(kind=R8), intent(out) :: width fluid element width public subroutine compute_corner_fluxes (fe_f, mat, bf) Read more… Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(inout) :: fe_f FE film type(MAT_SOLV), intent(inout) :: mat solver type matrices real(kind=R8), intent(out), dimension(MAX_NNC) :: bf table of fluxes at the corner public subroutine save_fe_field (fe_f, file_name, code, nodal) Read more… Arguments Type Intent Optional Attributes Name type( FE_FILM ), intent(in) :: fe_f character(len=*), intent(in) :: file_name integer(kind=I4), intent(in) :: code logical(kind=I4), intent(in) :: nodal if false : cell value, if true : nodal value","loc":"module/film.html"},{"tags":"","title":"fluid_law – MUSST","text":"Rheological and thermodynamic behavior of fluid Description of the fluid module The fluid module module_fluid_law proposes different rheological and thermodynamic laws for the fluids. Fluid type In the current version, three fluid types are proposed: incompressible liquid perfect gas mixture of liquid and gaz The fluid parameters are: \\rho_0 ,  liquid density; r_g ,     the perfect gas constant of the considered gas; \\lambda , the gas mass fraction. Density and compressibility The module is limited to the density \\rho rho and compressibility \\frac{\\partial \\rho}{\\partial p} drhodp computation based on the pressure p and absolute temperature t Incompressible INC \\rho=\\rho_0 \\frac{\\partial \\rho}{\\partial p}=0 Perfect gas GP \\rho=\\frac{p}{r_g T} \\frac{\\partial \\rho}{\\partial p}=\\frac{1}{r_g T} Mixture MIXT \\rho=\\frac{1}{\\frac{1-\\lambda}{\\rho_0}+\\frac{\\lambda r_g T}{p}} \\frac{\\partial \\rho}{\\partial p}=\\frac{\\lambda \\rho_O&#94;2 r_g T}{\\left(p(1-\\lambda) +\\lambda r_g T \\rho_0\\right)&#94;2} Uses data_arch module~~fluid_law~~UsesGraph module~fluid_law fluid_law module~data_arch data_arch module~fluid_law->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~fluid_law~~UsedByGraph module~fluid_law fluid_law module~film film module~film->module~fluid_law module~data_film_hd data_film_hd module~film->module~data_film_hd module~ms_film ms_film module~ms_film->module~fluid_law module~ms_film->module~film module~ms_film->module~data_film_hd module~data_film_hd->module~fluid_law module~test_musst test_musst module~test_musst->module~film module~test_musst->module~ms_film module~test_musst->module~data_film_hd module~inout_files inout_files module~test_musst->module~inout_files module~inout_files->module~film module~inout_files->module~ms_film program~main main program~main->module~test_musst Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables INC GP MIXT Derived Types FLUID Functions rho drhodp pres Variables Type Visibility Attributes Name Initial integer(kind=I4), public, parameter :: INC = 0 incompressible fluid integer(kind=I4), public, parameter :: GP = 1 perfect gas integer(kind=I4), public, parameter :: MIXT = 2 mixture of liquid and gas Derived Types type, public :: FLUID Components Type Visibility Attributes Name Initial integer(kind=I4), public :: fluid_type constant for the fluid type: INC, GP, MIXT real(kind=R8), public :: p_0 reference pressure real(kind=R8), public :: rho_0 reference liquid density real(kind=R8), public :: mu_0 reference dynamic viscosity real(kind=R8), public :: T_0 reference temperature real(kind=R8), public :: rg perfect gas constant real(kind=R8), public :: lambda gas mass fraction real(kind=R8), public, dimension(20) :: cst table of parameters for the thermodynamic and rheological laws Type-Bound Procedures procedure, public :: rho density procedure, public :: drhodp compressibility procedure, public :: pres pressure (perfect gas) Functions private function rho (fl, p, t) Read more… Arguments Type Intent Optional Attributes Name class( FLUID ), intent(in) :: fl fluid type real(kind=R8), intent(in) :: p pressure real(kind=R8), intent(in) :: t absolute temperature Return Value real(kind=R8) private function drhodp (fl, p, t) Read more… Arguments Type Intent Optional Attributes Name class( FLUID ), intent(in) :: fl fluid type real(kind=R8), intent(in) :: p pressure real(kind=R8), intent(in) :: t absolute temperature Return Value real(kind=R8) private function pres (fl, rho, t) Read more… Arguments Type Intent Optional Attributes Name class( FLUID ), intent(in) :: fl fluid type real(kind=R8), intent(in) :: rho density real(kind=R8), intent(in) :: t absolute temperature Return Value real(kind=R8)","loc":"module/fluid_law.html"},{"tags":"","title":"inout_files – MUSST","text":"Subroutines to save the data Uses VTK data_arch film ms_film surfile module~~inout_files~~UsesGraph module~inout_files inout_files module~surfile surfile module~inout_files->module~surfile module~film film module~inout_files->module~film module~vtk VTK module~inout_files->module~vtk module~ms_film ms_film module~inout_files->module~ms_film module~data_arch data_arch module~inout_files->module~data_arch module~surfile->module~data_arch iso_c_binding iso_c_binding module~surfile->iso_c_binding module~sort_arrays sort_arrays module~surfile->module~sort_arrays module~film->module~surfile module~film->module~data_arch module~mesh mesh module~film->module~mesh module~fluid_law fluid_law module~film->module~fluid_law omp_lib omp_lib module~film->omp_lib module~elements elements module~film->module~elements module~solver solver module~film->module~solver module~data_film_hd data_film_hd module~film->module~data_film_hd module~num_param num_param module~film->module~num_param module~ir_vtk IR_VTK module~vtk->module~ir_vtk module~ms_film->module~surfile module~ms_film->module~film module~ms_film->module~data_arch module~ms_film->module~mesh module~ms_film->module~fluid_law module~bspline bspline module~ms_film->module~bspline module~ms_film->omp_lib module~ms_film->module~solver module~ms_film->module~data_film_hd module~ms_film->module~num_param iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~mesh->module~data_arch module~fluid_law->module~data_arch module~bspline->iso_fortran_env module~elements->module~data_arch module~solver->module~data_arch module~solver->iso_c_binding module~solver->iso_fortran_env module~solver->module~sort_arrays module~mumfpack mumfpack module~solver->module~mumfpack hsl_ma48_double hsl_ma48_double module~solver->hsl_ma48_double module~mumps_wrapper mumps_wrapper module~solver->module~mumps_wrapper module~gen_param gen_param module~solver->module~gen_param module~sulu_wrapper sulu_wrapper module~solver->module~sulu_wrapper module~data_film_hd->module~data_arch module~data_film_hd->module~fluid_law module~sort_arrays->module~data_arch module~num_param->module~data_arch module~num_param->iso_fortran_env module~mumfpack->iso_c_binding module~gen_param->module~data_arch module~sulu_wrapper->iso_c_binding var panmoduleinout_filesUsesGraph = svgPanZoom('#moduleinout_filesUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~inout_files~~UsedByGraph module~inout_files inout_files module~test_musst test_musst module~test_musst->module~inout_files program~main main program~main->module~test_musst Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables s_vtk NO_VTK TS_VTK BS_VTK Subroutines save_fe_f_vtk save_ms_fe_f_vtk save_profile_x_fe save_profile_x_ms save_profile_x_comp_slider save_profile_x_comp_air_pocket save_profile_y_comp_air_pocket Variables Type Visibility Attributes Name Initial integer(kind=I4), public :: s_vtk integer(kind=I4), public, parameter :: NO_VTK = 0 integer(kind=I4), public, parameter :: TS_VTK = 1 integer(kind=I4), public, parameter :: BS_VTK = 2 Subroutines public subroutine save_fe_f_vtk (fe_f, nom_fic) Read more… Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(in) :: fe_f FE_FILM element to store character(len=*), intent(in) :: nom_fic filename public subroutine save_ms_fe_f_vtk (ms_fe_f, nom_fic) Read more… Arguments Type Intent Optional Attributes Name type(MS_FE_FILM), intent(in) :: ms_fe_f MS_FE_FILM element to store character(len=*), intent(in) :: nom_fic filename public subroutine save_profile_x_fe (fe_f, file_name, lx, zy) Read more… Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(in) :: fe_f FE_FILM element character(len=*), intent(in) :: file_name filename real(kind=R8), intent(in) :: lx surface length real(kind=R8), intent(in) :: zy distance from a border public subroutine save_profile_x_ms (ms_fe_f, file_name, lx, zy) Read more… Arguments Type Intent Optional Attributes Name type(MS_FE_FILM), intent(in) :: ms_fe_f MS_FE_FILM element character(len=*), intent(in) :: file_name filename real(kind=R8), intent(in) :: lx surface length real(kind=R8), intent(in) :: zy distance from a border public subroutine save_profile_x_comp_slider (fe_f, file_name, lx, zy) Read more… Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(in) :: fe_f FE_FILM element character(len=*), intent(in) :: file_name filename real(kind=R8), intent(in) :: lx slider length real(kind=R8), intent(in) :: zy distance from a border public subroutine save_profile_x_comp_air_pocket (fe_f, file_name, lx, zy, bc) Read more… Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(in) :: fe_f FE_FILM element character(len=*), intent(in) :: file_name filename real(kind=R8), intent(in) :: lx pocket length real(kind=R8), intent(in) :: zy distance from a border real(kind=R8), intent(in), dimension(4) :: bc pressure boundaries public subroutine save_profile_y_comp_air_pocket (fe_f, file_name, ly, zx, bc) Read more… Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(in) :: fe_f FE_FILM element character(len=*), intent(in) :: file_name filename real(kind=R8), intent(in) :: ly pocket width real(kind=R8), intent(in) :: zx distance from the pocket entry real(kind=R8), intent(in), dimension(4) :: bc pressure boundaries","loc":"module/inout_files.html"},{"tags":"","title":"IR_VTK – MUSST","text":"The following are the portable kind parameters available. Real precision definitions: strz overloading\n ctoi overloading Used by module~~ir_vtk~~UsedByGraph module~ir_vtk IR_VTK module~vtk VTK module~vtk->module~ir_vtk module~inout_files inout_files module~inout_files->module~vtk module~test_musst test_musst module~test_musst->module~inout_files program~main main program~main->module~test_musst Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables R16P R8P R4P R_P I8P I4P I2P I1P I_P FR16P FR8P FR4P FR_P DR16P DR8P DR4P DR_P MinR16P MaxR16P MinR8P MaxR8P MinR4P MaxR4P MinR_P MaxR_P FI8P FI8PZP FI4P FI4PZP FI2P FI2PZP FI1P FI1PZP FI_P FI_PZP DI8P DI4P DI2P DI1P DI_P MinI8P MaxI8P MinI4P MaxI4P MinI2P MaxI2P MinI1P MaxI1P MinI_P MaxI_P ZeroR16 ZeroR8 ZeroR4 ZeroR8 ZeroR4 Zero Interfaces str strz cton Functions str_R16P str_R8P str_R4P str_I8P str_I4P str_I2P str_I1P strz_I8P strz_I4P strz_I2P strz_I1P ctor_R16P ctor_R8P ctor_R4P ctoi_I8P ctoi_I4P ctoi_I2P ctoi_I1P Subroutines IR_Print Variables Type Visibility Attributes Name Initial integer, public, parameter :: R16P = selected_real_kind(33, 4931) integer, public, parameter :: R8P = selected_real_kind(15, 307) integer, public, parameter :: R4P = selected_real_kind(6, 37) integer, public, parameter :: R_P = R8P Integer precision definitions: integer, public, parameter :: I8P = selected_int_kind(18) integer, public, parameter :: I4P = selected_int_kind(9) integer, public, parameter :: I2P = selected_int_kind(4) integer, public, parameter :: I1P = selected_int_kind(2) integer, public, parameter :: I_P = I4P Besides the kind parameters there are also the format parameters useful for writing in a well-ascii-format numeric variables. Real output formats: character(len=10), public, parameter :: FR16P = '(E42.33E4)' character(len=10), public, parameter :: FR8P = '(E23.15E3)' character(len=9), public, parameter :: FR4P = '(E13.6E2)' character(len=10), public, parameter :: FR_P = FR8P Real number of digits of output formats: integer, public, parameter :: DR16P = 42 integer, public, parameter :: DR8P = 23 integer, public, parameter :: DR4P = 13 integer, public, parameter :: DR_P = DR8P Real min and max values: real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) real(kind=R_P), public, parameter :: MinR_P = MinR8P Integer output formats: real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Integer output formats: character(len=5), public, parameter :: FI8P = '(I20)' character(len=8), private, parameter :: FI8PZP = '(I20.19)' character(len=5), public, parameter :: FI4P = '(I11)' character(len=8), private, parameter :: FI4PZP = '(I11.10)' character(len=4), public, parameter :: FI2P = '(I6)' character(len=6), private, parameter :: FI2PZP = '(I6.5)' character(len=4), public, parameter :: FI1P = '(I4)' character(len=6), private, parameter :: FI1PZP = '(I4.3)' character(len=5), public, parameter :: FI_P = FI4P character(len=8), private, parameter :: FI_PZP = FI4PZP Integer number of digits of output formats: integer, public, parameter :: DI8P = 20 integer, public, parameter :: DI4P = 11 integer, public, parameter :: DI2P = 6 integer, public, parameter :: DI1P = 4 integer, public, parameter :: DI_P = DI4P Integer min and max values: integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P)-1_I8P integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P)-1_I4P integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P)-1_I2P integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) integer(kind=I2P), public, parameter :: MinI1P = -huge(1_I1P)-1_I1P integer(kind=I2P), public, parameter :: MaxI1P = huge(1_I1P) integer(kind=I_P), public, parameter :: MinI_P = MinI4P IR_Precision module provides some global variables in order to store the smallest real evaluable by the running calculator. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P IR_Precision module provides some global variables in order to store the smallest real evaluable by the running calculator. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P, 1._R16P)-nearest(1._R16P, -1._R16P) real(kind=R8P), public, parameter :: ZeroR8 = 0._R8P real(kind=R4P), public, parameter :: ZeroR4 = 0._R4P real(kind=R8P), private, parameter :: ZeroR8 = nearest(1._R8P, 1._R8P)-nearest(1._R8P, -1._R8P) real(kind=R4P), private, parameter :: ZeroR4 = nearest(1._R4P, 1._R4P)-nearest(1._R4P, -1._R4P) real(kind=R_P), public, parameter :: Zero = ZeroR8 str overloading Interfaces public interface str private elemental function str_R16P (no_sign, n) result(str) The function str_R16P converts real to string. This function achieves casting of real to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign real(kind=R16P), intent(in) :: n Return Value character(len=DR16P) private elemental function str_R8P (no_sign, n) result(str) The function str_R8P converts real to string. This function achieves casting of real to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign real(kind=R8P), intent(in) :: n Return Value character(len=DR8P) private elemental function str_R4P (no_sign, n) result(str) The function str_R4P converts real to string. This function achieves casting of real to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign real(kind=R4P), intent(in) :: n Return Value character(len=DR4P) private elemental function str_I8P (no_sign, n) result(str) The function str_I8P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I8P), intent(in) :: n Return Value character(len=DI8P) private elemental function str_I4P (no_sign, n) result(str) The function str_I4P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I4P), intent(in) :: n Return Value character(len=DI4P) private elemental function str_I2P (no_sign, n) result(str) The function str_I2P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I2P), intent(in) :: n Return Value character(len=DI2P) private elemental function str_I1P (no_sign, n) result(str) The function str_I1P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I1P), intent(in) :: n Return Value character(len=DI1P) public interface strz private elemental function strz_I8P (nz_pad, n) result(str) The function strz_I8P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I8P), intent(in) :: n Return Value character(len=DI8P) private elemental function strz_I4P (nz_pad, n) result(str) The function strz_I4P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I4P), intent(in) :: n Return Value character(len=DI4P) private elemental function strz_I2P (nz_pad, n) result(str) The function strz_I2P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I2P), intent(in) :: n Return Value character(len=DI2P) private elemental function strz_I1P (nz_pad, n) result(str) The function strz_I1P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I1P), intent(in) :: n Return Value character(len=DI1P) public interface cton private function ctor_R16P (str, knd) result(n) The function ctor_R16P converts string to real. This function achieves casting of string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R16P), intent(in) :: knd Return Value real(kind=R16P) private function ctor_R8P (str, knd) result(n) The function ctor_R8P converts string to real. This function achieves casting of string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R8P), intent(in) :: knd Return Value real(kind=R8P) private function ctor_R4P (str, knd) result(n) The function ctor_R4P converts string to real. This function achieves casting of string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R4P), intent(in) :: knd Return Value real(kind=R4P) private function ctoi_I8P (str, knd) result(n) The function ctoi_I8P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I8P), intent(in) :: knd Return Value integer(kind=I8P) private function ctoi_I4P (str, knd) result(n) The function ctoi_I4P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I4P), intent(in) :: knd Return Value integer(kind=I4P) private function ctoi_I2P (str, knd) result(n) The function ctoi_I2P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I2P), intent(in) :: knd Return Value integer(kind=I2P) private function ctoi_I1P (str, knd) result(n) The function ctoi_I1P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I1P), intent(in) :: knd Return Value integer(kind=I1P) Functions private elemental function str_R16P (no_sign, n) result(str) The function str_R16P converts real to string. This function achieves casting of real to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign real(kind=R16P), intent(in) :: n Return Value character(len=DR16P) private elemental function str_R8P (no_sign, n) result(str) The function str_R8P converts real to string. This function achieves casting of real to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign real(kind=R8P), intent(in) :: n Return Value character(len=DR8P) private elemental function str_R4P (no_sign, n) result(str) The function str_R4P converts real to string. This function achieves casting of real to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign real(kind=R4P), intent(in) :: n Return Value character(len=DR4P) private elemental function str_I8P (no_sign, n) result(str) The function str_I8P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I8P), intent(in) :: n Return Value character(len=DI8P) private elemental function str_I4P (no_sign, n) result(str) The function str_I4P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I4P), intent(in) :: n Return Value character(len=DI4P) private elemental function str_I2P (no_sign, n) result(str) The function str_I2P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I2P), intent(in) :: n Return Value character(len=DI2P) private elemental function str_I1P (no_sign, n) result(str) The function str_I1P converts integer to string. This function achieves casting of integer to string. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign integer(kind=I1P), intent(in) :: n Return Value character(len=DI1P) private elemental function strz_I8P (nz_pad, n) result(str) The function strz_I8P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I8P), intent(in) :: n Return Value character(len=DI8P) private elemental function strz_I4P (nz_pad, n) result(str) The function strz_I4P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I4P), intent(in) :: n Return Value character(len=DI4P) private elemental function strz_I2P (nz_pad, n) result(str) The function strz_I2P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I2P), intent(in) :: n Return Value character(len=DI2P) private elemental function strz_I1P (nz_pad, n) result(str) The function strz_I1P converts integer to string, prefixing with the right number of zeros. This function achieves casting of\ninteger to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad integer(kind=I1P), intent(in) :: n Return Value character(len=DI1P) private function ctor_R16P (str, knd) result(n) The function ctor_R16P converts string to real. This function achieves casting of string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R16P), intent(in) :: knd Return Value real(kind=R16P) private function ctor_R8P (str, knd) result(n) The function ctor_R8P converts string to real. This function achieves casting of string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R8P), intent(in) :: knd Return Value real(kind=R8P) private function ctor_R4P (str, knd) result(n) The function ctor_R4P converts string to real. This function achieves casting of string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=R4P), intent(in) :: knd Return Value real(kind=R4P) private function ctoi_I8P (str, knd) result(n) The function ctoi_I8P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I8P), intent(in) :: knd Return Value integer(kind=I8P) private function ctoi_I4P (str, knd) result(n) The function ctoi_I4P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I4P), intent(in) :: knd Return Value integer(kind=I4P) private function ctoi_I2P (str, knd) result(n) The function ctoi_I2P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I2P), intent(in) :: knd Return Value integer(kind=I2P) private function ctoi_I1P (str, knd) result(n) The function ctoi_I1P converts string to integer. This function achieves casting of string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=I1P), intent(in) :: knd Return Value integer(kind=I1P) Subroutines public subroutine IR_Print () The subroutine IR_Print print to the standard output the kind definition of reals and integers and the utility variables. Arguments None","loc":"module/ir_vtk.html"},{"tags":"","title":"mesh – MUSST","text":"Definition of a finite element mesh FE_edge type The edge type define a line which is the boundary of the domain. It contains a number of node, of elements and a connectivity table.\n A table is used to give a link with the 2D domain nodes number Fe_mesh type The mesh is a 2D mesh (only 4 nodes quadrangles in the current version) Mesh generation It is possible to create a structured rectanguler mesh with \\ref module_fe_mesh::create_rect_x_ymesh Uses data_arch module~~mesh~~UsesGraph module~mesh mesh module~data_arch data_arch module~mesh->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~mesh~~UsedByGraph module~mesh mesh module~film film module~film->module~mesh module~ms_film ms_film module~ms_film->module~mesh module~ms_film->module~film module~test_musst test_musst module~test_musst->module~film module~test_musst->module~ms_film module~inout_files inout_files module~test_musst->module~inout_files module~inout_files->module~film module~inout_files->module~ms_film program~main main program~main->module~test_musst Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables MAX_NNE MAX_NNC MAX_NNG MAX_NBS Derived Types FE_EDGE FE_MESH Subroutines create_rect_x_ymesh Variables Type Visibility Attributes Name Initial integer(kind=I4), public, parameter :: MAX_NNE = 4 maximum number of nodes per element integer(kind=I4), public, parameter :: MAX_NNC = 4 maximum number of corners per element integer(kind=I4), public, parameter :: MAX_NNG = 2 maximum number of Gauss points in a direction integer(kind=I4), public, parameter :: MAX_NBS = 512 maximum number of nodes per BS element in a direction Derived Types type, public :: FE_EDGE Components Type Visibility Attributes Name Initial integer(kind=I4), public :: n number of nodes integer(kind=I4), public :: ne number of elements integer(kind=I4), public, dimension(:), allocatable :: nm mesh node (numbers in the 2d mesh) integer(kind=I4), public, dimension(:,:), allocatable :: con connectivity table type, public :: FE_MESH Components Type Visibility Attributes Name Initial real(kind=R8), public :: lx size of rectangle real(kind=R8), public :: ly size of rectangle real(kind=R8), public :: zx coordinates of first point real(kind=R8), public :: zy coordinates of first point integer(kind=I4), public :: nx number of nodes in x , y directions integer(kind=I4), public :: ny number of nodes in x , y directions integer(kind=I4), public :: n number of nodes integer(kind=I4), public :: ne number of elements integer(kind=I4), public :: ned number of edges integer(kind=I4), public :: nc number of corners real(kind=R8), public, dimension(:), allocatable :: x nodes coordinates real(kind=R8), public, dimension(:), allocatable :: y nodes coordinates real(kind=R8), public, dimension(:), allocatable :: z nodes coordinates integer(kind=I4), public, dimension(:,:), allocatable :: con connectivity table integer(kind=I4), public, dimension(:), allocatable :: el_t element type integer(kind=I4), public, dimension(:), allocatable :: el_n element number of lines type( FE_EDGE ), public, dimension(:), allocatable :: ed edges of the mesh integer(kind=I4), public, dimension(:), allocatable :: cor number of the corner node Subroutines public subroutine create_rect_x_ymesh (m) Read more… Arguments Type Intent Optional Attributes Name type( FE_MESH ), intent(inout) :: m FE mesh","loc":"module/mesh.html"},{"tags":"","title":"ms_film – MUSST","text":"MultiScale FE solution of the Reynolds equation Description of the film module This module can be used for a two-scale solution of the lubrication problems (more particularly for rough surface problems) Definition of MS_FE_film MS_FE_FILM is a data structure containing a FE_FILM which is the Top Scale or macro-scale of the problem and a table of FE_FILM which is the Bottom Scale or micro-scale Solution procedure This module can be used to create a MS_FE_FILM , assemble the MS_FE_FILM , and solve it. Some post-treatements like fluxes, forces are available. Uses data_arch film mesh solver omp_lib bspline surfile data_film_hd num_param fluid_law module~~ms_film~~UsesGraph module~ms_film ms_film module~mesh mesh module~ms_film->module~mesh module~fluid_law fluid_law module~ms_film->module~fluid_law module~bspline bspline module~ms_film->module~bspline module~film film module~ms_film->module~film module~surfile surfile module~ms_film->module~surfile omp_lib omp_lib module~ms_film->omp_lib module~solver solver module~ms_film->module~solver module~data_film_hd data_film_hd module~ms_film->module~data_film_hd module~num_param num_param module~ms_film->module~num_param module~data_arch data_arch module~ms_film->module~data_arch module~mesh->module~data_arch module~fluid_law->module~data_arch iso_fortran_env iso_fortran_env module~bspline->iso_fortran_env module~film->module~mesh module~film->module~fluid_law module~film->module~surfile module~film->omp_lib module~film->module~solver module~film->module~data_film_hd module~film->module~num_param module~film->module~data_arch module~elements elements module~film->module~elements module~surfile->module~data_arch iso_c_binding iso_c_binding module~surfile->iso_c_binding module~sort_arrays sort_arrays module~surfile->module~sort_arrays module~solver->module~data_arch module~sulu_wrapper sulu_wrapper module~solver->module~sulu_wrapper module~gen_param gen_param module~solver->module~gen_param module~mumfpack mumfpack module~solver->module~mumfpack module~solver->iso_fortran_env module~solver->iso_c_binding module~mumps_wrapper mumps_wrapper module~solver->module~mumps_wrapper module~solver->module~sort_arrays hsl_ma48_double hsl_ma48_double module~solver->hsl_ma48_double module~data_film_hd->module~fluid_law module~data_film_hd->module~data_arch module~num_param->module~data_arch module~num_param->iso_fortran_env module~data_arch->iso_fortran_env module~sulu_wrapper->iso_c_binding module~gen_param->module~data_arch module~mumfpack->iso_c_binding module~elements->module~data_arch module~sort_arrays->module~data_arch Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ms_film~~UsedByGraph module~ms_film ms_film module~test_musst test_musst module~test_musst->module~ms_film module~inout_files inout_files module~test_musst->module~inout_files module~inout_files->module~ms_film program~main main program~main->module~test_musst Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables scal_tmp SMOOTH_MS Derived Types MS_FE_FILM Functions ms_fz ms_fx ms_fy Subroutines multi_scale_create_rect_fe_film multi_scale_solve_fe_film interp_ts_bs_splin save_ms_field ms_fe_f_2_mat mat_2_ms_fe_f smooth_ms_fe_f smooth_mat multi_scale_assembly_fe_film_reynolds Variables Type Visibility Attributes Name Initial type(SCALE_SURF), private :: scal_tmp object SCALE_SURF logical(kind=I4), private, parameter :: SMOOTH_MS = .true. at the end of the iterative process, the pressure field can be smoothed Derived Types type, public :: MS_FE_FILM MS_FE_FILM is the top-scale FE_FILM plus all of the bottom-scale FE_FILM Components Type Visibility Attributes Name Initial type(FE_FILM), public :: ts_fe_f top-scale fe_film type(FE_FILM), public, dimension(:), allocatable :: bs_fe_f bottom-scale fe_film Type-Bound Procedures procedure, public :: ms_fx force computation along x procedure, public :: ms_fy force computation along y procedure, public :: ms_fz force computation along z Functions private function ms_fz (ms_fe_f) Read more… Arguments Type Intent Optional Attributes Name class( MS_FE_FILM ), intent(inout) :: ms_fe_f MS FE film Return Value real(kind=R8) private function ms_fx (ms_fe_f) Read more… Arguments Type Intent Optional Attributes Name class( MS_FE_FILM ), intent(inout) :: ms_fe_f Return Value real(kind=R8) private function ms_fy (ms_fe_f) Read more… Arguments Type Intent Optional Attributes Name class( MS_FE_FILM ), intent(inout) :: ms_fe_f Return Value real(kind=R8) Subroutines public subroutine multi_scale_create_rect_fe_film (data_f, bs_nx, bs_ny, num_pts, num_pbs, ms_fe_f) Read more… Arguments Type Intent Optional Attributes Name type(DATA_FILM), intent(inout) :: data_f data of the film integer(kind=I4), intent(in) :: bs_nx number of nodes in x direction for the bottom scale integer(kind=I4), intent(in) :: bs_ny number of nodes in y direction for the bottom scale type(NUM_PAR), intent(in) :: num_pts numerical parameters for iterative solution, top scale type(NUM_PAR), intent(in) :: num_pbs numerical parameters for iterative solution, bottom scale type( MS_FE_FILM ), intent(inout) :: ms_fe_f MS FE film public subroutine multi_scale_solve_fe_film (ms_fe_f, ms_mat, bc) Read more… Arguments Type Intent Optional Attributes Name type( MS_FE_FILM ), intent(inout) :: ms_fe_f multi-scale FE film type(MS_MAT_SOLV), intent(inout) :: ms_mat multi-scale solver matrices real(kind=R8), intent(in), dimension(MAX_NNC) :: bc boundary conditions at the corners private subroutine interp_ts_bs_splin (ms_fe_f) Read more… Arguments Type Intent Optional Attributes Name type( MS_FE_FILM ), intent(inout) :: ms_fe_f public subroutine save_ms_field (ms_fe_f, file_name, code, nodal) Read more… Arguments Type Intent Optional Attributes Name type( MS_FE_FILM ), intent(in) :: ms_fe_f character(len=*), intent(in) :: file_name filename like \"./out/pressure.sur\" integer(kind=I4), intent(in) :: code saved information like P_N logical(kind=I4), intent(in) :: nodal if false : cell value, if true : nodal value public subroutine ms_fe_f_2_mat (ms_fe_f, code, nodal, mat) Read more… Arguments Type Intent Optional Attributes Name type( MS_FE_FILM ), intent(in) :: ms_fe_f integer(kind=I4), intent(in) :: code saved information like P_N logical(kind=I4), intent(in) :: nodal if false : cell value, if true : nodal value real(kind=R8), intent(inout), allocatable :: mat (:,:) output matrix containing the information private subroutine mat_2_ms_fe_f (ms_fe_f, code, nodal, mat) Read more… Arguments Type Intent Optional Attributes Name type( MS_FE_FILM ), intent(inout) :: ms_fe_f integer(kind=I4), intent(in) :: code saved information like P_N logical(kind=I4), intent(in) :: nodal if false : cell value, if true : nodal value real(kind=R8), intent(in), dimension(:,:) :: mat input matrix containing the information private subroutine smooth_ms_fe_f (ms_fe_f, code, nodal) Read more… Arguments Type Intent Optional Attributes Name type( MS_FE_FILM ), intent(inout) :: ms_fe_f integer(kind=I4), intent(in) :: code saved information like P_N logical(kind=I4), intent(in) :: nodal if false : cell value, if true : nodal value private subroutine smooth_mat (mat, nx, ny, s) Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(nx, ny) :: mat matrix integer(kind=I4), intent(in) :: nx matrix x size integer(kind=I4), intent(in) :: ny matrix y size integer(kind=I4), intent(in) :: s kernel size private subroutine multi_scale_assembly_fe_film_reynolds (ms_fe_f, ms_mat, ass_c) Read more… Arguments Type Intent Optional Attributes Name type( MS_FE_FILM ), intent(inout) :: ms_fe_f type(MS_MAT_SOLV), intent(inout) :: ms_mat solver type matrices table integer(kind=I4), intent(in) :: ass_c assembly type","loc":"module/ms_film.html"},{"tags":"","title":"num_param – MUSST","text":"MUSST general parameters Note The type NUM_PAR is not used in MSOLV , it is a type related to the iterative process of MUSST Uses iso_fortran_env data_arch module~~num_param~~UsesGraph module~num_param num_param iso_fortran_env iso_fortran_env module~num_param->iso_fortran_env module~data_arch data_arch module~num_param->module~data_arch module~data_arch->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~num_param~~UsedByGraph module~num_param num_param module~test_musst test_musst module~test_musst->module~num_param module~film film module~test_musst->module~film module~ms_film ms_film module~test_musst->module~ms_film module~inout_files inout_files module~test_musst->module~inout_files module~film->module~num_param module~ms_film->module~num_param module~ms_film->module~film program~main main program~main->module~num_param program~main->module~test_musst module~inout_files->module~film module~inout_files->module~ms_film Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables NO_MESS PRINT_MESS VERBOSE OPU OUTPUT_FILE Derived Types NUM_PAR Variables Type Visibility Attributes Name Initial integer(kind=I4), public, parameter :: NO_MESS = 0 code for no message on screen during problem solving integer(kind=I4), public, parameter :: PRINT_MESS = 1 code for printing message during problem solving integer(kind=I4), public :: VERBOSE Output detail control integer(kind=I4), public :: OPU = output_unit Output unit character(len=128), public :: OUTPUT_FILE When needed, output file Derived Types type, public :: NUM_PAR Components Type Visibility Attributes Name Initial real(kind=R8), public :: relax relaxation parameter real(kind=R8), public :: eps error for convergence integer(kind=I4), public :: it_max maximal number of iterations integer(kind=I4), public :: mess message","loc":"module/num_param.html"},{"tags":"","title":"test_musst – MUSST","text":"Subroutines to read a batch file and run tests Uses data_arch data_film_hd ms_film film inout_files surfile num_param solver module~~test_musst~~UsesGraph module~test_musst test_musst module~film film module~test_musst->module~film module~ms_film ms_film module~test_musst->module~ms_film module~surfile surfile module~test_musst->module~surfile module~solver solver module~test_musst->module~solver module~inout_files inout_files module~test_musst->module~inout_files module~data_film_hd data_film_hd module~test_musst->module~data_film_hd module~num_param num_param module~test_musst->module~num_param module~data_arch data_arch module~test_musst->module~data_arch module~film->module~surfile module~film->module~solver module~film->module~data_film_hd module~film->module~num_param module~film->module~data_arch module~mesh mesh module~film->module~mesh module~fluid_law fluid_law module~film->module~fluid_law module~elements elements module~film->module~elements omp_lib omp_lib module~film->omp_lib module~ms_film->module~film module~ms_film->module~surfile module~ms_film->module~solver module~ms_film->module~data_film_hd module~ms_film->module~num_param module~ms_film->module~data_arch module~ms_film->module~mesh module~ms_film->module~fluid_law module~bspline bspline module~ms_film->module~bspline module~ms_film->omp_lib module~surfile->module~data_arch iso_c_binding iso_c_binding module~surfile->iso_c_binding module~sort_arrays sort_arrays module~surfile->module~sort_arrays module~solver->module~data_arch module~sulu_wrapper sulu_wrapper module~solver->module~sulu_wrapper module~gen_param gen_param module~solver->module~gen_param module~mumfpack mumfpack module~solver->module~mumfpack module~solver->iso_c_binding iso_fortran_env iso_fortran_env module~solver->iso_fortran_env module~mumps_wrapper mumps_wrapper module~solver->module~mumps_wrapper module~solver->module~sort_arrays hsl_ma48_double hsl_ma48_double module~solver->hsl_ma48_double module~inout_files->module~film module~inout_files->module~ms_film module~inout_files->module~surfile module~inout_files->module~data_arch module~vtk VTK module~inout_files->module~vtk module~data_film_hd->module~data_arch module~data_film_hd->module~fluid_law module~num_param->module~data_arch module~num_param->iso_fortran_env module~data_arch->iso_fortran_env module~mesh->module~data_arch module~fluid_law->module~data_arch module~ir_vtk IR_VTK module~vtk->module~ir_vtk module~bspline->iso_fortran_env module~sulu_wrapper->iso_c_binding module~gen_param->module~data_arch module~mumfpack->iso_c_binding module~elements->module~data_arch module~sort_arrays->module~data_arch var panmoduletest_musstUsesGraph = svgPanZoom('#moduletest_musstUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~test_musst~~UsedByGraph module~test_musst test_musst program~main main program~main->module~test_musst Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables fe_f ms_fe_f data_f num_pbs num_pts mat ms_mat nx ny n_mac n_mic lx ly sq tab_s tab_sol bc bf t1 t2 cend cr cinit unit_num_res compare_solution_file ms_vtk prof_ts prof_bs res_file surface_file pressure_solution_file res_dir scal_tmp test_num save_PeK save_PeE Subroutines run_test read_data modify_h_slider modify_h_pocket modify_h_slider_MS modify_h_bearing modify_h_bearing_y apply_roughness apply_roughness_MS test_slider_fe test_bearing_x_fe test_bearing_y_fe test_rough_fe test_pocket_fe test_slider_ms test_rough_ms init_fe_prob init_rough_prob init_ms_prob solve_fe_prob solve_ms_prob Variables Type Visibility Attributes Name Initial type(FE_FILM), private :: fe_f FE_FILM deterministic finite element type(MS_FE_FILM), private :: ms_fe_f MS_FE_FILM multiscale finite element type(DATA_FILM), private :: data_f DATA_FILM parameter type(NUM_PAR), private :: num_pbs NUM_PAR parameter for the bottom-scale type(NUM_PAR), private :: num_pts NUM_PAR parameter for the top-scale type(MAT_SOLV), private :: mat MAT_SOLV solver type matrices type(MS_MAT_SOLV), private :: ms_mat MS_MAT_SOLV solver type matrices integer(kind=I4), private :: nx total number of nodes in x direction integer(kind=I4), private :: ny total number of nodes in y direction integer(kind=I4), private :: n_mac number of macro elements in a direction integer(kind=I4), private :: n_mic number of nodes in x or y direction for the bottom scale real(kind=R8), private :: lx domain size along x real(kind=R8), private :: ly domain size along y real(kind=R8), private :: sq roughness height real(kind=R8), private, dimension(:, :), allocatable :: tab_s roughness table real(kind=R8), private, dimension(:, :), allocatable :: tab_sol rough surface pressure solution real(kind=R8), private, dimension(4) :: bc boundary conditions real(kind=R8), private, dimension(4) :: bf boundary conditions real(kind=R4), private :: t1 cpu time real(kind=R4), private :: t2 cpu time integer(kind=I4), private :: cend real time integer(kind=I4), private :: cr real time integer(kind=I4), private :: cinit real time integer(kind=I4), private :: unit_num_res file number integer(kind=I4), private :: compare_solution_file whether to compare the pressure MS solution to a reference character(len=256), private :: ms_vtk output vtk file name character(len=256), private :: prof_ts ts/bs mat profile name character(len=256), private :: prof_bs ts/bs mat profile name character(len=256), private :: res_file result file name character(len=256), private :: surface_file surface file name character(len=256), private :: pressure_solution_file pressure solution file for a rough surface character(len=15), private :: res_dir \"/out\" subdirectory for results type(SCALE_SURF), private :: scal_tmp object SCALE_SURF integer(kind=I4), public :: test_num test number logical(kind=I4), private :: save_PeK save x Peclet field logical(kind=I4), private :: save_PeE save y Peclet field Subroutines public subroutine run_test () Read more… Arguments None public subroutine read_data (iunit, dir) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: iunit character(len=15), intent(in) :: dir output directory private subroutine modify_h_slider (fe_f, lx) Read more… Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(inout) :: fe_f real(kind=R8), intent(in) :: lx private subroutine modify_h_pocket (fe_f, lx) Read more… Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(inout) :: fe_f real(kind=R8), intent(in) :: lx private subroutine modify_h_slider_MS (ms_fe_f, lx) Read more… Arguments Type Intent Optional Attributes Name type(MS_FE_FILM), intent(inout) :: ms_fe_f real(kind=R8), intent(in) :: lx private subroutine modify_h_bearing (fe_f, lx) Read more… Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(inout) :: fe_f real(kind=R8), intent(in) :: lx private subroutine modify_h_bearing_y (fe_f, ly) Read more… Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(inout) :: fe_f real(kind=R8), intent(in) :: ly private subroutine apply_roughness (fe_f, tab_s) Read more… Arguments Type Intent Optional Attributes Name type(FE_FILM), intent(inout) :: fe_f real(kind=R8), intent(in), dimension(:,:) :: tab_s private subroutine apply_roughness_MS (ms_fe_f, tab_s) Read more… Arguments Type Intent Optional Attributes Name type(MS_FE_FILM), intent(inout) :: ms_fe_f real(kind=R8), intent(in), dimension(:,:) :: tab_s private subroutine test_slider_fe () Read more… Arguments None private subroutine test_bearing_x_fe () Read more… Arguments None private subroutine test_bearing_y_fe () Read more… Arguments None private subroutine test_rough_fe () Read more… Arguments None private subroutine test_pocket_fe () Read more… Arguments None private subroutine test_slider_ms () Read more… Arguments None private subroutine test_rough_ms () Read more… Arguments None private subroutine init_fe_prob () Read more… Arguments None private subroutine init_rough_prob () Read more… Arguments None private subroutine init_ms_prob () Read more… Arguments None private subroutine solve_fe_prob () Read more… Arguments None private subroutine solve_ms_prob () Read more… Arguments None","loc":"module/test_musst.html"},{"tags":"","title":"VTK – MUSST","text":"LIBVTKIO is a library of functions for Input and Output pure fortran data (both ascii and binary) in VTK format. The VTK standard can be separated into two main catagories: the \\MaiuscolettoBS{VTK Legacy Standard} and the\n\\MaiuscolettoBS{VTK XML Standard}. The latter is more powerful and will has a stronger support from VTk comunity than legacy\nstandard; XML file format would to be preferred despite the legacy one. Uses IR_VTK module~~vtk~~UsesGraph module~vtk VTK module~ir_vtk IR_VTK module~vtk->module~ir_vtk Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~vtk~~UsedByGraph module~vtk VTK module~inout_files inout_files module~inout_files->module~vtk module~test_musst test_musst module~test_musst->module~inout_files program~main main program~main->module~test_musst Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables maxlen end_rec f_out_ascii f_out_binary f_out topology Unit_VTK Unit_VTK_Append N_Byte Tipo_R8 Tipo_R4 Tipo_I8 Tipo_I4 Tipo_I2 Tipo_I1 ioffset indent Unit_VTM blk vtm_indent Interfaces VTK_GEO VTK_VAR VTK_GEO_XML VTK_VAR_XML Functions GetUnit Upper_Case VTK_INI VTK_GEO_STRP_R8 VTK_GEO_STRP_R4 VTK_GEO_STRG_R8 VTK_GEO_STRG_R4 VTK_GEO_RECT_R8 VTK_GEO_RECT_R4 VTK_GEO_UNST_R8 VTK_GEO_UNST_R4 VTK_CON VTK_DAT VTK_VAR_SCAL_R8 VTK_VAR_SCAL_R4 VTK_VAR_SCAL_I4 VTK_VAR_VECT_R8 VTK_VAR_VECT_R4 VTK_VAR_VECT_I4 VTK_VAR_TEXT_R8 VTK_VAR_TEXT_R4 VTK_END VTK_INI_XML VTK_GEO_XML_STRG_R8 VTK_GEO_XML_STRG_R4 VTK_GEO_XML_RECT_R8 VTK_GEO_XML_RECT_R4 VTK_GEO_XML_UNST_R8 VTK_GEO_XML_UNST_R4 VTK_GEO_XML_CLOSEP VTK_CON_XML VTK_DAT_XML VTK_VAR_XML_SCAL_R8 VTK_VAR_XML_SCAL_R4 VTK_VAR_XML_SCAL_I8 VTK_VAR_XML_SCAL_I4 VTK_VAR_XML_SCAL_I2 VTK_VAR_XML_SCAL_I1 VTK_VAR_XML_VECT_R8 VTK_VAR_XML_VECT_R4 VTK_VAR_XML_VECT_I8 VTK_VAR_XML_VECT_I4 VTK_VAR_XML_VECT_I2 VTK_VAR_XML_VECT_I1 VTK_VAR_XML_LIST_R8 VTK_VAR_XML_LIST_R4 VTK_VAR_XML_LIST_I8 VTK_VAR_XML_LIST_I4 VTK_VAR_XML_LIST_I2 VTK_VAR_XML_LIST_I1 VTK_END_XML VTM_INI_XML VTM_BLK_XML VTM_WRF_XML VTM_END_XML Variables Type Visibility Attributes Name Initial integer(kind=I4P), private, parameter :: maxlen = 500 character(len=1), private, parameter :: end_rec = char(10) integer(kind=I4P), private, parameter :: f_out_ascii = 0 integer(kind=I4P), private, parameter :: f_out_binary = 1 integer(kind=I4P), private :: f_out = f_out_ascii character(len=maxlen), private :: topology integer(kind=I4P), private :: Unit_VTK integer(kind=I4P), private :: Unit_VTK_Append integer(kind=I4P), private :: N_Byte real(kind=R8P), private :: Tipo_R8 = 1._R8P real(kind=R4P), private :: Tipo_R4 = 1._R4P integer(kind=I8P), private :: Tipo_I8 = 1_I8P integer(kind=I4P), private :: Tipo_I4 = 1_I4P integer(kind=I2P), private :: Tipo_I2 = 1_I2P integer(kind=I1P), private :: Tipo_I1 = 1_I1P integer(kind=I8P), private :: ioffset integer(kind=I4P), private :: indent integer(kind=I4P), private :: Unit_VTM integer(kind=I4P), private :: blk integer(kind=I4P), private :: vtm_indent Interfaces public interface VTK_GEO private function VTK_GEO_UNST_R8 (NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = UNSTRUCTURED_GRID (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_UNST_R4 (NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = UNSTRUCTURED_GRID (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_STRP_R8 (Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz) result(E_IO) Function for saving mesh; topology = STRUCTURED_POINTS (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R8P), intent(in) :: X0 real(kind=R8P), intent(in) :: Y0 real(kind=R8P), intent(in) :: Z0 real(kind=R8P), intent(in) :: Dx real(kind=R8P), intent(in) :: Dy real(kind=R8P), intent(in) :: Dz Return Value integer(kind=I4P) private function VTK_GEO_STRP_R4 (Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz) result(E_IO) Function for saving mesh; topology = STRUCTURED_POINTS (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R4P), intent(in) :: X0 real(kind=R4P), intent(in) :: Y0 real(kind=R4P), intent(in) :: Z0 real(kind=R4P), intent(in) :: Dx real(kind=R4P), intent(in) :: Dy real(kind=R4P), intent(in) :: Dz Return Value integer(kind=I4P) private function VTK_GEO_STRG_R8 (Nx, Ny, Nz, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = STRUCTURED_GRID (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz integer(kind=I4P), intent(in) :: NN real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_STRG_R4 (Nx, Ny, Nz, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = STRUCTURED_GRID (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz integer(kind=I4P), intent(in) :: NN real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_RECT_R8 (Nx, Ny, Nz, X, Y, Z) result(E_IO) Function for saving mesh; topology = RECTILINEAR_GRID (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R8P), intent(in) :: X (1:Nx) real(kind=R8P), intent(in) :: Y (1:Ny) real(kind=R8P), intent(in) :: Z (1:Nz) Return Value integer(kind=I4P) private function VTK_GEO_RECT_R4 (Nx, Ny, Nz, X, Y, Z) result(E_IO) Function for saving mesh; topology = RECTILINEAR_GRID (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R4P), intent(in) :: X (1:Nx) real(kind=R4P), intent(in) :: Y (1:Ny) real(kind=R4P), intent(in) :: Z (1:Nz) Return Value integer(kind=I4P) public interface VTK_VAR private function VTK_VAR_SCAL_R8 (NC_NN, varname, var) result(E_IO) Function for saving field of scalar variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_SCAL_R4 (NC_NN, varname, var) result(E_IO) Function for saving field of scalar variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_SCAL_I4 (NC_NN, varname, var) result(E_IO) Function for saving field of scalar variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_VECT_R8 (vec_type, NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving field of vectorial variable (R8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: varX (1:NC_NN) real(kind=R8P), intent(in) :: varY (1:NC_NN) real(kind=R8P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_VECT_R4 (vec_type, NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving field of vectorial variable (R4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: varX (1:NC_NN) real(kind=R4P), intent(in) :: varY (1:NC_NN) real(kind=R4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_VECT_I4 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving field of vectorial variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: varX (1:NC_NN) integer(kind=I4P), intent(in) :: varY (1:NC_NN) integer(kind=I4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_TEXT_R8 (NC_NN, dimm, varname, textCoo) result(E_IO) Function for saving texture variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: dimm character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: textCoo (1:NC_NN,1:dimm) Return Value integer(kind=I4P) private function VTK_VAR_TEXT_R4 (NC_NN, dimm, varname, textCoo) result(E_IO) Function for saving texture variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: dimm character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: textCoo (1:NC_NN,1:dimm) Return Value integer(kind=I4P) public interface VTK_GEO_XML private function VTK_GEO_XML_STRG_R4 (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = StructuredGrid (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 integer(kind=I4P), intent(in) :: NN real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_XML_STRG_R8 (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = StructuredGrid (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 integer(kind=I4P), intent(in) :: NN real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_XML_RECT_R8 (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z) result(E_IO) Function for saving mesh; topology = RectilinearGrid (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 real(kind=R8P), intent(in) :: X (nx1:nx2) real(kind=R8P), intent(in) :: Y (ny1:ny2) real(kind=R8P), intent(in) :: Z (nz1:nz2) Return Value integer(kind=I4P) private function VTK_GEO_XML_RECT_R4 (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z) result(E_IO) Function for saving mesh; topology = RectilinearGrid (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 real(kind=R4P), intent(in) :: X (nx1:nx2) real(kind=R4P), intent(in) :: Y (ny1:ny2) real(kind=R4P), intent(in) :: Z (nz1:nz2) Return Value integer(kind=I4P) private function VTK_GEO_XML_UNST_R8 (NN, NC, X, Y, Z) result(E_IO) Function for saving mesh; topology = UnstructuredGrid (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN integer(kind=I4P), intent(in) :: NC real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_XML_UNST_R4 (NN, NC, X, Y, Z) result(E_IO) Function for saving mesh; topology = UnstructuredGrid (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN integer(kind=I4P), intent(in) :: NC real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_XML_CLOSEP () result(E_IO) Function for closing mesh block data. Arguments None Return Value integer(kind=I4P) public interface VTK_VAR_XML private function VTK_VAR_XML_SCAL_R8 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_R4 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_I8 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I8P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_I4 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_I2 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I2P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_I1 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I1P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_R8 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: varX (1:NC_NN) real(kind=R8P), intent(in) :: varY (1:NC_NN) real(kind=R8P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_R4 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: varX (1:NC_NN) real(kind=R4P), intent(in) :: varY (1:NC_NN) real(kind=R4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_I8 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I8P), intent(in) :: varX (1:NC_NN) integer(kind=I8P), intent(in) :: varY (1:NC_NN) integer(kind=I8P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_I4 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: varX (1:NC_NN) integer(kind=I4P), intent(in) :: varY (1:NC_NN) integer(kind=I4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_I2 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I2P), intent(in) :: varX (1:NC_NN) integer(kind=I2P), intent(in) :: varY (1:NC_NN) integer(kind=I2P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_I1 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I1P), intent(in) :: varX (1:NC_NN) integer(kind=I1P), intent(in) :: varY (1:NC_NN) integer(kind=I1P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_R8 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_R4 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_I8 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I8P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_I4 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_I2 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I2P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_I1 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I1P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) Functions private function GetUnit () result(Free_Unit) The GetUnit function is used for getting a free logic unit. The users of \\LIBVTKIO does not know which is\nthe logical unit: \\LIBVTKIO handels this information without boring the users. The logical unit used is safe-free: if the\nprogram calling \\LIBVTKIO has others logical units used \\LIBVTKIO will never use these units, but will choice one that is free. Read more… Arguments None Return Value integer(kind=I4P) private function Upper_Case (string) The Upper_Case function converts the lower case characters of a string to upper case one. \\LIBVTKIO uses this function in\norder to achieve case-insensitive: all character variables used within \\LIBVTKIO functions are pre-processed by\nUppper_Case function before these variables are used. So the users can call \\LIBVTKIO functions whitout pay attention of the\ncase of the kwywords passed to the functions: calling the function VTK_INI with the string \\code{E_IO = VTK_INI('Ascii',…)}\nor with the string  \\code{E_IO = VTK_INI('AscII',…)} is equivalent. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len(string)) public function VTK_INI (output_format, filename, title, mesh_topology) result(E_IO) The VTK_INI function is used for initializing file. This function must be the first to be called. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: output_format character(len=*), intent(in) :: filename character(len=*), intent(in) :: title character(len=*), intent(in) :: mesh_topology Return Value integer(kind=I4P) The VTK_INI variables have the following meaning: Read more… private function VTK_GEO_STRP_R8 (Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz) result(E_IO) Function for saving mesh; topology = STRUCTURED_POINTS (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R8P), intent(in) :: X0 real(kind=R8P), intent(in) :: Y0 real(kind=R8P), intent(in) :: Z0 real(kind=R8P), intent(in) :: Dx real(kind=R8P), intent(in) :: Dy real(kind=R8P), intent(in) :: Dz Return Value integer(kind=I4P) private function VTK_GEO_STRP_R4 (Nx, Ny, Nz, X0, Y0, Z0, Dx, Dy, Dz) result(E_IO) Function for saving mesh; topology = STRUCTURED_POINTS (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R4P), intent(in) :: X0 real(kind=R4P), intent(in) :: Y0 real(kind=R4P), intent(in) :: Z0 real(kind=R4P), intent(in) :: Dx real(kind=R4P), intent(in) :: Dy real(kind=R4P), intent(in) :: Dz Return Value integer(kind=I4P) private function VTK_GEO_STRG_R8 (Nx, Ny, Nz, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = STRUCTURED_GRID (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz integer(kind=I4P), intent(in) :: NN real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_STRG_R4 (Nx, Ny, Nz, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = STRUCTURED_GRID (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz integer(kind=I4P), intent(in) :: NN real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_RECT_R8 (Nx, Ny, Nz, X, Y, Z) result(E_IO) Function for saving mesh; topology = RECTILINEAR_GRID (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R8P), intent(in) :: X (1:Nx) real(kind=R8P), intent(in) :: Y (1:Ny) real(kind=R8P), intent(in) :: Z (1:Nz) Return Value integer(kind=I4P) private function VTK_GEO_RECT_R4 (Nx, Ny, Nz, X, Y, Z) result(E_IO) Function for saving mesh; topology = RECTILINEAR_GRID (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: Nx integer(kind=I4P), intent(in) :: Ny integer(kind=I4P), intent(in) :: Nz real(kind=R4P), intent(in) :: X (1:Nx) real(kind=R4P), intent(in) :: Y (1:Ny) real(kind=R4P), intent(in) :: Z (1:Nz) Return Value integer(kind=I4P) private function VTK_GEO_UNST_R8 (NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = UNSTRUCTURED_GRID (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_UNST_R4 (NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = UNSTRUCTURED_GRID (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) public function VTK_CON (NC, connect, cell_type) result(E_IO) This function \\MaiuscolettoBS{must} be used when unstructured grid is used. It saves the connectivity of the unstructured\nmesh. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC integer(kind=I4P), intent(in) :: connect (:) integer(kind=I4P), intent(in) :: cell_type (1:NC) Return Value integer(kind=I4P) public function VTK_DAT (NC_NN, var_location) result(E_IO) This function \\MaiuscolettoBS{must} be called before saving the data related to geometric mesh. This function initializes the\nsaving of data variables indicating the \\emph{type} of variables that will be saved. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: var_location Return Value integer(kind=I4P) private function VTK_VAR_SCAL_R8 (NC_NN, varname, var) result(E_IO) Function for saving field of scalar variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_SCAL_R4 (NC_NN, varname, var) result(E_IO) Function for saving field of scalar variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_SCAL_I4 (NC_NN, varname, var) result(E_IO) Function for saving field of scalar variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_VECT_R8 (vec_type, NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving field of vectorial variable (R8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: varX (1:NC_NN) real(kind=R8P), intent(in) :: varY (1:NC_NN) real(kind=R8P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_VECT_R4 (vec_type, NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving field of vectorial variable (R4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vec_type integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: varX (1:NC_NN) real(kind=R4P), intent(in) :: varY (1:NC_NN) real(kind=R4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_VECT_I4 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving field of vectorial variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: varX (1:NC_NN) integer(kind=I4P), intent(in) :: varY (1:NC_NN) integer(kind=I4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_TEXT_R8 (NC_NN, dimm, varname, textCoo) result(E_IO) Function for saving texture variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: dimm character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: textCoo (1:NC_NN,1:dimm) Return Value integer(kind=I4P) private function VTK_VAR_TEXT_R4 (NC_NN, dimm, varname, textCoo) result(E_IO) Function for saving texture variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: dimm character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: textCoo (1:NC_NN,1:dimm) Return Value integer(kind=I4P) public function VTK_END () result(E_IO) This function is used to finalize the file opened and it has not inputs. The \\LIBVTKIO manages the file unit without the\nuser's action. Arguments None Return Value integer(kind=I4P) The VTK_END variables have the following meaning: Read more… public function VTK_INI_XML (output_format, filename, mesh_topology, nx1, nx2, ny1, ny2, nz1, nz2) result(E_IO) The VTK_INI_XML function is used for initializing file. This function must be the first to be called. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: output_format character(len=*), intent(in) :: filename character(len=*), intent(in) :: mesh_topology integer(kind=I4P), intent(in), optional :: nx1 integer(kind=I4P), intent(in), optional :: nx2 integer(kind=I4P), intent(in), optional :: ny1 integer(kind=I4P), intent(in), optional :: ny2 integer(kind=I4P), intent(in), optional :: nz1 integer(kind=I4P), intent(in), optional :: nz2 Return Value integer(kind=I4P) private function VTK_GEO_XML_STRG_R8 (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = StructuredGrid (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 integer(kind=I4P), intent(in) :: NN real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_XML_STRG_R4 (nx1, nx2, ny1, ny2, nz1, nz2, NN, X, Y, Z) result(E_IO) Function for saving mesh; topology = StructuredGrid (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 integer(kind=I4P), intent(in) :: NN real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_XML_RECT_R8 (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z) result(E_IO) Function for saving mesh; topology = RectilinearGrid (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 real(kind=R8P), intent(in) :: X (nx1:nx2) real(kind=R8P), intent(in) :: Y (ny1:ny2) real(kind=R8P), intent(in) :: Z (nz1:nz2) Return Value integer(kind=I4P) private function VTK_GEO_XML_RECT_R4 (nx1, nx2, ny1, ny2, nz1, nz2, X, Y, Z) result(E_IO) Function for saving mesh; topology = RectilinearGrid (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: nx1 integer(kind=I4P), intent(in) :: nx2 integer(kind=I4P), intent(in) :: ny1 integer(kind=I4P), intent(in) :: ny2 integer(kind=I4P), intent(in) :: nz1 integer(kind=I4P), intent(in) :: nz2 real(kind=R4P), intent(in) :: X (nx1:nx2) real(kind=R4P), intent(in) :: Y (ny1:ny2) real(kind=R4P), intent(in) :: Z (nz1:nz2) Return Value integer(kind=I4P) private function VTK_GEO_XML_UNST_R8 (NN, NC, X, Y, Z) result(E_IO) Function for saving mesh; topology = UnstructuredGrid (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN integer(kind=I4P), intent(in) :: NC real(kind=R8P), intent(in) :: X (1:NN) real(kind=R8P), intent(in) :: Y (1:NN) real(kind=R8P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_XML_UNST_R4 (NN, NC, X, Y, Z) result(E_IO) Function for saving mesh; topology = UnstructuredGrid (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NN integer(kind=I4P), intent(in) :: NC real(kind=R4P), intent(in) :: X (1:NN) real(kind=R4P), intent(in) :: Y (1:NN) real(kind=R4P), intent(in) :: Z (1:NN) Return Value integer(kind=I4P) private function VTK_GEO_XML_CLOSEP () result(E_IO) Function for closing mesh block data. Arguments None Return Value integer(kind=I4P) public function VTK_CON_XML (NC, connect, offset, cell_type) result(E_IO) This function \\MaiuscolettoBS{must} be used when unstructured grid is used. It saves the connectivity of the unstructured mesh. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC integer(kind=I4P), intent(in) :: connect (:) integer(kind=I4P), intent(in) :: offset (1:NC) integer(kind=I1P), intent(in) :: cell_type (1:NC) Return Value integer(kind=I4P) public function VTK_DAT_XML (var_location, var_block_action) result(E_IO) This function \\MaiuscolettoBS{must} be called before saving the data related to geometric mesh. This function initializes\nthe saving of data variables indicating the \\emph{type} of variables that will be saved. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var_location character(len=*), intent(in) :: var_block_action Return Value integer(kind=I4P) The VTK_DAT_XML variables have the following meaning: Read more… private function VTK_VAR_XML_SCAL_R8 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_R4 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_I8 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I8P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_I4 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_I2 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I2P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_SCAL_I1 (NC_NN, varname, var) result(E_IO) Function for saving scalar variable (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I1P), intent(in) :: var (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_R8 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: varX (1:NC_NN) real(kind=R8P), intent(in) :: varY (1:NC_NN) real(kind=R8P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_R4 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: varX (1:NC_NN) real(kind=R4P), intent(in) :: varY (1:NC_NN) real(kind=R4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_I8 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I8P), intent(in) :: varX (1:NC_NN) integer(kind=I8P), intent(in) :: varY (1:NC_NN) integer(kind=I8P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_I4 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: varX (1:NC_NN) integer(kind=I4P), intent(in) :: varY (1:NC_NN) integer(kind=I4P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_I2 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I2P), intent(in) :: varX (1:NC_NN) integer(kind=I2P), intent(in) :: varY (1:NC_NN) integer(kind=I2P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_VECT_I1 (NC_NN, varname, varX, varY, varZ) result(E_IO) Function for saving vectorial variable (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN character(len=*), intent(in) :: varname integer(kind=I1P), intent(in) :: varX (1:NC_NN) integer(kind=I1P), intent(in) :: varY (1:NC_NN) integer(kind=I1P), intent(in) :: varZ (1:NC_NN) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_R8 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (R8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname real(kind=R8P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_R4 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (R4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname real(kind=R4P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_I8 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I8P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_I4 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I4P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_I2 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I2P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) private function VTK_VAR_XML_LIST_I1 (NC_NN, N_COL, varname, var) result(E_IO) Function for saving list variable (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: NC_NN integer(kind=I4P), intent(in) :: N_COL character(len=*), intent(in) :: varname integer(kind=I1P), intent(in) :: var (1:NC_NN,1:N_COL) Return Value integer(kind=I4P) public function VTK_END_XML () result(E_IO) This function is used to finalize the file opened. The \\LIBVTKIO manages the file unit without the user's action. Arguments None Return Value integer(kind=I4P) public function VTM_INI_XML (filename) result(E_IO) The VTK_VTM_XML function is used for initializing a VTM (VTK Multiblocks) XML file that is a wrapper to a set of VTK XML files. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer(kind=I4P) public function VTM_BLK_XML (block_action) result(E_IO) The VTM_BLK_XML function is used for opening or closing a block level of a VTM file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: block_action Return Value integer(kind=I4P) public function VTM_WRF_XML (wrf_dir, vtk_xml_file_list) result(E_IO) The VTM_WRF_XML function is used for saving the list of VTK XML wrapped files by the actual block of the mutliblock VTM file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: wrf_dir character(len=*), intent(in) :: vtk_xml_file_list (:) Return Value integer(kind=I4P) public function VTM_END_XML () result(E_IO) This function is used to finalize the VTM file opened. The \\LIBVTKIO manages the file unit without the user's action. Arguments None Return Value integer(kind=I4P)","loc":"module/vtk.html"},{"tags":"","title":"elements – MUSST","text":"Subroutines about the finite elements that are used Uses data_arch module~~elements~~UsesGraph module~elements elements module~data_arch data_arch module~elements->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~elements~~UsedByGraph module~elements elements module~film film module~film->module~elements module~test_musst test_musst module~test_musst->module~film module~inout_files inout_files module~test_musst->module~inout_files module~ms_film ms_film module~test_musst->module~ms_film module~inout_files->module~film module~inout_files->module~ms_film module~ms_film->module~film program~main main program~main->module~test_musst Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions ni4 ni4_up_1d ni4_up_2d ni_tanh_1d ni_tanh_1d_der ni_tanh_2d ni_tanh_2d_ksi ni_tanh_2d_eta ni4ksi ni4eta j4 dj4 Subroutines calc_ni4_xy_derivatives Functions public function ni4 (numn, ksi, eta) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn local node number: 1->SW, 2-> SE, 3->NE, 4->NW real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta Return Value real(kind=R8) private function ni4_up_1d (numn, ksi, pe, se) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn local node number real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: pe parameter controlling the shape function slope real(kind=R8), intent(in) :: se +1 -> upwind, -1 -> downwind Return Value real(kind=R8) public function ni4_up_2d (numn, ksi, eta, pe, se) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn local node number real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta real(kind=R8), intent(in), dimension(2) :: pe parameter controling the shape function slope for each direction real(kind=R8), intent(in), dimension(2) :: se +1 -> upwind, -1 -> downwind, for each direction Return Value real(kind=R8) private function ni_tanh_1d (numn, ksi, pe, se) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: pe real(kind=R8), intent(in) :: se Return Value real(kind=R8) private function ni_tanh_1d_der (numn, ksi, pe, se) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: pe real(kind=R8), intent(in) :: se Return Value real(kind=R8) private function ni_tanh_2d (numn, ksi, eta, pe, se) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta real(kind=R8), intent(in), dimension(2) :: pe real(kind=R8), intent(in), dimension(2) :: se Return Value real(kind=R8) private function ni_tanh_2d_ksi (numn, ksi, eta, pe, se) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta real(kind=R8), intent(in), dimension(2) :: pe real(kind=R8), intent(in), dimension(2) :: se Return Value real(kind=R8) private function ni_tanh_2d_eta (numn, ksi, eta, pe, se) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta real(kind=R8), intent(in), dimension(2) :: pe real(kind=R8), intent(in), dimension(2) :: se Return Value real(kind=R8) private function ni4ksi (numn, eta) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: eta Return Value real(kind=R8) private function ni4eta (numn, ksi) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: ksi Return Value real(kind=R8) private function j4 (numn, ksi, eta, x, y) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: numn real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta real(kind=R8), intent(in), dimension(4) :: x real(kind=R8), intent(in), dimension(4) :: y Return Value real(kind=R8) public function dj4 (ksi, eta, x, y) Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta real(kind=R8), intent(in), dimension(4) :: x real(kind=R8), intent(in), dimension(4) :: y Return Value real(kind=R8) Subroutines public subroutine calc_ni4_xy_derivatives (ni4x, ni4y, ksi, eta, x, y, dj) Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(4) :: ni4x real(kind=R8), intent(out), dimension(4) :: ni4y real(kind=R8), intent(in) :: ksi real(kind=R8), intent(in) :: eta real(kind=R8), intent(in), dimension(4) :: x real(kind=R8), intent(in), dimension(4) :: y real(kind=R8), intent(in) :: dj","loc":"module/elements.html"},{"tags":"","title":"surfile – MUSST","text":"Routines to handle Digital Surf binary format (.sur) Uses iso_c_binding data_arch sort_arrays module~~surfile~~UsesGraph module~surfile surfile module~sort_arrays sort_arrays module~surfile->module~sort_arrays iso_c_binding iso_c_binding module~surfile->iso_c_binding module~data_arch data_arch module~surfile->module~data_arch module~sort_arrays->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~surfile~~UsedByGraph module~surfile surfile module~test_musst test_musst module~test_musst->module~surfile module~film film module~test_musst->module~film module~ms_film ms_film module~test_musst->module~ms_film module~inout_files inout_files module~test_musst->module~inout_files module~film->module~surfile module~ms_film->module~surfile module~ms_film->module~film module~inout_files->module~surfile module~inout_files->module~film module~inout_files->module~ms_film program~main main program~main->module~test_musst Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables SURF_DAT SURF_SUR Derived Types SCALE_SURF OBJ_SURF Functions lower unit2IUc unit2IUf Subroutines scal2surf surf2scal empty c_f_string f_c_string init_scal trans_surf_txt open_surffile trans_surf_tab read_surf build_surf write_surffile write_surf Variables Type Visibility Attributes Name Initial integer(kind=4), private, parameter :: SURF_DAT = 1 '.dat' format, txt integer(kind=4), private, parameter :: SURF_SUR = 2 '.sur' format, binary Derived Types type, public :: SCALE_SURF Surface object: header and heights Read more… Components Type Visibility Attributes Name Initial character(len=12), public :: signature character(len=16), public :: xlength_unit character(len=16), public :: ylength_unit character(len=16), public :: zlength_unit character(len=16), public :: xaxis character(len=16), public :: yaxis character(len=16), public :: zaxis character(len=16), public :: dx_unit character(len=16), public :: dy_unit character(len=16), public :: dz_unit character(len=30), public :: object_name character(len=30), public :: operator_name character(len=128), public :: client_zone character(len=8), public :: reserved character(len=34), public :: reservedzone character(len=12), public :: obsolete character(len=10), public :: obsolete2 real(kind=R4), public :: dx real(kind=R4), public :: dy real(kind=R4), public :: dz real(kind=R4), public :: xunit_ratio real(kind=R4), public :: yunit_ratio real(kind=R4), public :: zunit_ratio real(kind=R4), public :: XOffset real(kind=R4), public :: YOffset real(kind=R4), public :: ZOffset real(kind=R4), public :: measurement_duration integer(kind=I4), public :: zmin integer(kind=I4), public :: zmax integer(kind=I4), public :: xres integer(kind=I4), public :: yres integer(kind=I4), public :: nofpoints integer(kind=2), public :: format integer(kind=2), public :: version integer(kind=2), public :: material_code integer(kind=2), public :: type integer(kind=2), public :: range integer(kind=2), public :: special_points integer(kind=2), public :: absolute integer(kind=2), public :: pointsize integer(kind=2), public :: imprint integer(kind=2), public :: inversion integer(kind=2), public :: leveling integer(kind=2), public :: seconds integer(kind=2), public :: minutes integer(kind=2), public :: hours integer(kind=2), public :: day integer(kind=2), public :: month integer(kind=2), public :: year integer(kind=2), public :: dayof integer(kind=2), public :: comment_size integer(kind=2), public :: private_size integer(kind=2), public :: nobjects integer(kind=2), public :: acquisition real(kind=R8), public :: lx surface length real(kind=R8), public :: ly surface width real(kind=R8), public :: lz surface height (max -min) real(kind=R8), public :: mu surface mean height real(kind=R8), public :: si surface mean height type, public :: OBJ_SURF Components Type Visibility Attributes Name Initial character(kind=C_CHAR), public, dimension( 12) :: signature character(kind=C_CHAR), public, dimension( 16) :: xlength_unit character(kind=C_CHAR), public, dimension( 16) :: ylength_unit character(kind=C_CHAR), public, dimension( 16) :: zlength_unit character(kind=C_CHAR), public, dimension( 16) :: xaxis character(kind=C_CHAR), public, dimension( 16) :: yaxis character(kind=C_CHAR), public, dimension( 16) :: zaxis character(kind=C_CHAR), public, dimension( 16) :: dx_unit character(kind=C_CHAR), public, dimension( 16) :: dy_unit character(kind=C_CHAR), public, dimension( 16) :: dz_unit character(kind=C_CHAR), public, dimension( 30) :: object_name character(kind=C_CHAR), public, dimension( 30) :: operator_name character(kind=C_CHAR), public, dimension(128) :: client_zone character(kind=C_CHAR), public, dimension(  8) :: reserved character(kind=C_CHAR), public, dimension( 34) :: reservedzone character(kind=C_CHAR), public, dimension( 12) :: obsolete character(kind=C_CHAR), public, dimension( 10) :: obsolete2 real(kind=C_FLOAT), public :: dx real(kind=C_FLOAT), public :: dy real(kind=C_FLOAT), public :: dz real(kind=C_FLOAT), public :: xunit_ratio real(kind=C_FLOAT), public :: yunit_ratio real(kind=C_FLOAT), public :: zunit_ratio real(kind=C_FLOAT), public :: XOffset real(kind=C_FLOAT), public :: YOffset real(kind=C_FLOAT), public :: ZOffset real(kind=C_FLOAT), public :: measurement_duration integer(kind=C_INT), public :: zmin integer(kind=C_INT), public :: zmax integer(kind=C_INT), public :: xres integer(kind=C_INT), public :: yres integer(kind=C_INT), public :: nofpoints integer(kind=C_SHORT), public :: format integer(kind=C_SHORT), public :: version integer(kind=C_SHORT), public :: material_code integer(kind=C_SHORT), public :: type integer(kind=C_SHORT), public :: range integer(kind=C_SHORT), public :: special_points integer(kind=C_SHORT), public :: absolute integer(kind=C_SHORT), public :: pointsize integer(kind=C_SHORT), public :: imprint integer(kind=C_SHORT), public :: inversion integer(kind=C_SHORT), public :: leveling integer(kind=C_SHORT), public :: seconds integer(kind=C_SHORT), public :: minutes integer(kind=C_SHORT), public :: hours integer(kind=C_SHORT), public :: day integer(kind=C_SHORT), public :: month integer(kind=C_SHORT), public :: year integer(kind=C_SHORT), public :: dayof integer(kind=C_SHORT), public :: comment_size integer(kind=C_SHORT), public :: private_size integer(kind=C_SHORT), public :: nobjects integer(kind=C_SHORT), public :: acquisition integer(kind=C_INT), public, allocatable :: val (:) heights Functions private function lower (s1) result(s2) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 string to transform to lower case Return Value character(len=len(s1)) result: same string but each character is lower case public function unit2IUc (string) result(met) Arguments Type Intent Optional Attributes Name character(kind=C_CHAR), intent(in), dimension(:) :: string Return Value real(kind=R8) public function unit2IUf (string) result(met) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value real(kind=R8) Subroutines public subroutine scal2surf (scal, surf) Arguments Type Intent Optional Attributes Name type( SCALE_SURF ), intent(in) :: scal object SCALE_SURF type( OBJ_SURF ), intent(out) :: surf object OBJ_SURF public subroutine surf2scal (surf, scal) Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(in) :: surf object OBJ_SURF type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF public subroutine empty (charinout) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: charinout private subroutine c_f_string (cs, fs, borne_s) Read more… Arguments Type Intent Optional Attributes Name character(kind=C_CHAR), intent(in), dimension(:) :: cs C string character(len=*), intent(out) :: fs Fortran string integer(kind=I4), intent(out) :: borne_s resulting Fortran string length private subroutine f_c_string (fs, cs) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fs fortran string character(kind=C_CHAR), intent(out), dimension(:) :: cs resulting C string public subroutine init_scal (scal, nx, ny, lx, ly, unit_z) Read more… Arguments Type Intent Optional Attributes Name type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF integer(kind=I4), intent(in), optional :: nx integer(kind=I4), intent(in), optional :: ny real(kind=R8), intent(in), optional :: lx real(kind=R8), intent(in), optional :: ly character(len=*), intent(in), optional :: unit_z public subroutine trans_surf_txt (surf, fichier, xyz) Read more… Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(in) :: surf object OBJ_SURF character(len=*), intent(in) :: fichier text file to write logical(kind=I4), intent(in) :: xyz whether to also write the heights (maybe huge) private subroutine open_surffile (fichier, surf, scal, dump) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fichier file to be read type( OBJ_SURF ), intent(out) :: surf object that will contain the file infos and heights type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF logical(kind=I4), intent(in), optional :: dump whether to transform the data in a text file private subroutine trans_surf_tab (surf, tab) Read more… Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(inout) :: surf object OBJ_SURF that contains the heights real(kind=R8), intent(out), dimension(:, :), allocatable :: tab height array public subroutine read_surf (nom_fic, mu, sq, tab_s, scal) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nom_fic file name real(kind=R8), intent(in) :: mu if > 0, values are centered real(kind=R8), intent(in) :: sq desired height standard deviation real(kind=R8), intent(out), dimension(:,:), allocatable :: tab_s height array type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF private subroutine build_surf (surf, tab) Read more… Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(inout) :: surf resulting object OBJ_SURF real(kind=R8), intent(in), dimension(1:surf%xres, 1:surf%yres) :: tab private subroutine write_surffile (fichier, surf) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fichier file to be written type( OBJ_SURF ), intent(inout) :: surf object OBJ_SURF to write public subroutine write_surf (nom_fic, tab_s, scal) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nom_fic file name real(kind=R8), intent(in), dimension(1:scal%xres, 1:scal%yres) :: tab_s type( SCALE_SURF ), intent(inout) :: scal object SCALE_SURF","loc":"module/surfile.html"},{"tags":"","title":"bspline – MUSST","text":"Determines the parameters of a function that interpolates\n History Jacob Williams, 10/30/2015 : Created 1D routine. Evaluates the tensor product piecewise polynomial\n History Jacob Williams, 10/30/2015 : Created 1D routine. Determines the parameters of a function that interpolates\n History Boisvert, Ronald, NBS : 25 may 1982 : Author of original routine. JEC : 000330 modified array declarations. Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. Evaluates the tensor product piecewise polynomial\n History Boisvert, Ronald, NBS : 25 may 1982 : Author of original routine. JEC : 000330 modified array declarations. Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. Check the validity of the inputs to the \"ink\" routines.\n Notes The code is new, but the logic is based on the original\n  logic in the CMLIB routines db2ink and db3ink. History Jacob Williams, 2/24/2015 : Created this routine. dbknot chooses a knot sequence for interpolation of order k at the\n History Jacob Williams, 2/24/2015 : Refactored this routine. dbtpcf computes b-spline interpolation coefficients for nf sets\n History Jacob Williams, 2/24/2015 : Refactored this routine. dbintk produces the b-spline coefficients, bcoef, of the\n Error conditions improper input singular system of equations History splint written by carl de boor [5] dbintk author: amos, d. e., (snla) : date written 800901 revision date 820801 000330 modified array declarations. (jec) Jacob Williams, 5/10/2015 : converted to free-form Fortran. Returns in w the LU-factorization (without pivoting) of the banded\n Work array Input w array of size (nroww,nrow) contains the interesting\n    part of a banded matrix  a , with the diagonals or bands of  a\n    stored in the rows of  w , while columns of  a  correspond to\n    columns of  w . this is the storage mode used in  linpack  and\n    results in efficient innermost loops.\n       explicitly,  a  has  nbandl  bands below the diagonal\n                        +     1     (main) diagonal\n                        +   nbandu  bands above the diagonal\n    and thus, with    middle = nbandu + 1,\n      a(i+j,j)  is in  w(i+middle,j)  for i=-nbandu,...,nbandl\n                                          j=1,...,nrow .\n    for example, the interesting entries of a (1,2)-banded matrix\n    of order  9  would appear in the first  1+1+2 = 4  rows of  w\n    as follows.\n                      13 24 35 46 57 68 79\n                   12 23 34 45 56 67 78 89\n                11 22 33 44 55 66 77 88 99\n                21 32 43 54 65 76 87 98\n\n    all other entries of  w  not identified in this way with an en-\n    try of  a  are never referenced . Output if  iflag = 1, then\n        w contains the lu-factorization of  a  into a unit lower triangu-\n        lar matrix  l  and an upper triangular matrix  u (both banded)\n        and stored in customary fashion over the corresponding entries\n        of  a . this makes it possible to solve any particular linear\n        system  a*x = b  for  x  by a\n              call dbnslv ( w, nroww, nrow, nbandl, nbandu, b )\n        with the solution x  contained in  b  on return . if  iflag = 2, then\n        one of  nrow-1, nbandl,nbandu failed to be nonnegative, or else\n        one of the potential pivots was found to be zero indicating\n        that  a  does not have an lu-factorization. this implies that\n        a  is singular in case it is totally positive . History banfac written by carl de boor [5] dbnfac from CMLIB [1] Jacob Williams, 5/10/2015 : converted to free-form Fortran. Companion routine to dbnfac . it returns the solution x of the\n History banslv written by carl de boor [5] dbnslv from SLATEC library [1] Jacob Williams, 5/10/2015 : converted to free-form Fortran. Calculates the value of all (possibly) nonzero basis\nError Conditions improper input History bsplvn written by carl de boor [5] dbspvn author: amos, d. e., (snla) : date written 800901 revision date 820801 000330 modified array declarations.  (jec) Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. Evaluates the b-representation (t,a,n,k) of a b-spline\nError Conditions improper input History bvalue written by carl de boor [5] dbvalu author: amos, d. e., (snla) : date written 800901 revision date 820801 000330 modified array declarations.  (jec) Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. Computes the largest integer ileft in 1 <= ileft <= lxt\n History interv written by carl de boor [5] dintrv author: amos, d. e., (snla) : date written 800901 revision date 820801 Jacob Williams, 2/24/2015 : updated to free-form Fortran. Uses iso_fortran_env iso_fortran_env module~~bspline~~UsesGraph module~bspline bspline iso_fortran_env iso_fortran_env module~bspline->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~bspline~~UsedByGraph module~bspline bspline module~ms_film ms_film module~ms_film->module~bspline module~test_musst test_musst module~test_musst->module~ms_film module~inout_files inout_files module~test_musst->module~inout_files module~inout_files->module~ms_film program~main main program~main->module~test_musst Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables wp Functions dbvalu Subroutines db1ink db1val db2ink db2val check_inputs dbknot dbtpcf dbintk dbnfac dbnslv dbspvn dintrv Variables Type Visibility Attributes Name Initial integer, private, parameter :: wp = real64 Real precision Functions private function dbvalu (t, a, n, k, ideriv, x, inbv, work, iflag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: t knot vector of length n+k real(kind=wp), intent(in), dimension(n) :: a b-spline coefficient vector of length n integer, intent(in) :: n number of b-spline coefficients.\n (sum of knot multiplicities-k) integer, intent(in) :: k order of the b-spline, k >= 1 integer, intent(in) :: ideriv order of the derivative, 0 <= ideriv <= k-1.\n ideriv = 0 returns the b-spline value real(kind=wp), intent(in) :: x argument, t(k) <= x <= t(n+1) integer, intent(inout) :: inbv an initialization parameter which must be set\n to 1 the first time dbvalu is called.\n inbv contains information for efficient process-\n ing after the initial call and inbv must not\n be changed by the user.  distinct splines require\n distinct inbv parameters. real(kind=wp), dimension(:) :: work work vector of length 3*k integer, intent(out) :: iflag Return Value real(kind=wp) Subroutines public subroutine db1ink (x, nx, fcn, kx, tx, bcoef, iflag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(nx) :: x Array of x abcissae. Must be strictly increasing. integer, intent(in) :: nx Number of x abcissae real(kind=wp), intent(in), dimension(nx) :: fcn Array of function values to interpolate. fcn(i) should\n    contain the function value at the point x(i) integer, intent(in) :: kx The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) real(kind=wp), intent(inout), dimension(nx+kx) :: tx The knots in the x direction for the spline interpolant.\n    If iflag=0 these are chosen by db1ink .\n    If iflag=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(out), dimension(nx) :: bcoef Array of coefficients of the b-spline interpolant. integer, intent(inout) :: iflag on input: 0 = knot sequence chosen by db1ink .\n                1 = knot sequence chosen by user. on output: 1 = successful execution.\n                2 = iflag out of range.\n                3 = nx out of range.\n                4 = kx out of range.\n                5 = x not strictly increasing.\n                6 = tx not non-decreasing. public subroutine db1val (xval, idx, tx, nx, kx, bcoef, f, iflag, inbvx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db1ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db1ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db1ink ) real(kind=wp), intent(in), dimension(nx) :: bcoef the b-spline coefficients computed by db1ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. public subroutine db2ink (x, nx, y, ny, fcn, kx, ky, tx, ty, bcoef, iflag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(nx) :: x Array of x abcissae. Must be strictly increasing. integer, intent(in) :: nx Number of x abcissae real(kind=wp), intent(in), dimension(ny) :: y Array of y abcissae. Must be strictly increasing. integer, intent(in) :: ny Number of y abcissae real(kind=wp), intent(in), dimension(nx,ny) :: fcn Array of function values to interpolate. fcn(i,j) should\n    contain the function value at the point (x(i),y(j)) integer, intent(in) :: kx The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: ky The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) real(kind=wp), intent(inout), dimension(nx+kx) :: tx The knots in the x direction for the spline interpolant.\n    If iflag=0 these are chosen by db2ink .\n    If iflag=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(inout), dimension(ny+ky) :: ty The knots in the y direction for the spline interpolant.\n    If iflag=0 these are chosen by db2ink .\n    If iflag=1 these are specified by the user.\n    Must be non-decreasing. real(kind=wp), intent(out), dimension(nx,ny) :: bcoef Array of coefficients of the b-spline interpolant. integer, intent(inout) :: iflag on input: 0 = knot sequence chosen by db2ink .\n                1 = knot sequence chosen by user. on output: 1 = successful execution.\n                2 = iflag out of range.\n                3 = nx out of range.\n                4 = kx out of range.\n                5 = x not strictly increasing.\n                6 = tx not non-decreasing.\n                7 = ny out of range.\n                8 = ky out of range.\n                9 = y not strictly increasing.\n               10 = ty not non-decreasing. public subroutine db2val (xval, yval, idx, idy, tx, ty, nx, ny, kx, ky, bcoef, f, iflag, inbvx, inbvy, iloy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. real(kind=wp), intent(in) :: yval y coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. integer, intent(in) :: idy y derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db2ink ) real(kind=wp), intent(in), dimension(ny+ky) :: ty sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to db2ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db2ink ) integer, intent(in) :: ny the number of interpolation points in y. (same as in last call to db2ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db2ink ) integer, intent(in) :: ky order of polynomial pieces in y. (same as in last call to db2ink ) real(kind=wp), intent(in), dimension(nx,ny) :: bcoef the b-spline coefficients computed by db2ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. private subroutine check_inputs (routine, iflag, nx, ny, nz, nq, nr, ns, kx, ky, kz, kq, kr, ks, x, y, z, q, r, s, tx, ty, tz, tq, tr, ts, status_ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: routine integer, intent(inout) :: iflag integer, intent(in), optional :: nx integer, intent(in), optional :: ny integer, intent(in), optional :: nz integer, intent(in), optional :: nq integer, intent(in), optional :: nr integer, intent(in), optional :: ns integer, intent(in), optional :: kx integer, intent(in), optional :: ky integer, intent(in), optional :: kz integer, intent(in), optional :: kq integer, intent(in), optional :: kr integer, intent(in), optional :: ks real(kind=wp), intent(in), optional dimension(:) :: x real(kind=wp), intent(in), optional dimension(:) :: y real(kind=wp), intent(in), optional dimension(:) :: z real(kind=wp), intent(in), optional dimension(:) :: q real(kind=wp), intent(in), optional dimension(:) :: r real(kind=wp), intent(in), optional dimension(:) :: s real(kind=wp), intent(in), optional dimension(:) :: tx real(kind=wp), intent(in), optional dimension(:) :: ty real(kind=wp), intent(in), optional dimension(:) :: tz real(kind=wp), intent(in), optional dimension(:) :: tq real(kind=wp), intent(in), optional dimension(:) :: tr real(kind=wp), intent(in), optional dimension(:) :: ts logical, intent(out) :: status_ok private subroutine dbknot (x, n, k, t) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(n) :: x integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(out), dimension(:) :: t private subroutine dbtpcf (x, n, fcn, ldf, nf, t, k, bcoef, work, iflag) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) integer, intent(in) :: n real(kind=wp) :: fcn (ldf,nf) integer, intent(in) :: ldf integer, intent(in) :: nf real(kind=wp) :: t (*) integer, intent(in) :: k real(kind=wp) :: bcoef (nf,n) real(kind=wp) :: work (*) integer, intent(out) :: iflag private subroutine dbintk (x, y, t, n, k, bcoef, q, work, iflag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(n) :: x vector of length n containing data point abscissa\n in strictly increasing order. real(kind=wp), intent(in), dimension(n) :: y corresponding vector of length n containing data\n point ordinates. real(kind=wp), intent(in), dimension(*) :: t knot vector of length n+k\n since t(1),..,t(k) <= x(1) and t(n+1),..,t(n+k) Read more… integer, intent(in) :: n number of data points, n >= k integer, intent(in) :: k order of the spline, k >= 1 real(kind=wp), intent(out), dimension(n) :: bcoef a vector of length n containing the b-spline coefficients real(kind=wp), intent(out), dimension(*) :: q a work vector of length (2 k-1) n, containing\n the triangular factorization of the coefficient\n matrix of the linear system being solved.  the\n coefficients for the interpolant of an\n additional data set (x(i),yy(i)), i=1,…,n\n with the same abscissa can be obtained by loading\n yy into bcoef and then executing\n call dbnslv(q,2k-1,n,k-1,k-1,bcoef) real(kind=wp), intent(out), dimension(*) :: work work vector of length 2*k integer, intent(out) :: iflag corresponding basis function and the system is singular.\n 104: the system of solver detects a singular system.\n although the theoretical conditions for a solution were satisfied. private subroutine dbnfac (w, nroww, nrow, nbandl, nbandu, iflag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(nroww,nrow) :: w work array. See header for details. integer, intent(in) :: nroww row dimension of the work array w. must be >= nbandl + 1 + nbandu. integer, intent(in) :: nrow matrix order integer, intent(in) :: nbandl number of bands of a below the main diagonal integer, intent(in) :: nbandu number of bands of a above the main diagonal integer, intent(out) :: iflag indicating success(=1) or failure (=2) private subroutine dbnslv (w, nroww, nrow, nbandl, nbandu, b) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(nroww,nrow) :: w describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nroww describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nrow describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nbandl describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nbandu describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . real(kind=wp), intent(inout), dimension(nrow) :: b in : right side of the system to be solved out : the solution x, of order nrow private subroutine dbspvn (t, jhigh, k, index, x, ileft, vnikx, work, iwork, iflag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t (*) knot vector of length n+k, where\n n = number of b-spline basis functions\n n = sum of knot multiplicities-k\n dimension t(ileft+jhigh) integer, intent(in) :: jhigh order of b-spline, 1 <= jhigh <= k integer, intent(in) :: k highest possible order integer, intent(in) :: index index = 1 gives basis functions of order jhigh\n       = 2 denotes previous entry with work, iwork\n         values saved for subsequent calls to\n         dbspvn. real(kind=wp), intent(in) :: x argument of basis functions, t(k) <= x <= t(n+1) integer, intent(in) :: ileft largest integer such that t(ileft) <= x < t(ileft+1) real(kind=wp), intent(out) :: vnikx (k) vector of length k for spline values. real(kind=wp), intent(out) :: work (*) a work vector of length 2*k integer, intent(out) :: iwork a work parameter.  both work and iwork contain\n information necessary to continue for index = 2.\n when index = 1 exclusively, these are scratch\n variables and can be used for other purposes. integer, intent(out) :: iflag private subroutine dintrv (XT, lxt, x, ilo, ileft, mflag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(lxt) :: XT a knot or break point vector of length lxt integer, intent(in) :: lxt length of the XT vector real(kind=wp), intent(in) :: x argument integer, intent(inout) :: ilo an initialization parameter which must be set\n to 1 the first time the spline array XT is\n processed by dintrv. ilo contains information for\n efficient processing after the initial call and ilo\n must not be changed by the user.  distinct splines\n require distinct ilo parameters. integer, intent(out) :: ileft largest integer satisfying XT(ileft) <= x integer, intent(out) :: mflag signals when x lies out of bounds","loc":"module/bspline.html"},{"tags":"","title":"sort_arrays – MUSST","text":"Various routines to sort real/integer arrays Uses data_arch module~~sort_arrays~~UsesGraph module~sort_arrays sort_arrays module~data_arch data_arch module~sort_arrays->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~sort_arrays~~UsedByGraph module~sort_arrays sort_arrays module~surfile surfile module~surfile->module~sort_arrays module~solver solver module~solver->module~sort_arrays module~test_musst test_musst module~test_musst->module~surfile module~test_musst->module~solver module~film film module~test_musst->module~film module~ms_film ms_film module~test_musst->module~ms_film module~inout_files inout_files module~test_musst->module~inout_files program~main main program~main->module~solver program~main->module~test_musst module~film->module~surfile module~film->module~solver module~ms_film->module~surfile module~ms_film->module~solver module~ms_film->module~film module~inout_files->module~surfile module~inout_files->module~film module~inout_files->module~ms_film Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines init_order sort_integer sort_real sort_real_1real sort_real_1int sort_real_2real sort_int_1int_1real sort_int_1real Subroutines public subroutine init_order (order) Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(out), dimension(:) :: order public recursive subroutine sort_integer (g, d, itabref) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d integer(kind=I4), intent(inout), dimension(:) :: itabref public recursive subroutine sort_real (g, d, rtabref) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d real(kind=R8), intent(inout), dimension(:) :: rtabref public recursive subroutine sort_real_1real (g, d, rtabref, rtab1) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d real(kind=R8), intent(inout), dimension(:) :: rtabref real(kind=R8), intent(inout), dimension(:) :: rtab1 public recursive subroutine sort_real_1int (g, d, rtabref, itab1) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d real(kind=R8), intent(inout), dimension(:) :: rtabref integer(kind=I4), intent(inout), dimension(:) :: itab1 public recursive subroutine sort_real_2real (g, d, rtabref, rtab1, rtab2) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d real(kind=R8), intent(inout), dimension(:) :: rtabref real(kind=R8), intent(inout), dimension(:) :: rtab1 real(kind=R8), intent(inout), dimension(:) :: rtab2 public recursive subroutine sort_int_1int_1real (g, d, itabref, itab1, rtab2) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d integer(kind=I4), intent(inout), dimension(:) :: itabref integer(kind=I4), intent(inout), dimension(:) :: itab1 real(kind=R8), intent(inout), dimension(:) :: rtab2 public recursive subroutine sort_int_1real (g, d, itabref, rtab1) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g integer(kind=I4), intent(in) :: d integer(kind=I4), intent(inout), dimension(:) :: itabref real(kind=R8), intent(inout), dimension(:) :: rtab1","loc":"module/sort_arrays.html"},{"tags":"","title":"data_arch – MUSST","text":"General type definition Uses iso_fortran_env module~~data_arch~~UsesGraph module~data_arch data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~data_arch~~UsedByGraph module~data_arch data_arch module~mesh mesh module~mesh->module~data_arch module~fluid_law fluid_law module~fluid_law->module~data_arch module~film film module~film->module~data_arch module~film->module~mesh module~film->module~fluid_law module~surfile surfile module~film->module~surfile module~elements elements module~film->module~elements module~solver solver module~film->module~solver module~data_film_hd data_film_hd module~film->module~data_film_hd module~num_param num_param module~film->module~num_param module~gen_param gen_param module~gen_param->module~data_arch module~ms_film ms_film module~ms_film->module~data_arch module~ms_film->module~mesh module~ms_film->module~fluid_law module~ms_film->module~film module~ms_film->module~surfile module~ms_film->module~solver module~ms_film->module~data_film_hd module~ms_film->module~num_param module~surfile->module~data_arch module~sort_arrays sort_arrays module~surfile->module~sort_arrays module~test_musst test_musst module~test_musst->module~data_arch module~test_musst->module~film module~test_musst->module~ms_film module~test_musst->module~surfile module~test_musst->module~solver module~inout_files inout_files module~test_musst->module~inout_files module~test_musst->module~data_film_hd module~test_musst->module~num_param module~elements->module~data_arch module~solver->module~data_arch module~solver->module~gen_param module~solver->module~sort_arrays module~inout_files->module~data_arch module~inout_files->module~film module~inout_files->module~ms_film module~inout_files->module~surfile module~data_film_hd->module~data_arch module~data_film_hd->module~fluid_law module~sort_arrays->module~data_arch module~num_param->module~data_arch program~main main program~main->module~data_arch program~main->module~test_musst program~main->module~solver program~main->module~num_param var panmoduledata_archUsedByGraph = svgPanZoom('#moduledata_archUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables I4 I8 R4 R8 HIG_I4 OPU IPU ERU UN PI_R4 PI_R8 EPS_R4 EPS_R8 HIG_R8 HIG_E8 EPS_E8 EXPO_MAX NB_THREADS_MAX Subroutines get_unit Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: I4 = int32 integer(kind=I4), public, parameter :: I8 = int64 integer(kind=I4), public, parameter :: R4 = real32 integer(kind=I4), public, parameter :: R8 = real64 integer(kind=I4), public, parameter :: HIG_I4 = huge(1) integer(kind=I4), public, parameter :: OPU = output_unit Output unit integer(kind=I4), public, parameter :: IPU = input_unit Input unit integer(kind=I4), public, parameter :: ERU = error_unit Error unit real(kind=R8), public, parameter :: UN = 1.0_R8 real(kind=R4), public, parameter :: PI_R4 = acos(-1._R4) real(kind=R8), public, parameter :: PI_R8 = acos(-1._R8) real(kind=R4), public, parameter :: EPS_R4 = tiny(1._R4) real(kind=R8), public, parameter :: EPS_R8 = tiny(1._R8) real(kind=R8), public, parameter :: HIG_R8 = huge(1._R8) real(kind=R8), public, parameter :: HIG_E8 = log(HIG_R8) real(kind=R8), public, parameter :: EPS_E8 = log(EPS_R8) integer(kind=I4), public, parameter :: EXPO_MAX = exponent(HIG_R8) integer(kind=I4), public :: NB_THREADS_MAX = 1 Subroutines public subroutine get_unit (iunit) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(out) :: iunit","loc":"module/data_arch.html"},{"tags":"","title":"mumps_wrapper – MUSST","text":"Used by module~~mumps_wrapper~~UsedByGraph module~mumps_wrapper mumps_wrapper module~solver solver module~solver->module~mumps_wrapper module~test_musst test_musst module~test_musst->module~solver module~film film module~test_musst->module~film module~ms_film ms_film module~test_musst->module~ms_film module~inout_files inout_files module~test_musst->module~inout_files module~film->module~solver module~ms_film->module~solver module~ms_film->module~film program~main main program~main->module~solver program~main->module~test_musst module~inout_files->module~film module~inout_files->module~ms_film var panmodulemumps_wrapperUsedByGraph = svgPanZoom('#modulemumps_wrapperUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables MPI_COMM_WORLD Derived Types DMUMPS_STRUC Variables Type Visibility Attributes Name Initial integer, public, parameter :: MPI_COMM_WORLD = 9 Derived Types type, public, sequence  :: DMUMPS_STRUC Components Type Visibility Attributes Name Initial integer, public :: COMM integer, public :: SYM integer, public :: PAR integer, public :: JOB integer, public :: N integer, public :: NZ integer(kind=8), public :: NNZ double precision, public, DIMENSION(:), POINTER :: A integer, public, DIMENSION(:), POINTER :: IRN integer, public, DIMENSION(:), POINTER :: JCN double precision, public, DIMENSION(:), POINTER :: COLSCA double precision, public, DIMENSION(:), POINTER :: ROWSCA double precision, public, DIMENSION(:), POINTER :: pad0 integer, public :: NZ_loc integer, public :: pad1 integer(kind=8), public :: NNZ_loc integer, public, DIMENSION(:), POINTER :: IRN_loc integer, public, DIMENSION(:), POINTER :: JCN_loc double precision, public, DIMENSION(:), POINTER :: A_loc double precision, public, DIMENSION(:), POINTER :: pad2 integer, public :: NELT integer, public :: pad3 integer, public, DIMENSION(:), POINTER :: ELTPTR integer, public, DIMENSION(:), POINTER :: ELTVAR double precision, public, DIMENSION(:), POINTER :: A_ELT double precision, public, DIMENSION(:), POINTER :: pad4 integer, public, DIMENSION(:), POINTER :: PERM_IN double precision, public, DIMENSION(:), POINTER :: RHS double precision, public, DIMENSION(:), POINTER :: REDRHS double precision, public, DIMENSION(:), POINTER :: RHS_SPARSE double precision, public, DIMENSION(:), POINTER :: SOL_loc integer, public, DIMENSION(:), POINTER :: IRHS_SPARSE integer, public, DIMENSION(:), POINTER :: IRHS_PTR integer, public, DIMENSION(:), POINTER :: ISOL_loc integer, public :: LRHS integer, public :: NRHS integer, public :: NZ_RHS integer, public :: LSOL_loc integer, public :: LREDRHS integer, public :: pad5 integer, public :: ICNTL (40) integer, public :: INFO (40) integer, public :: INFOG (40) double precision, public :: COST_SUBTREES double precision, public :: CNTL (15) double precision, public :: RINFO (40) double precision, public :: RINFOG (40) integer, public, DIMENSION(:), POINTER :: SYM_PERM integer, public, DIMENSION(:), POINTER :: UNS_PERM integer, public :: NPROW integer, public :: NPCOL integer, public :: MBLOCK integer, public :: NBLOCK integer, public :: SCHUR_MLOC integer, public :: SCHUR_NLOC integer, public :: SCHUR_LLD integer, public :: SIZE_SCHUR double precision, public, DIMENSION(:), POINTER :: SCHUR double precision, public, DIMENSION(:), POINTER :: SCHUR_CINTERFACE integer, public, DIMENSION(:), POINTER :: LISTVAR_SCHUR integer, public, DIMENSION(:), POINTER :: MAPPING character(len=30), public :: VERSION_NUMBER character(len=255), public :: OOC_TMPDIR character(len=63), public :: OOC_PREFIX character(len=255), public :: WRITE_PROBLEM character(len=255), public :: SAVE_DIR character(len=255), public :: SAVE_PREFIX character(len=7), public :: pad8 integer(kind=8), public :: KEEP8 (150) integer(kind=8), public :: MAX_SURF_MASTER integer, public :: INST_Number integer, public :: COMM_NODES integer, public :: MYID_NODES integer, public :: COMM_LOAD integer, public :: MYID integer, public :: NPROCS integer, public :: NSLAVES integer, public :: ASS_IRECV integer, public :: LBUFR integer, public :: LBUFR_BYTES integer, public, DIMENSION(:), POINTER :: BUFR integer, public, DIMENSION(:), POINTER :: IS integer, public, DIMENSION(:), POINTER :: IS1 integer, public :: MAXIS1 integer, public :: Deficiency integer, public :: KEEP (500) integer, public :: LNA integer, public :: NBSA integer, public, POINTER, DIMENSION(:) :: STEP integer, public, POINTER, DIMENSION(:) :: NE_STEPS integer, public, POINTER, DIMENSION(:) :: ND_STEPS integer, public, POINTER, DIMENSION(:) :: Step2node integer, public, POINTER, DIMENSION(:) :: FRERE_STEPS integer, public, POINTER, DIMENSION(:) :: DAD_STEPS integer, public, POINTER, DIMENSION(:) :: FILS integer, public, POINTER, DIMENSION(:) :: FRTPTR integer, public, POINTER, DIMENSION(:) :: FRTELT integer(kind=8), public, POINTER, DIMENSION(:) :: PTRAR integer, public, POINTER, DIMENSION(:) :: NA integer, public, POINTER, DIMENSION(:) :: PROCNODE_STEPS integer, public, DIMENSION(:), POINTER :: PTLUST_S integer(kind=8), public, DIMENSION(:), POINTER :: PTRFAC double precision, public, DIMENSION(:), POINTER :: S integer, public, DIMENSION(:), POINTER :: PROCNODE integer, public, DIMENSION(:), POINTER :: INTARR double precision, public, DIMENSION(:), POINTER :: DBLARR integer, public :: NELT_loc integer, public :: LELTVAR integer, public, DIMENSION(:), POINTER :: ELTPROC integer, public, DIMENSION(:,:), POINTER :: CANDIDATES integer, public, DIMENSION(:), POINTER :: ISTEP_TO_INIV2 integer, public, DIMENSION(:), POINTER :: FUTURE_NIV2 integer, public, DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE logical, public, DIMENSION(:), POINTER :: I_AM_CAND integer, public, DIMENSION(:), POINTER :: MEM_DIST integer, public, DIMENSION(:), POINTER :: POSINRHSCOMP_ROW logical, public :: POSINRHSCOMP_COL_ALLOC logical, public :: pad11 integer, public, DIMENSION(:), POINTER :: POSINRHSCOMP_COL double precision, public, DIMENSION(:), POINTER :: RHSCOMP double precision, public, DIMENSION(:), POINTER :: MEM_SUBTREE double precision, public, DIMENSION(:), POINTER :: COST_TRAV integer, public, DIMENSION(:), POINTER :: MY_ROOT_SBTR integer, public, DIMENSION(:), POINTER :: MY_FIRST_LEAF integer, public, DIMENSION(:), POINTER :: MY_NB_LEAF integer, public, DIMENSION(:), POINTER :: DEPTH_FIRST integer, public, DIMENSION(:), POINTER :: DEPTH_FIRST_SEQ integer, public, DIMENSION(:), POINTER :: SBTR_ID integer, public, DIMENSION(:), POINTER :: SCHED_DEP integer, public, DIMENSION(:), POINTER :: SCHED_GRP integer, public, DIMENSION(:), POINTER :: SCHED_SBTR integer, public, DIMENSION(:), POINTER :: CROIX_MANU double precision, public, DIMENSION(:), POINTER :: WK_USER integer, public :: NBSA_LOCAL integer, public :: LWK_USER double precision, public :: DKEEP (230) double precision, public, DIMENSION(:), POINTER :: CB_SON_SIZE integer, public :: INSTANCE_NUMBER integer, public :: OOC_MAX_NB_NODES_FOR_ZONE integer, public, DIMENSION(:,:), POINTER :: OOC_INODE_SEQUENCE integer(kind=8), public, DIMENSION(:,:), POINTER :: OOC_SIZE_OF_BLOCK integer(kind=8), public, DIMENSION(:,:), POINTER :: OOC_VADDR integer, public, DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES integer, public, DIMENSION(:), POINTER :: OOC_NB_FILES integer, public :: OOC_NB_FILE_TYPE integer, public :: pad12 integer, public, DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH character, public, DIMENSION(:,:), POINTER :: OOC_FILE_NAMES integer, public, DIMENSION(:), POINTER :: PIVNUL_LIST integer, public, DIMENSION(:,:), POINTER :: SUP_PROC integer, public, DIMENSION(:,:), POINTER :: pad14 integer, public, DIMENSION(:), POINTER :: IPTR_WORKING integer, public, DIMENSION(:), POINTER :: WORKING type(DMUMPS_ROOT_STRUC), public :: root integer, public, POINTER, DIMENSION(:) :: LRGROUPS integer, public :: NBGRP integer, public :: pad13 character(len=1), public, DIMENSION(:), POINTER :: FDM_F_ENCODING character(len=1), public, DIMENSION(:), POINTER :: BLRARRAY_ENCODING integer, public :: LPOOL_AFTER_L0_OMP integer, public :: LPOOL_BEFORE_L0_OMP integer, public :: L_PHYS_L0_OMP integer, public :: L_VIRT_L0_OMP integer, public :: LL0_OMP_MAPPING integer, public :: pad15 integer(kind=8), public :: THREAD_LA integer, public, DIMENSION(:), POINTER :: IPOOL_BEFORE_L0_OMP integer, public, DIMENSION(:), POINTER :: IPOOL_AFTER_L0_OMP integer, public, DIMENSION(:), POINTER :: PHYS_L0_OMP integer, public, DIMENSION(:), POINTER :: VIRT_L0_OMP integer, public, DIMENSION(:), POINTER :: PERM_L0_OMP integer, public, DIMENSION(:), POINTER :: PTR_LEAFS_L0_OMP integer, public, DIMENSION(:), POINTER :: L0_OMP_MAPPING double precision, public, DIMENSION(:), POINTER :: SINGULAR_VALUES integer, public :: NB_SINGULAR_VALUES logical, public :: ASSOCIATED_OOC_FILES","loc":"module/mumps_wrapper.html"},{"tags":"","title":"gen_param – MUSST","text":"MUSST general parameters Uses data_arch module~~gen_param~~UsesGraph module~gen_param gen_param module~data_arch data_arch module~gen_param->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~gen_param~~UsedByGraph module~gen_param gen_param module~solver solver module~solver->module~gen_param module~test_musst test_musst module~test_musst->module~solver module~film film module~test_musst->module~film module~ms_film ms_film module~test_musst->module~ms_film module~inout_files inout_files module~test_musst->module~inout_files module~film->module~solver module~ms_film->module~solver module~ms_film->module~film program~main main program~main->module~solver program~main->module~test_musst module~inout_files->module~film module~inout_files->module~ms_film Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables NO_MESS PRINT_MESS SOLV_MESS VERBOSE OUTPUT_FILE Variables Type Visibility Attributes Name Initial integer(kind=I4), public, parameter :: NO_MESS = 0 code for no message on screen during problem solving integer(kind=I4), public, parameter :: PRINT_MESS = 1 code for printing message during problem solving integer(kind=I4), public :: SOLV_MESS = NO_MESS Solver output detail control integer(kind=I4), public :: VERBOSE Output detail control character(len=128), public :: OUTPUT_FILE When needed, output file","loc":"module/gen_param.html"},{"tags":"","title":"solver – MUSST","text":"Api for different sparse matrix solvers Uses iso_c_binding iso_fortran_env data_arch gen_param sort_arrays hsl_ma48_double sulu_wrapper mumps_wrapper mumfpack module~~solver~~UsesGraph module~solver solver module~sulu_wrapper sulu_wrapper module~solver->module~sulu_wrapper module~gen_param gen_param module~solver->module~gen_param module~mumfpack mumfpack module~solver->module~mumfpack iso_c_binding iso_c_binding module~solver->iso_c_binding module~mumps_wrapper mumps_wrapper module~solver->module~mumps_wrapper iso_fortran_env iso_fortran_env module~solver->iso_fortran_env module~sort_arrays sort_arrays module~solver->module~sort_arrays hsl_ma48_double hsl_ma48_double module~solver->hsl_ma48_double module~data_arch data_arch module~solver->module~data_arch module~sulu_wrapper->iso_c_binding module~gen_param->module~data_arch module~mumfpack->iso_c_binding module~sort_arrays->module~data_arch module~data_arch->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~solver~~UsedByGraph module~solver solver module~test_musst test_musst module~test_musst->module~solver module~film film module~test_musst->module~film module~ms_film ms_film module~test_musst->module~ms_film module~inout_files inout_files module~test_musst->module~inout_files module~film->module~solver module~ms_film->module~solver module~ms_film->module~film program~main main program~main->module~solver program~main->module~test_musst module~inout_files->module~film module~inout_files->module~ms_film Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables MA48 SULU MUMP UMFP SOLVER_BS SOLVER_TS Derived Types MAT_MA48 MAT_MA48 MAT_UMFP MAT_SOLV MS_MAT_SOLV Subroutines solve_syst init_solver analyse_solver factorize_solver solution_solver freefact_solver close_solver convert_matrice_format from_elemental_to_assembled Variables Type Visibility Attributes Name Initial integer(kind=I4), private, parameter :: MA48 = 0 code for     Ma48 solver type integer(kind=I4), public, parameter :: SULU = 1 code for SUPER LU solver type integer(kind=I4), public, parameter :: MUMP = 2 code for    MUMPS solver type integer(kind=I4), public, parameter :: UMFP = 3 code for  UMFPACK solver type integer(kind=I4), public :: SOLVER_BS = -1 solver used for bottom scale grids [not used by the present module] integer(kind=I4), public :: SOLVER_TS = -1 solver used for top scale grids [not used by the present module] Derived Types type, private :: MAT_MA48 All the stuff needed by HSL_MA48 Components Type Visibility Attributes Name Initial type(ZD11_TYPE), public :: zmat type(MA48_CONTROL), public :: ctrl type(MA48_AINFO), public :: ainf type(MA48_FINFO), public :: finf type(MA48_SINFO), public :: sinf type(MA48_FACTORS), public :: fact integer(kind=I4), public :: fast real(kind=R8), public, dimension(2) :: resid type, private :: MAT_MA48 type, private :: MAT_UMFP All the stuff needed by UMFPACK Components Type Visibility Attributes Name Initial type(c_ptr), public :: c_symbolic type(c_ptr), public :: c_numeric real(kind=R8), public, dimension(0:UMFPACK_CONTROL-1) :: c_control real(kind=R8), public, dimension(0:UMFPACK_INFO   -1) :: c_info type, public :: MAT_SOLV MUSST high level system type Components Type Visibility Attributes Name Initial integer(kind=I4), public :: slv_t solver type logical(kind=I4), public :: first = .true. analysis of the system to be done? integer(kind=I4), public :: nn number of nodes integer(kind=I4), public :: ne number of elements integer(kind=I4), public :: nt number of a priori non-zero terms in the matrix integer(kind=I4), public :: nz number of non-zero terms in the matrix integer(kind=I4), public :: nvar eltvar length ( if 4-nodes elt -> 2 lines X number of elemental matrices) integer(kind=I4), public :: code error code [not used yet] real(kind=R8), public :: error error value [not used yet] character(len=1024), public :: mess message [not used yet] type(MAT_MUMP), public :: matmump matrices for mumps solver type( MAT_MA48 ), public :: matma48 matrices for ma48 solver type(MAT_SULU), public :: matsulu matrices for SuperLu solver type( MAT_UMFP ), public :: matumfp matrices for Umfpack solver integer(kind=I4), public, dimension(:), allocatable :: eltvar rows in assembled matrix integer(kind=I4), public, dimension(:), allocatable :: eltptr element rows pointer real(kind=R8), public, dimension(:), allocatable :: a_elt unassembled rigidity matrix integer(kind=I4), public, dimension(:), allocatable :: irow line number integer(kind=I4), public, dimension(:), allocatable :: jcol column number integer(kind=I4), public, dimension(:), allocatable :: jptr line pointer real(kind=R8), public, dimension(:), allocatable :: b right hand side vector real(kind=R8), public, dimension(:), allocatable :: x unknwon vector type, public :: MS_MAT_SOLV MUSST multiscale high level solver type Read more… Components Type Visibility Attributes Name Initial type( MAT_SOLV ), public :: ts_mat top-scale solver type matrices type( MAT_SOLV ), public, dimension(:), allocatable :: bs_mat bottom-scale solver type matrices (table) integer(kind=I4), public, dimension(:), allocatable :: ass_loc_in_mat table for assembly location (for parallel computation) Subroutines public subroutine solve_syst (mat, step) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type character(len=*), intent(in) :: step 'ini'=initialize, 'ana'=analyze, 'fac'=factorize, 'sol'=solve, 'fre'=free memory, 'end'=close solver private subroutine init_solver (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type private subroutine analyse_solver (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type private subroutine factorize_solver (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type private subroutine solution_solver (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type private subroutine freefact_solver (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type private subroutine close_solver (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type public subroutine convert_matrice_format (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type private subroutine from_elemental_to_assembled (mat) Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type","loc":"module/solver.html"},{"tags":"","title":"sulu_wrapper – MUSST","text":"A SuperLU wrapper Uses iso_c_binding module~~sulu_wrapper~~UsesGraph module~sulu_wrapper sulu_wrapper iso_c_binding iso_c_binding module~sulu_wrapper->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~sulu_wrapper~~UsedByGraph module~sulu_wrapper sulu_wrapper module~solver solver module~solver->module~sulu_wrapper module~test_musst test_musst module~test_musst->module~solver module~film film module~test_musst->module~film module~ms_film ms_film module~test_musst->module~ms_film module~inout_files inout_files module~test_musst->module~inout_files module~film->module~solver module~ms_film->module~solver module~ms_film->module~film program~main main program~main->module~solver program~main->module~test_musst module~inout_files->module~film module~inout_files->module~ms_film var panmodulesulu_wrapperUsedByGraph = svgPanZoom('#modulesulu_wrapperUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables I4 R4 R8 Enumerations Interfaces Destroy_SuperNode_Matrix Destroy_SuperMatrix_Store Destroy_CompCol_Matrix Destroy_Dense_Matrix StatInit StatFree dCreate_CompCol_Matrix dCreate_Dense_Matrix set_default_options dgssvx StatPrint Derived Types LU_STACK_T EXPHEADER GLOBALLU_T SUPERLUSTAT_T MEM_USAGE_T NCFORMAT SUPERMATRIX SUPERLU_OPTIONS_T SULU_ENV Subroutines init_superlu prep_superlu fact_superlu solv_superlu free_superlu close_superlu Variables Type Visibility Attributes Name Initial integer(kind=4), private, parameter :: I4 = 4 integer(kind=4), private, parameter :: R4 = 4 integer(kind=4), private, parameter :: R8 = 8 Enumerations enum, bind(c) Enumerators enumerator :: NOTRANS = 0 enumerator :: TRANS = 1 enumerator :: CONJ = 2 enum, bind(c) Enumerators enumerator :: DOFACT = 0 enumerator :: SAMEPATTERN = 1 enumerator :: SAMEPATTERN_SAMEROWPERM = 2 enumerator :: FACTORED = 3 enum, bind(c) Enumerators enumerator :: SLU_NC = 0 column-wise, no supernode enumerator :: SLU_NCP = 1 column-wise, column-permuted, no supernode enumerator :: SLU_NR = 2 row-wize, no supernode enumerator :: SLU_SC = 3 column-wise, supernode enumerator :: SLU_SCP = 4 supernode, column-wise, permuted enumerator :: SLU_SR = 5 row-wise, supernode enumerator :: SLU_DN = 6 Fortran style column-wise storage for dense matrix enumerator :: SLU_NR_loc = 7 distributed compressed row format enum, bind(c) Enumerators enumerator :: SLU_S = 0 single enumerator :: SLU_D = 1 double enumerator :: SLU_C = 2 single complex enumerator :: SLU_Z = 3 double complex enum, bind(c) Enumerators enumerator :: SLU_GE = 0 general enumerator :: SLU_TRLU = 1 lower triangular, unit diagonal enumerator :: SLU_TRUU = 2 upper triangular, unit diagonal enumerator :: SLU_TRL = 3 lower triangular enumerator :: SLU_TRU = 4 upper triangular enumerator :: SLU_SYL = 5 symmetric, store lower half enumerator :: SLU_SYU = 6 symmetric, store upper half enumerator :: SLU_HEL = 7 Hermitian, store lower half enumerator :: SLU_HEU = 8 Hermitian, store upper half Interfaces interface public subroutine Destroy_SuperNode_Matrix(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A interface private subroutine Destroy_SuperMatrix_Store(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A interface public subroutine Destroy_CompCol_Matrix(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A interface private subroutine Destroy_Dense_Matrix(A) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A interface private subroutine StatInit(stat) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(out) :: stat interface private subroutine StatFree(stat) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(in) :: stat interface private subroutine dCreate_CompCol_Matrix(A, m, n, nnz, nzval, rowind, colptr, stype, dtype, mtype) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(out) :: A integer(kind=C_INT), intent(in), value :: m integer(kind=C_INT), intent(in), value :: n integer(kind=C_INT), intent(in), value :: nnz real(kind=C_DOUBLE), intent(in) :: nzval (*) integer(kind=C_INT), intent(in) :: rowind (*) integer(kind=C_INT), intent(in) :: colptr (*) integer(kind=C_INT), intent(in), value :: stype integer(kind=C_INT), intent(in), value :: dtype integer(kind=C_INT), intent(in), value :: mtype interface private subroutine dCreate_Dense_Matrix(BX, m, n, x, ldx, stype, dtype, mtype) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(out) :: BX integer(kind=C_INT), intent(in), value :: m integer(kind=C_INT), intent(in), value :: n real(kind=C_DOUBLE), intent(in) :: x (*) integer(kind=C_INT), intent(in), value :: ldx integer(kind=C_INT), intent(in), value :: stype integer(kind=C_INT), intent(in), value :: dtype integer(kind=C_INT), intent(in), value :: mtype interface private subroutine set_default_options(options) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLU_OPTIONS_T ), intent(inout) :: options interface private subroutine dgssvx(options, A, perm_c, perm_r, etree, equed, R, C, L, U, work, lwork, B, X, recip_pivot_growth, rcond, ferr, berr, Glu, mem_usage, stat, info) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLU_OPTIONS_T ), intent(in) :: options type( SUPERMATRIX ), intent(inout) :: A integer(kind=C_INT), intent(inout) :: perm_c (*) integer(kind=C_INT), intent(inout) :: perm_r (*) integer(kind=C_INT), intent(inout) :: etree (*) character(kind=C_CHAR), intent(inout) :: equed (*) real(kind=C_DOUBLE), intent(inout) :: R (*) real(kind=C_DOUBLE), intent(inout) :: C (*) type( SUPERMATRIX ), intent(inout) :: L type( SUPERMATRIX ), intent(inout) :: U type(C_PTR), intent(out) :: work integer(kind=C_INT), intent(in), value :: lwork type( SUPERMATRIX ), intent(inout) :: B type( SUPERMATRIX ), intent(out) :: X real(kind=C_DOUBLE), intent(out) :: recip_pivot_growth (*) real(kind=C_DOUBLE), intent(out) :: rcond (*) real(kind=C_DOUBLE), intent(out) :: ferr (*) real(kind=C_DOUBLE), intent(out) :: berr (*) type( GLOBALLU_T ), intent(inout) :: Glu type( MEM_USAGE_T ), intent(out) :: mem_usage type( SUPERLUSTAT_T ), intent(out) :: stat integer(kind=C_INT), intent(out) :: info interface private subroutine StatPrint(stat) bind(c, name=\"0\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(in) :: stat Derived Types type, private, bind(c) :: LU_STACK_T Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: size integer(kind=C_INT), public :: used integer(kind=C_INT), public :: top1 integer(kind=C_INT), public :: top2 type(C_PTR), public :: array type, private, bind(c) :: EXPHEADER Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: size type(C_PTR), public :: mem type, private, bind(c) :: GLOBALLU_T Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: xsup integer(kind=C_INT), public :: supno integer(kind=C_INT), public :: lsub integer(kind=C_INT), public :: xlsub type(C_PTR), public :: lusup integer(kind=C_INT), public :: xlusup type(C_PTR), public :: ucol integer(kind=C_INT), public :: usub integer(kind=C_INT), public :: xusub integer(kind=C_INT), public :: nzlmax integer(kind=C_INT), public :: nzumax integer(kind=C_INT), public :: nzlumax integer(kind=C_INT), public :: MemModel = 0 integer(kind=C_INT), public :: num_expansions type( EXPHEADER ), public :: expanders type( LU_STACK_T ), public :: stack type, private, bind(c) :: SUPERLUSTAT_T Components Type Visibility Attributes Name Initial type(C_PTR), public :: panel_histo histogram of panel size distribution type(C_PTR), public :: utime running time at various phases type(C_PTR), public :: ops operation count at various phases integer(kind=C_INT), public :: TinyPivots number of tiny pivots integer(kind=C_INT), public :: RefineSteps number of iterative refinement steps integer(kind=C_INT), public :: expansions number of memory expansions type, private, bind(c) :: MEM_USAGE_T Components Type Visibility Attributes Name Initial real(kind=C_FLOAT), public :: for_lu real(kind=C_FLOAT), public :: total_needed type, private, bind(c) :: NCFORMAT Read more… Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: nnz number of nonzeros in the matrix type(C_PTR), public :: nzval pointer to array of nonzero values, packed by column type(C_PTR), public :: rowind pointer to array of row indices of the nonzeros type(C_PTR), public :: colptr pointer to array of beginning of columns in nzval[] and rowind[] type, private, bind(c) :: SUPERMATRIX Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: Stype Storage type: interprets the storage structure pointed to by Store integer(kind=C_INT), public :: Dtype Data type integer(kind=C_INT), public :: Mtype Matrix type: describes the mathematical property of the matrix integer(kind=C_INT), public :: nrow number of rows integer(kind=C_INT), public :: ncol number of columns type(C_PTR), public :: Store pointer to the actual storage of the matrix, here, pointer to NCFORMAT type, private, bind(c) :: SUPERLU_OPTIONS_T Read more… Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: Fact integer(kind=C_INT), public :: Equil integer(kind=C_INT), public :: ColPerm integer(kind=C_INT), public :: Trans integer(kind=C_INT), public :: IterRefine real(kind=C_DOUBLE), public :: DiagPivotThresh integer(kind=C_INT), public :: SymmetricMode integer(kind=C_INT), public :: PivotGrowth integer(kind=C_INT), public :: ConditionNumber integer(kind=C_INT), public :: RowPerm integer(kind=C_INT), public :: ILU_DropRule real(kind=C_DOUBLE), public :: ILU_DropTol real(kind=C_DOUBLE), public :: ILU_FillFactor integer(kind=C_INT), public :: ILU_Norm real(kind=C_DOUBLE), public :: ILU_FillTol integer(kind=C_INT), public :: ILU_MILU real(kind=C_DOUBLE), public :: ILU_MILU_Dim integer(kind=C_INT), public :: ParSymbFact integer(kind=C_INT), public :: ReplaceTinyPivot integer(kind=C_INT), public :: SolveInitialized integer(kind=C_INT), public :: RefineInitialized integer(kind=C_INT), public :: PrintStat integer(kind=C_INT), public :: nnzL used to store nnzs for now integer(kind=C_INT), public :: nnzU used to store nnzs for now integer(kind=C_INT), public :: num_lookaheads num of levels in look-ahead integer(kind=C_INT), public :: lookahead_etree use etree computed from the serial symbolic factorization integer(kind=C_INT), public :: SymPattern symmetric factorization type, public :: SULU_ENV Global type for SuperLU which covers all the stuff needed Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n system size integer(kind=C_INT), public :: nrhs number of right hand sides integer(kind=C_INT), public :: nz number on non-zero entries integer(kind=C_INT), public :: info info returned by dgssvx integer(kind=C_INT), public :: lwork size of workspace, not used here logical(kind=I4), public :: first if false the system has been factorized at least once real(kind=R8), public, dimension(:), pointer :: b right hand side: points to b real(kind=R8), public, allocatable, dimension(:) :: x solution real(kind=R8), public, dimension(:), pointer :: a_elt CC system matrix: points to a_elt integer(kind=I4), public, dimension(:), pointer :: irow matrix line of an a_elt element: points to irow integer(kind=I4), public, dimension(:), pointer :: jptr matrix column pointers: points to jptr real(kind=C_DOUBLE), public, allocatable, dimension(:) :: ferr estimated forward error bound for each solution vector real(kind=C_DOUBLE), public, allocatable, dimension(:) :: berr componentwise relative backward error of each solution real(kind=C_DOUBLE), public, allocatable, dimension(:) :: RR *row scale factors for A * real(kind=C_DOUBLE), public, allocatable, dimension(:) :: CC column scale factors for A real(kind=C_DOUBLE), public, allocatable, dimension(:) :: rpg reciprocal pivot growth factor real(kind=C_DOUBLE), public, allocatable, dimension(:) :: rcond estimate of the reciprocal condition number of the matrix A integer(kind=C_INT), public, allocatable, dimension(:) :: perm_c If A->Stype = SLU_NC , Column permutation vector of size A->ncol integer(kind=C_INT), public, allocatable, dimension(:) :: perm_r If A->Stype = SLU_NC , row permutation vector of size A->nrow integer(kind=C_INT), public, allocatable, dimension(:) :: etree Elimination tree character(kind=len=1,C_CHAR), public :: equed form of equilibration type(C_PTR), public :: work User supplied workspace type( SUPERLU_OPTIONS_T ), public :: options LU controls type( SUPERMATRIX ), public :: sma Matrix A in A X=B* type( SUPERMATRIX ), public :: smb On entry, the right hand side matrix type( SUPERMATRIX ), public :: smx olution matrix to the original system type( SUPERMATRIX ), public :: sml factor L from the factorization type( SUPERMATRIX ), public :: smu factor U from the factorization type( SUPERLUSTAT_T ), public :: stat statistics on runtime and floating-point operation count type( GLOBALLU_T ), public :: Glu first, an output with the whole stuff LU; next, an input for other resolutions with same sparsity type( MEM_USAGE_T ), public :: mem_usage memory usage statistics Subroutines public subroutine init_superlu (sulu) Read more… Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu public subroutine prep_superlu (sulu) Read more… Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu public subroutine fact_superlu (sulu, verbose) Read more… Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu logical(kind=I4), intent(in) :: verbose public subroutine solv_superlu (sol_x, sulu, verbose) Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(:) :: sol_x type( SULU_ENV ), intent(inout) :: sulu logical(kind=I4), intent(in) :: verbose public subroutine free_superlu () Read more… Arguments None public subroutine close_superlu (sulu) Read more… Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu","loc":"module/sulu_wrapper.html"},{"tags":"","title":"mumfpack – MUSST","text":"Uses iso_c_binding module~~mumfpack~~UsesGraph module~mumfpack mumfpack iso_c_binding iso_c_binding module~mumfpack->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~mumfpack~~UsedByGraph module~mumfpack mumfpack module~solver solver module~solver->module~mumfpack module~test_musst test_musst module~test_musst->module~solver module~film film module~test_musst->module~film module~ms_film ms_film module~test_musst->module~ms_film module~inout_files inout_files module~test_musst->module~inout_files module~film->module~solver module~ms_film->module~solver module~ms_film->module~film program~main main program~main->module~solver program~main->module~test_musst module~inout_files->module~film module~inout_files->module~ms_film Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables i4 i8 ip r4 r8 iSymbolic iNumeric UMFPACK_INFO UMFPACK_CONTROL UMFPACK_VERSION UMFPACK_COPYRIGHT UMFPACK_DATE UMFPACK_MAIN_VERSION UMFPACK_SUB_VERSION UMFPACK_SUBSUB_VERSION Enumerations Interfaces c_umfpack_di_symbolic c_umfpack_zi_symbolic c_umfpack_di_numeric c_umfpack_zi_numeric c_umfpack_di_solve c_umfpack_zi_solve c_umfpack_di_scale c_umfpack_zi_scale c_umfpack_di_save_numeric c_umfpack_zi_save_numeric c_umfpack_di_save_symbolic c_umfpack_zi_save_symbolic c_umfpack_di_load_numeric c_umfpack_zi_load_numeric c_umfpack_di_load_symbolic c_umfpack_zi_load_symbolic c_umfpack_di_report_numeric c_umfpack_zi_report_numeric c_umfpack_di_report_symbolic c_umfpack_zi_report_symbolic c_umfpack_di_free_symbolic c_umfpack_zi_free_symbolic c_umfpack_di_free_numeric c_umfpack_zi_free_numeric c_umfpack_di_defaults c_umfpack_zi_defaults c_umfpack_di_report_status c_umfpack_zi_report_status c_umfpack_di_report_control c_umfpack_zi_report_control c_umfpack_di_report_info c_umfpack_zi_report_info umfpack_zi_symbolic s_umfpack_zi_symbolic umfpack_symbolic s_umfpack_symbolic umfpack_zi_numeric s_umfpack_zi_numeric umfpack_numeric s_umfpack_numeric umfpack_zi_solve s_umfpack_zi_solve umfpack_solve s_umfpack_solve s_umfpack_free_symbolic s_umfpack_di_free_symbolic s_umfpack_zi_free_symbolic s_umfpack_free_numeric s_umfpack_di_free_numeric s_umfpack_zi_free_numeric s_umfpack_defaults s_umfpack_di_defaults s_umfpack_zi_defaults umfpack_zi_scale umfpack_scale_function s_umfpack_zi_scale s_umfpack_scale s_umfpack_report_control s_umfpack_di_report_control s_umfpack_zi_report_control s_umfpack_report_info s_umfpack_di_report_info s_umfpack_zi_report_info umf4csym umf4zsym umf4sym umf4cnum umf4znum umf4num umf4csolr umf4zsolr umf4solr umf4csol umf4zsol umf4sol umf4cscal umf4zscal umf4scal umf4cfnum umf4zfnum umf4fnum umf4cfsym umf4zfsym umf4fsym umf4csnum umf4zsnum umf4snum umf4cssym umf4zssym umf4ssym umf4clnum umf4zlnum umf4lnum umf4clsym umf4zlsym umf4lsym pCSC pCSR pVec operator(.umfpack.) Derived Types tCSC_di tCSC_zi tCSC_ci tCSR_di tCSR_zi tCSR_ci tVec_zi pCSC_di pCSC_zi pCSC_ci pCSR_di pCSR_zi pCSR_ci pVec_zi Functions umfpack_di_symbolic umfpack_zi_symbolic umfpack_ci_symbolic umfpack_di_numeric umfpack_zi_numeric umfpack_ci_numeric umfpack_di_solve umfpack_zi_solve umfpack_ci_solve umfpack_di_scale umfpack_zi_scale umfpack_ci_scale umfpack_di_save_numeric umfpack_zi_save_numeric umfpack_save_numeric umfpack_di_save_symbolic umfpack_zi_save_symbolic umfpack_save_symbolic umfpack_di_load_numeric umfpack_zi_load_numeric umfpack_load_numeric umfpack_di_load_symbolic umfpack_zi_load_symbolic umfpack_load_symbolic umfpack_di_operator_CSC umfpack_zi_operator_CSC umfpack_ci_operator_CSC umfpack_di_operator_CSR umfpack_zi_operator_CSR umfpack_ci_operator_CSR umfpack_di_operator_pCSC umfpack_zi_operator_pCSC umfpack_ci_operator_pCSC umfpack_di_operator_pCSR umfpack_zi_operator_pCSR umfpack_ci_operator_pCSR make_CSC_di make_CSC_zi make_CSC_ci make_CSR_di make_CSR_zi make_CSR_ci make_Vec_zi Subroutines s_umfpack_di_symbolic s_umfpack_zi_symbolic s_umfpack_ci_symbolic s_umfpack_di_numeric s_umfpack_zi_numeric s_umfpack_ci_numeric s_umfpack_di_solve s_umfpack_zi_solve s_umfpack_ci_solve umfpack_di_free_symbolic umfpack_zi_free_symbolic umfpack_free_symbolic umfpack_di_free_numeric umfpack_zi_free_numeric umfpack_free_numeric s_umfpack_di_scale s_umfpack_zi_scale s_umfpack_ci_scale umfpack_di_defaults umfpack_zi_defaults umfpack_defaults umfpack_di_report_control umfpack_zi_report_control umfpack_report_control umfpack_di_report_info umfpack_zi_report_info umfpack_report_info s_umfpack_di_save_numeric s_umfpack_zi_save_numeric s_umfpack_save_numeric s_umfpack_di_save_symbolic s_umfpack_zi_save_symbolic s_umfpack_save_symbolic s_umfpack_di_load_numeric s_umfpack_zi_load_numeric s_umfpack_load_numeric s_umfpack_di_load_symbolic s_umfpack_zi_load_symbolic s_umfpack_load_symbolic umf4def umf4zdef umf4cdef umf4pcon umf4zpcon umf4cpcon umf4sym umf4zsym umf4csym umf4sym_ip umf4zsym_ip umf4csym_ip umf4num umf4znum umf4cnum umf4num_ip umf4znum_ip umf4cnum_ip umf4solr umf4zsolr umf4csolr umf4solr_ip umf4zsolr_ip umf4csolr_ip umf4sol umf4zsol umf4csol umf4sol_ip umf4zsol_ip umf4csol_ip umf4scal umf4zscal umf4cscal umf4scal_ip umf4zscal_ip umf4cscal_ip umf4pinf umf4zpinf umf4cpinf umf4fnum umf4zfnum umf4cfnum umf4fnum_ip umf4zfnum_ip umf4cfnum_ip umf4fsym umf4zfsym umf4cfsym umf4fsym_ip umf4zfsym_ip umf4cfsym_ip umf4snum umf4zsnum umf4csnum umf4snum_ip umf4zsnum_ip umf4csnum_ip umf4ssym umf4zssym umf4cssym umf4ssym_ip umf4zssym_ip umf4cssym_ip umf4lnum umf4zlnum umf4clnum umf4lnum_ip umf4zlnum_ip umf4clnum_ip umf4lsym umf4zlsym umf4clsym umf4lsym_ip umf4zlsym_ip umf4clsym_ip Variables Type Visibility Attributes Name Initial integer, private, parameter :: i4 = 4 integer, private, parameter :: i8 = 8 integer, private, parameter :: ip = c_intptr_t integer, private, parameter :: r4 = 4 integer, private, parameter :: r8 = 8 type(c_ptr), private :: iSymbolic = c_null_ptr type(c_ptr), private :: iNumeric = c_null_ptr integer, public, parameter :: UMFPACK_INFO = 90 integer, public, parameter :: UMFPACK_CONTROL = 20 character(len=30), public, parameter :: UMFPACK_VERSION = \"UMFPACK V5.6.2 (Apr 25, 2013)\" character(len=79), public, parameter :: UMFPACK_COPYRIGHT = \"UMFPACK:  Copyright (c) 2005-2012 by Timothy A. Davis.  All Rights Reserved.\" character(len=12), public, parameter :: UMFPACK_DATE = \"Apr 25, 2013\" integer, public, parameter :: UMFPACK_MAIN_VERSION = 5 integer, public, parameter :: UMFPACK_SUB_VERSION = 6 integer, public, parameter :: UMFPACK_SUBSUB_VERSION = 2 Enumerations enum, bind(c) Enumerators enumerator :: UMFPACK_STATUS = 0 enumerator :: UMFPACK_NROW = 1 enumerator :: UMFPACK_NCOL = 16 enumerator :: UMFPACK_NZ = 2 enumerator :: UMFPACK_SIZE_OF_UNIT = 3 enumerator :: UMFPACK_SIZE_OF_INT = 4 enumerator :: UMFPACK_SIZE_OF_LONG = 5 enumerator :: UMFPACK_SIZE_OF_POINTER = 6 enumerator :: UMFPACK_SIZE_OF_ENTRY = 7 enumerator :: UMFPACK_NDENSE_ROW = 8 enumerator :: UMFPACK_NEMPTY_ROW = 9 enumerator :: UMFPACK_NDENSE_COL = 10 enumerator :: UMFPACK_NEMPTY_COL = 11 enumerator :: UMFPACK_SYMBOLIC_DEFRAG = 12 enumerator :: UMFPACK_SYMBOLIC_PEAK_MEMORY = 13 enumerator :: UMFPACK_SYMBOLIC_SIZE = 14 enumerator :: UMFPACK_SYMBOLIC_TIME = 15 enumerator :: UMFPACK_SYMBOLIC_WALLTIME = 17 enumerator :: UMFPACK_STRATEGY_USED = 18 enumerator :: UMFPACK_ORDERING_USED = 19 enumerator :: UMFPACK_QFIXED = 31 enumerator :: UMFPACK_DIAG_PREFERRED = 32 enumerator :: UMFPACK_PATTERN_SYMMETRY = 33 enumerator :: UMFPACK_NZ_A_PLUS_AT = 34 enumerator :: UMFPACK_NZDIAG = 35 enumerator :: UMFPACK_SYMMETRIC_LUNZ = 36 enumerator :: UMFPACK_SYMMETRIC_FLOPS = 37 enumerator :: UMFPACK_SYMMETRIC_NDENSE = 38 enumerator :: UMFPACK_SYMMETRIC_DMAX = 39 enumerator :: UMFPACK_COL_SINGLETONS = 56 enumerator :: UMFPACK_ROW_SINGLETONS = 57 enumerator :: UMFPACK_N2 = 58 enumerator :: UMFPACK_S_SYMMETRIC = 59 enumerator :: UMFPACK_NUMERIC_SIZE_ESTIMATE = 20 enumerator :: UMFPACK_PEAK_MEMORY_ESTIMATE = 21 enumerator :: UMFPACK_FLOPS_ESTIMATE = 22 enumerator :: UMFPACK_LNZ_ESTIMATE = 23 enumerator :: UMFPACK_UNZ_ESTIMATE = 24 enumerator :: UMFPACK_VARIABLE_INIT_ESTIMATE = 25 enumerator :: UMFPACK_VARIABLE_PEAK_ESTIMATE = 26 enumerator :: UMFPACK_VARIABLE_FINAL_ESTIMATE = 27 enumerator :: UMFPACK_MAX_FRONT_SIZE_ESTIMATE = 28 enumerator :: UMFPACK_MAX_FRONT_NROWS_ESTIMATE = 29 enumerator :: UMFPACK_MAX_FRONT_NCOLS_ESTIMATE = 30 enumerator :: UMFPACK_NUMERIC_SIZE = 40 enumerator :: UMFPACK_PEAK_MEMORY = 41 enumerator :: UMFPACK_FLOPS = 42 enumerator :: UMFPACK_LNZ = 43 enumerator :: UMFPACK_UNZ = 44 enumerator :: UMFPACK_VARIABLE_INIT = 45 enumerator :: UMFPACK_VARIABLE_PEAK = 46 enumerator :: UMFPACK_VARIABLE_FINAL = 47 enumerator :: UMFPACK_MAX_FRONT_SIZE = 48 enumerator :: UMFPACK_MAX_FRONT_NROWS = 49 enumerator :: UMFPACK_MAX_FRONT_NCOLS = 50 enumerator :: UMFPACK_NUMERIC_DEFRAG = 60 enumerator :: UMFPACK_NUMERIC_REALLOC = 61 enumerator :: UMFPACK_NUMERIC_COSTLY_REALLOC = 62 enumerator :: UMFPACK_COMPRESSED_PATTERN = 63 enumerator :: UMFPACK_LU_ENTRIES = 64 enumerator :: UMFPACK_NUMERIC_TIME = 65 enumerator :: UMFPACK_UDIAG_NZ = 66 enumerator :: UMFPACK_RCOND = 67 enumerator :: UMFPACK_WAS_SCALED = 68 enumerator :: UMFPACK_RSMIN = 69 enumerator :: UMFPACK_RSMAX = 70 enumerator :: UMFPACK_UMIN = 71 enumerator :: UMFPACK_UMAX = 72 enumerator :: UMFPACK_ALLOC_INIT_USED = 73 enumerator :: UMFPACK_FORCED_UPDATES = 74 enumerator :: UMFPACK_NUMERIC_WALLTIME = 75 enumerator :: UMFPACK_NOFF_DIAG = 76 enumerator :: UMFPACK_ALL_LNZ = 77 enumerator :: UMFPACK_ALL_UNZ = 78 enumerator :: UMFPACK_NZDROPPED = 79 enumerator :: UMFPACK_IR_TAKEN = 80 enumerator :: UMFPACK_IR_ATTEMPTED = 81 enumerator :: UMFPACK_OMEGA1 = 82 enumerator :: UMFPACK_OMEGA2 = 83 enumerator :: UMFPACK_SOLVE_FLOPS = 84 enumerator :: UMFPACK_SOLVE_TIME = 85 enumerator :: UMFPACK_SOLVE_WALLTIME = 86 enum, bind(c) Enumerators enumerator :: UMFPACK_PRL = 0 enumerator :: UMFPACK_DENSE_ROW = 1 enumerator :: UMFPACK_DENSE_COL = 2 enumerator :: UMFPACK_BLOCK_SIZE = 4 enumerator :: UMFPACK_STRATEGY = 5 enumerator :: UMFPACK_ORDERING = 10 enumerator :: UMFPACK_FIXQ = 13 enumerator :: UMFPACK_AMD_DENSE = 14 enumerator :: UMFPACK_AGGRESSIVE = 19 enumerator :: UMFPACK_SINGLETONS = 11 enumerator :: UMFPACK_PIVOT_TOLERANCE = 3 enumerator :: UMFPACK_ALLOC_INIT = 6 enumerator :: UMFPACK_SYM_PIVOT_TOLERANCE = 15 enumerator :: UMFPACK_SCALE = 16 enumerator :: UMFPACK_FRONT_ALLOC_INIT = 17 enumerator :: UMFPACK_DROPTOL = 18 enumerator :: UMFPACK_IRSTEP = 7 enumerator :: UMFPACK_COMPILED_WITH_BLAS = 8 enum, bind(c) Enumerators enumerator :: UMFPACK_STRATEGY_AUTO = 0 enumerator :: UMFPACK_STRATEGY_UNSYMMETRIC = 1 enumerator :: UMFPACK_STRATEGY_OBSOLETE = 2 enumerator :: UMFPACK_STRATEGY_SYMMETRIC = 3 enum, bind(c) Enumerators enumerator :: UMFPACK_SCALE_NONE = 0 enumerator :: UMFPACK_SCALE_SUM = 1 enumerator :: UMFPACK_SCALE_MAX = 2 enum, bind(c) Enumerators enumerator :: UMFPACK_ORDERING_CHOLMOD = 0 enumerator :: UMFPACK_ORDERING_AMD = 1 enumerator :: UMFPACK_ORDERING_GIVEN = 2 enumerator :: UMFPACK_ORDERING_METIS = 3 enumerator :: UMFPACK_ORDERING_BEST = 4 enumerator :: UMFPACK_ORDERING_NONE = 5 enumerator :: UMFPACK_ORDERING_USER = 6 enum, bind(c) Enumerators enumerator :: UMFPACK_OK = 0 enumerator :: UMFPACK_WARNING_singular_matrix = 1 enumerator :: UMFPACK_WARNING_determinant_underflow = 2 enumerator :: UMFPACK_WARNING_determinant_overflow = 3 enumerator :: UMFPACK_ERROR_out_of_memory = -1 enumerator :: UMFPACK_ERROR_invalid_Numeric_object = -3 enumerator :: UMFPACK_ERROR_invalid_Symbolic_object = -4 enumerator :: UMFPACK_ERROR_argument_missing = -5 enumerator :: UMFPACK_ERROR_n_nonpositive = -6 enumerator :: UMFPACK_ERROR_invalid_matrix = -8 enumerator :: UMFPACK_ERROR_different_pattern = -11 enumerator :: UMFPACK_ERROR_invalid_system = -13 enumerator :: UMFPACK_ERROR_invalid_permutation = -15 enumerator :: UMFPACK_ERROR_internal_error = -911 enumerator :: UMFPACK_ERROR_file_IO = -17 enumerator :: UMFPACK_ERROR_ordering_failed = -18 enum, bind(c) Enumerators enumerator :: UMFPACK_A = 0 enumerator :: UMFPACK_At = 1 enumerator :: UMFPACK_Aat = 2 enumerator :: UMFPACK_Pt_L = 3 enumerator :: UMFPACK_L = 4 enumerator :: UMFPACK_Lt_P = 5 enumerator :: UMFPACK_Lat_P = 6 enumerator :: UMFPACK_Lt = 7 enumerator :: UMFPACK_Lat = 8 enumerator :: UMFPACK_U_Qt = 9 enumerator :: UMFPACK_U = 10 enumerator :: UMFPACK_Q_Ut = 11 enumerator :: UMFPACK_Q_Uat = 12 enumerator :: UMFPACK_Ut = 13 enumerator :: UMFPACK_Uat = 14 Interfaces interface public function c_umfpack_di_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) bind(c,name='umfpack_di_symbolic') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n_row integer(kind=c_int), value :: n_col type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr) :: Symbolic type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public function c_umfpack_zi_symbolic(n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info) bind(c,name='umfpack_zi_symbolic') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n_row integer(kind=c_int), value :: n_col type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr) :: Symbolic type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public function c_umfpack_di_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) bind(c,name='umfpack_di_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Symbolic type(c_ptr) :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public function c_umfpack_zi_numeric(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) bind(c,name='umfpack_zi_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr), intent(in), value :: Symbolic type(c_ptr) :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public function c_umfpack_di_solve(sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) bind(c,name='umfpack_di_solve') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: sys type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), value :: X type(c_ptr), intent(in), value :: B type(c_ptr), intent(in), value :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public function c_umfpack_zi_solve(sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info) bind(c,name='umfpack_zi_solve') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: sys type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr), value :: Xx type(c_ptr), value :: Xz type(c_ptr), intent(in), value :: Bx type(c_ptr), intent(in), value :: Bz type(c_ptr), intent(in), value :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public function c_umfpack_di_scale(X, B, Numeric) bind(c,name='umfpack_di_scale') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: X type(c_ptr), intent(in), value :: B type(c_ptr), intent(in), value :: Numeric Return Value integer(kind=c_int) interface public function c_umfpack_zi_scale(Xx, Xz, Bx, Bz, Numeric) bind(c,name='umfpack_zi_scale') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Xx type(c_ptr), value :: Xz type(c_ptr), intent(in), value :: Bx type(c_ptr), intent(in), value :: Bz type(c_ptr), intent(in), value :: Numeric Return Value integer(kind=c_int) interface public function c_umfpack_di_save_numeric(Numeric, filename) bind(c,name='umfpack_di_save_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_zi_save_numeric(Numeric, filename) bind(c,name='umfpack_zi_save_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_di_save_symbolic(Symbolic, filename) bind(c,name='umfpack_di_save_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_zi_save_symbolic(Symbolic, filename) bind(c,name='umfpack_zi_save_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_di_load_numeric(Numeric, filename) bind(c,name='umfpack_di_load_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_zi_load_numeric(Numeric, filename) bind(c,name='umfpack_zi_load_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_di_load_symbolic(Symbolic, filename) bind(c,name='umfpack_di_load_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_zi_load_symbolic(Symbolic, filename) bind(c,name='umfpack_zi_load_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic character(len=1,c_char) :: filename (*) Return Value integer(kind=c_int) interface public function c_umfpack_di_report_numeric(Numeric, Control) bind(c,name='umfpack_di_report_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric type(c_ptr), value :: Control Return Value integer(kind=c_int) interface public function c_umfpack_zi_report_numeric(Numeric, Control) bind(c,name='umfpack_zi_report_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric type(c_ptr), value :: Control Return Value integer(kind=c_int) interface public function c_umfpack_di_report_symbolic(Symbolic, Control) bind(c,name='umfpack_di_report_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic type(c_ptr), value :: Control Return Value integer(kind=c_int) interface public function c_umfpack_zi_report_symbolic(Symbolic, Control) bind(c,name='umfpack_zi_report_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic type(c_ptr), value :: Control Return Value integer(kind=c_int) interface public subroutine c_umfpack_di_free_symbolic(Symbolic) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic interface public subroutine c_umfpack_zi_free_symbolic(Symbolic) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic interface public subroutine c_umfpack_di_free_numeric(Numeric) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric interface public subroutine c_umfpack_zi_free_numeric(Numeric) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric interface public subroutine c_umfpack_di_defaults(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control interface public subroutine c_umfpack_zi_defaults(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control interface public subroutine c_umfpack_di_report_status(Control, status) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control integer(kind=c_int), value :: status interface public subroutine c_umfpack_zi_report_status(Control, status) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control integer(kind=c_int), value :: status interface public subroutine c_umfpack_di_report_control(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control interface public subroutine c_umfpack_zi_report_control(Control) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control interface public subroutine c_umfpack_di_report_info(Control, Info) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control type(c_ptr), value :: Info interface public subroutine c_umfpack_zi_report_info(Control, Info) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control type(c_ptr), value :: Info public interface umfpack_zi_symbolic public interface umfpack_zi_symbolic () Arguments None public function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface s_umfpack_zi_symbolic public interface s_umfpack_zi_symbolic () Arguments None public subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface umfpack_symbolic public function umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface umfpack_zi_symbolic () Arguments None public function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface s_umfpack_symbolic public subroutine s_umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface s_umfpack_zi_symbolic () Arguments None public subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface umfpack_zi_numeric public interface umfpack_zi_numeric () Arguments None public function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface s_umfpack_zi_numeric public interface s_umfpack_zi_numeric () Arguments None public subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface umfpack_numeric public function umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface umfpack_zi_numeric () Arguments None public function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface s_umfpack_numeric public subroutine s_umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface s_umfpack_zi_numeric () Arguments None public subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface umfpack_zi_solve public interface umfpack_zi_solve () Arguments None public function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) complex(kind=r8), intent(in), optional target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface s_umfpack_zi_solve public interface s_umfpack_zi_solve () Arguments None public subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface umfpack_solve public function umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface umfpack_zi_solve () Arguments None public function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) complex(kind=r8), intent(in), optional target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public interface s_umfpack_solve public subroutine s_umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface s_umfpack_zi_solve () Arguments None public subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public interface s_umfpack_free_symbolic public subroutine umfpack_free_symbolic (Symbolic, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic character(len=*), optional :: version public interface s_umfpack_di_free_symbolic public subroutine umfpack_di_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic public interface s_umfpack_zi_free_symbolic public subroutine umfpack_zi_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic public interface s_umfpack_free_numeric public subroutine umfpack_free_numeric (Numeric, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric character(len=*), optional :: version public interface s_umfpack_di_free_numeric public subroutine umfpack_di_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric public interface s_umfpack_zi_free_numeric public subroutine umfpack_zi_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric public interface s_umfpack_defaults public subroutine umfpack_defaults (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version public interface s_umfpack_di_defaults public subroutine umfpack_di_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public interface s_umfpack_zi_defaults public subroutine umfpack_zi_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public interface umfpack_zi_scale public interface umfpack_zi_scale () Arguments None public function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public interface umfpack_scale_function public function umfpack_di_scale (X, B, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public interface umfpack_zi_scale () Arguments None public function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public interface s_umfpack_zi_scale public interface s_umfpack_zi_scale () Arguments None public subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public interface s_umfpack_scale public subroutine s_umfpack_di_scale (X, B, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public interface s_umfpack_zi_scale () Arguments None public subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public interface s_umfpack_report_control public subroutine umfpack_report_control (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version public interface s_umfpack_di_report_control public subroutine umfpack_di_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public interface s_umfpack_zi_report_control public subroutine umfpack_zi_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public interface s_umfpack_report_info public subroutine umfpack_report_info (Control, Info, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) character(len=*), optional :: version public interface s_umfpack_di_report_info public subroutine umfpack_di_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) public interface s_umfpack_zi_report_info public subroutine umfpack_zi_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) public interface umf4csym public interface umf4csym () Arguments None public subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsym public interface umf4zsym () Arguments None public subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csym () Arguments None public subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4sym public interface umf4sym () Arguments None public subroutine umf4sym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsym () Arguments None public subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csym () Arguments None public subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4cnum public interface umf4cnum () Arguments None public subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4znum public interface umf4znum () Arguments None public subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4cnum () Arguments None public subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4num public interface umf4num () Arguments None public subroutine umf4num_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4znum () Arguments None public subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4cnum () Arguments None public subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csolr public interface umf4csolr () Arguments None public subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsolr public interface umf4zsolr () Arguments None public subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csolr () Arguments None public subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4solr public interface umf4solr () Arguments None public subroutine umf4solr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsolr () Arguments None public subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csolr () Arguments None public subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csol public interface umf4csol () Arguments None public subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsol public interface umf4zsol () Arguments None public subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csol () Arguments None public subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4sol public interface umf4sol () Arguments None public subroutine umf4sol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4zsol () Arguments None public subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4csol () Arguments None public subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public interface umf4cscal public interface umf4cscal () Arguments None public subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4zscal public interface umf4zscal () Arguments None public subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4cscal () Arguments None public subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4scal public interface umf4scal () Arguments None public subroutine umf4scal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4zscal () Arguments None public subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4cscal () Arguments None public subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public interface umf4cfnum public interface umf4cfnum () Arguments None public subroutine umf4cfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public interface umf4zfnum public interface umf4zfnum () Arguments None public subroutine umf4zfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public interface umf4fnum public interface umf4fnum () Arguments None public subroutine umf4fnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public interface umf4cfsym public interface umf4cfsym () Arguments None public subroutine umf4cfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public interface umf4zfsym public interface umf4zfsym () Arguments None public subroutine umf4zfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public interface umf4fsym public interface umf4fsym () Arguments None public subroutine umf4fsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public interface umf4csnum public interface umf4csnum () Arguments None public subroutine umf4csnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4zsnum public interface umf4zsnum () Arguments None public subroutine umf4zsnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4snum public interface umf4snum () Arguments None public subroutine umf4snum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4cssym public interface umf4cssym () Arguments None public subroutine umf4cssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4zssym public interface umf4zssym () Arguments None public subroutine umf4zssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4ssym public interface umf4ssym () Arguments None public subroutine umf4ssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4clnum public interface umf4clnum () Arguments None public subroutine umf4clnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4zlnum public interface umf4zlnum () Arguments None public subroutine umf4zlnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4lnum public interface umf4lnum () Arguments None public subroutine umf4lnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4clsym public interface umf4clsym () Arguments None public subroutine umf4clsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4zlsym public interface umf4zlsym () Arguments None public subroutine umf4zlsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public interface umf4lsym public interface umf4lsym () Arguments None public subroutine umf4lsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public interface pCSC public function make_CSC_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_di ) public function make_CSC_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSC_zi ) public function make_CSC_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_ci ) public interface pCSR public function make_CSR_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_di ) public function make_CSR_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSR_zi ) public function make_CSR_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_ci ) public interface pVec public function make_Vec_zi (bx, bz) result(result) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), target :: bx (:) real(kind=r8), intent(in), target :: bz (:) Return Value type( pVec_zi ) public interface operator(.umfpack.) public function umfpack_di_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) Derived Types type, public :: tCSC_di Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:) type, public :: tCSC_zi Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:) real(kind=r8), public, allocatable :: Az (:) type, public :: tCSC_ci Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) complex(kind=r8), public, allocatable :: Ax (:) type, public :: tCSR_di Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:) type, public :: tCSR_zi Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) real(kind=r8), public, allocatable :: Ax (:) real(kind=r8), public, allocatable :: Az (:) type, public :: tCSR_ci Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ap (:) integer, public, allocatable :: Ai (:) complex(kind=r8), public, allocatable :: Ax (:) type, public :: tVec_zi Components Type Visibility Attributes Name Initial real(kind=r8), public, allocatable :: x (:) real(kind=r8), public, allocatable :: z (:) type, public :: pCSC_di Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:) type, public :: pCSC_zi Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:) real(kind=r8), public, pointer :: Az (:) type, public :: pCSC_ci Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) complex(kind=r8), public, pointer :: Ax (:) type, public :: pCSR_di Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:) type, public :: pCSR_zi Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) real(kind=r8), public, pointer :: Ax (:) real(kind=r8), public, pointer :: Az (:) type, public :: pCSR_ci Components Type Visibility Attributes Name Initial integer, public, pointer :: Ap (:) integer, public, pointer :: Ai (:) complex(kind=r8), public, pointer :: Ax (:) type, public :: pVec_zi Components Type Visibility Attributes Name Initial real(kind=r8), public, pointer :: x (:) real(kind=r8), public, pointer :: z (:) Functions public function umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_zi_symbolic (n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), intent(in), target :: Az (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_zi_numeric (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) real(kind=r8), intent(in), target :: Az (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_zi_solve (sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) real(kind=r8), intent(in), optional target :: Ax (*) real(kind=r8), intent(in), optional target :: Az (*) real(kind=r8), target :: Xx (*) real(kind=r8), target :: Xz (*) real(kind=r8), intent(in), target :: Bx (*) real(kind=r8), intent(in), target :: Bz (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional target :: Ap (*) integer, intent(in), optional target :: Ai (*) complex(kind=r8), intent(in), optional target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional target :: Info (0:UMFPACK_INFO-1) Return Value integer public function umfpack_di_scale (X, B, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public function umfpack_zi_scale (Xx, Xz, Bx, Bz, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: Xx (*) real(kind=r8), target :: Xz (*) real(kind=r8), intent(in), target :: Bx (*) real(kind=r8), intent(in), target :: Bz (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public function umfpack_di_save_numeric (Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer public function umfpack_zi_save_numeric (Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer public function umfpack_save_numeric (Numeric, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer public function umfpack_di_save_symbolic (Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer public function umfpack_zi_save_symbolic (Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer public function umfpack_save_symbolic (Symbolic, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer public function umfpack_di_load_numeric (Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer public function umfpack_zi_load_numeric (Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer public function umfpack_load_numeric (Numeric, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer public function umfpack_di_load_symbolic (Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer public function umfpack_zi_load_symbolic (Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer public function umfpack_load_symbolic (Symbolic, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer public function umfpack_di_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_di_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double)\n  (size(A%Ap)-1) public function umfpack_zi_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public function umfpack_ci_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double)\n  (size(A%Ap)-1) public function make_CSC_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_di ) public function make_CSC_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSC_zi ) public function make_CSC_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_ci ) public function make_CSR_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_di ) public function make_CSR_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSR_zi ) public function make_CSR_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_ci ) public function make_Vec_zi (bx, bz) result(result) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), target :: bx (:) real(kind=r8), intent(in), target :: bz (:) Return Value type( pVec_zi ) Subroutines public subroutine s_umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_zi_symbolic (n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_zi_numeric (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_zi_solve (sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(in), optional :: Az (*) real(kind=r8), intent(out) :: Xx (*) real(kind=r8), intent(out) :: Xz (*) real(kind=r8), intent(in) :: Bx (*) real(kind=r8), intent(in) :: Bz (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public subroutine umfpack_di_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic public subroutine umfpack_zi_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic public subroutine umfpack_free_symbolic (Symbolic, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic character(len=*), optional :: version public subroutine umfpack_di_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric public subroutine umfpack_zi_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric public subroutine umfpack_free_numeric (Numeric, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric character(len=*), optional :: version public subroutine s_umfpack_di_scale (X, B, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public subroutine s_umfpack_zi_scale (Xx, Xz, Bx, Bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: Xx (*) real(kind=r8), intent(out) :: Xz (*) real(kind=r8), intent(in) :: Bx (*) real(kind=r8), intent(in) :: Bz (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public subroutine umfpack_di_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public subroutine umfpack_zi_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public subroutine umfpack_defaults (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version public subroutine umfpack_di_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public subroutine umfpack_zi_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) public subroutine umfpack_report_control (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version public subroutine umfpack_di_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) public subroutine umfpack_zi_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) public subroutine umfpack_report_info (Control, Info, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) character(len=*), optional :: version public subroutine s_umfpack_di_save_numeric (Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_zi_save_numeric (Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_save_numeric (Numeric, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version public subroutine s_umfpack_di_save_symbolic (Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_zi_save_symbolic (Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_save_symbolic (Symbolic, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version public subroutine s_umfpack_di_load_numeric (Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_zi_load_numeric (Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_load_numeric (Numeric, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version public subroutine s_umfpack_di_load_symbolic (Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_zi_load_symbolic (Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status public subroutine s_umfpack_load_symbolic (Symbolic, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version public subroutine umf4def (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public subroutine umf4zdef (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public subroutine umf4cdef (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public subroutine umf4pcon (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public subroutine umf4zpcon (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public subroutine umf4cpcon (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public subroutine umf4sym (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4zsym (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4csym (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4sym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4num (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4znum (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4cnum (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4num_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4solr (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4zsolr (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4csolr (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4solr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4sol (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4zsol (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4csol (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4sol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4scal (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric integer, intent(out) :: status public subroutine umf4zscal (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric integer, intent(out) :: status public subroutine umf4cscal (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric integer, intent(out) :: status public subroutine umf4scal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public subroutine umf4pinf (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4zpinf (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4cpinf (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public subroutine umf4fnum (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric public subroutine umf4zfnum (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric public subroutine umf4cfnum (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric public subroutine umf4fnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public subroutine umf4zfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public subroutine umf4cfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public subroutine umf4fsym (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic public subroutine umf4zfsym (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic public subroutine umf4cfsym (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic public subroutine umf4fsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public subroutine umf4zfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public subroutine umf4cfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public subroutine umf4snum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zsnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4csnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4snum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zsnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4csnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4ssym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zssym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4cssym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4ssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4cssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4lnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zlnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4clnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4lnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zlnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4clnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4lsym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zlsym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4clsym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4lsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4zlsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public subroutine umf4clsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","loc":"module/mumfpack.html"},{"tags":"","title":"main – MUSST","text":"Uses omp_lib test_musst data_arch num_param solver program~~main~~UsesGraph program~main main module~test_musst test_musst program~main->module~test_musst omp_lib omp_lib program~main->omp_lib module~solver solver program~main->module~solver module~num_param num_param program~main->module~num_param module~data_arch data_arch program~main->module~data_arch module~test_musst->module~solver module~test_musst->module~num_param module~test_musst->module~data_arch module~film film module~test_musst->module~film module~ms_film ms_film module~test_musst->module~ms_film module~surfile surfile module~test_musst->module~surfile module~inout_files inout_files module~test_musst->module~inout_files module~data_film_hd data_film_hd module~test_musst->module~data_film_hd module~solver->module~data_arch module~sulu_wrapper sulu_wrapper module~solver->module~sulu_wrapper module~gen_param gen_param module~solver->module~gen_param module~mumfpack mumfpack module~solver->module~mumfpack iso_c_binding iso_c_binding module~solver->iso_c_binding iso_fortran_env iso_fortran_env module~solver->iso_fortran_env module~mumps_wrapper mumps_wrapper module~solver->module~mumps_wrapper module~sort_arrays sort_arrays module~solver->module~sort_arrays hsl_ma48_double hsl_ma48_double module~solver->hsl_ma48_double module~num_param->module~data_arch module~num_param->iso_fortran_env module~data_arch->iso_fortran_env module~sulu_wrapper->iso_c_binding module~film->omp_lib module~film->module~solver module~film->module~num_param module~film->module~data_arch module~film->module~surfile module~film->module~data_film_hd module~mesh mesh module~film->module~mesh module~fluid_law fluid_law module~film->module~fluid_law module~elements elements module~film->module~elements module~gen_param->module~data_arch module~ms_film->omp_lib module~ms_film->module~solver module~ms_film->module~num_param module~ms_film->module~data_arch module~ms_film->module~film module~ms_film->module~surfile module~ms_film->module~data_film_hd module~ms_film->module~mesh module~ms_film->module~fluid_law module~bspline bspline module~ms_film->module~bspline module~surfile->module~data_arch module~surfile->iso_c_binding module~surfile->module~sort_arrays module~mumfpack->iso_c_binding module~inout_files->module~data_arch module~inout_files->module~film module~inout_files->module~ms_film module~inout_files->module~surfile module~vtk VTK module~inout_files->module~vtk module~data_film_hd->module~data_arch module~data_film_hd->module~fluid_law module~sort_arrays->module~data_arch module~mesh->module~data_arch module~fluid_law->module~data_arch module~ir_vtk IR_VTK module~vtk->module~ir_vtk module~elements->module~data_arch module~bspline->iso_fortran_env var panprogrammainUsesGraph = svgPanZoom('#programmainUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutine to run a test with MUSST Calls program~~main~~CallsGraph program~main main proc~read_config read_config program~main->proc~read_config proc~run_test run_test program~main->proc~run_test proc~get_unit get_unit proc~read_config->proc~get_unit proc~read_data read_data proc~read_config->proc~read_data proc~test_slider_fe test_slider_fe proc~run_test->proc~test_slider_fe proc~test_slider_ms test_slider_ms proc~run_test->proc~test_slider_ms proc~test_bearing_x_fe test_bearing_x_fe proc~run_test->proc~test_bearing_x_fe proc~test_bearing_y_fe test_bearing_y_fe proc~run_test->proc~test_bearing_y_fe proc~run_test->proc~get_unit proc~test_rough_ms test_rough_ms proc~run_test->proc~test_rough_ms proc~test_pocket_fe test_pocket_fe proc~run_test->proc~test_pocket_fe proc~test_rough_fe test_rough_fe proc~run_test->proc~test_rough_fe proc~solve_fe_prob solve_fe_prob proc~test_slider_fe->proc~solve_fe_prob proc~modify_h_slider modify_h_slider proc~test_slider_fe->proc~modify_h_slider proc~init_fe_prob init_fe_prob proc~test_slider_fe->proc~init_fe_prob proc~modify_h_slider_ms modify_h_slider_MS proc~test_slider_ms->proc~modify_h_slider_ms proc~init_ms_prob init_ms_prob proc~test_slider_ms->proc~init_ms_prob proc~solve_ms_prob solve_ms_prob proc~test_slider_ms->proc~solve_ms_prob proc~modify_h_bearing modify_h_bearing proc~test_bearing_x_fe->proc~modify_h_bearing proc~test_bearing_x_fe->proc~solve_fe_prob proc~test_bearing_x_fe->proc~init_fe_prob proc~modify_h_bearing_y modify_h_bearing_y proc~test_bearing_y_fe->proc~modify_h_bearing_y proc~test_bearing_y_fe->proc~solve_fe_prob proc~test_bearing_y_fe->proc~init_fe_prob proc~apply_roughness_ms apply_roughness_MS proc~test_rough_ms->proc~apply_roughness_ms proc~test_rough_ms->proc~init_ms_prob proc~test_rough_ms->proc~solve_ms_prob proc~init_rough_prob init_rough_prob proc~test_rough_ms->proc~init_rough_prob proc~test_pocket_fe->proc~solve_fe_prob proc~modify_h_pocket modify_h_pocket proc~test_pocket_fe->proc~modify_h_pocket proc~test_pocket_fe->proc~init_fe_prob proc~test_rough_fe->proc~solve_fe_prob proc~apply_roughness apply_roughness proc~test_rough_fe->proc~apply_roughness proc~test_rough_fe->proc~init_rough_prob proc~test_rough_fe->proc~init_fe_prob num_par num_par proc~read_data->num_par proc~apply_roughness_ms->proc~apply_roughness proc~compute_corner_fluxes compute_corner_fluxes proc~solve_fe_prob->proc~compute_corner_fluxes proc~solve_fe_film solve_FE_film proc~solve_fe_prob->proc~solve_fe_film proc~save_fe_field save_fe_field proc~solve_fe_prob->proc~save_fe_field proc~modify_h_slider_ms->proc~modify_h_slider proc~multi_scale_create_rect_fe_film multi_scale_create_rect_fe_film proc~init_ms_prob->proc~multi_scale_create_rect_fe_film proc~save_ms_field save_ms_field proc~solve_ms_prob->proc~save_ms_field proc~multi_scale_solve_fe_film multi_scale_solve_fe_film proc~solve_ms_prob->proc~multi_scale_solve_fe_film proc~ms_fe_f_2_mat ms_fe_f_2_mat proc~solve_ms_prob->proc~ms_fe_f_2_mat proc~create_rect_fe_film create_rect_FE_film proc~init_fe_prob->proc~create_rect_fe_film proc~assembly_fe_film_reynolds assembly_FE_film_reynolds proc~compute_corner_fluxes->proc~assembly_fe_film_reynolds proc~multi_scale_create_rect_fe_film->proc~create_rect_fe_film proc~save_ms_field->proc~ms_fe_f_2_mat proc~init_scal init_scal proc~save_ms_field->proc~init_scal proc~empty empty proc~save_ms_field->proc~empty proc~write_surf write_surf proc~save_ms_field->proc~write_surf omp_get_thread_num omp_get_thread_num proc~solve_fe_film->omp_get_thread_num proc~solve_syst solve_syst proc~solve_fe_film->proc~solve_syst proc~solve_fe_film->proc~assembly_fe_film_reynolds proc~apply_bc_fe_film apply_bc_FE_film proc~solve_fe_film->proc~apply_bc_fe_film proc~convert_matrice_format convert_matrice_format proc~solve_fe_film->proc~convert_matrice_format proc~apply_bc_fe_film_simple apply_bc_FE_film_simple proc~solve_fe_film->proc~apply_bc_fe_film_simple proc~multi_scale_solve_fe_film->proc~solve_fe_film proc~multi_scale_solve_fe_film->omp_get_thread_num proc~multi_scale_solve_fe_film->proc~solve_syst proc~multi_scale_solve_fe_film->proc~convert_matrice_format proc~multi_scale_solve_fe_film->proc~apply_bc_fe_film_simple proc~multi_scale_assembly_fe_film_reynolds multi_scale_assembly_fe_film_reynolds proc~multi_scale_solve_fe_film->proc~multi_scale_assembly_fe_film_reynolds proc~save_fe_field->proc~init_scal proc~save_fe_field->proc~empty proc~save_fe_field->proc~write_surf proc~create_rect_x_ymesh create_rect_x_ymesh proc~create_rect_fe_film->proc~create_rect_x_ymesh proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~init_scal->proc~empty proc~elementary_assembly_fe_film_reynolds elementary_assembly_FE_film_reynolds proc~assembly_fe_film_reynolds->proc~elementary_assembly_fe_film_reynolds proc~assemble_in_mat_sol assemble_in_mat_sol proc~assembly_fe_film_reynolds->proc~assemble_in_mat_sol proc~write_surf->proc~get_unit proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~lower lower proc~write_surf->proc~lower proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~multi_scale_assembly_fe_film_reynolds->omp_get_thread_num proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string dmumps dmumps proc~init_solver->dmumps mpi_finalize mpi_finalize proc~init_solver->mpi_finalize ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_superlu init_superlu proc~init_solver->proc~init_superlu mpi_init mpi_init proc~init_solver->mpi_init proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~compute_prc_tables_reynolds_supg compute_prc_tables_reynolds_supg proc~elementary_assembly_fe_film_reynolds->proc~compute_prc_tables_reynolds_supg proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~solution_solver->dmumps ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~freefact_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_solver->dmumps proc~close_solver->mpi_finalize proc~close_solver->proc~umfpack_di_free_numeric proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~solv_superlu->proc~prep_superlu interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~statinit StatInit proc~solv_superlu->interface~statinit proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix proc~ni4_up_2d ni4_up_2d proc~compute_prc_tables_reynolds_supg->proc~ni4_up_2d proc~length_width_elem length_width_elem proc~compute_prc_tables_reynolds_supg->proc~length_width_elem proc~dj4 dj4 proc~compute_prc_tables_reynolds_supg->proc~dj4 interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~c_f_string->proc~empty interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults proc~ni4_up_1d ni4_up_1d proc~ni4_up_2d->proc~ni4_up_1d interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve var panprogrammainCallsGraph = svgPanZoom('#programmainCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables prg_arg job_file date time repos archive Subroutines read_config Source Code main Variables Type Attributes Name Initial character(len=128) :: prg_arg character(len=128) :: job_file character(len=8) :: date character(len=10) :: time character(len=15) :: repos integer(kind=I4) :: archive Subroutines subroutine read_config () Arguments None Source Code program main use omp_lib use test_musst use data_arch , only : I4 , NB_THREADS_MAX , OUT_U => OPU , get_unit use num_param , only : VERBOSE , OUTPUT_FILE , OPU use solver , only : SOLVER_BS , SOLVER_TS , SOLV_MESS implicit none character ( len = 128 ) :: prg_arg character ( len = 128 ) :: job_file character ( len = 8 ) :: date character ( len = 10 ) :: time character ( len = 15 ) :: repos integer ( kind = I4 ) :: archive ! a result directory is created under \"/out\" with the date as name ! ---------------------------------------------------------------- call date_and_time ( date , time ) repos = date // '_' // time ( 1 : 6 ) call execute_command_line ( \"mkdir out/\" // repos , wait = . true .) ! the job file is the program argument ! ------------------------------------ prg_arg = repeat ( ' ' , len ( prg_arg )) job_file = repeat ( ' ' , len ( job_file )) call get_command_argument ( 1 , prg_arg ) ! argument one: job file if ( len_trim ( prg_arg ) == 0 ) then ! if there is no job file, stop stop 'no job file, stop' else job_file = trim ( adjustl ( prg_arg )) endif ! the job file is copied in the result directory ! ---------------------------------------------- call execute_command_line ( \"cp \" // trim ( job_file ) // \" out/\" // repos , wait = . true .) ! the job file is processed ! ------------------------- call read_config call run_test if ( OPU /= OUT_U ) close ( OPU ) stop contains subroutine read_config () implicit none integer ( kind = I4 ) :: jf , err_read character ( len = 032 ) :: word character ( len = 128 ) :: job_copy job_copy = \"out/\" // repos // job_file ( 4 : len_trim ( job_file )) VERBOSE = 20 SOLV_MESS = 0 OPU = 0 OUTPUT_FILE = \"no_file\" SOLVER_BS = 3 SOLVER_TS = 2 NB_THREADS_MAX = - 1 archive = 0 test_num = 0 call get_unit ( jf ) ; open ( jf , file = trim ( job_file ), status = 'old' ) do word = repeat ( ' ' , len ( word )) read ( jf , * , iostat = err_read ) word if ( index ( word , 'END_FILE' ) /= 0 ) exit if ( index ( word , 'VERBOSE' ) /= 0 ) then read ( jf , * ) VERBOSE endif if ( index ( word , 'SOLV_MESS' ) /= 0 ) then read ( jf , * ) SOLV_MESS endif if ( index ( word , 'OUTPUT_UNIT' ) /= 0 ) then read ( jf , * ) OPU if ( OPU == 0 ) then OPU = OUT_U else read ( jf , * ) OUTPUT_FILE call get_unit ( OPU ) open ( unit = OPU , & file = \"out/\" // repos // \"/\" // trim ( adjustl ( OUTPUT_FILE )), & status = 'unknown' ) endif endif if ( index ( word , 'SOLVER_BS' ) /= 0 ) then read ( jf , * ) SOLVER_BS if ( SOLVER_BS == 1 ) stop \"some remaining problems with SuLU, choose '3' instead\" if ( SOLVER_BS == 2 ) stop \"MUMPS is multithreaded, it is designed for TS, choose '3' instead\" endif if ( index ( word , 'SOLVER_TS' ) /= 0 ) then read ( jf , * ) SOLVER_TS endif if ( index ( word , 'PROBLEM_TYPE' ) /= 0 ) then read ( jf , * ) test_num endif if ( index ( word , 'PARAM_MUSST' ) /= 0 ) then call read_data ( jf , repos ) endif if ( index ( word , 'NB_THREADS_MAX' ) /= 0 ) then read ( jf , * ) NB_THREADS_MAX if ( NB_THREADS_MAX < 0 ) then !$ NB_THREADS_MAX = omp_get_num_procs() endif endif if ( index ( word , 'ARCHIVE' ) /= 0 ) then read ( jf , * ) archive if ( ARCHIVE == 1 ) then call execute_command_line ( \"sh bin/save/save.sh\" , wait = . true .) call execute_command_line ( \"mv *.7z out/\" // repos // \"/\" ) endif endif enddo close ( jf ) return endsubroutine read_config endprogram main","loc":"program/main.html"}]}